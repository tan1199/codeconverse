code_chunk,file_name,file_path,path_to_code_chunk,parent,prev_sibling,next_sibling,start_point,end_point,has_error,code_node_type,code_identifier,is_chunked,num_tokens,uuid_str
"class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)

        if(N < 2*k+1): return [-1]*N
        if(k==0): return nums

        ans = []
        prefix_sum = 0
        index = 0

        while(index <= 2*k and index<N):
            prefix_sum += nums[index]
            index += 1
        
        start = 0
        ans.append(prefix_sum//(2*k+1))

        while(index < N):
            prefix_sum += nums[index]
            prefix_sum -= nums[start]
            ans.append(prefix_sum//(2*k+1))
            index += 1
            start += 1
        
        return [-1]*k + ans + [-1]*k
",getAverages.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\getAverages.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(27, 0)",N,module,module,,169,85908c65-d7ee-4d05-a7c2-565928006117
"class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)

        if(N < 2*k+1): return [-1]*N
        if(k==0): return nums

        ans = []
        prefix_sum = 0
        index = 0

        while(index <= 2*k and index<N):
            prefix_sum += nums[index]
            index += 1
        
        start = 0
        ans.append(prefix_sum//(2*k+1))

        while(index < N):
            prefix_sum += nums[index]
            prefix_sum -= nums[start]
            ans.append(prefix_sum//(2*k+1))
            index += 1
            start += 1
        
        return [-1]*k + ans + [-1]*k",getAverages.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\getAverages.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(26, 36)",N,class_definition,Solution,,168,ba4d64f4-ed5e-4fea-b82b-25e4f33d8bb1
"def getAverages(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)

        if(N < 2*k+1): return [-1]*N
        if(k==0): return nums

        ans = []
        prefix_sum = 0
        index = 0

        while(index <= 2*k and index<N):
            prefix_sum += nums[index]
            index += 1
        
        start = 0
        ans.append(prefix_sum//(2*k+1))

        while(index < N):
            prefix_sum += nums[index]
            prefix_sum -= nums[start]
            ans.append(prefix_sum//(2*k+1))
            index += 1
            start += 1
        
        return [-1]*k + ans + [-1]*k",getAverages.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\getAverages.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(26, 36)",N,function_definition,getAverages,,164,e1c17138-47eb-47fd-bea5-875a399bc457
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
    
        curIndex = 0
        allowed = curIndex + nums[0]

        while(curIndex<=allowed and curIndex<len(nums)):
            allowed = max(allowed, curIndex + nums[curIndex])
            curIndex+=1
        
        # print(curIndex)
        return curIndex == len(nums)
",Jump Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\Jump Game.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(12, 0)",N,module,module,,81,a3fcc343-010f-40a6-ba6c-2594d8926f3d
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
    
        curIndex = 0
        allowed = curIndex + nums[0]

        while(curIndex<=allowed and curIndex<len(nums)):
            allowed = max(allowed, curIndex + nums[curIndex])
            curIndex+=1
        
        # print(curIndex)
        return curIndex == len(nums)",Jump Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\Jump Game.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(11, 36)",N,class_definition,Solution,,81,6a88b0c0-c7c3-45bd-a75d-f219bf717afa
"def canJump(self, nums: List[int]) -> bool:
    
        curIndex = 0
        allowed = curIndex + nums[0]

        while(curIndex<=allowed and curIndex<len(nums)):
            allowed = max(allowed, curIndex + nums[curIndex])
            curIndex+=1
        
        # print(curIndex)
        return curIndex == len(nums)",Jump Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\Jump Game.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(11, 36)",N,function_definition,canJump,,77,046c5d46-44f4-4bf9-97ff-a87bf2e186ab
"class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:

        max_candies = max(candies)
        return [i+extraCandies >= max_candies for i in candies]
",kidsWithCandies.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\kidsWithCandies.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(5, 0)",N,module,module,,59,44d6849b-3b70-47ee-ba1a-0261685e1bb0
"class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:

        max_candies = max(candies)
        return [i+extraCandies >= max_candies for i in candies]",kidsWithCandies.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\kidsWithCandies.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(4, 63)",N,class_definition,Solution,,59,039d490d-9e5b-489e-9a70-b31b9771f2c9
"def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:

        max_candies = max(candies)
        return [i+extraCandies >= max_candies for i in candies]",kidsWithCandies.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\kidsWithCandies.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(4, 63)",N,function_definition,kidsWithCandies,,55,26486abb-2091-4b4d-b3b1-9e83319b0f0c
"class Solution:
    def answerQueries(self, arr: List[int], queries: List[int]) -> List[int]:
        arr.sort()
        N = len(arr)
        for i in range(1, N): arr[i] += arr[i-1]


        def binarySearch(num, low=0 , high=N-1):
            if(low>high): return low
            mid = low + (high - low)//2
            if(arr[mid] == num): return mid+1
            if(arr[mid]>num): return binarySearch(num, 0, mid-1)
            return binarySearch(num, mid+1, high)
        
        return list(map(binarySearch, queries))
",LongestSubsequenceWithLimitedSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\LongestSubsequenceWithLimitedSum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(15, 0)",N,module,module,,142,4eb41ae2-99ce-4c7b-9c30-230e66ed0e14
"class Solution:
    def answerQueries(self, arr: List[int], queries: List[int]) -> List[int]:
        arr.sort()
        N = len(arr)
        for i in range(1, N): arr[i] += arr[i-1]


        def binarySearch(num, low=0 , high=N-1):
            if(low>high): return low
            mid = low + (high - low)//2
            if(arr[mid] == num): return mid+1
            if(arr[mid]>num): return binarySearch(num, 0, mid-1)
            return binarySearch(num, mid+1, high)
        
        return list(map(binarySearch, queries))",LongestSubsequenceWithLimitedSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\LongestSubsequenceWithLimitedSum.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 47)",N,class_definition,Solution,,142,5002ec05-6504-430e-befd-3186dc81a5b7
"def answerQueries(self, arr: List[int], queries: List[int]) -> List[int]:
        arr.sort()
        N = len(arr)
        for i in range(1, N): arr[i] += arr[i-1]


        def binarySearch(num, low=0 , high=N-1):
            if(low>high): return low
            mid = low + (high - low)//2
            if(arr[mid] == num): return mid+1
            if(arr[mid]>num): return binarySearch(num, 0, mid-1)
            return binarySearch(num, mid+1, high)
        
        return list(map(binarySearch, queries))",LongestSubsequenceWithLimitedSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\LongestSubsequenceWithLimitedSum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(14, 47)",N,function_definition,answerQueries,,138,a0c43ed7-efde-457a-a8e8-5e54b2946819
"def binarySearch(num, low=0 , high=N-1):
            if(low>high): return low
            mid = low + (high - low)//2
            if(arr[mid] == num): return mid+1
            if(arr[mid]>num): return binarySearch(num, 0, mid-1)
            return binarySearch(num, mid+1, high)",LongestSubsequenceWithLimitedSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\LongestSubsequenceWithLimitedSum.py,module/class_definition-Solution/function_definition-answerQueries/,answerQueries,"for i in range(1, N): arr[i] += arr[i-1]","return list(map(binarySearch, queries))","(7, 8)","(12, 49)",N,function_definition,binarySearch,,79,7fe12c20-c659-451d-832e-8767dac1330e
"class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:

        arr = []
        for val, freq in groupby([i for i in s]):
            arr.append([val, len(list(freq))])        


        N = len(arr)

        if(N == 1): return 0
        start = 1 if(arr[0][0] == '0') else 0
        end = N-1 if(arr[-1][0] == '0') else N-2
        if(start>end): return 0

        zero = 0
        one = 0
        prefix = []
        for i in range(start, end, 2):
            one += arr[i][1]
            zero += arr[i+1][1]
            prefix.append([one, zero])
        
        ans = 10**10
        for i in range(len(prefix)):
            ans = min(ans, prefix[i][0] + prefix[-1][1]-prefix[i][1])
        
        ans = min(ans, prefix[-1][0])
        ans = min(ans, prefix[-1][1])
        return ans
",minFlipsMonoIncr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\minFlipsMonoIncr.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 0)",N,module,module,,244,db66965e-3074-4430-b338-6e5753dfe34d
"class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:

        arr = []
        for val, freq in groupby([i for i in s]):
            arr.append([val, len(list(freq))])        


        N = len(arr)

        if(N == 1): return 0
        start = 1 if(arr[0][0] == '0') else 0
        end = N-1 if(arr[-1][0] == '0') else N-2
        if(start>end): return 0

        zero = 0
        one = 0
        prefix = []
        for i in range(start, end, 2):
            one += arr[i][1]
            zero += arr[i+1][1]
            prefix.append([one, zero])
        
        ans = 10**10
        for i in range(len(prefix)):
            ans = min(ans, prefix[i][0] + prefix[-1][1]-prefix[i][1])
        
        ans = min(ans, prefix[-1][0])
        ans = min(ans, prefix[-1][1])
        return ans",minFlipsMonoIncr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\minFlipsMonoIncr.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 18)",N,class_definition,Solution,,243,65606f30-52ed-4f29-9bd1-4c60656fa9d2
"def minFlipsMonoIncr(self, s: str) -> int:

        arr = []
        for val, freq in groupby([i for i in s]):
            arr.append([val, len(list(freq))])        


        N = len(arr)

        if(N == 1): return 0
        start = 1 if(arr[0][0] == '0') else 0
        end = N-1 if(arr[-1][0] == '0') else N-2
        if(start>end): return 0

        zero = 0
        one = 0
        prefix = []
        for i in range(start, end, 2):
            one += arr[i][1]
            zero += arr[i+1][1]
            prefix.append([one, zero])
        
        ans = 10**10
        for i in range(len(prefix)):
            ans = min(ans, prefix[i][0] + prefix[-1][1]-prefix[i][1])
        
        ans = min(ans, prefix[-1][0])
        ans = min(ans, prefix[-1][1])
        return ans",minFlipsMonoIncr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\minFlipsMonoIncr.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(29, 18)",N,function_definition,minFlipsMonoIncr,,239,24195368-6a50-411a-80ae-928d09e17c75
"class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        
        if(nums1 == nums2):
            return 0
        
        if(k==0):
            return -1
        
        
        diff = [a-b for a,b in zip(nums1, nums2)]
        
        total = sum(diff)
        if(total != 0): return -1
        
        ans = 0
        for i in diff:
            if(i%k != 0):
                # print(i)
                return  -1
            if(i>0): ans += i//k
                
        return ans
",minOperations.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\minOperations.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,module,module,,136,2d2865b2-3704-4fe1-afac-317aa6c86c55
"class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        
        if(nums1 == nums2):
            return 0
        
        if(k==0):
            return -1
        
        
        diff = [a-b for a,b in zip(nums1, nums2)]
        
        total = sum(diff)
        if(total != 0): return -1
        
        ans = 0
        for i in diff:
            if(i%k != 0):
                # print(i)
                return  -1
            if(i>0): ans += i//k
                
        return ans",minOperations.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\minOperations.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 18)",N,class_definition,Solution,,135,3e3d3264-316e-46c3-9099-d1b3d8e2b921
"def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        
        if(nums1 == nums2):
            return 0
        
        if(k==0):
            return -1
        
        
        diff = [a-b for a,b in zip(nums1, nums2)]
        
        total = sum(diff)
        if(total != 0): return -1
        
        ans = 0
        for i in diff:
            if(i%k != 0):
                # print(i)
                return  -1
            if(i>0): ans += i//k
                
        return ans",minOperations.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\minOperations.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(22, 18)",N,function_definition,minOperations,,131,4cd52e6a-dc31-42fe-bac3-6d60e8fbfd82
"class Solution:
    def compress(self, chars: List[str]) -> int:

        def getLen(num):
            ans = []
            if num == 1: return ans
            while(num):
                ans.append(str(num%10))
                num = num//10
            return ans[::-1]
        
        def replace(arr, swap, index):
            for i, val in enumerate(swap):
                if(index+i < len(arr)): arr[index+i] = val
                else: arr.append(val)

        index = 0
        start = 0
        end = 0
        while(start<len(chars)):
            while(end<len(chars) and chars[end] == chars[start]): end+=1
            
            chars[index] = chars[start]
            index+=1

            arr = getLen(end-start)
            replace(chars, arr, index)
            
            index+=len(arr)
            start = end

        return index
",compress.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\compress.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(32, 0)",N,module,module,,190,91859fda-e640-480b-92ad-a0fc8b45d5dc
"class Solution:
    def compress(self, chars: List[str]) -> int:

        def getLen(num):
            ans = []
            if num == 1: return ans
            while(num):
                ans.append(str(num%10))
                num = num//10
            return ans[::-1]
        
        def replace(arr, swap, index):
            for i, val in enumerate(swap):
                if(index+i < len(arr)): arr[index+i] = val
                else: arr.append(val)

        index = 0
        start = 0
        end = 0
        while(start<len(chars)):
            while(end<len(chars) and chars[end] == chars[start]): end+=1
            
            chars[index] = chars[start]
            index+=1

            arr = getLen(end-start)
            replace(chars, arr, index)
            
            index+=len(arr)
            start = end

        return index",compress.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\compress.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 20)",N,class_definition,Solution,,189,588da0b4-c401-46d5-9a25-ecbaba4f3d34
"def compress(self, chars: List[str]) -> int:

        def getLen(num):
            ans = []
            if num == 1: return ans
            while(num):
                ans.append(str(num%10))
                num = num//10
            return ans[::-1]
        
        def replace(arr, swap, index):
            for i, val in enumerate(swap):
                if(index+i < len(arr)): arr[index+i] = val
                else: arr.append(val)

        index = 0
        start = 0
        end = 0
        while(start<len(chars)):
            while(end<len(chars) and chars[end] == chars[start]): end+=1
            
            chars[index] = chars[start]
            index+=1

            arr = getLen(end-start)
            replace(chars, arr, index)
            
            index+=len(arr)
            start = end

        return index",compress.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\compress.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(31, 20)",N,function_definition,compress,,185,bb595643-d9ea-4a2d-9a0a-5c65527fcea7
"def getLen(num):
            ans = []
            if num == 1: return ans
            while(num):
                ans.append(str(num%10))
                num = num//10
            return ans[::-1]",compress.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\compress.py,module/class_definition-Solution/function_definition-compress/,compress,Previous sibling does not exist,"def replace(arr, swap, index):
            for i, val in enumerate(swap):
                if(index+i < len(arr)): arr[index+i] = val
                else: arr.append(val)","(3, 8)","(9, 28)",N,function_definition,getLen,,44,8950fd10-cbd7-44e7-9367-34d4bce857b8
"def replace(arr, swap, index):
            for i, val in enumerate(swap):
                if(index+i < len(arr)): arr[index+i] = val
                else: arr.append(val)",compress.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\compress.py,module/class_definition-Solution/function_definition-compress/,compress,"def getLen(num):
            ans = []
            if num == 1: return ans
            while(num):
                ans.append(str(num%10))
                num = num//10
            return ans[::-1]",index = 0,"(11, 8)","(14, 37)",N,function_definition,replace,,40,c2978e61-a7ad-4660-9c04-62fdb37c4470
"class Solution:

    def getNumOfCombinations(self, mn, mx, index1, index2, start, end):
        if(index1>=len(mn) or index2>=len(mx)): return 0
        mn_idx, mx_idx = min(mn[index1], mx[index2]), max(mn[index1], mx[index2])

        left = mn_idx - start + 1
        right = end - mx_idx
        if(mn_idx == mn[index1]): ans = self.getNumOfCombinations(mn, mx, index1+1, index2, mn[index1]+1, end)
        else: ans = self.getNumOfCombinations(mn, mx, index1, index2+1, mx[index2]+1, end)

        return (left*right) + ans

    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:

        def getSubAns(nums, start, end):
            mn = []
            mx = []
            for i in range(start, end): 
                if(nums[i] == minK): mn.append(i)
                if(nums[i] == maxK): mx.append(i)

            if((len(mn)==0 or len(mx)==0)): return 0
            
            # if we have n minK and m maxK in [start, end)
            # how to get all possible combinations
            return self.getNumOfCombinations(mn, mx, 0, 0, start, end)

        start = 0
        end = 0
        ans = 0 

        while(end<len(nums)):
            while(end<len(nums) and minK<=nums[end]<=maxK): end += 1
            ans += getSubAns(nums, start, end)
            end += 1
            start = end
        
        return ans

            


            
",countSubarraysWithFixedBounds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\countSubarraysWithFixedBounds.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(44, 0)",N,module,module,,393,8567b96d-783c-41b9-a358-e67903d11756
"class Solution:

    def getNumOfCombinations(self, mn, mx, index1, index2, start, end):
        if(index1>=len(mn) or index2>=len(mx)): return 0
        mn_idx, mx_idx = min(mn[index1], mx[index2]), max(mn[index1], mx[index2])

        left = mn_idx - start + 1
        right = end - mx_idx
        if(mn_idx == mn[index1]): ans = self.getNumOfCombinations(mn, mx, index1+1, index2, mn[index1]+1, end)
        else: ans = self.getNumOfCombinations(mn, mx, index1, index2+1, mx[index2]+1, end)

        return (left*right) + ans

    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:

        def getSubAns(nums, start, end):
            mn = []
            mx = []
            for i in range(start, end): 
                if(nums[i] == minK): mn.append(i)
                if(nums[i] == maxK): mx.append(i)

            if((len(mn)==0 or len(mx)==0)): return 0
            
            # if we have n minK and m maxK in [start, end)
            # how to get all possible combinations
            return self.getNumOfCombinations(mn, mx, 0, 0, start, end)

        start = 0
        end = 0
        ans = 0 

        while(end<len(nums)):
            while(end<len(nums) and minK<=nums[end]<=maxK): end += 1
            ans += getSubAns(nums, start, end)
            end += 1
            start = end
        
        return ans",countSubarraysWithFixedBounds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\countSubarraysWithFixedBounds.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(38, 18)",N,class_definition,Solution,,389,9fe8d511-c982-40bb-a6bb-773f6164794a
"def getNumOfCombinations(self, mn, mx, index1, index2, start, end):
        if(index1>=len(mn) or index2>=len(mx)): return 0
        mn_idx, mx_idx = min(mn[index1], mx[index2]), max(mn[index1], mx[index2])

        left = mn_idx - start + 1
        right = end - mx_idx
        if(mn_idx == mn[index1]): ans = self.getNumOfCombinations(mn, mx, index1+1, index2, mn[index1]+1, end)
        else: ans = self.getNumOfCombinations(mn, mx, index1, index2+1, mx[index2]+1, end)

        return (left*right) + ans",countSubarraysWithFixedBounds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\countSubarraysWithFixedBounds.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:

        def getSubAns(nums, start, end):
            mn = []
            mx = []
            for i in range(start, end): 
                if(nums[i] == minK): mn.append(i)
                if(nums[i] == maxK): mx.append(i)

            if((len(mn)==0 or len(mx)==0)): return 0
            
            # if we have n minK and m maxK in [start, end)
            # how to get all possible combinations
            return self.getNumOfCombinations(mn, mx, 0, 0, start, end)

        start = 0
        end = 0
        ans = 0 

        while(end<len(nums)):
            while(end<len(nums) and minK<=nums[end]<=maxK): end += 1
            ans += getSubAns(nums, start, end)
            end += 1
            start = end
        
        return ans","(2, 4)","(11, 33)",N,function_definition,getNumOfCombinations,,166,4467aa3b-fe02-448c-96b1-242de9c43f6c
"def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:

        def getSubAns(nums, start, end):
            mn = []
            mx = []
            for i in range(start, end): 
                if(nums[i] == minK): mn.append(i)
                if(nums[i] == maxK): mx.append(i)

            if((len(mn)==0 or len(mx)==0)): return 0
            
            # if we have n minK and m maxK in [start, end)
            # how to get all possible combinations
            return self.getNumOfCombinations(mn, mx, 0, 0, start, end)

        start = 0
        end = 0
        ans = 0 

        while(end<len(nums)):
            while(end<len(nums) and minK<=nums[end]<=maxK): end += 1
            ans += getSubAns(nums, start, end)
            end += 1
            start = end
        
        return ans",countSubarraysWithFixedBounds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\countSubarraysWithFixedBounds.py,module/class_definition-Solution/,Solution,"def getNumOfCombinations(self, mn, mx, index1, index2, start, end):
        if(index1>=len(mn) or index2>=len(mx)): return 0
        mn_idx, mx_idx = min(mn[index1], mx[index2]), max(mn[index1], mx[index2])

        left = mn_idx - start + 1
        right = end - mx_idx
        if(mn_idx == mn[index1]): ans = self.getNumOfCombinations(mn, mx, index1+1, index2, mn[index1]+1, end)
        else: ans = self.getNumOfCombinations(mn, mx, index1, index2+1, mx[index2]+1, end)

        return (left*right) + ans",Next sibling does not exist,"(13, 4)","(38, 18)",N,function_definition,countSubarrays,,217,b369cdee-1f83-4b08-8fdb-10fc863001a7
"def getSubAns(nums, start, end):
            mn = []
            mx = []
            for i in range(start, end): 
                if(nums[i] == minK): mn.append(i)
                if(nums[i] == maxK): mx.append(i)

            if((len(mn)==0 or len(mx)==0)): return 0
            
            # if we have n minK and m maxK in [start, end)
            # how to get all possible combinations
            return self.getNumOfCombinations(mn, mx, 0, 0, start, end)",countSubarraysWithFixedBounds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\countSubarraysWithFixedBounds.py,module/class_definition-Solution/function_definition-countSubarrays/,countSubarrays,Previous sibling does not exist,start = 0,"(15, 8)","(26, 70)",N,function_definition,getSubAns,,121,d4c5891c-aed6-4293-840d-bc28bc8ec2ba
"class Solution:
    def jump(self, nums: List[int]) -> int:

        if(len(nums)==1): return 0

        count = 0
        start = 0
        end = 1

        while True:
            # print(nums[start:end], count)
            maxReach = start    
            while(start<end and start<len(nums)):
                maxReach = max(maxReach, start+nums[start])
                start += 1
            
            # print(maxReach)
            count += 1
            if(maxReach >= len(nums)-1): return count
            else: start, end = end, maxReach + 1
             


",jumpTwo.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\jumpTwo.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,module,module,,135,7066274d-3059-4e7b-b3bb-37f95cb67327
"class Solution:
    def jump(self, nums: List[int]) -> int:

        if(len(nums)==1): return 0

        count = 0
        start = 0
        end = 1

        while True:
            # print(nums[start:end], count)
            maxReach = start    
            while(start<end and start<len(nums)):
                maxReach = max(maxReach, start+nums[start])
                start += 1
            
            # print(maxReach)
            count += 1
            if(maxReach >= len(nums)-1): return count
            else: start, end = end, maxReach + 1",jumpTwo.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\jumpTwo.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(19, 48)",N,class_definition,Solution,,132,dc8c4888-83a7-4f8b-8aa1-fc86d6d89c58
"def jump(self, nums: List[int]) -> int:

        if(len(nums)==1): return 0

        count = 0
        start = 0
        end = 1

        while True:
            # print(nums[start:end], count)
            maxReach = start    
            while(start<end and start<len(nums)):
                maxReach = max(maxReach, start+nums[start])
                start += 1
            
            # print(maxReach)
            count += 1
            if(maxReach >= len(nums)-1): return count
            else: start, end = end, maxReach + 1",jumpTwo.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\jumpTwo.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(19, 48)",N,function_definition,jump,,128,6244a907-4981-470a-9fc8-31f1b2b3e42e
"class Solution:

    def __init__(self):
        self.arr = None
        self.ans = set()

    def helper(self, cur, index):        
        if(index == len(self.arr) and len(cur)>1): 
            self.ans.add(tuple(i for i in cur))
            return
        
        if(index >= len(self.arr)): return
        
        if(len(cur)==0 or (cur[-1]<=self.arr[index])): 
            cur.append(self.arr[index])
            self.helper(cur, index+1)
            cur.pop()
        
        self.helper(cur, index+1)
        


    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        self.arr = nums
        self.helper([], 0)
        return self.ans
",findSubsequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\findSubsequences.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(26, 0)",N,module,module,,159,bad091f6-6de7-4d3b-8655-886b8f7186d6
"class Solution:

    def __init__(self):
        self.arr = None
        self.ans = set()

    def helper(self, cur, index):        
        if(index == len(self.arr) and len(cur)>1): 
            self.ans.add(tuple(i for i in cur))
            return
        
        if(index >= len(self.arr)): return
        
        if(len(cur)==0 or (cur[-1]<=self.arr[index])): 
            cur.append(self.arr[index])
            self.helper(cur, index+1)
            cur.pop()
        
        self.helper(cur, index+1)
        


    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        self.arr = nums
        self.helper([], 0)
        return self.ans",findSubsequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\findSubsequences.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 23)",N,class_definition,Solution,,158,dc4ad75a-432a-4e2f-804a-ec2300e99d7e
"def __init__(self):
        self.arr = None
        self.ans = set()",findSubsequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\findSubsequences.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def helper(self, cur, index):        
        if(index == len(self.arr) and len(cur)>1): 
            self.ans.add(tuple(i for i in cur))
            return
        
        if(index >= len(self.arr)): return
        
        if(len(cur)==0 or (cur[-1]<=self.arr[index])): 
            cur.append(self.arr[index])
            self.helper(cur, index+1)
            cur.pop()
        
        self.helper(cur, index+1)","(2, 4)","(4, 24)",N,function_definition,__init__,,19,46bbe720-9f78-43e6-b8e3-fe2824d0b76f
"def helper(self, cur, index):        
        if(index == len(self.arr) and len(cur)>1): 
            self.ans.add(tuple(i for i in cur))
            return
        
        if(index >= len(self.arr)): return
        
        if(len(cur)==0 or (cur[-1]<=self.arr[index])): 
            cur.append(self.arr[index])
            self.helper(cur, index+1)
            cur.pop()
        
        self.helper(cur, index+1)",findSubsequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\findSubsequences.py,module/class_definition-Solution/,Solution,"def __init__(self):
        self.arr = None
        self.ans = set()","def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        self.arr = nums
        self.helper([], 0)
        return self.ans","(6, 4)","(18, 33)",N,function_definition,helper,,97,7a8162e3-8e62-4afe-bf7a-475d7177e908
"def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        self.arr = nums
        self.helper([], 0)
        return self.ans",findSubsequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\findSubsequences.py,module/class_definition-Solution/,Solution,"def helper(self, cur, index):        
        if(index == len(self.arr) and len(cur)>1): 
            self.ans.add(tuple(i for i in cur))
            return
        
        if(index >= len(self.arr)): return
        
        if(len(cur)==0 or (cur[-1]<=self.arr[index])): 
            cur.append(self.arr[index])
            self.helper(cur, index+1)
            cur.pop()
        
        self.helper(cur, index+1)",Next sibling does not exist,"(22, 4)","(25, 23)",N,function_definition,findSubsequences,,34,1894ab8c-b127-456e-b790-a054d2dff662
"class Solution {
    
    private ArrayList<String> ans = new ArrayList<>();
    private String[] mapping = new String[] {""0"", ""1"", ""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""};

    
    public List<String> letterCombinations(String digits) {
        if(digits.length()>0) helper(digits, 0, """");
        return ans;
    }
    
    
    public void helper(String digits, int index, String cur){
        
        if(index==digits.length()){
            ans.add(cur);
            return;
        }
        
        for(char ch: mapping[digits.charAt(index) - '0'].toCharArray()){
            helper(digits, index+1, cur+ch);
        }
    }
    
    
    
}
",LetterCombinations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\LetterCombinations.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(27, 0)",N,program,program,,160,cd95d967-2f82-4cde-acd3-cf6e227f99d8
"class Solution {
    
    private ArrayList<String> ans = new ArrayList<>();
    private String[] mapping = new String[] {""0"", ""1"", ""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""};

    
    public List<String> letterCombinations(String digits) {
        if(digits.length()>0) helper(digits, 0, """");
        return ans;
    }
    
    
    public void helper(String digits, int index, String cur){
        
        if(index==digits.length()){
            ans.add(cur);
            return;
        }
        
        for(char ch: mapping[digits.charAt(index) - '0'].toCharArray()){
            helper(digits, index+1, cur+ch);
        }
    }
    
    
    
}",LetterCombinations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\LetterCombinations.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(26, 1)",N,class_declaration,Solution,,160,b5322227-a772-4550-a559-afc3c0b49131
"public List<String> letterCombinations(String digits) {
        if(digits.length()>0) helper(digits, 0, """");
        return ans;
    }",LetterCombinations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\LetterCombinations.java,program/class_declaration-Solution/,Solution,"private String[] mapping = new String[] {""0"", ""1"", ""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""};","public void helper(String digits, int index, String cur){
        
        if(index==digits.length()){
            ans.add(cur);
            return;
        }
        
        for(char ch: mapping[digits.charAt(index) - '0'].toCharArray()){
            helper(digits, index+1, cur+ch);
        }
    }","(6, 4)","(9, 5)",N,method_declaration,letterCombinations,,31,833eeca2-6d51-42fc-b833-c69140ec8a56
"public void helper(String digits, int index, String cur){
        
        if(index==digits.length()){
            ans.add(cur);
            return;
        }
        
        for(char ch: mapping[digits.charAt(index) - '0'].toCharArray()){
            helper(digits, index+1, cur+ch);
        }
    }",LetterCombinations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\LetterCombinations.java,program/class_declaration-Solution/,Solution,"public List<String> letterCombinations(String digits) {
        if(digits.length()>0) helper(digits, 0, """");
        return ans;
    }",Next sibling does not exist,"(12, 4)","(22, 5)",N,method_declaration,helper,,65,f7610740-3e91-4e67-b2f2-f1ea4931bc05
"class Solution {
    public List<List<Integer>> permute(int[] nums) {
        boolean[] added = new boolean[nums.length];
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        permute(nums, added, ans, new ArrayList<Integer>());
        return ans;
    }
    
    public void permute(int[] nums, boolean[] added, List<List<Integer>> ans, ArrayList<Integer> cur){
        
        if(cur.size() == nums.length) {
            ans.add(new ArrayList(cur));
            return;
        }
        
        for(int index=0; index<nums.length; index++){
            
            if(added[index]) continue;
            
            added[index] = true;
            cur.add(nums[index]);
            permute(nums, added, ans, cur);
            added[index] = false;
            cur.remove(cur.size()-1);
        }
    }
    
    
    
}
",Permutations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\Permutations.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 0)",N,program,program,,176,65c2a905-bd07-41c4-9dfb-0127dba77355
"class Solution {
    public List<List<Integer>> permute(int[] nums) {
        boolean[] added = new boolean[nums.length];
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        permute(nums, added, ans, new ArrayList<Integer>());
        return ans;
    }
    
    public void permute(int[] nums, boolean[] added, List<List<Integer>> ans, ArrayList<Integer> cur){
        
        if(cur.size() == nums.length) {
            ans.add(new ArrayList(cur));
            return;
        }
        
        for(int index=0; index<nums.length; index++){
            
            if(added[index]) continue;
            
            added[index] = true;
            cur.add(nums[index]);
            permute(nums, added, ans, cur);
            added[index] = false;
            cur.remove(cur.size()-1);
        }
    }
    
    
    
}",Permutations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\Permutations.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 1)",N,class_declaration,Solution,,176,22d20d1d-e821-4af4-b8ca-496712e176b0
"public List<List<Integer>> permute(int[] nums) {
        boolean[] added = new boolean[nums.length];
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        permute(nums, added, ans, new ArrayList<Integer>());
        return ans;
    }",Permutations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\Permutations.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public void permute(int[] nums, boolean[] added, List<List<Integer>> ans, ArrayList<Integer> cur){
        
        if(cur.size() == nums.length) {
            ans.add(new ArrayList(cur));
            return;
        }
        
        for(int index=0; index<nums.length; index++){
            
            if(added[index]) continue;
            
            added[index] = true;
            cur.add(nums[index]);
            permute(nums, added, ans, cur);
            added[index] = false;
            cur.remove(cur.size()-1);
        }
    }","(1, 4)","(6, 5)",N,method_declaration,permute,,54,28a7ed94-e8e1-4bf8-a5c6-b14548255b23
"public void permute(int[] nums, boolean[] added, List<List<Integer>> ans, ArrayList<Integer> cur){
        
        if(cur.size() == nums.length) {
            ans.add(new ArrayList(cur));
            return;
        }
        
        for(int index=0; index<nums.length; index++){
            
            if(added[index]) continue;
            
            added[index] = true;
            cur.add(nums[index]);
            permute(nums, added, ans, cur);
            added[index] = false;
            cur.remove(cur.size()-1);
        }
    }",Permutations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\Permutations.java,program/class_declaration-Solution/,Solution,"public List<List<Integer>> permute(int[] nums) {
        boolean[] added = new boolean[nums.length];
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        permute(nums, added, ans, new ArrayList<Integer>());
        return ans;
    }",Next sibling does not exist,"(8, 4)","(25, 5)",N,method_declaration,permute,,114,d5c0ee5c-bdce-4c8f-9f74-8ebb2ed35729
"class Solution:
    def totalNQueens(self, n: int) -> int:


        def good(row_index, col_index, cur):
            for val in cur:
                if(val & 1<<col_index): return False
            
            for index in range(1, row_index+1):
                val = 0
                if(col_index-index >=0 ): val = val | (1<<(col_index-index))
                if(0 <= col_index+index < n): val = val | (1<<(col_index+index))

                if(cur[row_index-index] & val): return False
            
            return True




        def helper(row_index, cur):
            if(row_index == n): return 1
            ans = 0
            for col_index in range(n):
                if(good(row_index, col_index, cur)):
                    cur[row_index] = 1<<col_index
                    ans += helper(row_index+1, cur)
                    cur[row_index] = 0
            
            return ans

        cur = [0 for i in range(n)]
        return helper(0, cur)
",totalNQueens.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\totalNQueens.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(33, 0)",N,module,module,,227,fb2ec46a-d408-4ad4-a4ef-aa7b4faec0d2
"class Solution:
    def totalNQueens(self, n: int) -> int:


        def good(row_index, col_index, cur):
            for val in cur:
                if(val & 1<<col_index): return False
            
            for index in range(1, row_index+1):
                val = 0
                if(col_index-index >=0 ): val = val | (1<<(col_index-index))
                if(0 <= col_index+index < n): val = val | (1<<(col_index+index))

                if(cur[row_index-index] & val): return False
            
            return True




        def helper(row_index, cur):
            if(row_index == n): return 1
            ans = 0
            for col_index in range(n):
                if(good(row_index, col_index, cur)):
                    cur[row_index] = 1<<col_index
                    ans += helper(row_index+1, cur)
                    cur[row_index] = 0
            
            return ans

        cur = [0 for i in range(n)]
        return helper(0, cur)",totalNQueens.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\totalNQueens.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(32, 29)",N,class_definition,Solution,,227,5db2b603-73de-46ca-84db-b1f4b02ef38c
"def totalNQueens(self, n: int) -> int:


        def good(row_index, col_index, cur):
            for val in cur:
                if(val & 1<<col_index): return False
            
            for index in range(1, row_index+1):
                val = 0
                if(col_index-index >=0 ): val = val | (1<<(col_index-index))
                if(0 <= col_index+index < n): val = val | (1<<(col_index+index))

                if(cur[row_index-index] & val): return False
            
            return True




        def helper(row_index, cur):
            if(row_index == n): return 1
            ans = 0
            for col_index in range(n):
                if(good(row_index, col_index, cur)):
                    cur[row_index] = 1<<col_index
                    ans += helper(row_index+1, cur)
                    cur[row_index] = 0
            
            return ans

        cur = [0 for i in range(n)]
        return helper(0, cur)",totalNQueens.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\totalNQueens.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(32, 29)",N,function_definition,totalNQueens,,223,12a1d86a-63d6-4c27-87b3-562ac4f21f05
"def good(row_index, col_index, cur):
            for val in cur:
                if(val & 1<<col_index): return False
            
            for index in range(1, row_index+1):
                val = 0
                if(col_index-index >=0 ): val = val | (1<<(col_index-index))
                if(0 <= col_index+index < n): val = val | (1<<(col_index+index))

                if(cur[row_index-index] & val): return False
            
            return True",totalNQueens.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\totalNQueens.py,module/class_definition-Solution/function_definition-totalNQueens/,totalNQueens,Previous sibling does not exist,"def helper(row_index, cur):
            if(row_index == n): return 1
            ans = 0
            for col_index in range(n):
                if(good(row_index, col_index, cur)):
                    cur[row_index] = 1<<col_index
                    ans += helper(row_index+1, cur)
                    cur[row_index] = 0
            
            return ans","(4, 8)","(15, 23)",N,function_definition,good,,107,a74ab2fe-bdfc-4ab7-bf97-271d23602d24
"def helper(row_index, cur):
            if(row_index == n): return 1
            ans = 0
            for col_index in range(n):
                if(good(row_index, col_index, cur)):
                    cur[row_index] = 1<<col_index
                    ans += helper(row_index+1, cur)
                    cur[row_index] = 0
            
            return ans",totalNQueens.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\totalNQueens.py,module/class_definition-Solution/function_definition-totalNQueens/,totalNQueens,"def good(row_index, col_index, cur):
            for val in cur:
                if(val & 1<<col_index): return False
            
            for index in range(1, row_index+1):
                val = 0
                if(col_index-index >=0 ): val = val | (1<<(col_index-index))
                if(0 <= col_index+index < n): val = val | (1<<(col_index+index))

                if(cur[row_index-index] & val): return False
            
            return True",cur = [0 for i in range(n)],"(20, 8)","(29, 22)",N,function_definition,helper,,79,b4a6f0cc-7347-4759-ae66-0870c6d6eb90
"package com.akarsh.designpatterns;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class WordSearch2 {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findWords(
                new char[][]{
                        {'o','a','a','n'},
                        {'e','t','a','e'},
                        {'i','h','k','r'},
                        {'i','f','l','v'}
                },
                new String[]{""oath"",""pea"",""eat"",""rain""}
        ));
    }
}


class Solution {
    public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        List<String> ans = new ArrayList<>();


        for (String word: words) {
            TrieNode node = root;
            for (Character ch: word.toCharArray()){
                if(!node.hasChild(ch)) {
                    node.setChild(ch, new TrieNode());
                }
                node = node.getChild(ch);
            }
            node.setWord(word);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i=0;i<board.length;i++){
            for (int j=0; j<board[0].length; j++){
                helper(i ,j, board, root, ans, visited);
            }
        }

        return ans;
    }

    public void helper(int i, int j, char[][] board, TrieNode node, List<String> ans, boolean[][] visited){

        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) return;
        if(!node.hasChild(board[i][j])) return;

        Character ch = board[i][j];
        node = node.getChild(ch);

        if(node.getWord() != null ) {
            ans.add(node.getWord());
        }

        visited[i][j] = true;

        helper(i-1, j, board, node, ans, visited);
        helper(i, j+1, board, node, ans, visited);
        helper(i+1, j, board, node, ans, visited);
        helper(i, j-1, board, node, ans, visited);

        visited[i][j] = false;
    }

}

class TrieNode{
    private String word;
    private final TrieNode[] children;

    public TrieNode(){
        word = null;
        children = new TrieNode[26];
    }

    public void setWord(String word) {
        this.word = word;
    }

    public String getWord() {
        return word;
    }

    public boolean hasChild(Character ch){
        return children[ch - 'a'] != null;
    }

    public TrieNode getChild(Character ch) {
        return children[ch-'a'];
    }

    public void setChild(Character ch, TrieNode child) {
        this.children[ch-'a'] = child;
    }

    @Override
    public String toString() {
        return ""TrieNode{"" +
                ""Word="" + word +
                "", children="" + Arrays.toString(children) +
                '}';
    }
}
",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,,NA,Previous sibling does not exist,"package com.akarsh.designpatterns;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;","(0, 0)","(111, 0)",N,program,program,,655,4d8dc7c9-89e6-4346-b53c-dd18d2a2eeed
"package com.akarsh.designpatterns;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/,program,Previous sibling does not exist,"public class WordSearch2 {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findWords(
                new char[][]{
                        {'o','a','a','n'},
                        {'e','t','a','e'},
                        {'i','h','k','r'},
                        {'i','f','l','v'}
                },
                new String[]{""oath"",""pea"",""eat"",""rain""}
        ));
    }
}","(0, 0)","(4, 22)",N,"package_declaration,import_declaration,import_declaration,import_declaration",package_declaration,,23,04683a20-1b96-4855-984b-169247143baa
"public class WordSearch2 {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findWords(
                new char[][]{
                        {'o','a','a','n'},
                        {'e','t','a','e'},
                        {'i','h','k','r'},
                        {'i','f','l','v'}
                },
                new String[]{""oath"",""pea"",""eat"",""rain""}
        ));
    }
}",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/,program,"package com.akarsh.designpatterns;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;","class Solution {
    public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        List<String> ans = new ArrayList<>();


        for (String word: words) {
            TrieNode node = root;
            for (Character ch: word.toCharArray()){
                if(!node.hasChild(ch)) {
                    node.setChild(ch, new TrieNode());
                }
                node = node.getChild(ch);
            }
            node.setWord(word);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i=0;i<board.length;i++){
            for (int j=0; j<board[0].length; j++){
                helper(i ,j, board, root, ans, visited);
            }
        }

        return ans;
    }

    public void helper(int i, int j, char[][] board, TrieNode node, List<String> ans, boolean[][] visited){

        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) return;
        if(!node.hasChild(board[i][j])) return;

        Character ch = board[i][j];
        node = node.getChild(ch);

        if(node.getWord() != null ) {
            ans.add(node.getWord());
        }

        visited[i][j] = true;

        helper(i-1, j, board, node, ans, visited);
        helper(i, j+1, board, node, ans, visited);
        helper(i+1, j, board, node, ans, visited);
        helper(i, j-1, board, node, ans, visited);

        visited[i][j] = false;
    }

}","(6, 0)","(19, 1)",N,class_declaration,WordSearch2,,97,43e90a49-6053-4bad-b0bd-79b0a0bc0bea
"public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findWords(
                new char[][]{
                        {'o','a','a','n'},
                        {'e','t','a','e'},
                        {'i','h','k','r'},
                        {'i','f','l','v'}
                },
                new String[]{""oath"",""pea"",""eat"",""rain""}
        ));
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-WordSearch2/,WordSearch2,Previous sibling does not exist,Next sibling does not exist,"(7, 4)","(18, 5)",N,method_declaration,main,,89,9ad5a867-525c-4dc2-b5fe-1c78f33e769c
"class Solution {
    public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        List<String> ans = new ArrayList<>();


        for (String word: words) {
            TrieNode node = root;
            for (Character ch: word.toCharArray()){
                if(!node.hasChild(ch)) {
                    node.setChild(ch, new TrieNode());
                }
                node = node.getChild(ch);
            }
            node.setWord(word);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i=0;i<board.length;i++){
            for (int j=0; j<board[0].length; j++){
                helper(i ,j, board, root, ans, visited);
            }
        }

        return ans;
    }

    public void helper(int i, int j, char[][] board, TrieNode node, List<String> ans, boolean[][] visited){

        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) return;
        if(!node.hasChild(board[i][j])) return;

        Character ch = board[i][j];
        node = node.getChild(ch);

        if(node.getWord() != null ) {
            ans.add(node.getWord());
        }

        visited[i][j] = true;

        helper(i-1, j, board, node, ans, visited);
        helper(i, j+1, board, node, ans, visited);
        helper(i+1, j, board, node, ans, visited);
        helper(i, j-1, board, node, ans, visited);

        visited[i][j] = false;
    }

}",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/,program,"public class WordSearch2 {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findWords(
                new char[][]{
                        {'o','a','a','n'},
                        {'e','t','a','e'},
                        {'i','h','k','r'},
                        {'i','f','l','v'}
                },
                new String[]{""oath"",""pea"",""eat"",""rain""}
        ));
    }
}","class TrieNode{
    private String word;
    private final TrieNode[] children;

    public TrieNode(){
        word = null;
        children = new TrieNode[26];
    }

    public void setWord(String word) {
        this.word = word;
    }

    public String getWord() {
        return word;
    }

    public boolean hasChild(Character ch){
        return children[ch - 'a'] != null;
    }

    public TrieNode getChild(Character ch) {
        return children[ch-'a'];
    }

    public void setChild(Character ch, TrieNode child) {
        this.children[ch-'a'] = child;
    }

    @Override
    public String toString() {
        return ""TrieNode{"" +
                ""Word="" + word +
                "", children="" + Arrays.toString(children) +
                '}';
    }
}","(22, 0)","(72, 1)",N,class_declaration,Solution,,363,a5723e6b-718d-44d6-b468-685853f3f4f4
"public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        List<String> ans = new ArrayList<>();


        for (String word: words) {
            TrieNode node = root;
            for (Character ch: word.toCharArray()){
                if(!node.hasChild(ch)) {
                    node.setChild(ch, new TrieNode());
                }
                node = node.getChild(ch);
            }
            node.setWord(word);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i=0;i<board.length;i++){
            for (int j=0; j<board[0].length; j++){
                helper(i ,j, board, root, ans, visited);
            }
        }

        return ans;
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public void helper(int i, int j, char[][] board, TrieNode node, List<String> ans, boolean[][] visited){

        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) return;
        if(!node.hasChild(board[i][j])) return;

        Character ch = board[i][j];
        node = node.getChild(ch);

        if(node.getWord() != null ) {
            ans.add(node.getWord());
        }

        visited[i][j] = true;

        helper(i-1, j, board, node, ans, visited);
        helper(i, j+1, board, node, ans, visited);
        helper(i+1, j, board, node, ans, visited);
        helper(i, j-1, board, node, ans, visited);

        visited[i][j] = false;
    }","(23, 4)","(48, 5)",N,method_declaration,findWords,,169,6fab010d-88fc-46f6-b42e-eaf1b80218a0
"public void helper(int i, int j, char[][] board, TrieNode node, List<String> ans, boolean[][] visited){

        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) return;
        if(!node.hasChild(board[i][j])) return;

        Character ch = board[i][j];
        node = node.getChild(ch);

        if(node.getWord() != null ) {
            ans.add(node.getWord());
        }

        visited[i][j] = true;

        helper(i-1, j, board, node, ans, visited);
        helper(i, j+1, board, node, ans, visited);
        helper(i+1, j, board, node, ans, visited);
        helper(i, j-1, board, node, ans, visited);

        visited[i][j] = false;
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-Solution/,Solution,"public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        List<String> ans = new ArrayList<>();


        for (String word: words) {
            TrieNode node = root;
            for (Character ch: word.toCharArray()){
                if(!node.hasChild(ch)) {
                    node.setChild(ch, new TrieNode());
                }
                node = node.getChild(ch);
            }
            node.setWord(word);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i=0;i<board.length;i++){
            for (int j=0; j<board[0].length; j++){
                helper(i ,j, board, root, ans, visited);
            }
        }

        return ans;
    }",Next sibling does not exist,"(50, 4)","(70, 5)",N,method_declaration,helper,,188,deb42203-dfa4-4310-b8a1-5e9edb1e5b42
"class TrieNode{
    private String word;
    private final TrieNode[] children;

    public TrieNode(){
        word = null;
        children = new TrieNode[26];
    }

    public void setWord(String word) {
        this.word = word;
    }

    public String getWord() {
        return word;
    }

    public boolean hasChild(Character ch){
        return children[ch - 'a'] != null;
    }

    public TrieNode getChild(Character ch) {
        return children[ch-'a'];
    }

    public void setChild(Character ch, TrieNode child) {
        this.children[ch-'a'] = child;
    }

    @Override
    public String toString() {
        return ""TrieNode{"" +
                ""Word="" + word +
                "", children="" + Arrays.toString(children) +
                '}';
    }
}",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/,program,"class Solution {
    public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        List<String> ans = new ArrayList<>();


        for (String word: words) {
            TrieNode node = root;
            for (Character ch: word.toCharArray()){
                if(!node.hasChild(ch)) {
                    node.setChild(ch, new TrieNode());
                }
                node = node.getChild(ch);
            }
            node.setWord(word);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i=0;i<board.length;i++){
            for (int j=0; j<board[0].length; j++){
                helper(i ,j, board, root, ans, visited);
            }
        }

        return ans;
    }

    public void helper(int i, int j, char[][] board, TrieNode node, List<String> ans, boolean[][] visited){

        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) return;
        if(!node.hasChild(board[i][j])) return;

        Character ch = board[i][j];
        node = node.getChild(ch);

        if(node.getWord() != null ) {
            ans.add(node.getWord());
        }

        visited[i][j] = true;

        helper(i-1, j, board, node, ans, visited);
        helper(i, j+1, board, node, ans, visited);
        helper(i+1, j, board, node, ans, visited);
        helper(i, j-1, board, node, ans, visited);

        visited[i][j] = false;
    }

}",Next sibling does not exist,"(74, 0)","(110, 1)",N,class_declaration,TrieNode,,172,42a6d135-b9f5-4899-9fab-5c88380e378f
"public TrieNode(){
        word = null;
        children = new TrieNode[26];
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,private final TrieNode[] children;,"public void setWord(String word) {
        this.word = word;
    }","(78, 4)","(81, 5)",N,constructor_declaration,TrieNode,,20,fa362b39-3029-4184-8d3a-aebec30e8cc1
"public void setWord(String word) {
        this.word = word;
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,"public TrieNode(){
        word = null;
        children = new TrieNode[26];
    }","public String getWord() {
        return word;
    }","(83, 4)","(85, 5)",N,method_declaration,setWord,,16,029adba2-14af-4707-aaca-764990f90f81
"public String getWord() {
        return word;
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,"public void setWord(String word) {
        this.word = word;
    }","public boolean hasChild(Character ch){
        return children[ch - 'a'] != null;
    }","(87, 4)","(89, 5)",N,method_declaration,getWord,,12,1fce1848-f36a-494a-bc51-5874dfaaeda6
"public boolean hasChild(Character ch){
        return children[ch - 'a'] != null;
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,"public String getWord() {
        return word;
    }","public TrieNode getChild(Character ch) {
        return children[ch-'a'];
    }","(91, 4)","(93, 5)",N,method_declaration,hasChild,,20,b6c7a3bf-58a6-4610-9381-2b6ed6704bdc
"public TrieNode getChild(Character ch) {
        return children[ch-'a'];
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,"public boolean hasChild(Character ch){
        return children[ch - 'a'] != null;
    }","public void setChild(Character ch, TrieNode child) {
        this.children[ch-'a'] = child;
    }","(95, 4)","(97, 5)",N,method_declaration,getChild,,17,dafda2dc-31fe-40df-b8bd-1d922db1aabd
"public void setChild(Character ch, TrieNode child) {
        this.children[ch-'a'] = child;
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,"public TrieNode getChild(Character ch) {
        return children[ch-'a'];
    }","@Override
    public String toString() {
        return ""TrieNode{"" +
                ""Word="" + word +
                "", children="" + Arrays.toString(children) +
                '}';
    }","(99, 4)","(101, 5)",N,method_declaration,setChild,,24,fd3dab1e-feee-4ec4-98bb-94b7a9c3f002
"@Override
    public String toString() {
        return ""TrieNode{"" +
                ""Word="" + word +
                "", children="" + Arrays.toString(children) +
                '}';
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,"public void setChild(Character ch, TrieNode child) {
        this.children[ch-'a'] = child;
    }",Next sibling does not exist,"(103, 4)","(109, 5)",N,method_declaration,toString,,37,99c7f7d8-9d15-4842-bcb8-e926bec36fde
"class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        
        def isValid(target):
            carry = 0
            
            for index in range(len(nums)-1,-1,-1):
                cur = nums[index]
                cur += carry
                carry = 0
                if(cur>target):
                    carry = cur - target
                    
            return carry == 0
        
        left = 0
        right = 10**9
        
        while left<right:
            mid = (left+right)//2
            
            # print(mid, isValid(mid))
            
            if(isValid(mid)):
                right = mid
            else:
                left = mid+1
                
        # print(left,right)
        return right
        
",MinimizeMaximumOfArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\MinimizeMaximumOfArray.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 0)",N,module,module,,151,d0e20542-9c70-4505-811d-4f72ba34340f
"class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        
        def isValid(target):
            carry = 0
            
            for index in range(len(nums)-1,-1,-1):
                cur = nums[index]
                cur += carry
                carry = 0
                if(cur>target):
                    carry = cur - target
                    
            return carry == 0
        
        left = 0
        right = 10**9
        
        while left<right:
            mid = (left+right)//2
            
            # print(mid, isValid(mid))
            
            if(isValid(mid)):
                right = mid
            else:
                left = mid+1
                
        # print(left,right)
        return right",MinimizeMaximumOfArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\MinimizeMaximumOfArray.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 20)",N,class_definition,Solution,,150,2d782979-9bee-43b1-9b4e-dc57aca19b61
"def minimizeArrayValue(self, nums: List[int]) -> int:
        
        def isValid(target):
            carry = 0
            
            for index in range(len(nums)-1,-1,-1):
                cur = nums[index]
                cur += carry
                carry = 0
                if(cur>target):
                    carry = cur - target
                    
            return carry == 0
        
        left = 0
        right = 10**9
        
        while left<right:
            mid = (left+right)//2
            
            # print(mid, isValid(mid))
            
            if(isValid(mid)):
                right = mid
            else:
                left = mid+1
                
        # print(left,right)
        return right",MinimizeMaximumOfArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\MinimizeMaximumOfArray.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(29, 20)",N,function_definition,minimizeArrayValue,,146,559559db-fc30-48b4-9898-b1325800f8ce
"def isValid(target):
            carry = 0
            
            for index in range(len(nums)-1,-1,-1):
                cur = nums[index]
                cur += carry
                carry = 0
                if(cur>target):
                    carry = cur - target
                    
            return carry == 0",MinimizeMaximumOfArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\MinimizeMaximumOfArray.py,module/class_definition-Solution/function_definition-minimizeArrayValue/,minimizeArrayValue,Previous sibling does not exist,left = 0,"(3, 8)","(13, 29)",N,function_definition,isValid,,60,87e29b0f-4fdd-4d00-915b-785cc502aa25
"class Solution:
    def minimumSeconds(self, nums: List[int]) -> int:
        
        N = len(nums)
        map = defaultdict(list)
        for index, num in enumerate(nums): map[num].append(index)
        
        def cov(indexs):
            if(len(indexs) <= 1): return 10 ** 10
            
            ans = 0
            for index in range(1, len(indexs)):
                ans = max(ans, indexs[index] - indexs[index-1])
            ans = max(ans, indexs[0] -  indexs[-1] + N)
            return ans
            
        
        
        val, minCov = -1, 10**10 + 1
        for num in map:
            re = cov(map[num])
            if(re < minCov):
                val = num
                minCov = re
        
        
        print(val)
        
        def can(s):
            nonlocal val
            counter = defaultdict(int)
            start = N - s
            end = start + 2*s
            # print(s, start, end)
            for index in range(start, end+1):  counter[nums[index%N]] += 1
                
            for index in range(N):
                # print(index, counter)
                if(counter[val] == 0): return False
                counter[nums[start%N]] -= 1
                start += 1
                end += 1
                counter[nums[end%N]] += 1
            
            return True
            
            
        low = 0
        high = len(nums)//2 + 1
        while(low<high):
            # print(low, high)
            mid = (low + high)//2
            if(can(mid)): high = mid
            else: low = mid + 1
        return low
",minimumSeconds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\minimumSeconds.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(55, 0)",N,module,module,,380,56b46dde-7b03-49ff-b7ef-f0f8b7eb50cc
"class Solution:
    def minimumSeconds(self, nums: List[int]) -> int:
        
        N = len(nums)
        map = defaultdict(list)
        for index, num in enumerate(nums): map[num].append(index)
        
        def cov(indexs):
            if(len(indexs) <= 1): return 10 ** 10
            
            ans = 0
            for index in range(1, len(indexs)):
                ans = max(ans, indexs[index] - indexs[index-1])
            ans = max(ans, indexs[0] -  indexs[-1] + N)
            return ans
            
        
        
        val, minCov = -1, 10**10 + 1
        for num in map:
            re = cov(map[num])
            if(re < minCov):
                val = num
                minCov = re
        
        
        print(val)
        
        def can(s):
            nonlocal val
            counter = defaultdict(int)
            start = N - s
            end = start + 2*s
            # print(s, start, end)
            for index in range(start, end+1):  counter[nums[index%N]] += 1
                
            for index in range(N):
                # print(index, counter)
                if(counter[val] == 0): return False
                counter[nums[start%N]] -= 1
                start += 1
                end += 1
                counter[nums[end%N]] += 1
            
            return True
            
            
        low = 0
        high = len(nums)//2 + 1
        while(low<high):
            # print(low, high)
            mid = (low + high)//2
            if(can(mid)): high = mid
            else: low = mid + 1
        return low",minimumSeconds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\minimumSeconds.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(54, 18)",N,class_definition,Solution,,379,56500515-5582-4049-a521-948609284295
"def minimumSeconds(self, nums: List[int]) -> int:
        
        N = len(nums)
        map = defaultdict(list)
        for index, num in enumerate(nums): map[num].append(index)
        
        def cov(indexs):
            if(len(indexs) <= 1): return 10 ** 10
            
            ans = 0
            for index in range(1, len(indexs)):
                ans = max(ans, indexs[index] - indexs[index-1])
            ans = max(ans, indexs[0] -  indexs[-1] + N)
            return ans
            
        
        
        val, minCov = -1, 10**10 + 1
        for num in map:
            re = cov(map[num])
            if(re < minCov):
                val = num
                minCov = re
        
        
        print(val)
        
        def can(s):
            nonlocal val
            counter = defaultdict(int)
            start = N - s
            end = start + 2*s
            # print(s, start, end)
            for index in range(start, end+1):  counter[nums[index%N]] += 1
                
            for index in range(N):
                # print(index, counter)
                if(counter[val] == 0): return False
                counter[nums[start%N]] -= 1
                start += 1
                end += 1
                counter[nums[end%N]] += 1
            
            return True
            
            
        low = 0
        high = len(nums)//2 + 1
        while(low<high):
            # print(low, high)
            mid = (low + high)//2
            if(can(mid)): high = mid
            else: low = mid + 1
        return low",minimumSeconds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\minimumSeconds.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(54, 18)",N,function_definition,minimumSeconds,,375,7e69e644-ae36-4bcf-ad3a-6cecbab34978
"def cov(indexs):
            if(len(indexs) <= 1): return 10 ** 10
            
            ans = 0
            for index in range(1, len(indexs)):
                ans = max(ans, indexs[index] - indexs[index-1])
            ans = max(ans, indexs[0] -  indexs[-1] + N)
            return ans",minimumSeconds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\minimumSeconds.py,module/class_definition-Solution/function_definition-minimumSeconds/,minimumSeconds,"for index, num in enumerate(nums): map[num].append(index)","val, minCov = -1, 10**10 + 1","(7, 8)","(14, 22)",N,function_definition,cov,,81,255377e5-2039-44fe-978c-8d5709148f96
"def can(s):
            nonlocal val
            counter = defaultdict(int)
            start = N - s
            end = start + 2*s
            # print(s, start, end)
            for index in range(start, end+1):  counter[nums[index%N]] += 1
                
            for index in range(N):
                # print(index, counter)
                if(counter[val] == 0): return False
                counter[nums[start%N]] -= 1
                start += 1
                end += 1
                counter[nums[end%N]] += 1
            
            return True",minimumSeconds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\minimumSeconds.py,module/class_definition-Solution/function_definition-minimumSeconds/,minimumSeconds,print(val),low = 0,"(28, 8)","(44, 23)",N,function_definition,can,,128,5325bdab-1ab2-4b07-a0a5-e10bab315f27
"class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:

        nums.sort()
        N = len(nums)
        start = 0
        end = N-1
        mod = 10**9 + 7
        dp = {}

        def binarySearch(start, end):
            s = start

            while(start<=end):
                mid = start + (end - start +1)//2
                if(nums[s] + nums[mid] <= target):
                    if(start == end): return start 
                    start = mid
                else: end = mid-1
            
            return -1

        def getpow(num):
            if(num in dp): return dp[num]
            dp[num] = 2**num
            return dp[num]

        count = 0
        while(start<N):
            end = binarySearch(start, end)
            if(end == -1): break
            count += getpow(end - start)
            start += 1

        return count%mod
",numSubseq.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\numSubseq.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(35, 0)",N,module,module,,214,fad49f10-2a94-4114-b912-f914ad19fe6f
"class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:

        nums.sort()
        N = len(nums)
        start = 0
        end = N-1
        mod = 10**9 + 7
        dp = {}

        def binarySearch(start, end):
            s = start

            while(start<=end):
                mid = start + (end - start +1)//2
                if(nums[s] + nums[mid] <= target):
                    if(start == end): return start 
                    start = mid
                else: end = mid-1
            
            return -1

        def getpow(num):
            if(num in dp): return dp[num]
            dp[num] = 2**num
            return dp[num]

        count = 0
        while(start<N):
            end = binarySearch(start, end)
            if(end == -1): break
            count += getpow(end - start)
            start += 1

        return count%mod",numSubseq.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\numSubseq.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(34, 24)",N,class_definition,Solution,,213,4c8c989d-247b-4999-86af-f2528e9e1848
"def numSubseq(self, nums: List[int], target: int) -> int:

        nums.sort()
        N = len(nums)
        start = 0
        end = N-1
        mod = 10**9 + 7
        dp = {}

        def binarySearch(start, end):
            s = start

            while(start<=end):
                mid = start + (end - start +1)//2
                if(nums[s] + nums[mid] <= target):
                    if(start == end): return start 
                    start = mid
                else: end = mid-1
            
            return -1

        def getpow(num):
            if(num in dp): return dp[num]
            dp[num] = 2**num
            return dp[num]

        count = 0
        while(start<N):
            end = binarySearch(start, end)
            if(end == -1): break
            count += getpow(end - start)
            start += 1

        return count%mod",numSubseq.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\numSubseq.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(34, 24)",N,function_definition,numSubseq,,209,3646856e-e5f2-49f6-a919-266e1f83c5a4
"def binarySearch(start, end):
            s = start

            while(start<=end):
                mid = start + (end - start +1)//2
                if(nums[s] + nums[mid] <= target):
                    if(start == end): return start 
                    start = mid
                else: end = mid-1
            
            return -1",numSubseq.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\numSubseq.py,module/class_definition-Solution/function_definition-numSubseq/,numSubseq,dp = {},"def getpow(num):
            if(num in dp): return dp[num]
            dp[num] = 2**num
            return dp[num]","(10, 8)","(20, 21)",N,function_definition,binarySearch,,71,a941c67b-7b4a-47fb-b543-b5d0e84df5b6
"def getpow(num):
            if(num in dp): return dp[num]
            dp[num] = 2**num
            return dp[num]",numSubseq.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\numSubseq.py,module/class_definition-Solution/function_definition-numSubseq/,numSubseq,"def binarySearch(start, end):
            s = start

            while(start<=end):
                mid = start + (end - start +1)//2
                if(nums[s] + nums[mid] <= target):
                    if(start == end): return start 
                    start = mid
                else: end = mid-1
            
            return -1",count = 0,"(22, 8)","(25, 26)",N,function_definition,getpow,,30,face4b62-6377-42ef-bc64-c45257d2d18e
"class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        if(nums[-1] == target): return True
        while(nums and nums[-1] == nums[0]): nums.pop()
        if(not nums): return False

        N = len(nums)
        '''
            [x x x x x+1 x+2 .. x+k x-3 x-2 x-1 x x x x]
        '''

        def good(index):
            if(nums[index] >=  nums[0]):
                if(nums[0] <= target <= nums[index]): return True
                return False
            else:
                if(target > nums[-1] or target < nums[index]): return True
                return False
            
            return False

        low = 0
        high = N-1

        while(low < high):
            mid = low + (high - low)//2
            if(nums[mid] == target): return True
            # print(low, high, mid)

            # good(mid) => true means target in [0...mid]
            if(good(mid)): high = mid
            else: low = mid+1
        
        return (0 <= low < N and nums[low] == target) 
",searchInRotatedArray2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\searchInRotatedArray2.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(34, 0)",N,module,module,,260,e3ae4c74-7f9a-4ecb-a269-388c1cb93b01
"class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        if(nums[-1] == target): return True
        while(nums and nums[-1] == nums[0]): nums.pop()
        if(not nums): return False

        N = len(nums)
        '''
            [x x x x x+1 x+2 .. x+k x-3 x-2 x-1 x x x x]
        '''

        def good(index):
            if(nums[index] >=  nums[0]):
                if(nums[0] <= target <= nums[index]): return True
                return False
            else:
                if(target > nums[-1] or target < nums[index]): return True
                return False
            
            return False

        low = 0
        high = N-1

        while(low < high):
            mid = low + (high - low)//2
            if(nums[mid] == target): return True
            # print(low, high, mid)

            # good(mid) => true means target in [0...mid]
            if(good(mid)): high = mid
            else: low = mid+1
        
        return (0 <= low < N and nums[low] == target)",searchInRotatedArray2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\searchInRotatedArray2.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(33, 53)",N,class_definition,Solution,,259,d505bcc5-a89c-4260-b45c-4b46045bbc0e
"def search(self, nums: List[int], target: int) -> bool:
        if(nums[-1] == target): return True
        while(nums and nums[-1] == nums[0]): nums.pop()
        if(not nums): return False

        N = len(nums)
        '''
            [x x x x x+1 x+2 .. x+k x-3 x-2 x-1 x x x x]
        '''

        def good(index):
            if(nums[index] >=  nums[0]):
                if(nums[0] <= target <= nums[index]): return True
                return False
            else:
                if(target > nums[-1] or target < nums[index]): return True
                return False
            
            return False

        low = 0
        high = N-1

        while(low < high):
            mid = low + (high - low)//2
            if(nums[mid] == target): return True
            # print(low, high, mid)

            # good(mid) => true means target in [0...mid]
            if(good(mid)): high = mid
            else: low = mid+1
        
        return (0 <= low < N and nums[low] == target)",searchInRotatedArray2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\searchInRotatedArray2.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(33, 53)",N,function_definition,search,,255,2f64fffe-364c-4955-b23b-b5e56a52333e
"def good(index):
            if(nums[index] >=  nums[0]):
                if(nums[0] <= target <= nums[index]): return True
                return False
            else:
                if(target > nums[-1] or target < nums[index]): return True
                return False
            
            return False",searchInRotatedArray2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\searchInRotatedArray2.py,module/class_definition-Solution/function_definition-search/,search,"'''
            [x x x x x+1 x+2 .. x+k x-3 x-2 x-1 x x x x]
        '''",low = 0,"(11, 8)","(19, 24)",N,function_definition,good,,61,72d07d78-003c-4d1d-b75b-b62afd9d2df2
"class TimeMap {

    HashMap<String, ArrayList<Node>> map;
    
    public TimeMap() {
        map = new HashMap<>();
    }
    
    public void set(String key, String value, int timestamp) {
        Node newNode = new Node(timestamp, value);
        if(this.map.containsKey(key)){
            map.get(key).add(newNode);
        } else {
            ArrayList<Node> arr = new ArrayList<>();
            arr.add(newNode);
            map.put(key, arr);
        }
    }
    
    public String get(String key, int timestamp) {
        if(!map.containsKey(key)) return """";
        
        ArrayList<Node> list = map.get(key);
        int low = 0;
        int high = list.size()-1;
        
        while(low<high){
            int mid = (low + high + 1)/2;
            if(timestamp == list.get(mid).timestamp) return list.get(mid).value;
            else if(timestamp < list.get(mid).timestamp) high = mid -1;
            else low = mid;
        }
        
        return (0<=low && low<list.size() && list.get(low).timestamp<=timestamp) ? list.get(low).value : """";
        
    }
}



class Node{
    int timestamp;
    String value;
    
    Node(int timestamp, String key){
        this.timestamp = timestamp;
        this.value = key;
    }
}

/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap obj = new TimeMap();
 * obj.set(key,value,timestamp);
 * String param_2 = obj.get(key,timestamp);
 */
",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(56, 0)",N,program,program,,323,e4d56eb3-a87b-435d-9a62-2a308b76b112
"class TimeMap {

    HashMap<String, ArrayList<Node>> map;
    
    public TimeMap() {
        map = new HashMap<>();
    }
    
    public void set(String key, String value, int timestamp) {
        Node newNode = new Node(timestamp, value);
        if(this.map.containsKey(key)){
            map.get(key).add(newNode);
        } else {
            ArrayList<Node> arr = new ArrayList<>();
            arr.add(newNode);
            map.put(key, arr);
        }
    }
    
    public String get(String key, int timestamp) {
        if(!map.containsKey(key)) return """";
        
        ArrayList<Node> list = map.get(key);
        int low = 0;
        int high = list.size()-1;
        
        while(low<high){
            int mid = (low + high + 1)/2;
            if(timestamp == list.get(mid).timestamp) return list.get(mid).value;
            else if(timestamp < list.get(mid).timestamp) high = mid -1;
            else low = mid;
        }
        
        return (0<=low && low<list.size() && list.get(low).timestamp<=timestamp) ? list.get(low).value : """";
        
    }
}",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/,program,Previous sibling does not exist,"class Node{
    int timestamp;
    String value;
    
    Node(int timestamp, String key){
        this.timestamp = timestamp;
        this.value = key;
    }
}","(0, 0)","(36, 1)",N,class_declaration,TimeMap,,244,58b20928-8d09-4174-b0c2-fc37cb90ea5b
"public TimeMap() {
        map = new HashMap<>();
    }",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/class_declaration-TimeMap/,TimeMap,"HashMap<String, ArrayList<Node>> map;","public void set(String key, String value, int timestamp) {
        Node newNode = new Node(timestamp, value);
        if(this.map.containsKey(key)){
            map.get(key).add(newNode);
        } else {
            ArrayList<Node> arr = new ArrayList<>();
            arr.add(newNode);
            map.put(key, arr);
        }
    }","(4, 4)","(6, 5)",N,constructor_declaration,TimeMap,,13,926f0063-52bc-4b1a-afb2-2d62c4b0bd3b
"public void set(String key, String value, int timestamp) {
        Node newNode = new Node(timestamp, value);
        if(this.map.containsKey(key)){
            map.get(key).add(newNode);
        } else {
            ArrayList<Node> arr = new ArrayList<>();
            arr.add(newNode);
            map.put(key, arr);
        }
    }",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/class_declaration-TimeMap/,TimeMap,"public TimeMap() {
        map = new HashMap<>();
    }","public String get(String key, int timestamp) {
        if(!map.containsKey(key)) return """";
        
        ArrayList<Node> list = map.get(key);
        int low = 0;
        int high = list.size()-1;
        
        while(low<high){
            int mid = (low + high + 1)/2;
            if(timestamp == list.get(mid).timestamp) return list.get(mid).value;
            else if(timestamp < list.get(mid).timestamp) high = mid -1;
            else low = mid;
        }
        
        return (0<=low && low<list.size() && list.get(low).timestamp<=timestamp) ? list.get(low).value : """";
        
    }","(8, 4)","(17, 5)",N,method_declaration,set,,69,8b6b5326-ba69-432e-b4bb-99552ce9497d
"public String get(String key, int timestamp) {
        if(!map.containsKey(key)) return """";
        
        ArrayList<Node> list = map.get(key);
        int low = 0;
        int high = list.size()-1;
        
        while(low<high){
            int mid = (low + high + 1)/2;
            if(timestamp == list.get(mid).timestamp) return list.get(mid).value;
            else if(timestamp < list.get(mid).timestamp) high = mid -1;
            else low = mid;
        }
        
        return (0<=low && low<list.size() && list.get(low).timestamp<=timestamp) ? list.get(low).value : """";
        
    }",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/class_declaration-TimeMap/,TimeMap,"public void set(String key, String value, int timestamp) {
        Node newNode = new Node(timestamp, value);
        if(this.map.containsKey(key)){
            map.get(key).add(newNode);
        } else {
            ArrayList<Node> arr = new ArrayList<>();
            arr.add(newNode);
            map.put(key, arr);
        }
    }",Next sibling does not exist,"(19, 4)","(35, 5)",N,method_declaration,get,,142,56757520-4672-42b0-8aeb-7039cf763a18
"class Node{
    int timestamp;
    String value;
    
    Node(int timestamp, String key){
        this.timestamp = timestamp;
        this.value = key;
    }
}",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/,program,"class TimeMap {

    HashMap<String, ArrayList<Node>> map;
    
    public TimeMap() {
        map = new HashMap<>();
    }
    
    public void set(String key, String value, int timestamp) {
        Node newNode = new Node(timestamp, value);
        if(this.map.containsKey(key)){
            map.get(key).add(newNode);
        } else {
            ArrayList<Node> arr = new ArrayList<>();
            arr.add(newNode);
            map.put(key, arr);
        }
    }
    
    public String get(String key, int timestamp) {
        if(!map.containsKey(key)) return """";
        
        ArrayList<Node> list = map.get(key);
        int low = 0;
        int high = list.size()-1;
        
        while(low<high){
            int mid = (low + high + 1)/2;
            if(timestamp == list.get(mid).timestamp) return list.get(mid).value;
            else if(timestamp < list.get(mid).timestamp) high = mid -1;
            else low = mid;
        }
        
        return (0<=low && low<list.size() && list.get(low).timestamp<=timestamp) ? list.get(low).value : """";
        
    }
}","/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap obj = new TimeMap();
 * obj.set(key,value,timestamp);
 * String param_2 = obj.get(key,timestamp);
 */","(40, 0)","(48, 1)",N,class_declaration,Node,,35,c306e706-3154-487e-a9c9-e09e951b2d74
"Node(int timestamp, String key){
        this.timestamp = timestamp;
        this.value = key;
    }",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/class_declaration-Node/,Node,String value;,Next sibling does not exist,"(44, 4)","(47, 5)",N,constructor_declaration,Node,,21,e61271d1-461a-498a-80e3-0615d20d54b2
"/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap obj = new TimeMap();
 * obj.set(key,value,timestamp);
 * String param_2 = obj.get(key,timestamp);
 */",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/,program,"class Node{
    int timestamp;
    String value;
    
    Node(int timestamp, String key){
        this.timestamp = timestamp;
        this.value = key;
    }
}",Next sibling does not exist,"(50, 0)","(55, 3)",N,block_comment,block_comment,,44,eca9d568-8ce8-4587-8874-834a1117e3ef
"class Solution:
    def addBinary(self, a: str, b: str) -> str:
        
        def binToInt(s):
            num = 0
            for i in s:
                num = num << 1
                if( i == '1'): num = num | 1
            
            return num
        
        def intToBin(num):
            if(num == 0): return ""0""
            ans = """"
            while(num):
                ans += str(num%2)
                num = num//2
            return ans[::-1]


        a = binToInt(a)
        b = binToInt(b)
        # print(a, b)
        return intToBin(a+b)

",addBinary.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\addBinary.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 0)",N,module,module,,142,21c64400-9637-4ef2-8bf5-af5a8b974ba0
"class Solution:
    def addBinary(self, a: str, b: str) -> str:
        
        def binToInt(s):
            num = 0
            for i in s:
                num = num << 1
                if( i == '1'): num = num | 1
            
            return num
        
        def intToBin(num):
            if(num == 0): return ""0""
            ans = """"
            while(num):
                ans += str(num%2)
                num = num//2
            return ans[::-1]


        a = binToInt(a)
        b = binToInt(b)
        # print(a, b)
        return intToBin(a+b)",addBinary.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\addBinary.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 28)",N,class_definition,Solution,,142,0697ea09-779f-4c79-870a-4347a652e386
"def addBinary(self, a: str, b: str) -> str:
        
        def binToInt(s):
            num = 0
            for i in s:
                num = num << 1
                if( i == '1'): num = num | 1
            
            return num
        
        def intToBin(num):
            if(num == 0): return ""0""
            ans = """"
            while(num):
                ans += str(num%2)
                num = num//2
            return ans[::-1]


        a = binToInt(a)
        b = binToInt(b)
        # print(a, b)
        return intToBin(a+b)",addBinary.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\addBinary.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(23, 28)",N,function_definition,addBinary,,138,28ec0f4c-e2ac-45a4-94c1-4a1f9d2f5e9d
"def binToInt(s):
            num = 0
            for i in s:
                num = num << 1
                if( i == '1'): num = num | 1
            
            return num",addBinary.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\addBinary.py,module/class_definition-Solution/function_definition-addBinary/,addBinary,Previous sibling does not exist,"def intToBin(num):
            if(num == 0): return ""0""
            ans = """"
            while(num):
                ans += str(num%2)
                num = num//2
            return ans[::-1]","(3, 8)","(9, 22)",N,function_definition,binToInt,,43,d19e7a2c-9f76-4117-adf9-6892034db6d0
"def intToBin(num):
            if(num == 0): return ""0""
            ans = """"
            while(num):
                ans += str(num%2)
                num = num//2
            return ans[::-1]",addBinary.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\addBinary.py,module/class_definition-Solution/function_definition-addBinary/,addBinary,"def binToInt(s):
            num = 0
            for i in s:
                num = num << 1
                if( i == '1'): num = num | 1
            
            return num",a = binToInt(a),"(11, 8)","(17, 28)",N,function_definition,intToBin,,46,3209976e-c10b-44ba-bc4b-e27e29ea9d66
"class Solution:
    def beautifulSubarrays(self, nums: List[int]) -> int:
        
        running_xor = 0
        visited = defaultdict(int)
        visited[running_xor] = 1
        ans = 0
        
        for index, num in enumerate(nums):
            running_xor ^= num
            if(running_xor in visited): ans += visited[running_xor]
            visited[running_xor] += 1
        
        return ans
        
",beautifulSubarrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\beautifulSubarrays.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(15, 0)",N,module,module,,92,4f753848-967c-4b8d-a6a8-e3d8633592d6
"class Solution:
    def beautifulSubarrays(self, nums: List[int]) -> int:
        
        running_xor = 0
        visited = defaultdict(int)
        visited[running_xor] = 1
        ans = 0
        
        for index, num in enumerate(nums):
            running_xor ^= num
            if(running_xor in visited): ans += visited[running_xor]
            visited[running_xor] += 1
        
        return ans",beautifulSubarrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\beautifulSubarrays.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(13, 18)",N,class_definition,Solution,,91,0fdd0277-36d4-4b2b-81ab-639c07e86186
"def beautifulSubarrays(self, nums: List[int]) -> int:
        
        running_xor = 0
        visited = defaultdict(int)
        visited[running_xor] = 1
        ans = 0
        
        for index, num in enumerate(nums):
            running_xor ^= num
            if(running_xor in visited): ans += visited[running_xor]
            visited[running_xor] += 1
        
        return ans",beautifulSubarrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\beautifulSubarrays.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(13, 18)",N,function_definition,beautifulSubarrays,,87,fcf5e814-dd39-4b83-a5a2-d8117ebdd2ab
"class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:

        dp = [0 for i in range(high+1)]
        dp[one] += 1
        dp[zero] += 1

        mod = 10**9 + 7

        for index in range(high+1):
            if(index-one>=0): dp[index] = (dp[index]%mod + dp[index-one]%mod)%mod
            if(index-zero>=0): dp[index] = (dp[index]%mod + dp[index-zero]%mod)%mod
        
        ans = 0
        for val in dp[low:high+1]: ans = (ans%mod + val%mod)%mod
        
        return ans

",countGoodStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\countGoodStrings.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 0)",N,module,module,,165,b41358a6-8cb8-41e3-a06e-db8005edb8ca
"class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:

        dp = [0 for i in range(high+1)]
        dp[one] += 1
        dp[zero] += 1

        mod = 10**9 + 7

        for index in range(high+1):
            if(index-one>=0): dp[index] = (dp[index]%mod + dp[index-one]%mod)%mod
            if(index-zero>=0): dp[index] = (dp[index]%mod + dp[index-zero]%mod)%mod
        
        ans = 0
        for val in dp[low:high+1]: ans = (ans%mod + val%mod)%mod
        
        return ans",countGoodStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\countGoodStrings.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 18)",N,class_definition,Solution,,164,e5eb5066-a5de-469d-8581-8f4f8ab57b34
"def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:

        dp = [0 for i in range(high+1)]
        dp[one] += 1
        dp[zero] += 1

        mod = 10**9 + 7

        for index in range(high+1):
            if(index-one>=0): dp[index] = (dp[index]%mod + dp[index-one]%mod)%mod
            if(index-zero>=0): dp[index] = (dp[index]%mod + dp[index-zero]%mod)%mod
        
        ans = 0
        for val in dp[low:high+1]: ans = (ans%mod + val%mod)%mod
        
        return ans",countGoodStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\countGoodStrings.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(16, 18)",N,function_definition,countGoodStrings,,160,e3402c9b-5c3d-4689-af7a-77710feeb188
"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        for(int i=2;i<=(n-2);i++){
            // System.out.println(getBaseString(n,i));
            if(!isPalindrome(getBaseString(n,i))) return false;
        }
        
        return true;
    }
    
    public boolean isPalindrome(String s){
        int i=0;
        int j=s.length()-1;
        while(i<j){
            if(s.charAt(i)!=s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }
    
    public String getBaseString(int n, int base){
        StringBuffer ans = new StringBuffer();
        while(n>0){
            ans.append((n%base)+"""");
            n = n/base;
        }
        
        return ans.reverse().toString();
    }
}
",IsStrictlyPalindromic.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 0)",N,program,program,,174,bc20aa46-f15b-49f2-b0e1-a99068826ea3
"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        for(int i=2;i<=(n-2);i++){
            // System.out.println(getBaseString(n,i));
            if(!isPalindrome(getBaseString(n,i))) return false;
        }
        
        return true;
    }
    
    public boolean isPalindrome(String s){
        int i=0;
        int j=s.length()-1;
        while(i<j){
            if(s.charAt(i)!=s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }
    
    public String getBaseString(int n, int base){
        StringBuffer ans = new StringBuffer();
        while(n>0){
            ans.append((n%base)+"""");
            n = n/base;
        }
        
        return ans.reverse().toString();
    }
}",IsStrictlyPalindromic.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 1)",N,class_declaration,Solution,,174,218e8cbe-4c00-4981-9d99-03269862f095
"public boolean isStrictlyPalindromic(int n) {
        for(int i=2;i<=(n-2);i++){
            // System.out.println(getBaseString(n,i));
            if(!isPalindrome(getBaseString(n,i))) return false;
        }
        
        return true;
    }",IsStrictlyPalindromic.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public boolean isPalindrome(String s){
        int i=0;
        int j=s.length()-1;
        while(i<j){
            if(s.charAt(i)!=s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }","(1, 4)","(8, 5)",N,method_declaration,isStrictlyPalindromic,,61,ce3039fd-7b4f-4a01-9fcb-9fc18ee3390e
"public boolean isPalindrome(String s){
        int i=0;
        int j=s.length()-1;
        while(i<j){
            if(s.charAt(i)!=s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }",IsStrictlyPalindromic.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic.java,program/class_declaration-Solution/,Solution,"public boolean isStrictlyPalindromic(int n) {
        for(int i=2;i<=(n-2);i++){
            // System.out.println(getBaseString(n,i));
            if(!isPalindrome(getBaseString(n,i))) return false;
        }
        
        return true;
    }","public String getBaseString(int n, int base){
        StringBuffer ans = new StringBuffer();
        while(n>0){
            ans.append((n%base)+"""");
            n = n/base;
        }
        
        return ans.reverse().toString();
    }","(10, 4)","(19, 5)",N,method_declaration,isPalindrome,,53,d7333c43-bbed-455c-840a-2fed5601173e
"public String getBaseString(int n, int base){
        StringBuffer ans = new StringBuffer();
        while(n>0){
            ans.append((n%base)+"""");
            n = n/base;
        }
        
        return ans.reverse().toString();
    }",IsStrictlyPalindromic.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic.java,program/class_declaration-Solution/,Solution,"public boolean isPalindrome(String s){
        int i=0;
        int j=s.length()-1;
        while(i<j){
            if(s.charAt(i)!=s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }",Next sibling does not exist,"(21, 4)","(29, 5)",N,method_declaration,getBaseString,,51,0eecb317-ff03-416f-a889-87eb00f0d429
"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        return false;
    }
}
",IsStrictlyPalindromic2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic2.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(5, 0)",N,program,program,,24,40cce454-401d-4c82-9da8-ea2278b7d5d5
"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        return false;
    }
}",IsStrictlyPalindromic2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic2.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(4, 1)",N,class_declaration,Solution,,24,5e8befa3-42bd-4c7b-a175-7afea20e6aeb
"public boolean isStrictlyPalindromic(int n) {
        return false;
    }",IsStrictlyPalindromic2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic2.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(3, 5)",N,method_declaration,isStrictlyPalindromic,,19,4891e221-52fe-4ad5-8f6c-4c605dac9bf8
"class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        ans = 0
        count = [0 for i in range(66)]
        
        for num in nums:            
            index = 0
            while(num):
                if(num%2 == 1): count[index] += 1
                index+=1
                num >>= 1
            
        
        def op(nums, k):
            
            bor = 0
            for num in nums: bor = bor | num
            best = [-1, -1]
            
            for idx, num in enumerate(nums):
                temp = num
                cur = bor

                index = 0
                while(temp):
                    if(temp%2 == 1 and count[index]==1):
                        cur = cur ^ (1<<index)
                    index += 1
                    temp >>= 1

                cur = cur | (num<<k)
                if(best[0]<cur): best = [cur, idx]
            
            return best
            # idx = best[-1]
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
                
            # nums[idx] *= 2
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
        val, index = op(nums, k)
        return val
        # ans = 0
        # for i in nums: ans |= i
        # return ans
                
# if you observer you will see the shift (<<1) is always done on the same index to get the maximum OR
",maximumOr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\maximumOr.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(60, 0)",N,module,module,,398,d986de89-190c-44bf-8824-9e6183811d8c
"class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        ans = 0
        count = [0 for i in range(66)]
        
        for num in nums:            
            index = 0
            while(num):
                if(num%2 == 1): count[index] += 1
                index+=1
                num >>= 1
            
        
        def op(nums, k):
            
            bor = 0
            for num in nums: bor = bor | num
            best = [-1, -1]
            
            for idx, num in enumerate(nums):
                temp = num
                cur = bor

                index = 0
                while(temp):
                    if(temp%2 == 1 and count[index]==1):
                        cur = cur ^ (1<<index)
                    index += 1
                    temp >>= 1

                cur = cur | (num<<k)
                if(best[0]<cur): best = [cur, idx]
            
            return best
            # idx = best[-1]
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
                
            # nums[idx] *= 2
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
        val, index = op(nums, k)
        return val
        # ans = 0
        # for i in nums: ans |= i
        # return ans",maximumOr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\maximumOr.py,module/,module,Previous sibling does not exist,# if you observer you will see the shift (<<1) is always done on the same index to get the maximum OR,"(0, 0)","(57, 20)",N,class_definition,Solution,,371,6c407964-a985-468f-9d79-e9dfd9fe1dfc
"def maximumOr(self, nums: List[int], k: int) -> int:
        ans = 0
        count = [0 for i in range(66)]
        
        for num in nums:            
            index = 0
            while(num):
                if(num%2 == 1): count[index] += 1
                index+=1
                num >>= 1
            
        
        def op(nums, k):
            
            bor = 0
            for num in nums: bor = bor | num
            best = [-1, -1]
            
            for idx, num in enumerate(nums):
                temp = num
                cur = bor

                index = 0
                while(temp):
                    if(temp%2 == 1 and count[index]==1):
                        cur = cur ^ (1<<index)
                    index += 1
                    temp >>= 1

                cur = cur | (num<<k)
                if(best[0]<cur): best = [cur, idx]
            
            return best
            # idx = best[-1]
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
                
            # nums[idx] *= 2
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
        val, index = op(nums, k)
        return val
        # ans = 0
        # for i in nums: ans |= i
        # return ans",maximumOr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\maximumOr.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(57, 20)",N,function_definition,maximumOr,,367,fa36ad13-8020-4724-b788-b1b43273aed8
"def op(nums, k):
            
            bor = 0
            for num in nums: bor = bor | num
            best = [-1, -1]
            
            for idx, num in enumerate(nums):
                temp = num
                cur = bor

                index = 0
                while(temp):
                    if(temp%2 == 1 and count[index]==1):
                        cur = cur ^ (1<<index)
                    index += 1
                    temp >>= 1

                cur = cur | (num<<k)
                if(best[0]<cur): best = [cur, idx]
            
            return best
            # idx = best[-1]
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
                
            # nums[idx] *= 2
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1",maximumOr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\maximumOr.py,module/class_definition-Solution/function_definition-maximumOr/,maximumOr,"for num in nums:            
            index = 0
            while(num):
                if(num%2 == 1): count[index] += 1
                index+=1
                num >>= 1","val, index = op(nums, k)","(13, 8)","(51, 27)",N,function_definition,op,,248,40c2677d-c746-47b4-9827-fed157884321
# if you observer you will see the shift (<<1) is always done on the same index to get the maximum OR,maximumOr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\maximumOr.py,module/,module,"class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        ans = 0
        count = [0 for i in range(66)]
        
        for num in nums:            
            index = 0
            while(num):
                if(num%2 == 1): count[index] += 1
                index+=1
                num >>= 1
            
        
        def op(nums, k):
            
            bor = 0
            for num in nums: bor = bor | num
            best = [-1, -1]
            
            for idx, num in enumerate(nums):
                temp = num
                cur = bor

                index = 0
                while(temp):
                    if(temp%2 == 1 and count[index]==1):
                        cur = cur ^ (1<<index)
                    index += 1
                    temp >>= 1

                cur = cur | (num<<k)
                if(best[0]<cur): best = [cur, idx]
            
            return best
            # idx = best[-1]
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
                
            # nums[idx] *= 2
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
        val, index = op(nums, k)
        return val
        # ans = 0
        # for i in nums: ans |= i
        # return ans",Next sibling does not exist,"(59, 0)","(59, 101)",N,comment,comment,,25,94887022-ccf2-4d87-bcaa-5e1d9a183faa
"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        
        def getNumOfOnBits(num):
            ans = 0
            while(num):
                ans += 1
                num = num & (num-1)
            return ans
        
        ans = 0
        zero_one = ((a | b) ^ c) & c
        ans += getNumOfOnBits(zero_one)
        
        one_zero_a = ((a | b) ^ c) & a
        ans += getNumOfOnBits(one_zero_a)

        one_zero_b = ((a | b) ^ c) & b
        ans += getNumOfOnBits(one_zero_b)

        return ans
",minFlips.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\minFlips.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 0)",N,module,module,,159,29bea5db-7403-454e-bdf6-0f981dad85f7
"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        
        def getNumOfOnBits(num):
            ans = 0
            while(num):
                ans += 1
                num = num & (num-1)
            return ans
        
        ans = 0
        zero_one = ((a | b) ^ c) & c
        ans += getNumOfOnBits(zero_one)
        
        one_zero_a = ((a | b) ^ c) & a
        ans += getNumOfOnBits(one_zero_a)

        one_zero_b = ((a | b) ^ c) & b
        ans += getNumOfOnBits(one_zero_b)

        return ans",minFlips.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\minFlips.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(20, 18)",N,class_definition,Solution,,158,1a197e79-4cd3-4d4e-a414-cb578e05c6ac
"def minFlips(self, a: int, b: int, c: int) -> int:
        
        def getNumOfOnBits(num):
            ans = 0
            while(num):
                ans += 1
                num = num & (num-1)
            return ans
        
        ans = 0
        zero_one = ((a | b) ^ c) & c
        ans += getNumOfOnBits(zero_one)
        
        one_zero_a = ((a | b) ^ c) & a
        ans += getNumOfOnBits(one_zero_a)

        one_zero_b = ((a | b) ^ c) & b
        ans += getNumOfOnBits(one_zero_b)

        return ans",minFlips.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\minFlips.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(20, 18)",N,function_definition,minFlips,,154,cb9137d2-48c4-429f-a535-f06b364d8c5b
"def getNumOfOnBits(num):
            ans = 0
            while(num):
                ans += 1
                num = num & (num-1)
            return ans",minFlips.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\minFlips.py,module/class_definition-Solution/function_definition-minFlips/,minFlips,Previous sibling does not exist,ans = 0,"(3, 8)","(8, 22)",N,function_definition,getNumOfOnBits,,37,6993a478-e274-46cd-a8f6-5ae0c4bcf29f
"class Solution {
    public int minimizeXor(int num1, int num2) {
        int n2 = getnumBits(num2);
        int n1 = getnumBits(num1);
        
        // System.out.println(n1 + "" "" + n2);
        
        if(n2 == n1) return num1;
        int ans = 0;
        
        while(n2>0 && n1>0){
            int len = (int) (Math.log(num1) / Math.log(2) + 1);
            num1 = num1 ^ (1<<len-1);
            ans = ans | (1<<len-1);
            n1--;
            n2--;
        }
        
        // System.out.println(ans);
        
            for(int i=0;i<=31 && n2>0;i++){
                int val = 1<<i;
                // System.out.println(i + "" "" +  val);
                if((val&ans)==0){
                    ans = ans ^ val;
                    n2--;
                }
            }
        
        return ans;
    }
    
    public int getnumBits(int num2){
        int n = 0;
        while(num2>0){
            num2 = num2 & (num2-1);
            n++;
        }
        return n;
    }
}
",MinimizeXor.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\MinimizeXor.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(41, 0)",N,program,program,,275,2436eb96-3efa-45dd-a939-b0b1d877af7a
"class Solution {
    public int minimizeXor(int num1, int num2) {
        int n2 = getnumBits(num2);
        int n1 = getnumBits(num1);
        
        // System.out.println(n1 + "" "" + n2);
        
        if(n2 == n1) return num1;
        int ans = 0;
        
        while(n2>0 && n1>0){
            int len = (int) (Math.log(num1) / Math.log(2) + 1);
            num1 = num1 ^ (1<<len-1);
            ans = ans | (1<<len-1);
            n1--;
            n2--;
        }
        
        // System.out.println(ans);
        
            for(int i=0;i<=31 && n2>0;i++){
                int val = 1<<i;
                // System.out.println(i + "" "" +  val);
                if((val&ans)==0){
                    ans = ans ^ val;
                    n2--;
                }
            }
        
        return ans;
    }
    
    public int getnumBits(int num2){
        int n = 0;
        while(num2>0){
            num2 = num2 & (num2-1);
            n++;
        }
        return n;
    }
}",MinimizeXor.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\MinimizeXor.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(40, 1)",N,class_declaration,Solution,,275,fa803810-63da-4c86-b539-7f09d3c5a854
"public int minimizeXor(int num1, int num2) {
        int n2 = getnumBits(num2);
        int n1 = getnumBits(num1);
        
        // System.out.println(n1 + "" "" + n2);
        
        if(n2 == n1) return num1;
        int ans = 0;
        
        while(n2>0 && n1>0){
            int len = (int) (Math.log(num1) / Math.log(2) + 1);
            num1 = num1 ^ (1<<len-1);
            ans = ans | (1<<len-1);
            n1--;
            n2--;
        }
        
        // System.out.println(ans);
        
            for(int i=0;i<=31 && n2>0;i++){
                int val = 1<<i;
                // System.out.println(i + "" "" +  val);
                if((val&ans)==0){
                    ans = ans ^ val;
                    n2--;
                }
            }
        
        return ans;
    }",MinimizeXor.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\MinimizeXor.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public int getnumBits(int num2){
        int n = 0;
        while(num2>0){
            num2 = num2 & (num2-1);
            n++;
        }
        return n;
    }","(1, 4)","(30, 5)",N,method_declaration,minimizeXor,,221,8e9aadb7-0a17-437a-860a-d70198260d1f
"public int getnumBits(int num2){
        int n = 0;
        while(num2>0){
            num2 = num2 & (num2-1);
            n++;
        }
        return n;
    }",MinimizeXor.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\MinimizeXor.java,program/class_declaration-Solution/,Solution,"public int minimizeXor(int num1, int num2) {
        int n2 = getnumBits(num2);
        int n1 = getnumBits(num1);
        
        // System.out.println(n1 + "" "" + n2);
        
        if(n2 == n1) return num1;
        int ans = 0;
        
        while(n2>0 && n1>0){
            int len = (int) (Math.log(num1) / Math.log(2) + 1);
            num1 = num1 ^ (1<<len-1);
            ans = ans | (1<<len-1);
            n1--;
            n2--;
        }
        
        // System.out.println(ans);
        
            for(int i=0;i<=31 && n2>0;i++){
                int val = 1<<i;
                // System.out.println(i + "" "" +  val);
                if((val&ans)==0){
                    ans = ans ^ val;
                    n2--;
                }
            }
        
        return ans;
    }",Next sibling does not exist,"(32, 4)","(39, 5)",N,method_declaration,getnumBits,,47,cc23d54a-6170-4e1c-a5a1-51e51f082530
"class Solution {
    public int[] smallestSubarrays(int[] nums) {
        
        int[] backward = new int[nums.length];
        int index = nums.length - 1;
        backward[index] = nums[index];
        index--;
        
        while(index>=0){
            backward[index] = backward[index+1] | nums[index];
            index--;
        }
                
        index = 0;
        int index2 = 0;
        int or = 0;
        
        int[] bitCount = new int[32];
        int[] ans = new int[nums.length];
        
        
        while(index2<nums.length && or!=backward[index]) {
            for(int i=0;i<=30;i++){
                if(((1<<i) & nums[index2]) != 0) bitCount[i]++;
            }
            or = or | nums[index2];
            index2++;
        }
        
        if(index2<index){
            index2 = index;
        }
        
        
        
        
        ans[index] = index2 - index;
        if(ans[index]==0) ans[index] = 1;
        index++;
        
        while(index<nums.length){
            
            if(index2<index){
                index2 = index;
            }
            
            int prev = index-1;
            
            for(int i=0;i<=30;i++){
                if(((1<<i) & nums[prev]) != 0) {
                    if(bitCount[i]==1){
                        or = or^(1<<i);
                    }
                    bitCount[i]--;
                }
            }            
            
            while(index2<nums.length && or!=backward[index]) {
                for(int i=0;i<=30;i++){
                    if(((1<<i) & nums[index2]) != 0) bitCount[i]++;
                }
                or = or | nums[index2];
                index2++;
            }
            
            
            ans[index] = index2 - index;
            if(ans[index]==0) ans[index] = 1;
            index++;
        }
                
        return ans;
    }
}
",SmallestSubarrays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\SmallestSubarrays.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(74, 0)",N,program,program,,418,7e184d8d-f2e1-4b06-8847-24fbfc7b38f7
"class Solution {
    public int[] smallestSubarrays(int[] nums) {
        
        int[] backward = new int[nums.length];
        int index = nums.length - 1;
        backward[index] = nums[index];
        index--;
        
        while(index>=0){
            backward[index] = backward[index+1] | nums[index];
            index--;
        }
                
        index = 0;
        int index2 = 0;
        int or = 0;
        
        int[] bitCount = new int[32];
        int[] ans = new int[nums.length];
        
        
        while(index2<nums.length && or!=backward[index]) {
            for(int i=0;i<=30;i++){
                if(((1<<i) & nums[index2]) != 0) bitCount[i]++;
            }
            or = or | nums[index2];
            index2++;
        }
        
        if(index2<index){
            index2 = index;
        }
        
        
        
        
        ans[index] = index2 - index;
        if(ans[index]==0) ans[index] = 1;
        index++;
        
        while(index<nums.length){
            
            if(index2<index){
                index2 = index;
            }
            
            int prev = index-1;
            
            for(int i=0;i<=30;i++){
                if(((1<<i) & nums[prev]) != 0) {
                    if(bitCount[i]==1){
                        or = or^(1<<i);
                    }
                    bitCount[i]--;
                }
            }            
            
            while(index2<nums.length && or!=backward[index]) {
                for(int i=0;i<=30;i++){
                    if(((1<<i) & nums[index2]) != 0) bitCount[i]++;
                }
                or = or | nums[index2];
                index2++;
            }
            
            
            ans[index] = index2 - index;
            if(ans[index]==0) ans[index] = 1;
            index++;
        }
                
        return ans;
    }
}",SmallestSubarrays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\SmallestSubarrays.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(73, 1)",N,class_declaration,Solution,,418,60e31616-9124-46fb-9fad-0d7b8a8f3a65
"public int[] smallestSubarrays(int[] nums) {
        
        int[] backward = new int[nums.length];
        int index = nums.length - 1;
        backward[index] = nums[index];
        index--;
        
        while(index>=0){
            backward[index] = backward[index+1] | nums[index];
            index--;
        }
                
        index = 0;
        int index2 = 0;
        int or = 0;
        
        int[] bitCount = new int[32];
        int[] ans = new int[nums.length];
        
        
        while(index2<nums.length && or!=backward[index]) {
            for(int i=0;i<=30;i++){
                if(((1<<i) & nums[index2]) != 0) bitCount[i]++;
            }
            or = or | nums[index2];
            index2++;
        }
        
        if(index2<index){
            index2 = index;
        }
        
        
        
        
        ans[index] = index2 - index;
        if(ans[index]==0) ans[index] = 1;
        index++;
        
        while(index<nums.length){
            
            if(index2<index){
                index2 = index;
            }
            
            int prev = index-1;
            
            for(int i=0;i<=30;i++){
                if(((1<<i) & nums[prev]) != 0) {
                    if(bitCount[i]==1){
                        or = or^(1<<i);
                    }
                    bitCount[i]--;
                }
            }            
            
            while(index2<nums.length && or!=backward[index]) {
                for(int i=0;i<=30;i++){
                    if(((1<<i) & nums[index2]) != 0) bitCount[i]++;
                }
                or = or | nums[index2];
                index2++;
            }
            
            
            ans[index] = index2 - index;
            if(ans[index]==0) ans[index] = 1;
            index++;
        }
                
        return ans;
    }",SmallestSubarrays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\SmallestSubarrays.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(72, 5)",N,method_declaration,smallestSubarrays,,413,f4b9689c-5586-4108-88b4-fb18cb70d218
"class Solution {
    public int xorAllNums(int[] nums1, int[] nums2) {
        if(nums1.length%2==0 && nums2.length%2==0){
            return 0;
        } 
        
        if(nums1.length%2==1 && nums2.length%2==1){
            int ans = 0;
            for(int x: nums1) ans = ans ^ x;
            for(int x: nums2) ans = ans ^ x;
            return ans;
        }
        
        if(nums1.length%2==0 && nums2.length%2==1){
            int ans = 0;
            for(int x: nums1) ans = ans ^ x;
            return ans;
        }
        
        if(nums1.length%2==1 && nums2.length%2==0){
            int ans = 0;
            for(int x: nums2) ans = ans ^ x;
            return ans;
        }
        
        return 0;
    }
}
",XorAllNums.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\XorAllNums.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 0)",N,program,program,,207,836ae480-d1b7-41d5-8ea9-b03d4e65e8ae
"class Solution {
    public int xorAllNums(int[] nums1, int[] nums2) {
        if(nums1.length%2==0 && nums2.length%2==0){
            return 0;
        } 
        
        if(nums1.length%2==1 && nums2.length%2==1){
            int ans = 0;
            for(int x: nums1) ans = ans ^ x;
            for(int x: nums2) ans = ans ^ x;
            return ans;
        }
        
        if(nums1.length%2==0 && nums2.length%2==1){
            int ans = 0;
            for(int x: nums1) ans = ans ^ x;
            return ans;
        }
        
        if(nums1.length%2==1 && nums2.length%2==0){
            int ans = 0;
            for(int x: nums2) ans = ans ^ x;
            return ans;
        }
        
        return 0;
    }
}",XorAllNums.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\XorAllNums.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(27, 1)",N,class_declaration,Solution,,207,1aebd8c6-b253-45a3-bdbe-f14a5852349e
"public int xorAllNums(int[] nums1, int[] nums2) {
        if(nums1.length%2==0 && nums2.length%2==0){
            return 0;
        } 
        
        if(nums1.length%2==1 && nums2.length%2==1){
            int ans = 0;
            for(int x: nums1) ans = ans ^ x;
            for(int x: nums2) ans = ans ^ x;
            return ans;
        }
        
        if(nums1.length%2==0 && nums2.length%2==1){
            int ans = 0;
            for(int x: nums1) ans = ans ^ x;
            return ans;
        }
        
        if(nums1.length%2==1 && nums2.length%2==0){
            int ans = 0;
            for(int x: nums2) ans = ans ^ x;
            return ans;
        }
        
        return 0;
    }",XorAllNums.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\XorAllNums.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(26, 5)",N,method_declaration,xorAllNums,,202,59514edc-ae1d-4cc4-8760-0e59173ab354
"class Solution:
    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:

        arr = [[score, age] for score,age in zip(scores, ages)]
        arr.sort() # O(nlogn)
        dp = [None for i in range(len(scores))]
        dp[0] = arr[0][0]

        # O(n^2)
        for index in range(len(scores)):
            curmax = arr[index][0]
            cur_age = arr[index][1]
            for j in range(index-1, -1,-1):
                if(cur_age >= arr[j][-1]): 
                    curmax = max(curmax, arr[index][0] + 
            dp[index] = curmax
        return max(dp)
",bestTeamScoreWithNoConflicts.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\bestTeamScoreWithNoConflicts.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 0)",Y,module,module,,161,217f15a5-5c58-4813-91a3-8d40b58f45d4
"class Solution:
    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:

        arr = [[score, age] for score,age in zip(scores, ages)]
        arr.sort() # O(nlogn)
        dp = [None for i in range(len(scores))]
        dp[0] = arr[0][0]

        # O(n^2)
        for index in range(len(scores)):
            curmax = arr[index][0]
            cur_age = arr[index][1]
            for j in range(index-1, -1,-1):
                if(cur_age >= arr[j][-1]): 
                    curmax = max(curmax, arr[index][0] + 
            dp[index] = curmax
        return max(dp)",bestTeamScoreWithNoConflicts.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\bestTeamScoreWithNoConflicts.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 22)",Y,class_definition,Solution,,161,55c654e3-d575-4898-8b73-411f4d50c258
"def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:

        arr = [[score, age] for score,age in zip(scores, ages)]
        arr.sort() # O(nlogn)
        dp = [None for i in range(len(scores))]
        dp[0] = arr[0][0]

        # O(n^2)
        for index in range(len(scores)):
            curmax = arr[index][0]
            cur_age = arr[index][1]
            for j in range(index-1, -1,-1):
                if(cur_age >= arr[j][-1]): 
                    curmax = max(curmax, arr[index][0] + 
            dp[index] = curmax
        return max(dp)",bestTeamScoreWithNoConflicts.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\bestTeamScoreWithNoConflicts.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(16, 22)",Y,function_definition,bestTeamScore,,157,00909f45-251c-47df-9c84-0ddc54c302a7
"class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:

        N = len(grid)
        M = len(grid[0])
        dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        visited = [[False]*M for _ in range(N)]
        mod = 10**9 + 7

        @cache
        def dfs(row_index, col_index):
            ans = 1
            cur = grid[row_index][col_index]
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if(newx < 0  or newx >= N or newy < 0 or newy >= M): continue
                if(grid[newx][newy] <= cur): continue  
                ans = (ans%mod + dfs(newx, newy)%mod)%mod
            return ans
        
        ans = 0
        for row_index in range(N):
            for col_index in range(M):
                ans = (ans%mod + dfs(row_index, col_index)%mod)%mod
        
        return ans
",countIncreasingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\countIncreasingPaths.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(26, 0)",N,module,module,,246,fd5b4876-d62a-48b3-b394-35368bed72ab
"class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:

        N = len(grid)
        M = len(grid[0])
        dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        visited = [[False]*M for _ in range(N)]
        mod = 10**9 + 7

        @cache
        def dfs(row_index, col_index):
            ans = 1
            cur = grid[row_index][col_index]
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if(newx < 0  or newx >= N or newy < 0 or newy >= M): continue
                if(grid[newx][newy] <= cur): continue  
                ans = (ans%mod + dfs(newx, newy)%mod)%mod
            return ans
        
        ans = 0
        for row_index in range(N):
            for col_index in range(M):
                ans = (ans%mod + dfs(row_index, col_index)%mod)%mod
        
        return ans",countIncreasingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\countIncreasingPaths.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 18)",N,class_definition,Solution,,245,9bce68fa-0c1c-473d-ad35-4ca175d48faa
"def countPaths(self, grid: List[List[int]]) -> int:

        N = len(grid)
        M = len(grid[0])
        dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        visited = [[False]*M for _ in range(N)]
        mod = 10**9 + 7

        @cache
        def dfs(row_index, col_index):
            ans = 1
            cur = grid[row_index][col_index]
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if(newx < 0  or newx >= N or newy < 0 or newy >= M): continue
                if(grid[newx][newy] <= cur): continue  
                ans = (ans%mod + dfs(newx, newy)%mod)%mod
            return ans
        
        ans = 0
        for row_index in range(N):
            for col_index in range(M):
                ans = (ans%mod + dfs(row_index, col_index)%mod)%mod
        
        return ans",countIncreasingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\countIncreasingPaths.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(25, 18)",N,function_definition,countPaths,,241,37a56d8d-143c-4128-ac92-49fb7c8e6c8c
"@cache
        def dfs(row_index, col_index):
            ans = 1
            cur = grid[row_index][col_index]
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if(newx < 0  or newx >= N or newy < 0 or newy >= M): continue
                if(grid[newx][newy] <= cur): continue  
                ans = (ans%mod + dfs(newx, newy)%mod)%mod
            return ans",countIncreasingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\countIncreasingPaths.py,module/class_definition-Solution/function_definition-countPaths/,countPaths,mod = 10**9 + 7,ans = 0,"(9, 8)","(18, 22)",N,function_definition,"def dfs(row_index, col_index):
            ans = 1
            cur = grid[row_index][col_index]
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if(newx < 0  or newx >= N or newy < 0 or newy >= M): continue
                if(grid[newx][newy] <= cur): continue  
                ans = (ans%mod + dfs(newx, newy)%mod)%mod
            return ans",,116,73b8fec3-0bf9-4793-a121-ae4d030b2a93
"class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        dp = [1 for i in range(len(prices))]
        
        index = 1
        
        while(index<len(prices)):
            if(prices[index] + 1 == prices[index-1]):
                dp[index] = dp[index-1] + 1
            index = index+1
        
        return sum(dp)
",DescentStock.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\DescentStock.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(12, 0)",N,module,module,,88,6f50b6ce-4a4a-43c4-8cd7-26339adcdd4c
"class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        dp = [1 for i in range(len(prices))]
        
        index = 1
        
        while(index<len(prices)):
            if(prices[index] + 1 == prices[index-1]):
                dp[index] = dp[index-1] + 1
            index = index+1
        
        return sum(dp)",DescentStock.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\DescentStock.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(11, 22)",N,class_definition,Solution,,88,8b1f0dbc-77c3-406a-acb1-30d07c2f2bac
"def getDescentPeriods(self, prices: List[int]) -> int:
        dp = [1 for i in range(len(prices))]
        
        index = 1
        
        while(index<len(prices)):
            if(prices[index] + 1 == prices[index-1]):
                dp[index] = dp[index-1] + 1
            index = index+1
        
        return sum(dp)",DescentStock.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\DescentStock.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(11, 22)",N,function_definition,getDescentPeriods,,84,193ef0e1-988d-4ca3-a31a-25f811beafec
"class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        
        sLen = len(s)
        pLen = len(p)
        
        @cache
        def dfs(sIndex, pIndex):
            # print(sIndex, pIndex)
            if(sIndex == sLen and pIndex == pLen): return True
            if(not (pIndex < pLen and p[pIndex] == ""*"") and ((sIndex == sLen) ^ (pIndex == pLen))): return False
            
            
            if(p[pIndex] == ""?""): return dfs(sIndex+1, pIndex+1)
            if(p[pIndex] == ""*""): 
                for index in range(sIndex, sLen+1):
                    if(dfs(index, pIndex+1)): return True
                return False
            
            if(s[sIndex]!= p[pIndex]): return False
            return dfs(sIndex+1, pIndex+1)
        
        return dfs(0, 0)
",isMatch.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\isMatch.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,module,module,,211,1efe0034-2585-4163-abaf-28a95612f455
"class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        
        sLen = len(s)
        pLen = len(p)
        
        @cache
        def dfs(sIndex, pIndex):
            # print(sIndex, pIndex)
            if(sIndex == sLen and pIndex == pLen): return True
            if(not (pIndex < pLen and p[pIndex] == ""*"") and ((sIndex == sLen) ^ (pIndex == pLen))): return False
            
            
            if(p[pIndex] == ""?""): return dfs(sIndex+1, pIndex+1)
            if(p[pIndex] == ""*""): 
                for index in range(sIndex, sLen+1):
                    if(dfs(index, pIndex+1)): return True
                return False
            
            if(s[sIndex]!= p[pIndex]): return False
            return dfs(sIndex+1, pIndex+1)
        
        return dfs(0, 0)",isMatch.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\isMatch.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 24)",N,class_definition,Solution,,211,16ac77cb-c87b-42b8-910d-6699efbed9da
"def isMatch(self, s: str, p: str) -> bool:
        
        sLen = len(s)
        pLen = len(p)
        
        @cache
        def dfs(sIndex, pIndex):
            # print(sIndex, pIndex)
            if(sIndex == sLen and pIndex == pLen): return True
            if(not (pIndex < pLen and p[pIndex] == ""*"") and ((sIndex == sLen) ^ (pIndex == pLen))): return False
            
            
            if(p[pIndex] == ""?""): return dfs(sIndex+1, pIndex+1)
            if(p[pIndex] == ""*""): 
                for index in range(sIndex, sLen+1):
                    if(dfs(index, pIndex+1)): return True
                return False
            
            if(s[sIndex]!= p[pIndex]): return False
            return dfs(sIndex+1, pIndex+1)
        
        return dfs(0, 0)",isMatch.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\isMatch.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(22, 24)",N,function_definition,isMatch,,207,1571007f-7478-47a2-9c6f-22053b9ae346
"@cache
        def dfs(sIndex, pIndex):
            # print(sIndex, pIndex)
            if(sIndex == sLen and pIndex == pLen): return True
            if(not (pIndex < pLen and p[pIndex] == ""*"") and ((sIndex == sLen) ^ (pIndex == pLen))): return False
            
            
            if(p[pIndex] == ""?""): return dfs(sIndex+1, pIndex+1)
            if(p[pIndex] == ""*""): 
                for index in range(sIndex, sLen+1):
                    if(dfs(index, pIndex+1)): return True
                return False
            
            if(s[sIndex]!= p[pIndex]): return False
            return dfs(sIndex+1, pIndex+1)",isMatch.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\isMatch.py,module/class_definition-Solution/function_definition-isMatch/,isMatch,pLen = len(p),"return dfs(0, 0)","(6, 8)","(20, 42)",N,function_definition,"def dfs(sIndex, pIndex):
            # print(sIndex, pIndex)
            if(sIndex == sLen and pIndex == pLen): return True
            if(not (pIndex < pLen and p[pIndex] == ""*"") and ((sIndex == sLen) ^ (pIndex == pLen))): return False
            
            
            if(p[pIndex] == ""?""): return dfs(sIndex+1, pIndex+1)
            if(p[pIndex] == ""*""): 
                for index in range(sIndex, sLen+1):
                    if(dfs(index, pIndex+1)): return True
                return False
            
            if(s[sIndex]!= p[pIndex]): return False
            return dfs(sIndex+1, pIndex+1)",,164,fb026f25-70c1-4f61-9458-5ecd3e408bea
"class Solution:
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        
        N = len(obstacles)
        dp = [1 for i in range(N)]
        best = []

        for index, height in enumerate(obstacles):
            low = 0
            high = len(best)-1

            while(low<=high):
                mid = low + (high - low)//2
                if(best[mid] <= height): low = mid+1
                else: high = mid-1
            
            if(low < len(best)): best[low] = height
            else: best.append(height)
            dp[index] = low+1
        
        return dp
",longestObstacleCourseAtEachPosition.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\longestObstacleCourseAtEachPosition.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 0)",N,module,module,,145,2cb74e7d-a1e3-4212-8e90-6c0993e53a75
"class Solution:
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        
        N = len(obstacles)
        dp = [1 for i in range(N)]
        best = []

        for index, height in enumerate(obstacles):
            low = 0
            high = len(best)-1

            while(low<=high):
                mid = low + (high - low)//2
                if(best[mid] <= height): low = mid+1
                else: high = mid-1
            
            if(low < len(best)): best[low] = height
            else: best.append(height)
            dp[index] = low+1
        
        return dp",longestObstacleCourseAtEachPosition.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\longestObstacleCourseAtEachPosition.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(20, 17)",N,class_definition,Solution,,144,0e397eb8-0b01-42c9-9b94-3443e027d346
"def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        
        N = len(obstacles)
        dp = [1 for i in range(N)]
        best = []

        for index, height in enumerate(obstacles):
            low = 0
            high = len(best)-1

            while(low<=high):
                mid = low + (high - low)//2
                if(best[mid] <= height): low = mid+1
                else: high = mid-1
            
            if(low < len(best)): best[low] = height
            else: best.append(height)
            dp[index] = low+1
        
        return dp",longestObstacleCourseAtEachPosition.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\longestObstacleCourseAtEachPosition.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(20, 17)",N,function_definition,longestObstacleCourseAtEachPosition,,140,ef58a948-4f59-48aa-bb55-bd6b23890292
"class Solution:
    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
      
        arr2.sort()
        N = len(arr1)
        M = len(arr2)
        INF = 10**20

        @cache
        def helper(index1, prev):
            if(index1 == N): return 0
            
            best = INF
            if(arr1[index1] > prev): best = min(best, helper(index1 + 1, arr1[index1]))
            idx = bisect.bisect_right(arr2,prev)
            if(idx < M): best = min(best, 1 + helper(index1 + 1, arr2[idx]))
            return best

        res = helper(0, -1)    
        if(res == INF): return -1
        return res
",makeArrayIncreasing.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\makeArrayIncreasing.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 0)",N,module,module,,176,4e9dfd1a-119c-4604-9e98-97a244e0a499
"class Solution:
    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
      
        arr2.sort()
        N = len(arr1)
        M = len(arr2)
        INF = 10**20

        @cache
        def helper(index1, prev):
            if(index1 == N): return 0
            
            best = INF
            if(arr1[index1] > prev): best = min(best, helper(index1 + 1, arr1[index1]))
            idx = bisect.bisect_right(arr2,prev)
            if(idx < M): best = min(best, 1 + helper(index1 + 1, arr2[idx]))
            return best

        res = helper(0, -1)    
        if(res == INF): return -1
        return res",makeArrayIncreasing.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\makeArrayIncreasing.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(20, 18)",N,class_definition,Solution,,175,1977c917-b948-45d4-b231-176b3900981f
"def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
      
        arr2.sort()
        N = len(arr1)
        M = len(arr2)
        INF = 10**20

        @cache
        def helper(index1, prev):
            if(index1 == N): return 0
            
            best = INF
            if(arr1[index1] > prev): best = min(best, helper(index1 + 1, arr1[index1]))
            idx = bisect.bisect_right(arr2,prev)
            if(idx < M): best = min(best, 1 + helper(index1 + 1, arr2[idx]))
            return best

        res = helper(0, -1)    
        if(res == INF): return -1
        return res",makeArrayIncreasing.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\makeArrayIncreasing.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(20, 18)",N,function_definition,makeArrayIncreasing,,171,9bb1763d-65f4-4323-bac4-f36234f75e99
"@cache
        def helper(index1, prev):
            if(index1 == N): return 0
            
            best = INF
            if(arr1[index1] > prev): best = min(best, helper(index1 + 1, arr1[index1]))
            idx = bisect.bisect_right(arr2,prev)
            if(idx < M): best = min(best, 1 + helper(index1 + 1, arr2[idx]))
            return best",makeArrayIncreasing.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\makeArrayIncreasing.py,module/class_definition-Solution/function_definition-makeArrayIncreasing/,makeArrayIncreasing,INF = 10**20,"res = helper(0, -1)","(8, 8)","(16, 23)",N,function_definition,"def helper(index1, prev):
            if(index1 == N): return 0
            
            best = INF
            if(arr1[index1] > prev): best = min(best, helper(index1 + 1, arr1[index1]))
            idx = bisect.bisect_right(arr2,prev)
            if(idx < M): best = min(best, 1 + helper(index1 + 1, arr2[idx]))
            return best",,96,54cc6b18-e2ba-4125-8af4-83a1a0ee0759
"class Solution {
    public int maximumScore(int[] nums, int[] multipliers) {
     
        int[] cur = new int[nums.length];
        int[] prev = new int[nums.length];

        for(int row = multipliers.length-1; row>=0; row--){
            for(int i=row; i<nums.length; i++){
                int mIndex = row - (i) + nums.length -1;
//                System.out.println(row + "" "" + i + "" "" + nums.length + "" "" + mIndex);

                if(0>mIndex || mIndex>=multipliers.length) continue;

                int left = (0<=(i-1) && (i-1)<nums.length) ? cur[i-1] : 0;
                int down = (0<=(i) && (i)<nums.length) ? prev[i] : 0;

//                int left = (0<=row && row<nums.length && 0<=(i-1) && (i-1)<nums.length) ? dp[row][i-1] : 0;
//                int down = (0<=row+1 && row+1<nums.length && 0<=(i) && (i)<nums.length) ? dp[row+1][i] : 0;


//                dp[row][i] = Math.max(
//                        nums[row] * multipliers[mIndex] + down,
//                        nums[i] * multipliers[mIndex] + left
//                );

                cur[i] = Math.max(
                        nums[row] * multipliers[mIndex] + down,
                        nums[i] * multipliers[mIndex] + left
                );
//                System.out.println(cur[i]);
            }
            prev = cur;
        }


//        for(int diff=diffBtwIndex; diff<nums.length; diff++ ){
//            for(int i=0; i+diff<nums.length; i++){
//
//
//                int mIndex = i - (i + diff) + nums.length -1;
//                System.out.println( i + "" "" + (i+diff) + "" "" + diff + "" "" + nums.length + "" "" + mIndex);
//                System.out.println(dp[i][i+diff]);
//
//                int left = (0<=i && i<nums.length && 0<=(i+diff-1) && (i+diff-1)<nums.length) ? dp[i][i+diff-1] : 0;
//                int down = (0<=i+1 && i+1<nums.length && 0<=(i+diff) && (i+diff)<nums.length) ? dp[i+1][i+diff] : 0;
//
//
//                dp[i][i+diff] = Math.max(
//                        nums[i]*multipliers[mIndex] + down,
//                        nums[i+diff]*multipliers[mIndex] + left
//                );
//            }
//        }

//        for(int[] x:dp) System.out.println(Arrays.toString(x));

//        System.out.println(Arrays.toString(cur) + "" "" + Arrays.toString(prev));

        return prev[nums.length-1];
    }
}
",MaximumScore.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MaximumScore.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(61, 0)",N,program,program,,661,6e06abed-370e-41e7-86a1-7fcd1b3df6a2
"class Solution {
    public int maximumScore(int[] nums, int[] multipliers) {
     
        int[] cur = new int[nums.length];
        int[] prev = new int[nums.length];

        for(int row = multipliers.length-1; row>=0; row--){
            for(int i=row; i<nums.length; i++){
                int mIndex = row - (i) + nums.length -1;
//                System.out.println(row + "" "" + i + "" "" + nums.length + "" "" + mIndex);

                if(0>mIndex || mIndex>=multipliers.length) continue;

                int left = (0<=(i-1) && (i-1)<nums.length) ? cur[i-1] : 0;
                int down = (0<=(i) && (i)<nums.length) ? prev[i] : 0;

//                int left = (0<=row && row<nums.length && 0<=(i-1) && (i-1)<nums.length) ? dp[row][i-1] : 0;
//                int down = (0<=row+1 && row+1<nums.length && 0<=(i) && (i)<nums.length) ? dp[row+1][i] : 0;


//                dp[row][i] = Math.max(
//                        nums[row] * multipliers[mIndex] + down,
//                        nums[i] * multipliers[mIndex] + left
//                );

                cur[i] = Math.max(
                        nums[row] * multipliers[mIndex] + down,
                        nums[i] * multipliers[mIndex] + left
                );
//                System.out.println(cur[i]);
            }
            prev = cur;
        }


//        for(int diff=diffBtwIndex; diff<nums.length; diff++ ){
//            for(int i=0; i+diff<nums.length; i++){
//
//
//                int mIndex = i - (i + diff) + nums.length -1;
//                System.out.println( i + "" "" + (i+diff) + "" "" + diff + "" "" + nums.length + "" "" + mIndex);
//                System.out.println(dp[i][i+diff]);
//
//                int left = (0<=i && i<nums.length && 0<=(i+diff-1) && (i+diff-1)<nums.length) ? dp[i][i+diff-1] : 0;
//                int down = (0<=i+1 && i+1<nums.length && 0<=(i+diff) && (i+diff)<nums.length) ? dp[i+1][i+diff] : 0;
//
//
//                dp[i][i+diff] = Math.max(
//                        nums[i]*multipliers[mIndex] + down,
//                        nums[i+diff]*multipliers[mIndex] + left
//                );
//            }
//        }

//        for(int[] x:dp) System.out.println(Arrays.toString(x));

//        System.out.println(Arrays.toString(cur) + "" "" + Arrays.toString(prev));

        return prev[nums.length-1];
    }
}",MaximumScore.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MaximumScore.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(60, 1)",N,class_declaration,Solution,,661,a31ac203-d0f1-44aa-92cf-b462b5714c3a
"public int maximumScore(int[] nums, int[] multipliers) {
     
        int[] cur = new int[nums.length];
        int[] prev = new int[nums.length];

        for(int row = multipliers.length-1; row>=0; row--){
            for(int i=row; i<nums.length; i++){
                int mIndex = row - (i) + nums.length -1;
//                System.out.println(row + "" "" + i + "" "" + nums.length + "" "" + mIndex);

                if(0>mIndex || mIndex>=multipliers.length) continue;

                int left = (0<=(i-1) && (i-1)<nums.length) ? cur[i-1] : 0;
                int down = (0<=(i) && (i)<nums.length) ? prev[i] : 0;

//                int left = (0<=row && row<nums.length && 0<=(i-1) && (i-1)<nums.length) ? dp[row][i-1] : 0;
//                int down = (0<=row+1 && row+1<nums.length && 0<=(i) && (i)<nums.length) ? dp[row+1][i] : 0;


//                dp[row][i] = Math.max(
//                        nums[row] * multipliers[mIndex] + down,
//                        nums[i] * multipliers[mIndex] + left
//                );

                cur[i] = Math.max(
                        nums[row] * multipliers[mIndex] + down,
                        nums[i] * multipliers[mIndex] + left
                );
//                System.out.println(cur[i]);
            }
            prev = cur;
        }


//        for(int diff=diffBtwIndex; diff<nums.length; diff++ ){
//            for(int i=0; i+diff<nums.length; i++){
//
//
//                int mIndex = i - (i + diff) + nums.length -1;
//                System.out.println( i + "" "" + (i+diff) + "" "" + diff + "" "" + nums.length + "" "" + mIndex);
//                System.out.println(dp[i][i+diff]);
//
//                int left = (0<=i && i<nums.length && 0<=(i+diff-1) && (i+diff-1)<nums.length) ? dp[i][i+diff-1] : 0;
//                int down = (0<=i+1 && i+1<nums.length && 0<=(i+diff) && (i+diff)<nums.length) ? dp[i+1][i+diff] : 0;
//
//
//                dp[i][i+diff] = Math.max(
//                        nums[i]*multipliers[mIndex] + down,
//                        nums[i+diff]*multipliers[mIndex] + left
//                );
//            }
//        }

//        for(int[] x:dp) System.out.println(Arrays.toString(x));

//        System.out.println(Arrays.toString(cur) + "" "" + Arrays.toString(prev));

        return prev[nums.length-1];
    }",MaximumScore.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MaximumScore.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"int[] cur = new int[nums.length];
int[] prev = new int[nums.length];
for(int row = multipliers.length-1; row>=0; row--){
            for(int i=row; i<nums.length; i++){
                int mIndex = row - (i) + nums.length -1;
//                System.out.println(row + "" "" + i + "" "" + nums.length + "" "" + mIndex);

                if(0>mIndex || mIndex>=multipliers.length) continue;

                int left = (0<=(i-1) && (i-1)<nums.length) ? cur[i-1] : 0;
                int down = (0<=(i) && (i)<nums.length) ? prev[i] : 0;

//                int left = (0<=row && row<nums.length && 0<=(i-1) && (i-1)<nums.length) ? dp[row][i-1] : 0;
//                int down = (0<=row+1 && row+1<nums.length && 0<=(i) && (i)<nums.length) ? dp[row+1][i] : 0;


//                dp[row][i] = Math.max(
//                        nums[row] * multipliers[mIndex] + down,
//                        nums[i] * multipliers[mIndex] + left
//                );

                cur[i] = Math.max(
                        nums[row] * multipliers[mIndex] + down,
                        nums[i] * multipliers[mIndex] + left
                );
//                System.out.println(cur[i]);
            }
            prev = cur;
        }
//        for(int diff=diffBtwIndex; diff<nums.length; diff++ ){
//            for(int i=0; i+diff<nums.length; i++){
//
//
//                int mIndex = i - (i + diff) + nums.length -1;
//                System.out.println( i + "" "" + (i+diff) + "" "" + diff + "" "" + nums.length + "" "" + mIndex);
//                System.out.println(dp[i][i+diff]);
//
//                int left = (0<=i && i<nums.length && 0<=(i+diff-1) && (i+diff-1)<nums.length) ? dp[i][i+diff-1] : 0;","(1, 4)","(59, 5)",N,method_declaration,maximumScore,,656,5bd1a825-d7bb-4c94-b299-50ed97aaaf32
"int[] cur = new int[nums.length];
int[] prev = new int[nums.length];
for(int row = multipliers.length-1; row>=0; row--){
            for(int i=row; i<nums.length; i++){
                int mIndex = row - (i) + nums.length -1;
//                System.out.println(row + "" "" + i + "" "" + nums.length + "" "" + mIndex);

                if(0>mIndex || mIndex>=multipliers.length) continue;

                int left = (0<=(i-1) && (i-1)<nums.length) ? cur[i-1] : 0;
                int down = (0<=(i) && (i)<nums.length) ? prev[i] : 0;

//                int left = (0<=row && row<nums.length && 0<=(i-1) && (i-1)<nums.length) ? dp[row][i-1] : 0;
//                int down = (0<=row+1 && row+1<nums.length && 0<=(i) && (i)<nums.length) ? dp[row+1][i] : 0;


//                dp[row][i] = Math.max(
//                        nums[row] * multipliers[mIndex] + down,
//                        nums[i] * multipliers[mIndex] + left
//                );

                cur[i] = Math.max(
                        nums[row] * multipliers[mIndex] + down,
                        nums[i] * multipliers[mIndex] + left
                );
//                System.out.println(cur[i]);
            }
            prev = cur;
        }
//        for(int diff=diffBtwIndex; diff<nums.length; diff++ ){
//            for(int i=0; i+diff<nums.length; i++){
//
//
//                int mIndex = i - (i + diff) + nums.length -1;
//                System.out.println( i + "" "" + (i+diff) + "" "" + diff + "" "" + nums.length + "" "" + mIndex);
//                System.out.println(dp[i][i+diff]);
//
//                int left = (0<=i && i<nums.length && 0<=(i+diff-1) && (i+diff-1)<nums.length) ? dp[i][i+diff-1] : 0;",MaximumScore.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MaximumScore.java,program/class_declaration-Solution/method_declaration-maximumScore/,maximumScore,Previous sibling does not exist,"//                int down = (0<=i+1 && i+1<nums.length && 0<=(i+diff) && (i+diff)<nums.length) ? dp[i+1][i+diff] : 0;
//
//
//                dp[i][i+diff] = Math.max(
//                        nums[i]*multipliers[mIndex] + down,
//                        nums[i+diff]*multipliers[mIndex] + left
//                );
//            }
//        }
//        for(int[] x:dp) System.out.println(Arrays.toString(x));
//        System.out.println(Arrays.toString(cur) + "" "" + Arrays.toString(prev));
return prev[nums.length-1];
}","(3, 8)","(43, 118)",N,"local_variable_declaration,local_variable_declaration,for_statement,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment",local_variable_declaration,,493,09c4ac54-d649-41c5-a537-ec1012fdb8b5
"//                int down = (0<=i+1 && i+1<nums.length && 0<=(i+diff) && (i+diff)<nums.length) ? dp[i+1][i+diff] : 0;
//
//
//                dp[i][i+diff] = Math.max(
//                        nums[i]*multipliers[mIndex] + down,
//                        nums[i+diff]*multipliers[mIndex] + left
//                );
//            }
//        }
//        for(int[] x:dp) System.out.println(Arrays.toString(x));
//        System.out.println(Arrays.toString(cur) + "" "" + Arrays.toString(prev));
return prev[nums.length-1];
}",MaximumScore.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MaximumScore.java,program/class_declaration-Solution/method_declaration-maximumScore/,maximumScore,//                int left = (0<=i && i<nums.length && 0<=(i+diff-1) && (i+diff-1)<nums.length) ? dp[i][i+diff-1] : 0;,Next sibling does not exist,"(44, 0)","(59, 5)",N,"line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,return_statement,}",line_comment,,142,f545567a-0d71-4fbf-8ce6-5ba0d8c60ec2
"class Solution:
    def maxScore(self, nums: List[int]) -> int:

        N = len(nums)
        s = set([index for index in range(N)])

        def gcd(a, b):
            if(a<b): return gcd(b, a)
            return a if(b==0) else gcd(b, a%b)

        @cache
        def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans
        
        visited = 0        
        ans = helper(visited, 1)
        return ans

# [1,2]
# [3,4,6,8]
# [1,2,3,4,5,6]
# [111111, 222222, 333333, 444444, 555555 ,66666]
# [773274,313112,131789,222437,918065,49745,321270,74163,900218,80160,325440,961730]
# [7,3,1,2,9,4,3,7,9,8,3,9]
",maxScore_gcd.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxScore_gcd.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(35, 0)",N,module,module,,342,d66ae17f-15c3-4abd-b4fa-db2e1c89674e
"class Solution:
    def maxScore(self, nums: List[int]) -> int:

        N = len(nums)
        s = set([index for index in range(N)])

        def gcd(a, b):
            if(a<b): return gcd(b, a)
            return a if(b==0) else gcd(b, a%b)

        @cache
        def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans
        
        visited = 0        
        ans = helper(visited, 1)
        return ans",maxScore_gcd.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxScore_gcd.py,module/,module,Previous sibling does not exist,"# [1,2]","(0, 0)","(27, 18)",N,class_definition,Solution,,223,baf8e432-037b-4a4b-b9eb-483f47b29dbc
"def maxScore(self, nums: List[int]) -> int:

        N = len(nums)
        s = set([index for index in range(N)])

        def gcd(a, b):
            if(a<b): return gcd(b, a)
            return a if(b==0) else gcd(b, a%b)

        @cache
        def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans
        
        visited = 0        
        ans = helper(visited, 1)
        return ans",maxScore_gcd.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxScore_gcd.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(27, 18)",N,function_definition,maxScore,,219,c5413c63-38eb-4e7e-8d1d-c4660dda6db7
"def gcd(a, b):
            if(a<b): return gcd(b, a)
            return a if(b==0) else gcd(b, a%b)",maxScore_gcd.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxScore_gcd.py,module/class_definition-Solution/function_definition-maxScore/,maxScore,s = set([index for index in range(N)]),"@cache
        def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans","(6, 8)","(8, 46)",N,function_definition,gcd,,33,688abc4a-1974-4457-b729-5c230c400ddc
"@cache
        def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans",maxScore_gcd.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxScore_gcd.py,module/class_definition-Solution/function_definition-maxScore/,maxScore,"def gcd(a, b):
            if(a<b): return gcd(b, a)
            return a if(b==0) else gcd(b, a%b)","# [1,2]
# [3,4,6,8]
# [1,2,3,4,5,6]
# [111111, 222222, 333333, 444444, 555555 ,66666]
# [773274,313112,131789,222437,918065,49745,321270,74163,900218,80160,325440,961730]
# [7,3,1,2,9,4,3,7,9,8,3,9]","(10, 8)","(23, 22)",N,function_definition,"def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans",,133,0104af58-603b-463c-ae7d-4b22d790be82
"# [1,2]
# [3,4,6,8]
# [1,2,3,4,5,6]
# [111111, 222222, 333333, 444444, 555555 ,66666]
# [773274,313112,131789,222437,918065,49745,321270,74163,900218,80160,325440,961730]
# [7,3,1,2,9,4,3,7,9,8,3,9]",maxScore_gcd.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxScore_gcd.py,module/,module,"class Solution:
    def maxScore(self, nums: List[int]) -> int:

        N = len(nums)
        s = set([index for index in range(N)])

        def gcd(a, b):
            if(a<b): return gcd(b, a)
            return a if(b==0) else gcd(b, a%b)

        @cache
        def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans
        
        visited = 0        
        ans = helper(visited, 1)
        return ans",Next sibling does not exist,"(29, 0)","(34, 27)",N,"comment,comment,comment,comment,comment,comment",comment,,118,37c9daf9-0eca-4b15-adba-fb5820af34cd
"class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        
        @cache
        def helper(index1, index2):
            if(index1 >= len(nums1) or index2>=len(nums2)): return 0

            if(nums1[index1] == nums2[index2]): return 1+helper(index1+1, index2+1)
            
            ans = -1 * 10**10
            ans = max(ans, helper(index1+1, index2))
            ans = max(ans, helper(index1, index2+1))
            return ans

        return helper(0, 0)

    
    

# class Solution:
#     def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:

#         map1 = defaultdict(list)
#         for index, val in enumerate(nums1): map1[val].append(index)
        
#         indexMapper = defaultdict(list)
#         for index, val in enumerate(nums2): 
#             if(val not in map1): continue
#             for i in map1[val]: indexMapper[i].append(index)

#         @cache
#         def helper(index1, index2):
#             if(index1 >= len(nums1) or index2>=len(nums2)): return 0
#             ans = -1 * 10**10
#             ans = max(ans, helper(index1+1, index2))
#             for index in indexMapper[index1]:
#                 if(index<index2): continue
#                 ans = max(ans, 1+helper(index1+1, index+1))
            
#             return ans

#         return helper(0, 0)
",maxUncrossedLines.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxUncrossedLines.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(42, 0)",N,module,module,,371,ad9bcc3d-8c73-45f0-ac6f-2701524eda5f
"class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        
        @cache
        def helper(index1, index2):
            if(index1 >= len(nums1) or index2>=len(nums2)): return 0

            if(nums1[index1] == nums2[index2]): return 1+helper(index1+1, index2+1)
            
            ans = -1 * 10**10
            ans = max(ans, helper(index1+1, index2))
            ans = max(ans, helper(index1, index2+1))
            return ans

        return helper(0, 0)",maxUncrossedLines.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxUncrossedLines.py,module/,module,Previous sibling does not exist,# class Solution:,"(0, 0)","(14, 27)",N,class_definition,Solution,,145,3d1449dd-ed16-429c-955f-f0fc976fbe86
"def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        
        @cache
        def helper(index1, index2):
            if(index1 >= len(nums1) or index2>=len(nums2)): return 0

            if(nums1[index1] == nums2[index2]): return 1+helper(index1+1, index2+1)
            
            ans = -1 * 10**10
            ans = max(ans, helper(index1+1, index2))
            ans = max(ans, helper(index1, index2+1))
            return ans

        return helper(0, 0)",maxUncrossedLines.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxUncrossedLines.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(14, 27)",N,function_definition,maxUncrossedLines,,141,fcd3579b-7d49-45de-91cd-ff14035cf98a
"@cache
        def helper(index1, index2):
            if(index1 >= len(nums1) or index2>=len(nums2)): return 0

            if(nums1[index1] == nums2[index2]): return 1+helper(index1+1, index2+1)
            
            ans = -1 * 10**10
            ans = max(ans, helper(index1+1, index2))
            ans = max(ans, helper(index1, index2+1))
            return ans",maxUncrossedLines.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxUncrossedLines.py,module/class_definition-Solution/function_definition-maxUncrossedLines/,maxUncrossedLines,Previous sibling does not exist,"# class Solution:
#     def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
#         map1 = defaultdict(list)
#         for index, val in enumerate(nums1): map1[val].append(index)
#         indexMapper = defaultdict(list)
#         for index, val in enumerate(nums2): 
#             if(val not in map1): continue
#             for i in map1[val]: indexMapper[i].append(index)
#         @cache
#         def helper(index1, index2):
#             if(index1 >= len(nums1) or index2>=len(nums2)): return 0
#             ans = -1 * 10**10
#             ans = max(ans, helper(index1+1, index2))
#             for index in indexMapper[index1]:
#                 if(index<index2): continue
#                 ans = max(ans, 1+helper(index1+1, index+1))
#             return ans
#         return helper(0, 0)","(3, 8)","(12, 22)",N,function_definition,"def helper(index1, index2):
            if(index1 >= len(nums1) or index2>=len(nums2)): return 0

            if(nums1[index1] == nums2[index2]): return 1+helper(index1+1, index2+1)
            
            ans = -1 * 10**10
            ans = max(ans, helper(index1+1, index2))
            ans = max(ans, helper(index1, index2+1))
            return ans",,106,b3075e56-9e12-45cc-92dc-48c35383a9cb
"# class Solution:
#     def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
#         map1 = defaultdict(list)
#         for index, val in enumerate(nums1): map1[val].append(index)
#         indexMapper = defaultdict(list)
#         for index, val in enumerate(nums2): 
#             if(val not in map1): continue
#             for i in map1[val]: indexMapper[i].append(index)
#         @cache
#         def helper(index1, index2):
#             if(index1 >= len(nums1) or index2>=len(nums2)): return 0
#             ans = -1 * 10**10
#             ans = max(ans, helper(index1+1, index2))
#             for index in indexMapper[index1]:
#                 if(index<index2): continue
#                 ans = max(ans, 1+helper(index1+1, index+1))
#             return ans
#         return helper(0, 0)",maxUncrossedLines.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxUncrossedLines.py,module/,module,"class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        
        @cache
        def helper(index1, index2):
            if(index1 >= len(nums1) or index2>=len(nums2)): return 0

            if(nums1[index1] == nums2[index2]): return 1+helper(index1+1, index2+1)
            
            ans = -1 * 10**10
            ans = max(ans, helper(index1+1, index2))
            ans = max(ans, helper(index1, index2+1))
            return ans

        return helper(0, 0)",Next sibling does not exist,"(19, 0)","(41, 29)",N,"comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment",comment,,216,ed4467ad-141b-4169-a7e7-84da92d4cfda
"class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:

        N = len(days)
        days.sort()

        @cache
        def helper(index):
            if(index >= N): return 0
            curday = days[index]

            ans = 10**10
            ans = min(ans, helper(index+1)+costs[0])
            
            while(index<N and days[index]-curday<7): index+=1 
            ans = min(ans, helper(index) + costs[1])
            
            while(index<N and days[index]-curday<30): index+=1 
            ans = min(ans, helper(index) + costs[2])
            return ans

        return helper(0)
",mincostTickets.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\mincostTickets.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 0)",N,module,module,,157,7192d8e7-e1bd-45f5-8b27-6e334a54d5f2
"class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:

        N = len(days)
        days.sort()

        @cache
        def helper(index):
            if(index >= N): return 0
            curday = days[index]

            ans = 10**10
            ans = min(ans, helper(index+1)+costs[0])
            
            while(index<N and days[index]-curday<7): index+=1 
            ans = min(ans, helper(index) + costs[1])
            
            while(index<N and days[index]-curday<30): index+=1 
            ans = min(ans, helper(index) + costs[2])
            return ans

        return helper(0)",mincostTickets.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\mincostTickets.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 24)",N,class_definition,Solution,,157,4272dcb6-425a-48b0-9d3b-2626154edeaf
"def mincostTickets(self, days: List[int], costs: List[int]) -> int:

        N = len(days)
        days.sort()

        @cache
        def helper(index):
            if(index >= N): return 0
            curday = days[index]

            ans = 10**10
            ans = min(ans, helper(index+1)+costs[0])
            
            while(index<N and days[index]-curday<7): index+=1 
            ans = min(ans, helper(index) + costs[1])
            
            while(index<N and days[index]-curday<30): index+=1 
            ans = min(ans, helper(index) + costs[2])
            return ans

        return helper(0)",mincostTickets.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\mincostTickets.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(21, 24)",N,function_definition,mincostTickets,,153,4e71ad0c-19bf-47c2-908f-cb15bc75d2a3
"@cache
        def helper(index):
            if(index >= N): return 0
            curday = days[index]

            ans = 10**10
            ans = min(ans, helper(index+1)+costs[0])
            
            while(index<N and days[index]-curday<7): index+=1 
            ans = min(ans, helper(index) + costs[1])
            
            while(index<N and days[index]-curday<30): index+=1 
            ans = min(ans, helper(index) + costs[2])
            return ans",mincostTickets.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\mincostTickets.py,module/class_definition-Solution/function_definition-mincostTickets/,mincostTickets,days.sort(),return helper(0),"(6, 8)","(19, 22)",N,function_definition,"def helper(index):
            if(index >= N): return 0
            curday = days[index]

            ans = 10**10
            ans = min(ans, helper(index+1)+costs[0])
            
            while(index<N and days[index]-curday<7): index+=1 
            ans = min(ans, helper(index) + costs[1])
            
            while(index<N and days[index]-curday<30): index+=1 
            ans = min(ans, helper(index) + costs[2])
            return ans",,116,c4545e27-8239-4066-b8ae-a1e250643384
"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:

        N = len(cuts)
        cuts.sort()


        @cache
        def helper(start_index, end_index, cstart, cend):
            if(start_index == end_index): return 0
            if(cstart == cend): return end_index - start_index
            if(cstart>cend): return 0

            ans = 10**10
            cur_cost = end_index - start_index
            for index in range(cstart, cend+1):
                ans = min(ans, cur_cost + helper(start_index, cuts[index], cstart, index-1) + helper(cuts[index], end_index, index+1, cend))
            return ans

        return helper(0, n, 0, N-1)
",minCostToCutStick.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minCostToCutStick.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(20, 0)",N,module,module,,178,1e713205-9c1e-4666-b41b-81df75c01b1a
"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:

        N = len(cuts)
        cuts.sort()


        @cache
        def helper(start_index, end_index, cstart, cend):
            if(start_index == end_index): return 0
            if(cstart == cend): return end_index - start_index
            if(cstart>cend): return 0

            ans = 10**10
            cur_cost = end_index - start_index
            for index in range(cstart, cend+1):
                ans = min(ans, cur_cost + helper(start_index, cuts[index], cstart, index-1) + helper(cuts[index], end_index, index+1, cend))
            return ans

        return helper(0, n, 0, N-1)",minCostToCutStick.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minCostToCutStick.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(19, 35)",N,class_definition,Solution,,178,f1d90c57-738c-4f86-9f90-258cc5e11ae8
"def minCost(self, n: int, cuts: List[int]) -> int:

        N = len(cuts)
        cuts.sort()


        @cache
        def helper(start_index, end_index, cstart, cend):
            if(start_index == end_index): return 0
            if(cstart == cend): return end_index - start_index
            if(cstart>cend): return 0

            ans = 10**10
            cur_cost = end_index - start_index
            for index in range(cstart, cend+1):
                ans = min(ans, cur_cost + helper(start_index, cuts[index], cstart, index-1) + helper(cuts[index], end_index, index+1, cend))
            return ans

        return helper(0, n, 0, N-1)",minCostToCutStick.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minCostToCutStick.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(19, 35)",N,function_definition,minCost,,174,995b527c-be7a-4789-81fd-13b513b474d7
"@cache
        def helper(start_index, end_index, cstart, cend):
            if(start_index == end_index): return 0
            if(cstart == cend): return end_index - start_index
            if(cstart>cend): return 0

            ans = 10**10
            cur_cost = end_index - start_index
            for index in range(cstart, cend+1):
                ans = min(ans, cur_cost + helper(start_index, cuts[index], cstart, index-1) + helper(cuts[index], end_index, index+1, cend))
            return ans",minCostToCutStick.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minCostToCutStick.py,module/class_definition-Solution/function_definition-minCost/,minCost,cuts.sort(),"return helper(0, n, 0, N-1)","(7, 8)","(17, 22)",N,function_definition,"def helper(start_index, end_index, cstart, cend):
            if(start_index == end_index): return 0
            if(cstart == cend): return end_index - start_index
            if(cstart>cend): return 0

            ans = 10**10
            cur_cost = end_index - start_index
            for index in range(cstart, cend+1):
                ans = min(ans, cur_cost + helper(start_index, cuts[index], cstart, index-1) + helper(cuts[index], end_index, index+1, cend))
            return ans",,129,989986d8-5cd0-4b2b-923d-900252318315
"class Solution:
    def __init__(self):
        self.s1 = None
        self.s2 = None
        self.cache = {}


    def helper(self, index1, index2):
        key = (index1, index2)
        if(key  in self.cache): return self.cache[key]

        if(index1 == len(self.s1)): return len(self.s2) -index2
        if(len(self.s2) == index2): return len(self.s1) - index1
        if(self.s1[index1] == self.s2[index2]): ans = self.helper(index1+1, index2+1)
        else: ans = min(self.helper(index1, index2+1) +1, self.helper(index1+1, index2) +1, self.helper(index1+1, index2+1) +1)

        self.cache[key] = ans
        return ans

    def minDistance(self, s1: str, s2: str) -> int:
        self.s1 = s1
        self.s2 = s2
        return self.helper(0, 0)
",minDistance.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minDistance.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,module,module,,237,f5da8394-2f30-4d64-bdc6-45a1d8c500ed
"class Solution:
    def __init__(self):
        self.s1 = None
        self.s2 = None
        self.cache = {}


    def helper(self, index1, index2):
        key = (index1, index2)
        if(key  in self.cache): return self.cache[key]

        if(index1 == len(self.s1)): return len(self.s2) -index2
        if(len(self.s2) == index2): return len(self.s1) - index1
        if(self.s1[index1] == self.s2[index2]): ans = self.helper(index1+1, index2+1)
        else: ans = min(self.helper(index1, index2+1) +1, self.helper(index1+1, index2) +1, self.helper(index1+1, index2+1) +1)

        self.cache[key] = ans
        return ans

    def minDistance(self, s1: str, s2: str) -> int:
        self.s1 = s1
        self.s2 = s2
        return self.helper(0, 0)",minDistance.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minDistance.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 32)",N,class_definition,Solution,,237,9916e819-50ea-42e5-a792-0eeeb6991de9
"def __init__(self):
        self.s1 = None
        self.s2 = None
        self.cache = {}",minDistance.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minDistance.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def helper(self, index1, index2):
        key = (index1, index2)
        if(key  in self.cache): return self.cache[key]

        if(index1 == len(self.s1)): return len(self.s2) -index2
        if(len(self.s2) == index2): return len(self.s1) - index1
        if(self.s1[index1] == self.s2[index2]): ans = self.helper(index1+1, index2+1)
        else: ans = min(self.helper(index1, index2+1) +1, self.helper(index1+1, index2) +1, self.helper(index1+1, index2+1) +1)

        self.cache[key] = ans
        return ans","(1, 4)","(4, 23)",N,function_definition,__init__,,25,25193d84-95f2-43f1-9d34-798509f60879
"def helper(self, index1, index2):
        key = (index1, index2)
        if(key  in self.cache): return self.cache[key]

        if(index1 == len(self.s1)): return len(self.s2) -index2
        if(len(self.s2) == index2): return len(self.s1) - index1
        if(self.s1[index1] == self.s2[index2]): ans = self.helper(index1+1, index2+1)
        else: ans = min(self.helper(index1, index2+1) +1, self.helper(index1+1, index2) +1, self.helper(index1+1, index2+1) +1)

        self.cache[key] = ans
        return ans",minDistance.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minDistance.py,module/class_definition-Solution/,Solution,"def __init__(self):
        self.s1 = None
        self.s2 = None
        self.cache = {}","def minDistance(self, s1: str, s2: str) -> int:
        self.s1 = s1
        self.s2 = s2
        return self.helper(0, 0)","(7, 4)","(17, 18)",N,function_definition,helper,,161,93e1e8d6-a8a1-4073-9a50-d49718c56b51
"def minDistance(self, s1: str, s2: str) -> int:
        self.s1 = s1
        self.s2 = s2
        return self.helper(0, 0)",minDistance.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minDistance.py,module/class_definition-Solution/,Solution,"def helper(self, index1, index2):
        key = (index1, index2)
        if(key  in self.cache): return self.cache[key]

        if(index1 == len(self.s1)): return len(self.s2) -index2
        if(len(self.s2) == index2): return len(self.s1) - index1
        if(self.s1[index1] == self.s2[index2]): ans = self.helper(index1+1, index2+1)
        else: ans = min(self.helper(index1, index2+1) +1, self.helper(index1+1, index2) +1, self.helper(index1+1, index2+1) +1)

        self.cache[key] = ans
        return ans",Next sibling does not exist,"(19, 4)","(22, 32)",N,function_definition,minDistance,,44,4188f750-e2d7-4063-93f3-32bc7c58d5e4
"class Solution:
    def minimizeMax(self, nums: List[int], p: int) -> int:
        if(p == 0): return 0

        N = len(nums)
        nums.sort()
        inf = 10**10 +1

        prevprev = [inf for i in range(p + 1)]
        prev = [inf for i in range(p + 1)]
        dp = [inf for i in range(p + 1)]
        
        for index in range(N-2, -1, -1):
            for p_index in range(1, p+1):
                if(N - index < 2*p_index): continue
                if( p_index == 0): continue
                if(p_index == 1):
                    dp[p_index] = min(prev[p_index], nums[index+1] - nums[index])
                    continue

                dp[p_index] = min(
                    max(nums[index+1] - nums[index], prevprev[p_index-1]),
                    prev[p_index]
                )

            prevprev = prev
            prev = dp
            dp = [inf for i in range(p + 1)]
            
        return prev[-1]

# best solution for the problem is using binary search ckeck the problem (2616. leetcode)
# with a mix of greedy.
",minimizeMax.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minimizeMax.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(33, 0)",N,module,module,,273,6d8ef492-fb9d-48c0-81c8-65da7b6b5413
"class Solution:
    def minimizeMax(self, nums: List[int], p: int) -> int:
        if(p == 0): return 0

        N = len(nums)
        nums.sort()
        inf = 10**10 +1

        prevprev = [inf for i in range(p + 1)]
        prev = [inf for i in range(p + 1)]
        dp = [inf for i in range(p + 1)]
        
        for index in range(N-2, -1, -1):
            for p_index in range(1, p+1):
                if(N - index < 2*p_index): continue
                if( p_index == 0): continue
                if(p_index == 1):
                    dp[p_index] = min(prev[p_index], nums[index+1] - nums[index])
                    continue

                dp[p_index] = min(
                    max(nums[index+1] - nums[index], prevprev[p_index-1]),
                    prev[p_index]
                )

            prevprev = prev
            prev = dp
            dp = [inf for i in range(p + 1)]
            
        return prev[-1]",minimizeMax.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minimizeMax.py,module/,module,Previous sibling does not exist,# best solution for the problem is using binary search ckeck the problem (2616. leetcode),"(0, 0)","(29, 23)",N,class_definition,Solution,,244,9b40290f-a32f-47b3-9026-1f28751395e7
"def minimizeMax(self, nums: List[int], p: int) -> int:
        if(p == 0): return 0

        N = len(nums)
        nums.sort()
        inf = 10**10 +1

        prevprev = [inf for i in range(p + 1)]
        prev = [inf for i in range(p + 1)]
        dp = [inf for i in range(p + 1)]
        
        for index in range(N-2, -1, -1):
            for p_index in range(1, p+1):
                if(N - index < 2*p_index): continue
                if( p_index == 0): continue
                if(p_index == 1):
                    dp[p_index] = min(prev[p_index], nums[index+1] - nums[index])
                    continue

                dp[p_index] = min(
                    max(nums[index+1] - nums[index], prevprev[p_index-1]),
                    prev[p_index]
                )

            prevprev = prev
            prev = dp
            dp = [inf for i in range(p + 1)]
            
        return prev[-1]",minimizeMax.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minimizeMax.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"# best solution for the problem is using binary search ckeck the problem (2616. leetcode)
# with a mix of greedy.","(1, 4)","(29, 23)",N,function_definition,minimizeMax,,240,64b793e6-b6e6-4b10-a4c8-74e21372e02f
"# best solution for the problem is using binary search ckeck the problem (2616. leetcode)
# with a mix of greedy.",minimizeMax.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minimizeMax.py,module/,module,"class Solution:
    def minimizeMax(self, nums: List[int], p: int) -> int:
        if(p == 0): return 0

        N = len(nums)
        nums.sort()
        inf = 10**10 +1

        prevprev = [inf for i in range(p + 1)]
        prev = [inf for i in range(p + 1)]
        dp = [inf for i in range(p + 1)]
        
        for index in range(N-2, -1, -1):
            for p_index in range(1, p+1):
                if(N - index < 2*p_index): continue
                if( p_index == 0): continue
                if(p_index == 1):
                    dp[p_index] = min(prev[p_index], nums[index+1] - nums[index])
                    continue

                dp[p_index] = min(
                    max(nums[index+1] - nums[index], prevprev[p_index-1]),
                    prev[p_index]
                )

            prevprev = prev
            prev = dp
            dp = [inf for i in range(p + 1)]
            
        return prev[-1]",Next sibling does not exist,"(31, 0)","(32, 23)",N,"comment,comment",comment,,29,9572a20a-a8c2-4464-9687-5cefe533e654
"class Solution:
    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
                
        maxArr = [[-1]*len(jobDifficulty)  for i in range(len(jobDifficulty))]
        
        for i in range(len(jobDifficulty)):
            maxArr[i][i] = jobDifficulty[i]
        
        for l in range(1, len(jobDifficulty)):
            for start in range(0, len(jobDifficulty)):
                if(l+start < len(maxArr)):
                    maxArr[start][start+l] = max(maxArr[start][start+l-1], maxArr[start+1][start+l])
                        
        cache = {}
        
        def getMin(index, d):
            
            if(d == 1): return maxArr[index][-1]
            if(d>len(jobDifficulty)): return -1
            
            key = (index, d)
            
            if(key in cache): return cache[key]
        
            prefixMax = -1
            best = 10**20
        
            for i in range(0, len(jobDifficulty[index:])-d+1):
                best = min(best, maxArr[index][index+i] + getMin(index + i + 1, d-1))
            
            cache[key] = best
            return best
        
        return getMin(0, d)
",MinimumDifficultyJobSchedule.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MinimumDifficultyJobSchedule.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(34, 0)",N,module,module,,271,a6252e9a-3aaf-40f4-8e7a-d3dbc316be7d
"class Solution:
    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
                
        maxArr = [[-1]*len(jobDifficulty)  for i in range(len(jobDifficulty))]
        
        for i in range(len(jobDifficulty)):
            maxArr[i][i] = jobDifficulty[i]
        
        for l in range(1, len(jobDifficulty)):
            for start in range(0, len(jobDifficulty)):
                if(l+start < len(maxArr)):
                    maxArr[start][start+l] = max(maxArr[start][start+l-1], maxArr[start+1][start+l])
                        
        cache = {}
        
        def getMin(index, d):
            
            if(d == 1): return maxArr[index][-1]
            if(d>len(jobDifficulty)): return -1
            
            key = (index, d)
            
            if(key in cache): return cache[key]
        
            prefixMax = -1
            best = 10**20
        
            for i in range(0, len(jobDifficulty[index:])-d+1):
                best = min(best, maxArr[index][index+i] + getMin(index + i + 1, d-1))
            
            cache[key] = best
            return best
        
        return getMin(0, d)",MinimumDifficultyJobSchedule.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MinimumDifficultyJobSchedule.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(33, 27)",N,class_definition,Solution,,271,3f628821-9732-4321-9b72-c758d8cc7bbf
"def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
                
        maxArr = [[-1]*len(jobDifficulty)  for i in range(len(jobDifficulty))]
        
        for i in range(len(jobDifficulty)):
            maxArr[i][i] = jobDifficulty[i]
        
        for l in range(1, len(jobDifficulty)):
            for start in range(0, len(jobDifficulty)):
                if(l+start < len(maxArr)):
                    maxArr[start][start+l] = max(maxArr[start][start+l-1], maxArr[start+1][start+l])
                        
        cache = {}
        
        def getMin(index, d):
            
            if(d == 1): return maxArr[index][-1]
            if(d>len(jobDifficulty)): return -1
            
            key = (index, d)
            
            if(key in cache): return cache[key]
        
            prefixMax = -1
            best = 10**20
        
            for i in range(0, len(jobDifficulty[index:])-d+1):
                best = min(best, maxArr[index][index+i] + getMin(index + i + 1, d-1))
            
            cache[key] = best
            return best
        
        return getMin(0, d)",MinimumDifficultyJobSchedule.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MinimumDifficultyJobSchedule.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(33, 27)",N,function_definition,minDifficulty,,267,509d7c04-891f-4653-8626-a623108b48b6
"def getMin(index, d):
            
            if(d == 1): return maxArr[index][-1]
            if(d>len(jobDifficulty)): return -1
            
            key = (index, d)
            
            if(key in cache): return cache[key]
        
            prefixMax = -1
            best = 10**20
        
            for i in range(0, len(jobDifficulty[index:])-d+1):
                best = min(best, maxArr[index][index+i] + getMin(index + i + 1, d-1))
            
            cache[key] = best
            return best",MinimumDifficultyJobSchedule.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MinimumDifficultyJobSchedule.py,module/class_definition-Solution/function_definition-minDifficulty/,minDifficulty,cache = {},"return getMin(0, d)","(15, 8)","(31, 23)",N,function_definition,getMin,,125,a951c2ff-16d4-4057-9201-9130e8dea01c
"class Solution:
    def minPathSum(self, dp: List[List[int]]) -> int:

        N = len(dp)
        M = len(dp[0])

        for i in range(1, N): dp[i][0] += dp[i-1][0]
        for i in range(1, M): dp[0][i] += dp[0][i-1]

        for i in range(1, N):
            for j in range(1, M):
                dp[i][j] += min(dp[i-1][j], dp[i][j-1])

        return dp[-1][-1]
",minPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minPathSum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 0)",N,module,module,,131,c985b9ba-d137-4fd1-a181-d90215b7499e
"class Solution:
    def minPathSum(self, dp: List[List[int]]) -> int:

        N = len(dp)
        M = len(dp[0])

        for i in range(1, N): dp[i][0] += dp[i-1][0]
        for i in range(1, M): dp[0][i] += dp[0][i-1]

        for i in range(1, N):
            for j in range(1, M):
                dp[i][j] += min(dp[i-1][j], dp[i][j-1])

        return dp[-1][-1]",minPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minPathSum.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(13, 25)",N,class_definition,Solution,,131,cfeffe4e-fb60-401e-b424-0045baa811a3
"def minPathSum(self, dp: List[List[int]]) -> int:

        N = len(dp)
        M = len(dp[0])

        for i in range(1, N): dp[i][0] += dp[i-1][0]
        for i in range(1, M): dp[0][i] += dp[0][i-1]

        for i in range(1, N):
            for j in range(1, M):
                dp[i][j] += min(dp[i-1][j], dp[i][j-1])

        return dp[-1][-1]",minPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minPathSum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(13, 25)",N,function_definition,minPathSum,,127,5be3bbd1-7876-4bbe-9e45-c5ebb2e7ccc7
"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        dp = [[] for i in range(10**4+2)]
        for i in range(k, 10**4+2):
            if(k<=n): dp[i] = [1, 0]
            else: dp[i] = [0, 1]
        
        start_index = k
        end_index = k-1+maxPts
        x_sum = sum(i[0] for i in dp[start_index:end_index+1])
        y_sum = sum(i[-1] for i in dp[start_index:end_index+1])
        print(x_sum, y_sum)

        for i in range(k-1, -1, -1):
            ans = [x_sum * 1/maxPts, y_sum * 1/maxPts]
            dp[i] = ans

            x_sum = x_sum + dp[start_index-1][0] - dp[end_index][0]
            y_sum = y_sum + dp[start_index-1][1] - dp[end_index][1]
            start_index-=1
            end_index-=1
        
        print(dp)
        return x_sum


        # cache = {}
        # def helper(num):
        #     if(num >= k):
        #         if(num>n): return [0, 1]
        #         return [1, 0]

        #     ans = [0, 0]
        #     for i in range(1, maxPts+1):
        #         x, y = helper(num + i)
        #         ans[0] += x * (1/maxPts)
        #         ans[-1] += y * (1/maxPts)

        #     cache[num] = ans
        #     return ans 
        
        # arr = helper(0)
        # return arr[0]

ans = Solution().new21Game(10000, 6666, 565)
print(ans)",New21Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\New21Game.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(45, 10)",N,module,module,,419,c59d272f-e4d6-416b-acc8-bbadef9a610b
"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        dp = [[] for i in range(10**4+2)]
        for i in range(k, 10**4+2):
            if(k<=n): dp[i] = [1, 0]
            else: dp[i] = [0, 1]
        
        start_index = k
        end_index = k-1+maxPts
        x_sum = sum(i[0] for i in dp[start_index:end_index+1])
        y_sum = sum(i[-1] for i in dp[start_index:end_index+1])
        print(x_sum, y_sum)

        for i in range(k-1, -1, -1):
            ans = [x_sum * 1/maxPts, y_sum * 1/maxPts]
            dp[i] = ans

            x_sum = x_sum + dp[start_index-1][0] - dp[end_index][0]
            y_sum = y_sum + dp[start_index-1][1] - dp[end_index][1]
            start_index-=1
            end_index-=1
        
        print(dp)
        return x_sum


        # cache = {}
        # def helper(num):
        #     if(num >= k):
        #         if(num>n): return [0, 1]
        #         return [1, 0]

        #     ans = [0, 0]
        #     for i in range(1, maxPts+1):
        #         x, y = helper(num + i)
        #         ans[0] += x * (1/maxPts)
        #         ans[-1] += y * (1/maxPts)

        #     cache[num] = ans
        #     return ans 
        
        # arr = helper(0)
        # return arr[0]",New21Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\New21Game.py,module/,module,Previous sibling does not exist,"ans = Solution().new21Game(10000, 6666, 565)","(0, 0)","(42, 23)",N,class_definition,Solution,,398,ab853f67-5ff6-464e-89f0-c8780811765a
"def new21Game(self, n: int, k: int, maxPts: int) -> float:
        dp = [[] for i in range(10**4+2)]
        for i in range(k, 10**4+2):
            if(k<=n): dp[i] = [1, 0]
            else: dp[i] = [0, 1]
        
        start_index = k
        end_index = k-1+maxPts
        x_sum = sum(i[0] for i in dp[start_index:end_index+1])
        y_sum = sum(i[-1] for i in dp[start_index:end_index+1])
        print(x_sum, y_sum)

        for i in range(k-1, -1, -1):
            ans = [x_sum * 1/maxPts, y_sum * 1/maxPts]
            dp[i] = ans

            x_sum = x_sum + dp[start_index-1][0] - dp[end_index][0]
            y_sum = y_sum + dp[start_index-1][1] - dp[end_index][1]
            start_index-=1
            end_index-=1
        
        print(dp)
        return x_sum


        # cache = {}
        # def helper(num):
        #     if(num >= k):
        #         if(num>n): return [0, 1]
        #         return [1, 0]

        #     ans = [0, 0]
        #     for i in range(1, maxPts+1):
        #         x, y = helper(num + i)
        #         ans[0] += x * (1/maxPts)
        #         ans[-1] += y * (1/maxPts)

        #     cache[num] = ans
        #     return ans 
        
        # arr = helper(0)
        # return arr[0]",New21Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\New21Game.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"ans = Solution().new21Game(10000, 6666, 565)
print(ans)","(1, 4)","(42, 23)",N,function_definition,new21Game,,394,75792318-6b04-4ff3-b65b-b50709407113
"ans = Solution().new21Game(10000, 6666, 565)
print(ans)",New21Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\New21Game.py,module/,module,"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        dp = [[] for i in range(10**4+2)]
        for i in range(k, 10**4+2):
            if(k<=n): dp[i] = [1, 0]
            else: dp[i] = [0, 1]
        
        start_index = k
        end_index = k-1+maxPts
        x_sum = sum(i[0] for i in dp[start_index:end_index+1])
        y_sum = sum(i[-1] for i in dp[start_index:end_index+1])
        print(x_sum, y_sum)

        for i in range(k-1, -1, -1):
            ans = [x_sum * 1/maxPts, y_sum * 1/maxPts]
            dp[i] = ans

            x_sum = x_sum + dp[start_index-1][0] - dp[end_index][0]
            y_sum = y_sum + dp[start_index-1][1] - dp[end_index][1]
            start_index-=1
            end_index-=1
        
        print(dp)
        return x_sum


        # cache = {}
        # def helper(num):
        #     if(num >= k):
        #         if(num>n): return [0, 1]
        #         return [1, 0]

        #     ans = [0, 0]
        #     for i in range(1, maxPts+1):
        #         x, y = helper(num + i)
        #         ans[0] += x * (1/maxPts)
        #         ans[-1] += y * (1/maxPts)

        #     cache[num] = ans
        #     return ans 
        
        # arr = helper(0)
        # return arr[0]",Next sibling does not exist,"(44, 0)","(45, 10)",N,"expression_statement,expression_statement",expression_statement,,21,e8117b8d-0255-4d0d-88a8-2cd45190f662
"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        
        mod = 10**9 + 7

        @cache
        def helper(index):
            if(index == len(s)): return 1
            if(s[index] == '0'): return 0

            count = 0
            cur = 0
            for ind in range(index, len(s)):
                cur *= 10 
                cur += int(s[ind])
                if(cur > k): break

                count = (count%mod +  helper(ind+1)%mod)%mod
            return count

        return helper(0)
",numberOfArrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\numberOfArrays.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 0)",N,module,module,,136,5ca22486-79d5-45e3-a7a4-1522a0e861e5
"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        
        mod = 10**9 + 7

        @cache
        def helper(index):
            if(index == len(s)): return 1
            if(s[index] == '0'): return 0

            count = 0
            cur = 0
            for ind in range(index, len(s)):
                cur *= 10 
                cur += int(s[ind])
                if(cur > k): break

                count = (count%mod +  helper(ind+1)%mod)%mod
            return count

        return helper(0)",numberOfArrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\numberOfArrays.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(20, 24)",N,class_definition,Solution,,136,c329e348-7aaf-477e-ba12-e87ee5419d75
"def numberOfArrays(self, s: str, k: int) -> int:
        
        mod = 10**9 + 7

        @cache
        def helper(index):
            if(index == len(s)): return 1
            if(s[index] == '0'): return 0

            count = 0
            cur = 0
            for ind in range(index, len(s)):
                cur *= 10 
                cur += int(s[ind])
                if(cur > k): break

                count = (count%mod +  helper(ind+1)%mod)%mod
            return count

        return helper(0)",numberOfArrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\numberOfArrays.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(20, 24)",N,function_definition,numberOfArrays,,132,b4ab30bb-92b2-4276-8e81-c57257ef14cc
"@cache
        def helper(index):
            if(index == len(s)): return 1
            if(s[index] == '0'): return 0

            count = 0
            cur = 0
            for ind in range(index, len(s)):
                cur *= 10 
                cur += int(s[ind])
                if(cur > k): break

                count = (count%mod +  helper(ind+1)%mod)%mod
            return count",numberOfArrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\numberOfArrays.py,module/class_definition-Solution/function_definition-numberOfArrays/,numberOfArrays,mod = 10**9 + 7,return helper(0),"(5, 8)","(18, 24)",N,function_definition,"def helper(index):
            if(index == len(s)): return 1
            if(s[index] == '0'): return 0

            count = 0
            cur = 0
            for ind in range(index, len(s)):
                cur *= 10 
                cur += int(s[ind])
                if(cur > k): break

                count = (count%mod +  helper(ind+1)%mod)%mod
            return count",,96,43210542-c254-462e-93de-896dd656def2
"class Solution {
    public int numberOfWays(int startPos, int endPos, int k) {
        if(endPos<startPos) return numberOfWays(endPos, startPos, k);

        if(startPos+k < endPos) return 0;
        
        int xysum = k;
        int xysub = endPos - startPos;
        
        if((xysum + xysub)%2 == 1) return 0;
        
        int x = (xysum + xysub)/2;
        int y = xysum - x;
        
        return ncr(k, x);
    }
    
    public int ncr(int n, int r){
        int[][] ans = new int[n+1][n+1];
        ans[0][0] = 1;

        for(int i = 1; i <= n; i++) {
            ans[i][0] = 1;
            for(int j = 1; j <= i; j++) {
                ans[i][j] = (ans[i - 1][j - 1] + ans[i - 1][j]) % (1000000007);
            }
        }
        return ans[n][r];
    }
    
}
",NumberOfWays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumberOfWays.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 0)",N,program,program,,258,10c4f03e-fef2-42cb-82d8-0af56b3f7654
"class Solution {
    public int numberOfWays(int startPos, int endPos, int k) {
        if(endPos<startPos) return numberOfWays(endPos, startPos, k);

        if(startPos+k < endPos) return 0;
        
        int xysum = k;
        int xysub = endPos - startPos;
        
        if((xysum + xysub)%2 == 1) return 0;
        
        int x = (xysum + xysub)/2;
        int y = xysum - x;
        
        return ncr(k, x);
    }
    
    public int ncr(int n, int r){
        int[][] ans = new int[n+1][n+1];
        ans[0][0] = 1;

        for(int i = 1; i <= n; i++) {
            ans[i][0] = 1;
            for(int j = 1; j <= i; j++) {
                ans[i][j] = (ans[i - 1][j - 1] + ans[i - 1][j]) % (1000000007);
            }
        }
        return ans[n][r];
    }
    
}",NumberOfWays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumberOfWays.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 1)",N,class_declaration,Solution,,258,11795cc7-9a5d-4339-a0fa-0d4c53e97778
"public int numberOfWays(int startPos, int endPos, int k) {
        if(endPos<startPos) return numberOfWays(endPos, startPos, k);

        if(startPos+k < endPos) return 0;
        
        int xysum = k;
        int xysub = endPos - startPos;
        
        if((xysum + xysub)%2 == 1) return 0;
        
        int x = (xysum + xysub)/2;
        int y = xysum - x;
        
        return ncr(k, x);
    }",NumberOfWays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumberOfWays.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public int ncr(int n, int r){
        int[][] ans = new int[n+1][n+1];
        ans[0][0] = 1;

        for(int i = 1; i <= n; i++) {
            ans[i][0] = 1;
            for(int j = 1; j <= i; j++) {
                ans[i][j] = (ans[i - 1][j - 1] + ans[i - 1][j]) % (1000000007);
            }
        }
        return ans[n][r];
    }","(1, 4)","(15, 5)",N,method_declaration,numberOfWays,,126,1932606c-8493-4f8c-880f-768f29fe9119
"public int ncr(int n, int r){
        int[][] ans = new int[n+1][n+1];
        ans[0][0] = 1;

        for(int i = 1; i <= n; i++) {
            ans[i][0] = 1;
            for(int j = 1; j <= i; j++) {
                ans[i][j] = (ans[i - 1][j - 1] + ans[i - 1][j]) % (1000000007);
            }
        }
        return ans[n][r];
    }",NumberOfWays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumberOfWays.java,program/class_declaration-Solution/,Solution,"public int numberOfWays(int startPos, int endPos, int k) {
        if(endPos<startPos) return numberOfWays(endPos, startPos, k);

        if(startPos+k < endPos) return 0;
        
        int xysum = k;
        int xysub = endPos - startPos;
        
        if((xysum + xysub)%2 == 1) return 0;
        
        int x = (xysum + xysub)/2;
        int y = xysum - x;
        
        return ncr(k, x);
    }",Next sibling does not exist,"(17, 4)","(28, 5)",N,method_declaration,ncr,,124,ae26c86d-c8f3-47be-98bf-05c868ce855c
"class Solution {
    public int numDecodings(String s) {

        final int n = s.length();
        int[] ans = new int[n];
        
        ans[n-1] = s.charAt(n-1) != '0' ? 1 : 0;
        
        if(n>=2){
            ans[n-2] = isValid(s.substring(n-2)) * 1 +  isValid(s.substring(n-2,n-1)) * ans[s.length()-1];
        }
        
        for(int index = n-3; index>=0; index--){
            ans[index] = isValid(s.substring(index,index+2)) * ans[index+2] +  isValid(s.substring(index,index+1)) * ans[index+1];
        }
        
        // System.out.println(Arrays.toString(ans));
        
        return ans[0];
    }
    
    
    public int isValid(String s){
        // System.out.println(s);
        if(s.charAt(0)=='0') return 0;
        int val = Integer.parseInt(s);
        return (val>=1 && val<=26) ? 1 :0;
    }
}
",NumDecodings.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumDecodings.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 0)",N,program,program,,228,a8a7e2db-0da8-48f1-8b47-3415189e9ce1
"class Solution {
    public int numDecodings(String s) {

        final int n = s.length();
        int[] ans = new int[n];
        
        ans[n-1] = s.charAt(n-1) != '0' ? 1 : 0;
        
        if(n>=2){
            ans[n-2] = isValid(s.substring(n-2)) * 1 +  isValid(s.substring(n-2,n-1)) * ans[s.length()-1];
        }
        
        for(int index = n-3; index>=0; index--){
            ans[index] = isValid(s.substring(index,index+2)) * ans[index+2] +  isValid(s.substring(index,index+1)) * ans[index+1];
        }
        
        // System.out.println(Arrays.toString(ans));
        
        return ans[0];
    }
    
    
    public int isValid(String s){
        // System.out.println(s);
        if(s.charAt(0)=='0') return 0;
        int val = Integer.parseInt(s);
        return (val>=1 && val<=26) ? 1 :0;
    }
}",NumDecodings.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumDecodings.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 1)",N,class_declaration,Solution,,228,118d8df0-8883-4813-ae4d-d260605a63fe
"public int numDecodings(String s) {

        final int n = s.length();
        int[] ans = new int[n];
        
        ans[n-1] = s.charAt(n-1) != '0' ? 1 : 0;
        
        if(n>=2){
            ans[n-2] = isValid(s.substring(n-2)) * 1 +  isValid(s.substring(n-2,n-1)) * ans[s.length()-1];
        }
        
        for(int index = n-3; index>=0; index--){
            ans[index] = isValid(s.substring(index,index+2)) * ans[index+2] +  isValid(s.substring(index,index+1)) * ans[index+1];
        }
        
        // System.out.println(Arrays.toString(ans));
        
        return ans[0];
    }",NumDecodings.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumDecodings.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public int isValid(String s){
        // System.out.println(s);
        if(s.charAt(0)=='0') return 0;
        int val = Integer.parseInt(s);
        return (val>=1 && val<=26) ? 1 :0;
    }","(1, 4)","(19, 5)",N,method_declaration,numDecodings,,168,5078420a-7d68-48d6-9284-3467cb22bcc1
"public int isValid(String s){
        // System.out.println(s);
        if(s.charAt(0)=='0') return 0;
        int val = Integer.parseInt(s);
        return (val>=1 && val<=26) ? 1 :0;
    }",NumDecodings.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumDecodings.java,program/class_declaration-Solution/,Solution,"public int numDecodings(String s) {

        final int n = s.length();
        int[] ans = new int[n];
        
        ans[n-1] = s.charAt(n-1) != '0' ? 1 : 0;
        
        if(n>=2){
            ans[n-2] = isValid(s.substring(n-2)) * 1 +  isValid(s.substring(n-2,n-1)) * ans[s.length()-1];
        }
        
        for(int index = n-3; index>=0; index--){
            ans[index] = isValid(s.substring(index,index+2)) * ans[index+2] +  isValid(s.substring(index,index+1)) * ans[index+1];
        }
        
        // System.out.println(Arrays.toString(ans));
        
        return ans[0];
    }",Next sibling does not exist,"(22, 4)","(27, 5)",N,method_declaration,isValid,,53,efdfaf26-abd2-481a-ae29-a59aec239455
"class Solution {
    public int numRollsToTarget(int n, int k, int target) {
        int[][] dp = new int[n+1][target+1];
        
        for(int i=1; i<=k && i<=target; i++){
            dp[1][i] = 1;
        }
        
        for(int i=2; i<=n; i++){
            for(int j=0; j<=target; j++){
                dp[i][j] = (int) getVal(dp,i,j,k);
            }
        }
        
        return dp[n][target]; 
    }
    
    
    public long getVal(int[][] dp, int row, int col, int k){
        int mod = 1000000007;
        int val = 0;
        for(int index = col-1; index>=0 && k>0; index--){
            val = (val + dp[row-1][index])%mod;
            k-=1;
        }
        return val;
    }
    
}
",NumRollsToTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumRollsToTarget.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 0)",N,program,program,,212,37e8c268-6216-4f1d-b086-0becc5116179
"class Solution {
    public int numRollsToTarget(int n, int k, int target) {
        int[][] dp = new int[n+1][target+1];
        
        for(int i=1; i<=k && i<=target; i++){
            dp[1][i] = 1;
        }
        
        for(int i=2; i<=n; i++){
            for(int j=0; j<=target; j++){
                dp[i][j] = (int) getVal(dp,i,j,k);
            }
        }
        
        return dp[n][target]; 
    }
    
    
    public long getVal(int[][] dp, int row, int col, int k){
        int mod = 1000000007;
        int val = 0;
        for(int index = col-1; index>=0 && k>0; index--){
            val = (val + dp[row-1][index])%mod;
            k-=1;
        }
        return val;
    }
    
}",NumRollsToTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumRollsToTarget.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 1)",N,class_declaration,Solution,,212,1b324414-36ef-4f88-81ad-2a7392796450
"public int numRollsToTarget(int n, int k, int target) {
        int[][] dp = new int[n+1][target+1];
        
        for(int i=1; i<=k && i<=target; i++){
            dp[1][i] = 1;
        }
        
        for(int i=2; i<=n; i++){
            for(int j=0; j<=target; j++){
                dp[i][j] = (int) getVal(dp,i,j,k);
            }
        }
        
        return dp[n][target]; 
    }",NumRollsToTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumRollsToTarget.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public long getVal(int[][] dp, int row, int col, int k){
        int mod = 1000000007;
        int val = 0;
        for(int index = col-1; index>=0 && k>0; index--){
            val = (val + dp[row-1][index])%mod;
            k-=1;
        }
        return val;
    }","(1, 4)","(15, 5)",N,method_declaration,numRollsToTarget,,122,5db79d8a-fade-4741-a381-94c72822a07c
"public long getVal(int[][] dp, int row, int col, int k){
        int mod = 1000000007;
        int val = 0;
        for(int index = col-1; index>=0 && k>0; index--){
            val = (val + dp[row-1][index])%mod;
            k-=1;
        }
        return val;
    }",NumRollsToTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumRollsToTarget.java,program/class_declaration-Solution/,Solution,"public int numRollsToTarget(int n, int k, int target) {
        int[][] dp = new int[n+1][target+1];
        
        for(int i=1; i<=k && i<=target; i++){
            dp[1][i] = 1;
        }
        
        for(int i=2; i<=n; i++){
            for(int j=0; j<=target; j++){
                dp[i][j] = (int) getVal(dp,i,j,k);
            }
        }
        
        return dp[n][target]; 
    }",Next sibling does not exist,"(18, 4)","(26, 5)",N,method_declaration,getVal,,82,2a9af2ad-f925-4f84-8272-62b307d9688d
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:

        @cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans
        
        return (sum(piles) + helper(0, 1))//2
",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\stoneGameII.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 0)",N,module,module,,147,07605c95-49cc-4403-b924-190ebb062112
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:

        @cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans
        
        return (sum(piles) + helper(0, 1))//2",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\stoneGameII.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 45)",N,class_definition,Solution,,146,0ecc7c1e-3231-4171-a1db-4d102c4f0f78
"def stoneGameII(self, piles: List[int]) -> int:

        @cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans
        
        return (sum(piles) + helper(0, 1))//2",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\stoneGameII.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(17, 45)",N,function_definition,stoneGameII,,142,d56d6710-8f56-492d-965e-630318e8bad5
"@cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\stoneGameII.py,module/class_definition-Solution/function_definition-stoneGameII/,stoneGameII,Previous sibling does not exist,"return (sum(piles) + helper(0, 1))//2","(3, 8)","(15, 22)",N,function_definition,"def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans",,109,31de5076-a0b2-4820-971b-7f833e460f46
"class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        
        def f(x):
            if(x==0): return 0
            if(x==1): return 1
            if(x<=9): return 2
            if(x<=99): return 3
            return 4
        
        cache = {}
        
        def getMin(index, prevChar, run, k):
            
            key = (index, prevChar, run, k)
            
            if key in cache:
                return cache[key]
            
            if(index>=len(s)): return f(run)
            
            best = 10**20
            
            if(s[index] == prevChar):
                #keep
                best = min(best, getMin(index+1, prevChar, run+1, k))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            else:
                #keep
                best = min(best, getMin(index+1, s[index], 1, k) + f(run))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            cache[key] = best
            return best
        
        return getMin(0, '', 0, k)
",StringCompressionII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\StringCompressionII.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(43, 0)",N,module,module,,295,9bfd2b38-c0d7-477d-ae52-16b0aced883f
"class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        
        def f(x):
            if(x==0): return 0
            if(x==1): return 1
            if(x<=9): return 2
            if(x<=99): return 3
            return 4
        
        cache = {}
        
        def getMin(index, prevChar, run, k):
            
            key = (index, prevChar, run, k)
            
            if key in cache:
                return cache[key]
            
            if(index>=len(s)): return f(run)
            
            best = 10**20
            
            if(s[index] == prevChar):
                #keep
                best = min(best, getMin(index+1, prevChar, run+1, k))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            else:
                #keep
                best = min(best, getMin(index+1, s[index], 1, k) + f(run))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            cache[key] = best
            return best
        
        return getMin(0, '', 0, k)",StringCompressionII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\StringCompressionII.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(42, 34)",N,class_definition,Solution,,295,e2f52172-6745-4d24-995d-e12c6f1b54e6
"def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        
        def f(x):
            if(x==0): return 0
            if(x==1): return 1
            if(x<=9): return 2
            if(x<=99): return 3
            return 4
        
        cache = {}
        
        def getMin(index, prevChar, run, k):
            
            key = (index, prevChar, run, k)
            
            if key in cache:
                return cache[key]
            
            if(index>=len(s)): return f(run)
            
            best = 10**20
            
            if(s[index] == prevChar):
                #keep
                best = min(best, getMin(index+1, prevChar, run+1, k))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            else:
                #keep
                best = min(best, getMin(index+1, s[index], 1, k) + f(run))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            cache[key] = best
            return best
        
        return getMin(0, '', 0, k)",StringCompressionII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\StringCompressionII.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(42, 34)",N,function_definition,getLengthOfOptimalCompression,,291,23a684b6-fbe3-48e1-8294-2c0ba8450615
"def f(x):
            if(x==0): return 0
            if(x==1): return 1
            if(x<=9): return 2
            if(x<=99): return 3
            return 4",StringCompressionII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\StringCompressionII.py,module/class_definition-Solution/function_definition-getLengthOfOptimalCompression/,getLengthOfOptimalCompression,Previous sibling does not exist,cache = {},"(3, 8)","(8, 20)",N,function_definition,f,,48,c2d33d5e-0c42-4e9c-b3be-2db0193806b3
"def getMin(index, prevChar, run, k):
            
            key = (index, prevChar, run, k)
            
            if key in cache:
                return cache[key]
            
            if(index>=len(s)): return f(run)
            
            best = 10**20
            
            if(s[index] == prevChar):
                #keep
                best = min(best, getMin(index+1, prevChar, run+1, k))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            else:
                #keep
                best = min(best, getMin(index+1, s[index], 1, k) + f(run))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            cache[key] = best
            return best",StringCompressionII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\StringCompressionII.py,module/class_definition-Solution/function_definition-getLengthOfOptimalCompression/,getLengthOfOptimalCompression,cache = {},"return getMin(0, '', 0, k)","(12, 8)","(40, 23)",N,function_definition,getMin,,200,f42ac20e-03f4-4105-97da-4082a5c88271
"class Solution:
        
    pizza = []
    M = 0
    N = 0
    prefixSum = []
    cache = {}
    mod = 10**9 + 7
    
    def ways(self, pizza: List[str], k: int) -> int:
        
        self.pizza = pizza
        self.M = len(pizza) - 1
        self.N = len(pizza[0]) - 1
        self.cache = {}
        
        prefixSum = [[0]*len(pizza[0]) for i in range(len(pizza))]
        
        
        prefixSum[0][0] = 1 if(pizza[0][0]=='A') else 0
        
        for i in range(1, len(pizza[0])): 
            prefixSum[0][i] += prefixSum[0][i-1]
            prefixSum[0][i] += 1 if(pizza[0][i]=='A') else 0
        
        for i in range(1, len(pizza)): 
            prefixSum[i][0] += prefixSum[i-1][0]
            prefixSum[i][0] += 1 if(pizza[i][0]=='A') else 0
        
        
        for i in range(1, len(pizza)):
            for j in range(1, len(pizza[0])):
                prefixSum[i][j] += 1 if(pizza[i][j]=='A') else 0
                prefixSum[i][j] += prefixSum[i-1][j]
                prefixSum[i][j] += prefixSum[i][j-1]
                prefixSum[i][j] -= prefixSum[i-1][j-1]
                
        if(prefixSum[-1][-1]<k): return 0
        
        self.prefixSum = prefixSum
        return self.helper(0,0,k)
    
    
    def helper(self, rowIndex, colIndex, k):
        
        key = (rowIndex, colIndex, k)
        if(key in self.cache): return self.cache[key]
        
        ans = 0
        
        if(k == 1): return self.valid(rowIndex, self.M, colIndex, self.N)
        
        for index in range(rowIndex+1, self.M+1):
            ans += self.valid(rowIndex, index-1, colIndex, self.N) * self.helper(index, colIndex, k-1)
            ans = ans%self.mod
        
        for index in range(colIndex+1, self.N+1):
            ans += self.valid(rowIndex, self.M, colIndex, index-1) * self.helper(rowIndex, index, k-1)
            ans = ans%self.mod

        self.cache[key] = ans
        return ans
    
    def valid(self, rowStart, rowEnd, colStart, colEnd):        
        ans = self.prefixSum[rowEnd][colEnd]
        
        if(rowStart-1 >= 0):
            ans -= self.prefixSum[rowStart-1][colEnd]
            
        if(colStart-1 >= 0):
            ans -= self.prefixSum[rowEnd][colStart-1]
        
        if(rowStart-1 >= 0 and colStart-1 >= 0):
            ans += self.prefixSum[rowStart-1][colStart-1]
        
        return 1 if(ans>0) else 0

        
        
        



            
        
        
",WaysToCutPizza.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\WaysToCutPizza.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(86, 0)",N,module,module,,703,e16c13c6-10d5-411b-888c-c2afa732a93c
"class Solution:
        
    pizza = []
    M = 0
    N = 0
    prefixSum = []
    cache = {}
    mod = 10**9 + 7
    
    def ways(self, pizza: List[str], k: int) -> int:
        
        self.pizza = pizza
        self.M = len(pizza) - 1
        self.N = len(pizza[0]) - 1
        self.cache = {}
        
        prefixSum = [[0]*len(pizza[0]) for i in range(len(pizza))]
        
        
        prefixSum[0][0] = 1 if(pizza[0][0]=='A') else 0
        
        for i in range(1, len(pizza[0])): 
            prefixSum[0][i] += prefixSum[0][i-1]
            prefixSum[0][i] += 1 if(pizza[0][i]=='A') else 0
        
        for i in range(1, len(pizza)): 
            prefixSum[i][0] += prefixSum[i-1][0]
            prefixSum[i][0] += 1 if(pizza[i][0]=='A') else 0
        
        
        for i in range(1, len(pizza)):
            for j in range(1, len(pizza[0])):
                prefixSum[i][j] += 1 if(pizza[i][j]=='A') else 0
                prefixSum[i][j] += prefixSum[i-1][j]
                prefixSum[i][j] += prefixSum[i][j-1]
                prefixSum[i][j] -= prefixSum[i-1][j-1]
                
        if(prefixSum[-1][-1]<k): return 0
        
        self.prefixSum = prefixSum
        return self.helper(0,0,k)
    
    
    def helper(self, rowIndex, colIndex, k):
        
        key = (rowIndex, colIndex, k)
        if(key in self.cache): return self.cache[key]
        
        ans = 0
        
        if(k == 1): return self.valid(rowIndex, self.M, colIndex, self.N)
        
        for index in range(rowIndex+1, self.M+1):
            ans += self.valid(rowIndex, index-1, colIndex, self.N) * self.helper(index, colIndex, k-1)
            ans = ans%self.mod
        
        for index in range(colIndex+1, self.N+1):
            ans += self.valid(rowIndex, self.M, colIndex, index-1) * self.helper(rowIndex, index, k-1)
            ans = ans%self.mod

        self.cache[key] = ans
        return ans
    
    def valid(self, rowStart, rowEnd, colStart, colEnd):        
        ans = self.prefixSum[rowEnd][colEnd]
        
        if(rowStart-1 >= 0):
            ans -= self.prefixSum[rowStart-1][colEnd]
            
        if(colStart-1 >= 0):
            ans -= self.prefixSum[rowEnd][colStart-1]
        
        if(rowStart-1 >= 0 and colStart-1 >= 0):
            ans += self.prefixSum[rowStart-1][colStart-1]
        
        return 1 if(ans>0) else 0",WaysToCutPizza.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\WaysToCutPizza.py,module/,module,Previous sibling does not exist,"pizza = []
M = 0
N = 0
prefixSum = []
cache = {}
mod = 10**9 + 7","(0, 0)","(75, 33)",N,class_definition,Solution,,697,383b9997-6059-45bf-ae7e-b987ec539bbd
"pizza = []
M = 0
N = 0
prefixSum = []
cache = {}
mod = 10**9 + 7",WaysToCutPizza.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\WaysToCutPizza.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def ways(self, pizza: List[str], k: int) -> int:
        
        self.pizza = pizza
        self.M = len(pizza) - 1
        self.N = len(pizza[0]) - 1
        self.cache = {}
        
        prefixSum = [[0]*len(pizza[0]) for i in range(len(pizza))]
        
        
        prefixSum[0][0] = 1 if(pizza[0][0]=='A') else 0
        
        for i in range(1, len(pizza[0])): 
            prefixSum[0][i] += prefixSum[0][i-1]
            prefixSum[0][i] += 1 if(pizza[0][i]=='A') else 0
        
        for i in range(1, len(pizza)): 
            prefixSum[i][0] += prefixSum[i-1][0]
            prefixSum[i][0] += 1 if(pizza[i][0]=='A') else 0
        
        
        for i in range(1, len(pizza)):
            for j in range(1, len(pizza[0])):
                prefixSum[i][j] += 1 if(pizza[i][j]=='A') else 0
                prefixSum[i][j] += prefixSum[i-1][j]
                prefixSum[i][j] += prefixSum[i][j-1]
                prefixSum[i][j] -= prefixSum[i-1][j-1]
                
        if(prefixSum[-1][-1]<k): return 0
        
        self.prefixSum = prefixSum
        return self.helper(0,0,k)","(2, 4)","(7, 19)",N,"expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement",expression_statement,,27,30dd75a7-4fff-40a9-b326-856163ba57b7
"def ways(self, pizza: List[str], k: int) -> int:
        
        self.pizza = pizza
        self.M = len(pizza) - 1
        self.N = len(pizza[0]) - 1
        self.cache = {}
        
        prefixSum = [[0]*len(pizza[0]) for i in range(len(pizza))]
        
        
        prefixSum[0][0] = 1 if(pizza[0][0]=='A') else 0
        
        for i in range(1, len(pizza[0])): 
            prefixSum[0][i] += prefixSum[0][i-1]
            prefixSum[0][i] += 1 if(pizza[0][i]=='A') else 0
        
        for i in range(1, len(pizza)): 
            prefixSum[i][0] += prefixSum[i-1][0]
            prefixSum[i][0] += 1 if(pizza[i][0]=='A') else 0
        
        
        for i in range(1, len(pizza)):
            for j in range(1, len(pizza[0])):
                prefixSum[i][j] += 1 if(pizza[i][j]=='A') else 0
                prefixSum[i][j] += prefixSum[i-1][j]
                prefixSum[i][j] += prefixSum[i][j-1]
                prefixSum[i][j] -= prefixSum[i-1][j-1]
                
        if(prefixSum[-1][-1]<k): return 0
        
        self.prefixSum = prefixSum
        return self.helper(0,0,k)",WaysToCutPizza.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\WaysToCutPizza.py,module/class_definition-Solution/,Solution,"pizza = []
M = 0
N = 0
prefixSum = []
cache = {}
mod = 10**9 + 7","def helper(self, rowIndex, colIndex, k):
        
        key = (rowIndex, colIndex, k)
        if(key in self.cache): return self.cache[key]
        
        ans = 0
        
        if(k == 1): return self.valid(rowIndex, self.M, colIndex, self.N)
        
        for index in range(rowIndex+1, self.M+1):
            ans += self.valid(rowIndex, index-1, colIndex, self.N) * self.helper(index, colIndex, k-1)
            ans = ans%self.mod
        
        for index in range(colIndex+1, self.N+1):
            ans += self.valid(rowIndex, self.M, colIndex, index-1) * self.helper(rowIndex, index, k-1)
            ans = ans%self.mod

        self.cache[key] = ans
        return ans","(9, 4)","(40, 33)",N,function_definition,ways,,347,de34c84f-e963-4eb3-9213-f8c9ea5a2e96
"def helper(self, rowIndex, colIndex, k):
        
        key = (rowIndex, colIndex, k)
        if(key in self.cache): return self.cache[key]
        
        ans = 0
        
        if(k == 1): return self.valid(rowIndex, self.M, colIndex, self.N)
        
        for index in range(rowIndex+1, self.M+1):
            ans += self.valid(rowIndex, index-1, colIndex, self.N) * self.helper(index, colIndex, k-1)
            ans = ans%self.mod
        
        for index in range(colIndex+1, self.N+1):
            ans += self.valid(rowIndex, self.M, colIndex, index-1) * self.helper(rowIndex, index, k-1)
            ans = ans%self.mod

        self.cache[key] = ans
        return ans",WaysToCutPizza.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\WaysToCutPizza.py,module/class_definition-Solution/,Solution,"def ways(self, pizza: List[str], k: int) -> int:
        
        self.pizza = pizza
        self.M = len(pizza) - 1
        self.N = len(pizza[0]) - 1
        self.cache = {}
        
        prefixSum = [[0]*len(pizza[0]) for i in range(len(pizza))]
        
        
        prefixSum[0][0] = 1 if(pizza[0][0]=='A') else 0
        
        for i in range(1, len(pizza[0])): 
            prefixSum[0][i] += prefixSum[0][i-1]
            prefixSum[0][i] += 1 if(pizza[0][i]=='A') else 0
        
        for i in range(1, len(pizza)): 
            prefixSum[i][0] += prefixSum[i-1][0]
            prefixSum[i][0] += 1 if(pizza[i][0]=='A') else 0
        
        
        for i in range(1, len(pizza)):
            for j in range(1, len(pizza[0])):
                prefixSum[i][j] += 1 if(pizza[i][j]=='A') else 0
                prefixSum[i][j] += prefixSum[i-1][j]
                prefixSum[i][j] += prefixSum[i][j-1]
                prefixSum[i][j] -= prefixSum[i-1][j-1]
                
        if(prefixSum[-1][-1]<k): return 0
        
        self.prefixSum = prefixSum
        return self.helper(0,0,k)","def valid(self, rowStart, rowEnd, colStart, colEnd):        
        ans = self.prefixSum[rowEnd][colEnd]
        
        if(rowStart-1 >= 0):
            ans -= self.prefixSum[rowStart-1][colEnd]
            
        if(colStart-1 >= 0):
            ans -= self.prefixSum[rowEnd][colStart-1]
        
        if(rowStart-1 >= 0 and colStart-1 >= 0):
            ans += self.prefixSum[rowStart-1][colStart-1]
        
        return 1 if(ans>0) else 0","(43, 4)","(61, 18)",N,function_definition,helper,,178,ef88b7ff-b764-4d78-b65e-9d15003e7037
"def valid(self, rowStart, rowEnd, colStart, colEnd):        
        ans = self.prefixSum[rowEnd][colEnd]
        
        if(rowStart-1 >= 0):
            ans -= self.prefixSum[rowStart-1][colEnd]
            
        if(colStart-1 >= 0):
            ans -= self.prefixSum[rowEnd][colStart-1]
        
        if(rowStart-1 >= 0 and colStart-1 >= 0):
            ans += self.prefixSum[rowStart-1][colStart-1]
        
        return 1 if(ans>0) else 0",WaysToCutPizza.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\WaysToCutPizza.py,module/class_definition-Solution/,Solution,"def helper(self, rowIndex, colIndex, k):
        
        key = (rowIndex, colIndex, k)
        if(key in self.cache): return self.cache[key]
        
        ans = 0
        
        if(k == 1): return self.valid(rowIndex, self.M, colIndex, self.N)
        
        for index in range(rowIndex+1, self.M+1):
            ans += self.valid(rowIndex, index-1, colIndex, self.N) * self.helper(index, colIndex, k-1)
            ans = ans%self.mod
        
        for index in range(colIndex+1, self.N+1):
            ans += self.valid(rowIndex, self.M, colIndex, index-1) * self.helper(rowIndex, index, k-1)
            ans = ans%self.mod

        self.cache[key] = ans
        return ans",Next sibling does not exist,"(63, 4)","(75, 33)",N,function_definition,valid,,127,904155bd-788e-4ff6-8343-a804fae11a33
"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.isWord = False
    
    def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True
    
    def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return True if node.isWord else False
            
            ch = s[index]
            if(ch not in node.childern): return False
            node = node.childern[ch]
            if((node.isWord and helper(index+1, root)) or helper(index+1, node)): return True

        return helper(0, root)
",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(35, 0)",N,module,module,,243,bd51dad8-3119-4294-802c-9c6db8ad7d9d
"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.isWord = False
    
    def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True
    
    def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/,module,Previous sibling does not exist,"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return True if node.isWord else False
            
            ch = s[index]
            if(ch not in node.childern): return False
            node = node.childern[ch]
            if((node.isWord and helper(index+1, root)) or helper(index+1, node)): return True

        return helper(0, root)","(0, 0)","(17, 16)",N,class_definition,TrieNode,,115,bee3aa0b-cf15-435a-8950-73823dd029b8
"def __init__(self):
        self.childern = {}
        self.isWord = False",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/class_definition-TrieNode/,TrieNode,Previous sibling does not exist,"def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True","(1, 4)","(3, 27)",N,function_definition,__init__,,18,7fe4f38e-6748-4170-a169-52263c2e6cca
"def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/class_definition-TrieNode/,TrieNode,"def __init__(self):
        self.childern = {}
        self.isWord = False","def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s","(5, 4)","(12, 26)",N,function_definition,add,,49,15ea4191-714f-440f-a508-f35cc9d0c680
"def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/class_definition-TrieNode/,TrieNode,"def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True",Next sibling does not exist,"(14, 4)","(17, 16)",N,function_definition,__str__,,39,7fbb0920-ca01-40e1-872d-4f0ee8658b2b
"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return True if node.isWord else False
            
            ch = s[index]
            if(ch not in node.childern): return False
            node = node.childern[ch]
            if((node.isWord and helper(index+1, root)) or helper(index+1, node)): return True

        return helper(0, root)",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/,module,"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.isWord = False
    
    def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True
    
    def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s",Next sibling does not exist,"(19, 0)","(34, 30)",N,class_definition,Solution,,127,48f8d56d-c35d-430c-82fe-903f73c08375
"def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return True if node.isWord else False
            
            ch = s[index]
            if(ch not in node.childern): return False
            node = node.childern[ch]
            if((node.isWord and helper(index+1, root)) or helper(index+1, node)): return True

        return helper(0, root)",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(20, 4)","(34, 30)",N,function_definition,wordBreak,,123,209eab09-a656-4a3a-8d1d-c5c8aba1155d
"@cache
        def helper(index, node):
            if(index == len(s)): 
                return True if node.isWord else False
            
            ch = s[index]
            if(ch not in node.childern): return False
            node = node.childern[ch]
            if((node.isWord and helper(index+1, root)) or helper(index+1, node)): return True",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/class_definition-Solution/function_definition-wordBreak/,wordBreak,for word in wordDict: root.add(word),"return helper(0, root)","(24, 8)","(32, 93)",N,function_definition,"def helper(index, node):
            if(index == len(s)): 
                return True if node.isWord else False
            
            ch = s[index]
            if(ch not in node.childern): return False
            node = node.childern[ch]
            if((node.isWord and helper(index+1, root)) or helper(index+1, node)): return True",,78,1b0cc546-623d-486d-95a7-52a22aa5a1f5
"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.isWord = False
    
    def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True
    
    def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s


class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return [""""] if node.isWord else []
            
            ch = s[index]
            if(ch not in node.childern): return []
            node = node.childern[ch]

            ans = []
            if(node.isWord): for sub_str in helper(index+1, root): ans.append(ch + "" "" + sub_str)
            for sub_str in helper(index+1, node): ans.append(ch + sub_str)
            return ans

        return helper(0, root)
",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(41, 0)",Y,module,module,,273,f9367b2a-368c-40ed-9c79-501c32651496
"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.isWord = False
    
    def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True
    
    def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/,module,Previous sibling does not exist,"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return [""""] if node.isWord else []
            
            ch = s[index]
            if(ch not in node.childern): return []
            node = node.childern[ch]

            ans = []
            if(node.isWord): for sub_str in helper(index+1, root): ans.append(ch + "" "" + sub_str)
            for sub_str in helper(index+1, node): ans.append(ch + sub_str)
            return ans

        return helper(0, root)","(0, 0)","(17, 16)",N,class_definition,TrieNode,,115,d23778d8-d60e-4f0c-aa6b-d5383b672e54
"def __init__(self):
        self.childern = {}
        self.isWord = False",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/class_definition-TrieNode/,TrieNode,Previous sibling does not exist,"def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True","(1, 4)","(3, 27)",N,function_definition,__init__,,18,78b2290d-c824-48ce-b35c-966092296d08
"def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/class_definition-TrieNode/,TrieNode,"def __init__(self):
        self.childern = {}
        self.isWord = False","def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s","(5, 4)","(12, 26)",N,function_definition,add,,49,13ca603a-cf4e-48b9-80a7-2b7ffba52d1a
"def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/class_definition-TrieNode/,TrieNode,"def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True",Next sibling does not exist,"(14, 4)","(17, 16)",N,function_definition,__str__,,39,b8b77eff-c5a6-40db-9a2b-1f4404ea1fc0
"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return [""""] if node.isWord else []
            
            ch = s[index]
            if(ch not in node.childern): return []
            node = node.childern[ch]

            ans = []
            if(node.isWord): for sub_str in helper(index+1, root): ans.append(ch + "" "" + sub_str)
            for sub_str in helper(index+1, node): ans.append(ch + sub_str)
            return ans

        return helper(0, root)",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/,module,"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.isWord = False
    
    def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True
    
    def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s",Next sibling does not exist,"(20, 0)","(40, 30)",Y,class_definition,Solution,,157,c3119389-5e39-4b28-9a6d-c45941aab18e
"def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return [""""] if node.isWord else []
            
            ch = s[index]
            if(ch not in node.childern): return []
            node = node.childern[ch]

            ans = []
            if(node.isWord): for sub_str in helper(index+1, root): ans.append(ch + "" "" + sub_str)
            for sub_str in helper(index+1, node): ans.append(ch + sub_str)
            return ans

        return helper(0, root)",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(21, 4)","(40, 30)",Y,function_definition,wordBreak,,153,ba543127-2f8e-415d-95b1-86aa32dfdd30
"@cache
        def helper(index, node):
            if(index == len(s)): 
                return [""""] if node.isWord else []
            
            ch = s[index]
            if(ch not in node.childern): return []
            node = node.childern[ch]

            ans = []
            if(node.isWord): for sub_str in helper(index+1, root): ans.append(ch + "" "" + sub_str)
            for sub_str in helper(index+1, node): ans.append(ch + sub_str)
            return ans",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/class_definition-Solution/function_definition-wordBreak/,wordBreak,for word in wordDict: root.add(word),"return helper(0, root)","(26, 8)","(38, 22)",Y,function_definition,"def helper(index, node):
            if(index == len(s)): 
                return [""""] if node.isWord else []
            
            ch = s[index]
            if(ch not in node.childern): return []
            node = node.childern[ch]

            ans = []
            if(node.isWord): for sub_str in helper(index+1, root): ans.append(ch + "" "" + sub_str)
            for sub_str in helper(index+1, node): ans.append(ch + sub_str)
            return ans",,107,3ce47ddb-3561-4faa-8b8e-800e71828812
"class FenwickTree:

    def __init__(self, arr) -> None:
        self.arr = arr
        self.fenwickTree = [0] + [i for i in arr]
        self.buildTree()
    

    def buildTree(self):
        for i in range(1, len(self.fenwickTree)):
            parentIndex = i + FenwickTree.lsb(i)
            if(parentIndex<len(self.fenwickTree)): 
                self.fenwickTree[parentIndex] += self.fenwickTree[i]


    def query(self, index):
        index+=1
        ans = 0 
        while(index>0):
            ans += self.fenwickTree[index]
            index -= FenwickTree.lsb(index)
        return ans


    def rangeQuery(self, start, end=None):
        return self.query(end) - self.query(start)

    def update(self, index, new_val):
        prev = self.arr[index]
        index += 1
        while(index<len(self.fenwickTree)):
            self.fenwickTree[index] -= prev
            self.fenwickTree[index] += new_val
            index = index + FenwickTree.lsb(index)

    @staticmethod
    def lsb(num):
        return num ^ (num & (num-1))
    
FenwickTree = FenwickTree([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])
print(FenwickTree.fenwickTree)

print(FenwickTree.query(8))
print(FenwickTree.query(13))
print(FenwickTree.query(15))

FenwickTree.update(8, 19)
print(FenwickTree.fenwickTree)


# print(FenwickTree.lsb(108))
# print(FenwickTree.lsb(104))
# print(FenwickTree.lsb(96))
# print(FenwickTree.lsb(64))
# print(FenwickTree.lsb(0))
",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(55, 0)",N,module,module,,425,c64592c3-b907-4d2a-87f6-28013500280b
"class FenwickTree:

    def __init__(self, arr) -> None:
        self.arr = arr
        self.fenwickTree = [0] + [i for i in arr]
        self.buildTree()
    

    def buildTree(self):
        for i in range(1, len(self.fenwickTree)):
            parentIndex = i + FenwickTree.lsb(i)
            if(parentIndex<len(self.fenwickTree)): 
                self.fenwickTree[parentIndex] += self.fenwickTree[i]


    def query(self, index):
        index+=1
        ans = 0 
        while(index>0):
            ans += self.fenwickTree[index]
            index -= FenwickTree.lsb(index)
        return ans


    def rangeQuery(self, start, end=None):
        return self.query(end) - self.query(start)

    def update(self, index, new_val):
        prev = self.arr[index]
        index += 1
        while(index<len(self.fenwickTree)):
            self.fenwickTree[index] -= prev
            self.fenwickTree[index] += new_val
            index = index + FenwickTree.lsb(index)

    @staticmethod
    def lsb(num):
        return num ^ (num & (num-1))",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/,module,Previous sibling does not exist,"FenwickTree = FenwickTree([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])","(0, 0)","(37, 36)",N,class_definition,FenwickTree,,270,d075620d-18a9-4d9c-8245-8a78754e04ea
"def __init__(self, arr) -> None:
        self.arr = arr
        self.fenwickTree = [0] + [i for i in arr]
        self.buildTree()",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/class_definition-FenwickTree/,FenwickTree,Previous sibling does not exist,"def buildTree(self):
        for i in range(1, len(self.fenwickTree)):
            parentIndex = i + FenwickTree.lsb(i)
            if(parentIndex<len(self.fenwickTree)): 
                self.fenwickTree[parentIndex] += self.fenwickTree[i]","(2, 4)","(5, 24)",N,function_definition,__init__,,40,38049069-821a-4e5c-8f51-ad96364b84dd
"def buildTree(self):
        for i in range(1, len(self.fenwickTree)):
            parentIndex = i + FenwickTree.lsb(i)
            if(parentIndex<len(self.fenwickTree)): 
                self.fenwickTree[parentIndex] += self.fenwickTree[i]",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/class_definition-FenwickTree/,FenwickTree,"def __init__(self, arr) -> None:
        self.arr = arr
        self.fenwickTree = [0] + [i for i in arr]
        self.buildTree()","def query(self, index):
        index+=1
        ans = 0 
        while(index>0):
            ans += self.fenwickTree[index]
            index -= FenwickTree.lsb(index)
        return ans","(8, 4)","(12, 68)",N,function_definition,buildTree,,62,6128b4df-74a9-4034-bfd9-78c49426cb06
"def query(self, index):
        index+=1
        ans = 0 
        while(index>0):
            ans += self.fenwickTree[index]
            index -= FenwickTree.lsb(index)
        return ans",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/class_definition-FenwickTree/,FenwickTree,"def buildTree(self):
        for i in range(1, len(self.fenwickTree)):
            parentIndex = i + FenwickTree.lsb(i)
            if(parentIndex<len(self.fenwickTree)): 
                self.fenwickTree[parentIndex] += self.fenwickTree[i]","def rangeQuery(self, start, end=None):
        return self.query(end) - self.query(start)","(15, 4)","(21, 18)",N,function_definition,query,,46,8e83854b-5725-4703-868d-9326cf40286e
"def rangeQuery(self, start, end=None):
        return self.query(end) - self.query(start)",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/class_definition-FenwickTree/,FenwickTree,"def query(self, index):
        index+=1
        ans = 0 
        while(index>0):
            ans += self.fenwickTree[index]
            index -= FenwickTree.lsb(index)
        return ans","def update(self, index, new_val):
        prev = self.arr[index]
        index += 1
        while(index<len(self.fenwickTree)):
            self.fenwickTree[index] -= prev
            self.fenwickTree[index] += new_val
            index = index + FenwickTree.lsb(index)","(24, 4)","(25, 50)",N,function_definition,rangeQuery,,21,5fefeef0-8ec9-4d7d-95d6-cdad4e7b49de
"def update(self, index, new_val):
        prev = self.arr[index]
        index += 1
        while(index<len(self.fenwickTree)):
            self.fenwickTree[index] -= prev
            self.fenwickTree[index] += new_val
            index = index + FenwickTree.lsb(index)",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/class_definition-FenwickTree/,FenwickTree,"def rangeQuery(self, start, end=None):
        return self.query(end) - self.query(start)","@staticmethod
    def lsb(num):
        return num ^ (num & (num-1))","(27, 4)","(33, 50)",N,function_definition,update,,67,ea3794a8-4b48-47b5-b66e-604e3a3b8d68
"@staticmethod
    def lsb(num):
        return num ^ (num & (num-1))",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/class_definition-FenwickTree/,FenwickTree,"def update(self, index, new_val):
        prev = self.arr[index]
        index += 1
        while(index<len(self.fenwickTree)):
            self.fenwickTree[index] -= prev
            self.fenwickTree[index] += new_val
            index = index + FenwickTree.lsb(index)","FenwickTree = FenwickTree([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])
print(FenwickTree.fenwickTree)
print(FenwickTree.query(8))
print(FenwickTree.query(13))
print(FenwickTree.query(15))
FenwickTree.update(8, 19)
print(FenwickTree.fenwickTree)
# print(FenwickTree.lsb(108))
# print(FenwickTree.lsb(104))
# print(FenwickTree.lsb(96))
# print(FenwickTree.lsb(64))
# print(FenwickTree.lsb(0))","(35, 4)","(37, 36)",N,function_definition,"def lsb(num):
        return num ^ (num & (num-1))",,21,2fa03394-3f45-4f9e-a816-d615491f993c
"FenwickTree = FenwickTree([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])
print(FenwickTree.fenwickTree)
print(FenwickTree.query(8))
print(FenwickTree.query(13))
print(FenwickTree.query(15))
FenwickTree.update(8, 19)
print(FenwickTree.fenwickTree)
# print(FenwickTree.lsb(108))
# print(FenwickTree.lsb(104))
# print(FenwickTree.lsb(96))
# print(FenwickTree.lsb(64))
# print(FenwickTree.lsb(0))",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/,module,"class FenwickTree:

    def __init__(self, arr) -> None:
        self.arr = arr
        self.fenwickTree = [0] + [i for i in arr]
        self.buildTree()
    

    def buildTree(self):
        for i in range(1, len(self.fenwickTree)):
            parentIndex = i + FenwickTree.lsb(i)
            if(parentIndex<len(self.fenwickTree)): 
                self.fenwickTree[parentIndex] += self.fenwickTree[i]


    def query(self, index):
        index+=1
        ans = 0 
        while(index>0):
            ans += self.fenwickTree[index]
            index -= FenwickTree.lsb(index)
        return ans


    def rangeQuery(self, start, end=None):
        return self.query(end) - self.query(start)

    def update(self, index, new_val):
        prev = self.arr[index]
        index += 1
        while(index<len(self.fenwickTree)):
            self.fenwickTree[index] -= prev
            self.fenwickTree[index] += new_val
            index = index + FenwickTree.lsb(index)

    @staticmethod
    def lsb(num):
        return num ^ (num & (num-1))",Next sibling does not exist,"(39, 0)","(54, 27)",N,"expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,comment,comment,comment,comment,comment",expression_statement,,154,8f87d56f-0cf1-4438-b4ca-2c257d1ac691
"class Solution {
    List<List<Integer>> list = new ArrayList<List<Integer>>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {    
        dfs(graph, 0, new ArrayList());
        return list;
    }
    
    public void dfs(int[][] graph, int cur, ArrayList<Integer> path){
        path.add(cur);
        if(cur==graph.length-1){
            list.add((ArrayList<Integer>) path.clone());
        }
        for(int i=0;i<graph[cur].length;i++){
            dfs(graph, graph[cur][i], path);
        }
        path.remove(path.size()-1);
    }
    
}
",AllPathsSourceTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AllPathsSourceTarget.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(19, 0)",N,program,program,,129,538b45ff-a3ae-4d4f-acf0-6eb4e3cfc5a9
"class Solution {
    List<List<Integer>> list = new ArrayList<List<Integer>>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {    
        dfs(graph, 0, new ArrayList());
        return list;
    }
    
    public void dfs(int[][] graph, int cur, ArrayList<Integer> path){
        path.add(cur);
        if(cur==graph.length-1){
            list.add((ArrayList<Integer>) path.clone());
        }
        for(int i=0;i<graph[cur].length;i++){
            dfs(graph, graph[cur][i], path);
        }
        path.remove(path.size()-1);
    }
    
}",AllPathsSourceTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AllPathsSourceTarget.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 1)",N,class_declaration,Solution,,129,9f38f59b-ed7d-4f9f-9879-a7a2f8561509
"public List<List<Integer>> allPathsSourceTarget(int[][] graph) {    
        dfs(graph, 0, new ArrayList());
        return list;
    }",AllPathsSourceTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AllPathsSourceTarget.java,program/class_declaration-Solution/,Solution,List<List<Integer>> list = new ArrayList<List<Integer>>();,"public void dfs(int[][] graph, int cur, ArrayList<Integer> path){
        path.add(cur);
        if(cur==graph.length-1){
            list.add((ArrayList<Integer>) path.clone());
        }
        for(int i=0;i<graph[cur].length;i++){
            dfs(graph, graph[cur][i], path);
        }
        path.remove(path.size()-1);
    }","(2, 4)","(5, 5)",N,method_declaration,allPathsSourceTarget,,31,b60f8c53-d39d-4ab7-b0bd-f79ff49b2873
"public void dfs(int[][] graph, int cur, ArrayList<Integer> path){
        path.add(cur);
        if(cur==graph.length-1){
            list.add((ArrayList<Integer>) path.clone());
        }
        for(int i=0;i<graph[cur].length;i++){
            dfs(graph, graph[cur][i], path);
        }
        path.remove(path.size()-1);
    }",AllPathsSourceTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AllPathsSourceTarget.java,program/class_declaration-Solution/,Solution,"public List<List<Integer>> allPathsSourceTarget(int[][] graph) {    
        dfs(graph, 0, new ArrayList());
        return list;
    }",Next sibling does not exist,"(7, 4)","(16, 5)",N,method_declaration,dfs,,78,64ececd1-23f7-48e0-b2d0-c16904a19219
"class Point{
    
    public  int x;
    public int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}

class Solution {
    public int maxDistance(int[][] grid) {
        
        Queue<Point> queue = new LinkedList<>();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1) { 
                    queue.add(new Point(i,j));
                    visited[i][j] = true;
                }
            }
        }
        
        int ans = 0;
        int l = queue.size();
        
        if(l== ( grid.length)*(grid[0].length)) return -1;
        
        while(!queue.isEmpty()){
            
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int[] k = dir[i];
                int newRow = cur.x + k[0];
                int newCol = cur.y + k[1];
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol< grid[0].length &&   !visited[newRow][newCol]){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
            }
            
            if(l==0) {
                ans++;
                l = queue.size();
            }
            
        }
        return ans-1;
    }
}
",AsFarFromLandAsPossible.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AsFarFromLandAsPossible.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(58, 0)",N,program,program,,354,a4120e2c-eaf9-4267-a11a-cc26439fc818
"class Point{
    
    public  int x;
    public int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}",AsFarFromLandAsPossible.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AsFarFromLandAsPossible.java,program/,program,Previous sibling does not exist,"class Solution {
    public int maxDistance(int[][] grid) {
        
        Queue<Point> queue = new LinkedList<>();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1) { 
                    queue.add(new Point(i,j));
                    visited[i][j] = true;
                }
            }
        }
        
        int ans = 0;
        int l = queue.size();
        
        if(l== ( grid.length)*(grid[0].length)) return -1;
        
        while(!queue.isEmpty()){
            
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int[] k = dir[i];
                int newRow = cur.x + k[0];
                int newCol = cur.y + k[1];
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol< grid[0].length &&   !visited[newRow][newCol]){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
            }
            
            if(l==0) {
                ans++;
                l = queue.size();
            }
            
        }
        return ans-1;
    }
}","(0, 0)","(9, 1)",N,class_declaration,Point,,39,8e5fde0b-3d88-4d9b-845e-fa09d25274ba
"Point(int x, int y){
        this.x = x;
        this.y = y;
    }",AsFarFromLandAsPossible.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AsFarFromLandAsPossible.java,program/class_declaration-Point/,Point,public int y;,Next sibling does not exist,"(5, 4)","(8, 5)",N,constructor_declaration,Point,,21,c3f78ea7-b572-4260-b6ff-34a931995fb6
"class Solution {
    public int maxDistance(int[][] grid) {
        
        Queue<Point> queue = new LinkedList<>();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1) { 
                    queue.add(new Point(i,j));
                    visited[i][j] = true;
                }
            }
        }
        
        int ans = 0;
        int l = queue.size();
        
        if(l== ( grid.length)*(grid[0].length)) return -1;
        
        while(!queue.isEmpty()){
            
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int[] k = dir[i];
                int newRow = cur.x + k[0];
                int newCol = cur.y + k[1];
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol< grid[0].length &&   !visited[newRow][newCol]){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
            }
            
            if(l==0) {
                ans++;
                l = queue.size();
            }
            
        }
        return ans-1;
    }
}",AsFarFromLandAsPossible.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AsFarFromLandAsPossible.java,program/,program,"class Point{
    
    public  int x;
    public int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}",Next sibling does not exist,"(11, 0)","(57, 1)",N,class_declaration,Solution,,315,6d53700a-7f85-4a3c-a014-76fc94c453a6
"public int maxDistance(int[][] grid) {
        
        Queue<Point> queue = new LinkedList<>();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1) { 
                    queue.add(new Point(i,j));
                    visited[i][j] = true;
                }
            }
        }
        
        int ans = 0;
        int l = queue.size();
        
        if(l== ( grid.length)*(grid[0].length)) return -1;
        
        while(!queue.isEmpty()){
            
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int[] k = dir[i];
                int newRow = cur.x + k[0];
                int newCol = cur.y + k[1];
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol< grid[0].length &&   !visited[newRow][newCol]){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
            }
            
            if(l==0) {
                ans++;
                l = queue.size();
            }
            
        }
        return ans-1;
    }",AsFarFromLandAsPossible.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AsFarFromLandAsPossible.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(12, 4)","(56, 5)",N,method_declaration,maxDistance,,310,ee8fa400-32f8-40ff-b175-43e5af41d5ac
"""""""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
""""""

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if(not node): return

        mapper = {}
        def dfs(node):
            if(node.val in mapper): return mapper[node.val]

            new_node = Node(node.val, [])
            mapper[new_node.val] = new_node
            for neigh in node.neighbors: new_node.neighbors.append(dfs(neigh))
            return mapper[new_node.val] 
        
        dfs(node)
        return mapper[node.val]
",cloneGraph.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\cloneGraph.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,module,module,,144,10ba15a9-5ac4-47f7-89db-daa5d6c3eb09
"""""""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
""""""",cloneGraph.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\cloneGraph.py,module/,module,Previous sibling does not exist,"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if(not node): return

        mapper = {}
        def dfs(node):
            if(node.val in mapper): return mapper[node.val]

            new_node = Node(node.val, [])
            mapper[new_node.val] = new_node
            for neigh in node.neighbors: new_node.neighbors.append(dfs(neigh))
            return mapper[new_node.val] 
        
        dfs(node)
        return mapper[node.val]","(0, 0)","(6, 3)",N,expression_statement,expression_statement,,45,e084290a-3fb8-451c-8111-016b45549cd1
"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if(not node): return

        mapper = {}
        def dfs(node):
            if(node.val in mapper): return mapper[node.val]

            new_node = Node(node.val, [])
            mapper[new_node.val] = new_node
            for neigh in node.neighbors: new_node.neighbors.append(dfs(neigh))
            return mapper[new_node.val] 
        
        dfs(node)
        return mapper[node.val]",cloneGraph.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\cloneGraph.py,module/,module,"""""""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
""""""",Next sibling does not exist,"(8, 0)","(22, 31)",N,class_definition,Solution,,99,b604bf7e-b4df-4fb6-a687-d71d9cd10d61
"def cloneGraph(self, node: 'Node') -> 'Node':
        if(not node): return

        mapper = {}
        def dfs(node):
            if(node.val in mapper): return mapper[node.val]

            new_node = Node(node.val, [])
            mapper[new_node.val] = new_node
            for neigh in node.neighbors: new_node.neighbors.append(dfs(neigh))
            return mapper[new_node.val] 
        
        dfs(node)
        return mapper[node.val]",cloneGraph.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\cloneGraph.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(9, 4)","(22, 31)",N,function_definition,cloneGraph,,95,dcd05cad-d401-4e48-b878-7bc294758a26
"def dfs(node):
            if(node.val in mapper): return mapper[node.val]

            new_node = Node(node.val, [])
            mapper[new_node.val] = new_node
            for neigh in node.neighbors: new_node.neighbors.append(dfs(neigh))
            return mapper[new_node.val]",cloneGraph.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\cloneGraph.py,module/class_definition-Solution/function_definition-cloneGraph/,cloneGraph,mapper = {},dfs(node),"(13, 8)","(19, 39)",N,function_definition,dfs,,58,23c21cbc-564d-43d2-bae9-ce948c9e630f
"class Solution {
    
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int ans = 0;
        boolean[][] visited = new boolean[grid1.length][grid1[0].length];
        
        for(int i=0;i<grid2.length;i++){
            for(int j=0;j<grid2[0].length;j++){
                if(grid2[i][j]==1 && !visited[i][j] && dfs(grid1, grid2, i, j, visited)) {
                    ans += 1;
                }
            }
        }
        
        return ans;
    }
    
    public boolean dfs(int[][] grid1, int[][] grid2, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid1.length && sc<grid1[0].length && grid2[sr][sc]==1 && !visited[sr][sc]){
            visited[sr][sc] = true;
            
            boolean isSubIsland = true;
            if(grid1[sr][sc]==0) isSubIsland = false;
            
            isSubIsland =  dfs(grid1, grid2, sr-1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc+1, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr+1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc-1, visited) && isSubIsland;
            
            return isSubIsland;
        } else {
            return true;
        }
    }
    
}
",CountSubIslands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\CountSubIslands.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(36, 0)",N,program,program,,367,b791b549-c44d-4d0f-b181-027ff94c4f46
"class Solution {
    
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int ans = 0;
        boolean[][] visited = new boolean[grid1.length][grid1[0].length];
        
        for(int i=0;i<grid2.length;i++){
            for(int j=0;j<grid2[0].length;j++){
                if(grid2[i][j]==1 && !visited[i][j] && dfs(grid1, grid2, i, j, visited)) {
                    ans += 1;
                }
            }
        }
        
        return ans;
    }
    
    public boolean dfs(int[][] grid1, int[][] grid2, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid1.length && sc<grid1[0].length && grid2[sr][sc]==1 && !visited[sr][sc]){
            visited[sr][sc] = true;
            
            boolean isSubIsland = true;
            if(grid1[sr][sc]==0) isSubIsland = false;
            
            isSubIsland =  dfs(grid1, grid2, sr-1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc+1, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr+1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc-1, visited) && isSubIsland;
            
            return isSubIsland;
        } else {
            return true;
        }
    }
    
}",CountSubIslands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\CountSubIslands.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(35, 1)",N,class_declaration,Solution,,367,5e40723b-c585-4678-bf0e-0f4d5cf307c0
"public int countSubIslands(int[][] grid1, int[][] grid2) {
        int ans = 0;
        boolean[][] visited = new boolean[grid1.length][grid1[0].length];
        
        for(int i=0;i<grid2.length;i++){
            for(int j=0;j<grid2[0].length;j++){
                if(grid2[i][j]==1 && !visited[i][j] && dfs(grid1, grid2, i, j, visited)) {
                    ans += 1;
                }
            }
        }
        
        return ans;
    }",CountSubIslands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\CountSubIslands.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public boolean dfs(int[][] grid1, int[][] grid2, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid1.length && sc<grid1[0].length && grid2[sr][sc]==1 && !visited[sr][sc]){
            visited[sr][sc] = true;
            
            boolean isSubIsland = true;
            if(grid1[sr][sc]==0) isSubIsland = false;
            
            isSubIsland =  dfs(grid1, grid2, sr-1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc+1, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr+1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc-1, visited) && isSubIsland;
            
            return isSubIsland;
        } else {
            return true;
        }
    }","(2, 4)","(15, 5)",N,method_declaration,countSubIslands,,123,47ff53f4-0525-41a7-b684-2e89dca09f65
"public boolean dfs(int[][] grid1, int[][] grid2, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid1.length && sc<grid1[0].length && grid2[sr][sc]==1 && !visited[sr][sc]){
            visited[sr][sc] = true;
            
            boolean isSubIsland = true;
            if(grid1[sr][sc]==0) isSubIsland = false;
            
            isSubIsland =  dfs(grid1, grid2, sr-1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc+1, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr+1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc-1, visited) && isSubIsland;
            
            return isSubIsland;
        } else {
            return true;
        }
    }",CountSubIslands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\CountSubIslands.java,program/class_declaration-Solution/,Solution,"public int countSubIslands(int[][] grid1, int[][] grid2) {
        int ans = 0;
        boolean[][] visited = new boolean[grid1.length][grid1[0].length];
        
        for(int i=0;i<grid2.length;i++){
            for(int j=0;j<grid2[0].length;j++){
                if(grid2[i][j]==1 && !visited[i][j] && dfs(grid1, grid2, i, j, visited)) {
                    ans += 1;
                }
            }
        }
        
        return ans;
    }",Next sibling does not exist,"(17, 4)","(33, 5)",N,method_declaration,dfs,,235,b42116b1-a5aa-4a13-a8a2-c4bdd75116d5
"class Solution:
    
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:

        N = len(graph)
        visited = [False for _ in range(N)]
        isSafe = [None for _ in range(N)]
        stack = set()

        def dfs(node):
            if(node >= N): return False
            
            if(len(graph[node]) == 0):
                visited[node] = True
                isSafe[node] = True
                return True
            
            if(visited[node]):
                if(node in stack): return False 
                return isSafe[node]

            stack.add(node)
            visited[node] = True
            ans = True
            
            for neigh in graph[node]: 
                ans = ans and dfs(neigh)
            
            isSafe[node] = ans
            stack.remove(node)
            return ans
        
        for index in range(N):
            if(not visited[index]): dfs(index)
        
        # print(isSafe)
        return [i for i in range(N) if(isSafe[i])]


",eventualSafeNodes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\eventualSafeNodes.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(39, 0)",N,module,module,,210,af220e42-8fb8-4e69-814c-ee31ad0d1a1e
"class Solution:
    
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:

        N = len(graph)
        visited = [False for _ in range(N)]
        isSafe = [None for _ in range(N)]
        stack = set()

        def dfs(node):
            if(node >= N): return False
            
            if(len(graph[node]) == 0):
                visited[node] = True
                isSafe[node] = True
                return True
            
            if(visited[node]):
                if(node in stack): return False 
                return isSafe[node]

            stack.add(node)
            visited[node] = True
            ans = True
            
            for neigh in graph[node]: 
                ans = ans and dfs(neigh)
            
            isSafe[node] = ans
            stack.remove(node)
            return ans
        
        for index in range(N):
            if(not visited[index]): dfs(index)
        
        # print(isSafe)
        return [i for i in range(N) if(isSafe[i])]",eventualSafeNodes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\eventualSafeNodes.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(36, 50)",N,class_definition,Solution,,209,91dfe9ad-ffc4-45f5-acd3-ef16aed2eabb
"def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:

        N = len(graph)
        visited = [False for _ in range(N)]
        isSafe = [None for _ in range(N)]
        stack = set()

        def dfs(node):
            if(node >= N): return False
            
            if(len(graph[node]) == 0):
                visited[node] = True
                isSafe[node] = True
                return True
            
            if(visited[node]):
                if(node in stack): return False 
                return isSafe[node]

            stack.add(node)
            visited[node] = True
            ans = True
            
            for neigh in graph[node]: 
                ans = ans and dfs(neigh)
            
            isSafe[node] = ans
            stack.remove(node)
            return ans
        
        for index in range(N):
            if(not visited[index]): dfs(index)
        
        # print(isSafe)
        return [i for i in range(N) if(isSafe[i])]",eventualSafeNodes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\eventualSafeNodes.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(2, 4)","(36, 50)",N,function_definition,eventualSafeNodes,,204,b33ea6ab-bf13-471a-8710-c68c781d4e61
"def dfs(node):
            if(node >= N): return False
            
            if(len(graph[node]) == 0):
                visited[node] = True
                isSafe[node] = True
                return True
            
            if(visited[node]):
                if(node in stack): return False 
                return isSafe[node]

            stack.add(node)
            visited[node] = True
            ans = True
            
            for neigh in graph[node]: 
                ans = ans and dfs(neigh)
            
            isSafe[node] = ans
            stack.remove(node)
            return ans",eventualSafeNodes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\eventualSafeNodes.py,module/class_definition-Solution/function_definition-eventualSafeNodes/,eventualSafeNodes,stack = set(),"for index in range(N):
            if(not visited[index]): dfs(index)","(9, 8)","(30, 22)",N,function_definition,dfs,,114,91b4123a-7979-4b9a-839f-2bb6eb6a1d61
"class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:

        if(len(trust)==0):
            return 1 if n==1 else -1


        out_graph = {}
        in_graph = {}

        for a, b in trust:
            if a not in out_graph: out_graph[a] = set()
            if(b not in in_graph): in_graph[b] = set()

            out_graph[a].add(b)
            in_graph[b].add(a)
        
        for i in range(1, n+1):
            if(i not in out_graph and (i in in_graph and len(in_graph[i])==n-1)):
                return i
        
        return -1
",findJudge.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findJudge.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 0)",N,module,module,,151,5e49bb0e-a467-468a-9da1-db64b4a09127
"class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:

        if(len(trust)==0):
            return 1 if n==1 else -1


        out_graph = {}
        in_graph = {}

        for a, b in trust:
            if a not in out_graph: out_graph[a] = set()
            if(b not in in_graph): in_graph[b] = set()

            out_graph[a].add(b)
            in_graph[b].add(a)
        
        for i in range(1, n+1):
            if(i not in out_graph and (i in in_graph and len(in_graph[i])==n-1)):
                return i
        
        return -1",findJudge.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findJudge.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 17)",N,class_definition,Solution,,150,83599606-34c9-4933-a5c4-1b8b920ee536
"def findJudge(self, n: int, trust: List[List[int]]) -> int:

        if(len(trust)==0):
            return 1 if n==1 else -1


        out_graph = {}
        in_graph = {}

        for a, b in trust:
            if a not in out_graph: out_graph[a] = set()
            if(b not in in_graph): in_graph[b] = set()

            out_graph[a].add(b)
            in_graph[b].add(a)
        
        for i in range(1, n+1):
            if(i not in out_graph and (i in in_graph and len(in_graph[i])==n-1)):
                return i
        
        return -1",findJudge.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findJudge.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(21, 17)",N,function_definition,findJudge,,146,cc700672-68e1-46a9-b2a5-636fe176c34f
"class Solution:
    def findMaxFish(self, grid: List[List[int]]) -> int:
        
        N = len(grid)
        M = len(grid[0])
        visited = [[False]*M for i in range(N)]
        
        def dfs(row, col):
            if(row<0 or row>=N or col<0 or col>=M or visited[row][col] or grid[row][col] == 0): return 0
            
            visited[row][col] = True
            ans = grid[row][col]
            for dx, dy in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
                newx, newy = row+dx, col+dy
                ans += dfs(newx, newy)
            
            return ans
        
        ans = 0
        for index1 in range(N):
            for index2 in range(M):
                if(not visited[index1][index2] and grid[index1][index2]!=0):
                    sub_ans = dfs(index1, index2)
                    ans = max(ans, sub_ans)
        
        return ans
        
        
",findMaxFish.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findMaxFish.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 0)",N,module,module,,236,9f4a1d1c-08ec-4ff7-bc01-cc827a2230b9
"class Solution:
    def findMaxFish(self, grid: List[List[int]]) -> int:
        
        N = len(grid)
        M = len(grid[0])
        visited = [[False]*M for i in range(N)]
        
        def dfs(row, col):
            if(row<0 or row>=N or col<0 or col>=M or visited[row][col] or grid[row][col] == 0): return 0
            
            visited[row][col] = True
            ans = grid[row][col]
            for dx, dy in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
                newx, newy = row+dx, col+dy
                ans += dfs(newx, newy)
            
            return ans
        
        ans = 0
        for index1 in range(N):
            for index2 in range(M):
                if(not visited[index1][index2] and grid[index1][index2]!=0):
                    sub_ans = dfs(index1, index2)
                    ans = max(ans, sub_ans)
        
        return ans",findMaxFish.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findMaxFish.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 18)",N,class_definition,Solution,,235,b18b3034-3dc6-46fc-94e1-d1374353d037
"def findMaxFish(self, grid: List[List[int]]) -> int:
        
        N = len(grid)
        M = len(grid[0])
        visited = [[False]*M for i in range(N)]
        
        def dfs(row, col):
            if(row<0 or row>=N or col<0 or col>=M or visited[row][col] or grid[row][col] == 0): return 0
            
            visited[row][col] = True
            ans = grid[row][col]
            for dx, dy in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
                newx, newy = row+dx, col+dy
                ans += dfs(newx, newy)
            
            return ans
        
        ans = 0
        for index1 in range(N):
            for index2 in range(M):
                if(not visited[index1][index2] and grid[index1][index2]!=0):
                    sub_ans = dfs(index1, index2)
                    ans = max(ans, sub_ans)
        
        return ans",findMaxFish.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findMaxFish.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(25, 18)",N,function_definition,findMaxFish,,231,6a107182-f308-416d-bd6c-64102254d8b7
"def dfs(row, col):
            if(row<0 or row>=N or col<0 or col>=M or visited[row][col] or grid[row][col] == 0): return 0
            
            visited[row][col] = True
            ans = grid[row][col]
            for dx, dy in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
                newx, newy = row+dx, col+dy
                ans += dfs(newx, newy)
            
            return ans",findMaxFish.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findMaxFish.py,module/class_definition-Solution/function_definition-findMaxFish/,findMaxFish,visited = [[False]*M for i in range(N)],ans = 0,"(7, 8)","(16, 22)",N,function_definition,dfs,,119,c0be8be5-a8e7-4bcf-a3fa-1b13509df0f5
"class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        boolean[] visited = new boolean[rooms.size()];
        
        dfs(rooms, 0, visited);
        
        for(boolean x: visited){
            if(!x) return x;
        }
        
        return true;
    }
    
    
    public void dfs(List<List<Integer>> rooms, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int key: rooms.get(cur)){
            dfs(rooms, key, visited);
        }
    }
}
",KeysAndRooms.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\KeysAndRooms.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 0)",N,program,program,,120,564f38bf-a2b4-41e1-849a-5df6a4859f6f
"class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        boolean[] visited = new boolean[rooms.size()];
        
        dfs(rooms, 0, visited);
        
        for(boolean x: visited){
            if(!x) return x;
        }
        
        return true;
    }
    
    
    public void dfs(List<List<Integer>> rooms, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int key: rooms.get(cur)){
            dfs(rooms, key, visited);
        }
    }
}",KeysAndRooms.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\KeysAndRooms.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 1)",N,class_declaration,Solution,,120,a7b32078-8574-4594-9db6-cc2a6af7ba2f
"public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        boolean[] visited = new boolean[rooms.size()];
        
        dfs(rooms, 0, visited);
        
        for(boolean x: visited){
            if(!x) return x;
        }
        
        return true;
    }",KeysAndRooms.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\KeysAndRooms.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public void dfs(List<List<Integer>> rooms, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int key: rooms.get(cur)){
            dfs(rooms, key, visited);
        }
    }","(1, 4)","(11, 5)",N,method_declaration,canVisitAllRooms,,60,62612087-ae34-42e3-8553-c7a1bdf3d76b
"public void dfs(List<List<Integer>> rooms, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int key: rooms.get(cur)){
            dfs(rooms, key, visited);
        }
    }",KeysAndRooms.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\KeysAndRooms.java,program/class_declaration-Solution/,Solution,"public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        boolean[] visited = new boolean[rooms.size()];
        
        dfs(rooms, 0, visited);
        
        for(boolean x: visited){
            if(!x) return x;
        }
        
        return true;
    }",Next sibling does not exist,"(14, 4)","(20, 5)",N,method_declaration,dfs,,53,b0f4e609-3338-4e64-9177-f776020489ac
"class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        words = {}
        for index, word in enumerate(wordList): words[word] = index
        if(endWord not in words): return 0

        src = -1
        dest = words[endWord]

        if(beginWord not in words): 
            wordList.append(beginWord)
            src = len(wordList)-1
        else:
            src = wordList.index(beginWord)
        
        N = len(wordList)
        graph = {}
        for index in range(N): graph[index] = set()
        

        # O(N * L * 26) ~ O(N * 260) ~ O((1.3)*10**6)
        for wordIndex in range(N):
            word = wordList[wordIndex]
            for index in range(len(word)):
                for ch in 'abcdefghijklmnopqrstuvwyz':
                    new = word[:index] + ch + word[index+1:]
                    if(new not in words): continue 
                    node = words[new]
                    graph[wordIndex].add(node)
                    graph[node].add(wordIndex)

        # Make it bidirectional bfs
        def bfs(root, dest):
            queue = [root]
            visited = set()
            visited.add(root)
            l = 1
            depth = 1

            while(queue):
                cur = queue.pop(0)
                l -= 1
                if(cur == dest): return depth 

                for neigh in graph[cur]:
                    if(neigh in visited): continue
                    if(neigh == dest): return depth+1
                    visited.add(neigh)
                    queue.append(neigh)
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1
        
        def biDirectionalBfs(root, dest):
            queue = [(root, 0), (dest, 1)]
            visited = [{}, {}]
            l = 2
            depth = 1

            while(queue):
                cur, parent = queue.pop(0)
                l -= 1
                if(cur in visited[1^parent]): return depth + visited[1^parent][cur] 

                for neigh in graph[cur]:
                    if(neigh in visited[parent]): continue
                    visited[parent][neigh] = depth
                    queue.append((neigh, parent))
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1

        depth = bfs(src, dest)
        if(depth == -1): return 0
        return depth
",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(82, 0)",N,module,module,,551,6787915c-d753-4e8c-9678-ef451287c928
"class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        words = {}
        for index, word in enumerate(wordList): words[word] = index
        if(endWord not in words): return 0

        src = -1
        dest = words[endWord]

        if(beginWord not in words): 
            wordList.append(beginWord)
            src = len(wordList)-1
        else:
            src = wordList.index(beginWord)
        
        N = len(wordList)
        graph = {}
        for index in range(N): graph[index] = set()
        

        # O(N * L * 26) ~ O(N * 260) ~ O((1.3)*10**6)
        for wordIndex in range(N):
            word = wordList[wordIndex]
            for index in range(len(word)):
                for ch in 'abcdefghijklmnopqrstuvwyz':
                    new = word[:index] + ch + word[index+1:]
                    if(new not in words): continue 
                    node = words[new]
                    graph[wordIndex].add(node)
                    graph[node].add(wordIndex)

        # Make it bidirectional bfs
        def bfs(root, dest):
            queue = [root]
            visited = set()
            visited.add(root)
            l = 1
            depth = 1

            while(queue):
                cur = queue.pop(0)
                l -= 1
                if(cur == dest): return depth 

                for neigh in graph[cur]:
                    if(neigh in visited): continue
                    if(neigh == dest): return depth+1
                    visited.add(neigh)
                    queue.append(neigh)
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1
        
        def biDirectionalBfs(root, dest):
            queue = [(root, 0), (dest, 1)]
            visited = [{}, {}]
            l = 2
            depth = 1

            while(queue):
                cur, parent = queue.pop(0)
                l -= 1
                if(cur in visited[1^parent]): return depth + visited[1^parent][cur] 

                for neigh in graph[cur]:
                    if(neigh in visited[parent]): continue
                    visited[parent][neigh] = depth
                    queue.append((neigh, parent))
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1

        depth = bfs(src, dest)
        if(depth == -1): return 0
        return depth",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(81, 20)",N,class_definition,Solution,,550,b457c335-3209-45cc-a87f-56de3987170b
"def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        words = {}
        for index, word in enumerate(wordList): words[word] = index
        if(endWord not in words): return 0

        src = -1
        dest = words[endWord]

        if(beginWord not in words): 
            wordList.append(beginWord)
            src = len(wordList)-1
        else:
            src = wordList.index(beginWord)
        
        N = len(wordList)
        graph = {}
        for index in range(N): graph[index] = set()
        

        # O(N * L * 26) ~ O(N * 260) ~ O((1.3)*10**6)
        for wordIndex in range(N):
            word = wordList[wordIndex]
            for index in range(len(word)):
                for ch in 'abcdefghijklmnopqrstuvwyz':
                    new = word[:index] + ch + word[index+1:]
                    if(new not in words): continue 
                    node = words[new]
                    graph[wordIndex].add(node)
                    graph[node].add(wordIndex)

        # Make it bidirectional bfs
        def bfs(root, dest):
            queue = [root]
            visited = set()
            visited.add(root)
            l = 1
            depth = 1

            while(queue):
                cur = queue.pop(0)
                l -= 1
                if(cur == dest): return depth 

                for neigh in graph[cur]:
                    if(neigh in visited): continue
                    if(neigh == dest): return depth+1
                    visited.add(neigh)
                    queue.append(neigh)
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1
        
        def biDirectionalBfs(root, dest):
            queue = [(root, 0), (dest, 1)]
            visited = [{}, {}]
            l = 2
            depth = 1

            while(queue):
                cur, parent = queue.pop(0)
                l -= 1
                if(cur in visited[1^parent]): return depth + visited[1^parent][cur] 

                for neigh in graph[cur]:
                    if(neigh in visited[parent]): continue
                    visited[parent][neigh] = depth
                    queue.append((neigh, parent))
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1

        depth = bfs(src, dest)
        if(depth == -1): return 0
        return depth",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"words = {}
for index, word in enumerate(wordList): words[word] = index
if(endWord not in words): return 0
src = -1
dest = words[endWord]
if(beginWord not in words): 
            wordList.append(beginWord)
            src = len(wordList)-1
        else:
            src = wordList.index(beginWord)
N = len(wordList)
graph = {}
for index in range(N): graph[index] = set()
# O(N * L * 26) ~ O(N * 260) ~ O((1.3)*10**6)
for wordIndex in range(N):
            word = wordList[wordIndex]
            for index in range(len(word)):
                for ch in 'abcdefghijklmnopqrstuvwyz':
                    new = word[:index] + ch + word[index+1:]
                    if(new not in words): continue 
                    node = words[new]
                    graph[wordIndex].add(node)
                    graph[node].add(wordIndex)
# Make it bidirectional bfs","(1, 4)","(81, 20)",N,function_definition,ladderLength,,546,8935a1a8-e0da-4f0e-a57d-9b339b4ad3fe
"words = {}
for index, word in enumerate(wordList): words[word] = index
if(endWord not in words): return 0
src = -1
dest = words[endWord]
if(beginWord not in words): 
            wordList.append(beginWord)
            src = len(wordList)-1
        else:
            src = wordList.index(beginWord)
N = len(wordList)
graph = {}
for index in range(N): graph[index] = set()
# O(N * L * 26) ~ O(N * 260) ~ O((1.3)*10**6)
for wordIndex in range(N):
            word = wordList[wordIndex]
            for index in range(len(word)):
                for ch in 'abcdefghijklmnopqrstuvwyz':
                    new = word[:index] + ch + word[index+1:]
                    if(new not in words): continue 
                    node = words[new]
                    graph[wordIndex].add(node)
                    graph[node].add(wordIndex)
# Make it bidirectional bfs",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,module/class_definition-Solution/function_definition-ladderLength/,ladderLength,Previous sibling does not exist,"def bfs(root, dest):
            queue = [root]
            visited = set()
            visited.add(root)
            l = 1
            depth = 1

            while(queue):
                cur = queue.pop(0)
                l -= 1
                if(cur == dest): return depth 

                for neigh in graph[cur]:
                    if(neigh in visited): continue
                    if(neigh == dest): return depth+1
                    visited.add(neigh)
                    queue.append(neigh)
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1","(3, 8)","(32, 35)",N,"expression_statement,for_statement,if_statement,expression_statement,expression_statement,if_statement,expression_statement,expression_statement,for_statement,comment,for_statement,comment",expression_statement,,206,7b2e34d2-9bab-454d-808f-16f76db43fd0
"def bfs(root, dest):
            queue = [root]
            visited = set()
            visited.add(root)
            l = 1
            depth = 1

            while(queue):
                cur = queue.pop(0)
                l -= 1
                if(cur == dest): return depth 

                for neigh in graph[cur]:
                    if(neigh in visited): continue
                    if(neigh == dest): return depth+1
                    visited.add(neigh)
                    queue.append(neigh)
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,module/class_definition-Solution/function_definition-ladderLength/,ladderLength,"words = {}
for index, word in enumerate(wordList): words[word] = index
if(endWord not in words): return 0
src = -1
dest = words[endWord]
if(beginWord not in words): 
            wordList.append(beginWord)
            src = len(wordList)-1
        else:
            src = wordList.index(beginWord)
N = len(wordList)
graph = {}
for index in range(N): graph[index] = set()
# O(N * L * 26) ~ O(N * 260) ~ O((1.3)*10**6)
for wordIndex in range(N):
            word = wordList[wordIndex]
            for index in range(len(word)):
                for ch in 'abcdefghijklmnopqrstuvwyz':
                    new = word[:index] + ch + word[index+1:]
                    if(new not in words): continue 
                    node = words[new]
                    graph[wordIndex].add(node)
                    graph[node].add(wordIndex)
# Make it bidirectional bfs","def biDirectionalBfs(root, dest):
            queue = [(root, 0), (dest, 1)]
            visited = [{}, {}]
            l = 2
            depth = 1

            while(queue):
                cur, parent = queue.pop(0)
                l -= 1
                if(cur in visited[1^parent]): return depth + visited[1^parent][cur] 

                for neigh in graph[cur]:
                    if(neigh in visited[parent]): continue
                    visited[parent][neigh] = depth
                    queue.append((neigh, parent))
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1","(33, 8)","(55, 21)",N,function_definition,bfs,,125,b0bd7c41-39f9-42f6-97ca-76170704c596
"def biDirectionalBfs(root, dest):
            queue = [(root, 0), (dest, 1)]
            visited = [{}, {}]
            l = 2
            depth = 1

            while(queue):
                cur, parent = queue.pop(0)
                l -= 1
                if(cur in visited[1^parent]): return depth + visited[1^parent][cur] 

                for neigh in graph[cur]:
                    if(neigh in visited[parent]): continue
                    visited[parent][neigh] = depth
                    queue.append((neigh, parent))
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,module/class_definition-Solution/function_definition-ladderLength/,ladderLength,"def bfs(root, dest):
            queue = [root]
            visited = set()
            visited.add(root)
            l = 1
            depth = 1

            while(queue):
                cur = queue.pop(0)
                l -= 1
                if(cur == dest): return depth 

                for neigh in graph[cur]:
                    if(neigh in visited): continue
                    if(neigh == dest): return depth+1
                    visited.add(neigh)
                    queue.append(neigh)
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1","depth = bfs(src, dest)
if(depth == -1): return 0
return depth","(57, 8)","(77, 21)",N,function_definition,biDirectionalBfs,,146,7f73c2c2-ab34-43b9-ac95-96e23a1106a5
"depth = bfs(src, dest)
if(depth == -1): return 0
return depth",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,module/class_definition-Solution/function_definition-ladderLength/,ladderLength,"def biDirectionalBfs(root, dest):
            queue = [(root, 0), (dest, 1)]
            visited = [{}, {}]
            l = 2
            depth = 1

            while(queue):
                cur, parent = queue.pop(0)
                l -= 1
                if(cur in visited[1^parent]): return depth + visited[1^parent][cur] 

                for neigh in graph[cur]:
                    if(neigh in visited[parent]): continue
                    visited[parent][neigh] = depth
                    queue.append((neigh, parent))
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1",Next sibling does not exist,"(79, 8)","(81, 20)",N,"expression_statement,if_statement,return_statement",expression_statement,,18,43483b65-1cb1-4b53-bdf4-20b9d7375c00
"import collections


class Solution:

    def __init__(self):
        self.stack = set()
        self.ans = 0
        self.cycleDetected = False
        self.graph = None
        self.colors = None
        self.cache = None


    def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]
    

    def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1

    def largestPathValue(self, colors, edges):

        N = len(colors)

        self.ans = 0
        self.cache = collections.defaultdict(list)
        self.stack = set()
        self.cycleDetected = False
        self.graph = collections.defaultdict(list)
        self.colors = colors
        self.visited = set()

        for source, destination in edges: self.graph[source].append(destination)
        def maximumFrequency(arr): return max(arr)

        for node in range(N):
            if(node not in self.visited):
                self.dfs(node)
                if(self.cycleDetected): return -1
        
        # print(self.cache)
        return self.ans

sol = Solution()
# ans =  sol.largestPathValue(""abaca"", [[0,1],[0,2],[2,3],[3,4]])
ans =  sol.largestPathValue(""a"", [[0,0]])
print(ans)",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(69, 10)",N,module,module,,445,20d1ddf6-e8e2-45f4-b416-69bdee1a0e6a
import collections,largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/,module,Previous sibling does not exist,"class Solution:

    def __init__(self):
        self.stack = set()
        self.ans = 0
        self.cycleDetected = False
        self.graph = None
        self.colors = None
        self.cache = None


    def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]
    

    def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1

    def largestPathValue(self, colors, edges):

        N = len(colors)

        self.ans = 0
        self.cache = collections.defaultdict(list)
        self.stack = set()
        self.cycleDetected = False
        self.graph = collections.defaultdict(list)
        self.colors = colors
        self.visited = set()

        for source, destination in edges: self.graph[source].append(destination)
        def maximumFrequency(arr): return max(arr)

        for node in range(N):
            if(node not in self.visited):
                self.dfs(node)
                if(self.cycleDetected): return -1
        
        # print(self.cache)
        return self.ans","(0, 0)","(0, 18)",N,import_statement,import_statement,,2,715103e7-079c-4576-ae45-c0e361500a11
"class Solution:

    def __init__(self):
        self.stack = set()
        self.ans = 0
        self.cycleDetected = False
        self.graph = None
        self.colors = None
        self.cache = None


    def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]
    

    def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1

    def largestPathValue(self, colors, edges):

        N = len(colors)

        self.ans = 0
        self.cache = collections.defaultdict(list)
        self.stack = set()
        self.cycleDetected = False
        self.graph = collections.defaultdict(list)
        self.colors = colors
        self.visited = set()

        for source, destination in edges: self.graph[source].append(destination)
        def maximumFrequency(arr): return max(arr)

        for node in range(N):
            if(node not in self.visited):
                self.dfs(node)
                if(self.cycleDetected): return -1
        
        # print(self.cache)
        return self.ans",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/,module,import collections,sol = Solution(),"(3, 0)","(64, 23)",N,class_definition,Solution,,388,cf21c790-3838-4320-ba18-2f3564e6bee2
"def __init__(self):
        self.stack = set()
        self.ans = 0
        self.cycleDetected = False
        self.graph = None
        self.colors = None
        self.cache = None",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]","(5, 4)","(11, 25)",N,function_definition,__init__,,45,01b70b15-2b3c-4fe3-96ab-0fff17818918
"def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/class_definition-Solution/,Solution,"def __init__(self):
        self.stack = set()
        self.ans = 0
        self.cycleDetected = False
        self.graph = None
        self.colors = None
        self.cache = None","def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1","(14, 4)","(35, 31)",N,function_definition,dfs,,156,4153388b-87e5-4cc8-8ee3-3eb817e77713
"def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/class_definition-Solution/,Solution,"def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]","def largestPathValue(self, colors, edges):

        N = len(colors)

        self.ans = 0
        self.cache = collections.defaultdict(list)
        self.stack = set()
        self.cycleDetected = False
        self.graph = collections.defaultdict(list)
        self.colors = colors
        self.visited = set()

        for source, destination in edges: self.graph[source].append(destination)
        def maximumFrequency(arr): return max(arr)

        for node in range(N):
            if(node not in self.visited):
                self.dfs(node)
                if(self.cycleDetected): return -1
        
        # print(self.cache)
        return self.ans","(38, 4)","(41, 19)",N,function_definition,maxArr,,39,258bbcb0-ed18-413e-989c-0f622aaeb038
"def largestPathValue(self, colors, edges):

        N = len(colors)

        self.ans = 0
        self.cache = collections.defaultdict(list)
        self.stack = set()
        self.cycleDetected = False
        self.graph = collections.defaultdict(list)
        self.colors = colors
        self.visited = set()

        for source, destination in edges: self.graph[source].append(destination)
        def maximumFrequency(arr): return max(arr)

        for node in range(N):
            if(node not in self.visited):
                self.dfs(node)
                if(self.cycleDetected): return -1
        
        # print(self.cache)
        return self.ans",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/class_definition-Solution/,Solution,"def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1",Next sibling does not exist,"(43, 4)","(64, 23)",N,function_definition,largestPathValue,,138,b6fd23f6-bfbe-42b1-9740-c4d3ec4431fb
def maximumFrequency(arr): return max(arr),largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/class_definition-Solution/function_definition-largestPathValue/,largestPathValue,"for source, destination in edges: self.graph[source].append(destination)","sol = Solution()
# ans =  sol.largestPathValue(""abaca"", [[0,1],[0,2],[2,3],[3,4]])
ans =  sol.largestPathValue(""a"", [[0,0]])
print(ans)","(56, 8)","(56, 50)",N,function_definition,maximumFrequency,,9,d0e4eea3-7d50-45d2-99c0-7bd49cd8605b
"sol = Solution()
# ans =  sol.largestPathValue(""abaca"", [[0,1],[0,2],[2,3],[3,4]])
ans =  sol.largestPathValue(""a"", [[0,0]])
print(ans)",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/,module,"class Solution:

    def __init__(self):
        self.stack = set()
        self.ans = 0
        self.cycleDetected = False
        self.graph = None
        self.colors = None
        self.cache = None


    def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]
    

    def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1

    def largestPathValue(self, colors, edges):

        N = len(colors)

        self.ans = 0
        self.cache = collections.defaultdict(list)
        self.stack = set()
        self.cycleDetected = False
        self.graph = collections.defaultdict(list)
        self.colors = colors
        self.visited = set()

        for source, destination in edges: self.graph[source].append(destination)
        def maximumFrequency(arr): return max(arr)

        for node in range(N):
            if(node not in self.visited):
                self.dfs(node)
                if(self.cycleDetected): return -1
        
        # print(self.cache)
        return self.ans",Next sibling does not exist,"(66, 0)","(69, 10)",N,"expression_statement,comment,expression_statement,expression_statement",expression_statement,,53,177dcca6-b3d9-46d7-80ed-da346a899ed6
"from UnionFind.EquationsPossible import UnionFind


class Solution:
    def latestDayToCross(self, row, col, cells):

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            for index in range(row*col-1, mid-1, -1): uf.add((index // col) + 1, (index % col) + 1)
            # prev = mid

            if(connected()): low = mid
            else: high = mid-1        
        return low


class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(cell):
            row_index, col_index = cell
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            # print(tops, bottoms)
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            print(low, high, mid)

            for index in range(row*col-1, mid-1, -1):
                # print(index, ((index // col) + 1, (index % col) + 1))
                # uf.merge((index // col) + 1, (index % col) + 1)
                # uf.merge(cells[index][0], cells[index][1])
                print(index, cells[index])
                add_node(cells[index])                
                
            print(uf.idx, connected())
            if(connected()): low = mid
            else: high = mid-1        
        
        print(low, high)
        return low",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(99, 18)",N,module,module,,833,444d9e89-3860-4b21-9adb-d3c185d662be
from UnionFind.EquationsPossible import UnionFind,latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/,module,Previous sibling does not exist,"class Solution:
    def latestDayToCross(self, row, col, cells):

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            for index in range(row*col-1, mid-1, -1): uf.add((index // col) + 1, (index % col) + 1)
            # prev = mid

            if(connected()): low = mid
            else: high = mid-1        
        return low","(0, 0)","(0, 49)",N,import_from_statement,import_from_statement,,10,d7fbd670-ecf7-4f89-97f7-52c48e668738
"class Solution:
    def latestDayToCross(self, row, col, cells):

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            for index in range(row*col-1, mid-1, -1): uf.add((index // col) + 1, (index % col) + 1)
            # prev = mid

            if(connected()): low = mid
            else: high = mid-1        
        return low",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/,module,from UnionFind.EquationsPossible import UnionFind,"class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(cell):
            row_index, col_index = cell
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            # print(tops, bottoms)
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            print(low, high, mid)

            for index in range(row*col-1, mid-1, -1):
                # print(index, ((index // col) + 1, (index % col) + 1))
                # uf.merge((index // col) + 1, (index % col) + 1)
                # uf.merge(cells[index][0], cells[index][1])
                print(index, cells[index])
                add_node(cells[index])                
                
            print(uf.idx, connected())
            if(connected()): low = mid
            else: high = mid-1        
        
        print(low, high)
        return low","(3, 0)","(44, 18)",N,class_definition,Solution,,364,63d09cca-22f8-46d8-9892-63f1f84d1779
"def latestDayToCross(self, row, col, cells):

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            for index in range(row*col-1, mid-1, -1): uf.add((index // col) + 1, (index % col) + 1)
            # prev = mid

            if(connected()): low = mid
            else: high = mid-1        
        return low",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(4, 4)","(44, 18)",N,function_definition,latestDayToCross,,360,0bd5149d-4372-4b1b-a2b4-5692adff9779
"def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/class_definition-Solution/function_definition-latestDayToCross/,latestDayToCross,"dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]","def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False","(13, 8)","(21, 86)",N,function_definition,add_node,,124,cd1c5e0f-0446-436a-8bd5-5dd85e03239b
"def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/class_definition-Solution/function_definition-latestDayToCross/,latestDayToCross,"def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)",low = 0,"(23, 8)","(31, 24)",N,function_definition,connected,,59,dbc792a9-f9ab-4620-af8b-89bb5c7d49d0
"class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(cell):
            row_index, col_index = cell
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            # print(tops, bottoms)
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            print(low, high, mid)

            for index in range(row*col-1, mid-1, -1):
                # print(index, ((index // col) + 1, (index % col) + 1))
                # uf.merge((index // col) + 1, (index % col) + 1)
                # uf.merge(cells[index][0], cells[index][1])
                print(index, cells[index])
                add_node(cells[index])                
                
            print(uf.idx, connected())
            if(connected()): low = mid
            else: high = mid-1        
        
        print(low, high)
        return low",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/,module,"class Solution:
    def latestDayToCross(self, row, col, cells):

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            for index in range(row*col-1, mid-1, -1): uf.add((index // col) + 1, (index % col) + 1)
            # prev = mid

            if(connected()): low = mid
            else: high = mid-1        
        return low",Next sibling does not exist,"(47, 0)","(99, 18)",N,class_definition,Solution,,457,490b6f55-d2bb-4458-b9d5-ec816404914c
"def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(cell):
            row_index, col_index = cell
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            # print(tops, bottoms)
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            print(low, high, mid)

            for index in range(row*col-1, mid-1, -1):
                # print(index, ((index // col) + 1, (index % col) + 1))
                # uf.merge((index // col) + 1, (index % col) + 1)
                # uf.merge(cells[index][0], cells[index][1])
                print(index, cells[index])
                add_node(cells[index])                
                
            print(uf.idx, connected())
            if(connected()): low = mid
            else: high = mid-1        
        
        print(low, high)
        return low",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(48, 4)","(99, 18)",N,function_definition,latestDayToCross,,453,9b85d440-7360-4e9e-ba04-c663c7db9e86
"def add_node(cell):
            row_index, col_index = cell
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/class_definition-Solution/function_definition-latestDayToCross/,latestDayToCross,"dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]","def connected():
            # print(tops, bottoms)
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False","(57, 8)","(66, 86)",N,function_definition,add_node,,129,8ed0d1bc-3ce6-43c1-b142-a63099f25631
"def connected():
            # print(tops, bottoms)
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/class_definition-Solution/function_definition-latestDayToCross/,latestDayToCross,"def add_node(cell):
            row_index, col_index = cell
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)",low = 0,"(68, 8)","(77, 24)",N,function_definition,connected,,67,f9aa4537-ba4d-4563-97d0-088201e7542e
"class Solution {
    public int longestIncreasingPath(int[][] matrix) {
        
        int[][] ans = new int[matrix.length][matrix[0].length];
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                ans[i][j] = -1;
            }
        }
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                dfs(matrix, ans, i, j);
            }
        }
        
        
        // for(int[] x: ans) System.out.println(Arrays.toString(x));
        
        int max = 0;
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                max = Math.max(max, ans[i][j]);
            }
        }
        
        return max+1;
    }
    
    // 
    
    
    public int dfs(int[][] matrix, int[][] ans, int sr, int sc){
        // System.out.println(""start "" + sr + "" "" + sc);
        
        if(ans[sr][sc]!=-1) return ans[sr][sc];
        
        int[][] dir = new int[][] {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        
        for(int[] x: dir){
            int r = sr + x[0];
            int c = sc + x[1];
            if(r<0 || c<0 || r>=matrix.length || c>=matrix[0].length || matrix[r][c] <= matrix[sr][sc]) continue;
            ans[sr][sc] = Math.max(ans[sr][sc], dfs(matrix, ans, r, c));
        }
        
        // System.out.println(sr + "" "" + sc + "" "" + left + "" "" + right +"" "" + down + "" "" + left);
        ans[sr][sc] += 1;
        
        // System.out.println(""end "" + sr + "" "" + sc);
        return ans[sr][sc];
    }
    
    
    
    
}
",LongestIncreasingPathInAMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\LongestIncreasingPathInAMatrix.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(62, 0)",N,program,program,,468,86d2aa4f-7d36-42b0-b266-f983dfcadf1a
"class Solution {
    public int longestIncreasingPath(int[][] matrix) {
        
        int[][] ans = new int[matrix.length][matrix[0].length];
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                ans[i][j] = -1;
            }
        }
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                dfs(matrix, ans, i, j);
            }
        }
        
        
        // for(int[] x: ans) System.out.println(Arrays.toString(x));
        
        int max = 0;
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                max = Math.max(max, ans[i][j]);
            }
        }
        
        return max+1;
    }
    
    // 
    
    
    public int dfs(int[][] matrix, int[][] ans, int sr, int sc){
        // System.out.println(""start "" + sr + "" "" + sc);
        
        if(ans[sr][sc]!=-1) return ans[sr][sc];
        
        int[][] dir = new int[][] {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        
        for(int[] x: dir){
            int r = sr + x[0];
            int c = sc + x[1];
            if(r<0 || c<0 || r>=matrix.length || c>=matrix[0].length || matrix[r][c] <= matrix[sr][sc]) continue;
            ans[sr][sc] = Math.max(ans[sr][sc], dfs(matrix, ans, r, c));
        }
        
        // System.out.println(sr + "" "" + sc + "" "" + left + "" "" + right +"" "" + down + "" "" + left);
        ans[sr][sc] += 1;
        
        // System.out.println(""end "" + sr + "" "" + sc);
        return ans[sr][sc];
    }
    
    
    
    
}",LongestIncreasingPathInAMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\LongestIncreasingPathInAMatrix.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(61, 1)",N,class_declaration,Solution,,468,da02892d-f09f-4ce8-8bb4-746b3b33b814
"public int longestIncreasingPath(int[][] matrix) {
        
        int[][] ans = new int[matrix.length][matrix[0].length];
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                ans[i][j] = -1;
            }
        }
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                dfs(matrix, ans, i, j);
            }
        }
        
        
        // for(int[] x: ans) System.out.println(Arrays.toString(x));
        
        int max = 0;
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                max = Math.max(max, ans[i][j]);
            }
        }
        
        return max+1;
    }",LongestIncreasingPathInAMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\LongestIncreasingPathInAMatrix.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,// ,"(1, 4)","(29, 5)",N,method_declaration,longestIncreasingPath,,211,9aec47c5-739c-4df3-a1de-556faa714a3d
"public int dfs(int[][] matrix, int[][] ans, int sr, int sc){
        // System.out.println(""start "" + sr + "" "" + sc);
        
        if(ans[sr][sc]!=-1) return ans[sr][sc];
        
        int[][] dir = new int[][] {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        
        for(int[] x: dir){
            int r = sr + x[0];
            int c = sc + x[1];
            if(r<0 || c<0 || r>=matrix.length || c>=matrix[0].length || matrix[r][c] <= matrix[sr][sc]) continue;
            ans[sr][sc] = Math.max(ans[sr][sc], dfs(matrix, ans, r, c));
        }
        
        // System.out.println(sr + "" "" + sc + "" "" + left + "" "" + right +"" "" + down + "" "" + left);
        ans[sr][sc] += 1;
        
        // System.out.println(""end "" + sr + "" "" + sc);
        return ans[sr][sc];
    }",LongestIncreasingPathInAMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\LongestIncreasingPathInAMatrix.java,program/class_declaration-Solution/,Solution,// ,Next sibling does not exist,"(34, 4)","(56, 5)",N,method_declaration,dfs,,245,4af0432c-16f7-4d6b-aa8b-a174004ce328
"class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        
        N = len(bombs)
        def inRange(index1, index2):
            x1, y1, r1 = bombs[index1]
            x2, y2, r2 = bombs[index2]
            dis = ((x1-x2)**2 + (y1-y2)**2)**(1/2)
            return dis <= r1
        
        graph = defaultdict(list)
        for index1 in range(N):
            for index2 in range(N):
                if(index1 != index2 and inRange(index1, index2)): 
                    graph[index1].append(index2)
        
        
        stack = set()
        def dfs(index):
            if(index in stack): return
            stack.add(index)
            for child in graph[index]: dfs(child)


        ans = 0
        for index1 in range(N):
            stack = set()
            dfs(index1)
            ans = max(ans, len(stack))
        
        return ans
",maximumDetonation.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maximumDetonation.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 0)",N,module,module,,216,c20ce76d-f0f9-4156-9cf8-c5da7b0bf29a
"class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        
        N = len(bombs)
        def inRange(index1, index2):
            x1, y1, r1 = bombs[index1]
            x2, y2, r2 = bombs[index2]
            dis = ((x1-x2)**2 + (y1-y2)**2)**(1/2)
            return dis <= r1
        
        graph = defaultdict(list)
        for index1 in range(N):
            for index2 in range(N):
                if(index1 != index2 and inRange(index1, index2)): 
                    graph[index1].append(index2)
        
        
        stack = set()
        def dfs(index):
            if(index in stack): return
            stack.add(index)
            for child in graph[index]: dfs(child)


        ans = 0
        for index1 in range(N):
            stack = set()
            dfs(index1)
            ans = max(ans, len(stack))
        
        return ans",maximumDetonation.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maximumDetonation.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 18)",N,class_definition,Solution,,215,954b46d2-1ce6-450f-a007-aa729a383bd3
"def maximumDetonation(self, bombs: List[List[int]]) -> int:
        
        N = len(bombs)
        def inRange(index1, index2):
            x1, y1, r1 = bombs[index1]
            x2, y2, r2 = bombs[index2]
            dis = ((x1-x2)**2 + (y1-y2)**2)**(1/2)
            return dis <= r1
        
        graph = defaultdict(list)
        for index1 in range(N):
            for index2 in range(N):
                if(index1 != index2 and inRange(index1, index2)): 
                    graph[index1].append(index2)
        
        
        stack = set()
        def dfs(index):
            if(index in stack): return
            stack.add(index)
            for child in graph[index]: dfs(child)


        ans = 0
        for index1 in range(N):
            stack = set()
            dfs(index1)
            ans = max(ans, len(stack))
        
        return ans",maximumDetonation.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maximumDetonation.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(30, 18)",N,function_definition,maximumDetonation,,211,383f642d-006f-4208-aa10-688dc2442da0
"def inRange(index1, index2):
            x1, y1, r1 = bombs[index1]
            x2, y2, r2 = bombs[index2]
            dis = ((x1-x2)**2 + (y1-y2)**2)**(1/2)
            return dis <= r1",maximumDetonation.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maximumDetonation.py,module/class_definition-Solution/function_definition-maximumDetonation/,maximumDetonation,N = len(bombs),graph = defaultdict(list),"(4, 8)","(8, 28)",N,function_definition,inRange,,67,dbee6af8-b78e-4b7f-938e-d4f3a4e48849
"def dfs(index):
            if(index in stack): return
            stack.add(index)
            for child in graph[index]: dfs(child)",maximumDetonation.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maximumDetonation.py,module/class_definition-Solution/function_definition-maximumDetonation/,maximumDetonation,stack = set(),ans = 0,"(18, 8)","(21, 49)",N,function_definition,dfs,,27,9c14261b-28f8-40fe-b7b4-6001f679621f
"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        
        @cache
        def helper(row_index, col_index):
            if(not (0<=row_index and row_index<len(grid) and 0<=col_index and col_index<len(grid[0]))): return 0
            
            ans = 0
            dire = [[-1, 1], [0, 1], [1,1]]
            for dx, dy in dire:
                nx, ny = row_index+dx, col_index+dy
                if(0<=nx and nx<len(grid) and 0<=ny and ny<len(grid[0]) and grid[row_index][col_index]<grid[nx][ny]):
                    sub = 1+helper(nx, ny)
                    ans = max(ans, sub)
            return ans
        
        ans = 0
        for index in range(len(grid)):
            ans = max(ans, helper(index, 0))
        
        return ans
              
",maxMoves_grid.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxMoves_grid.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 0)",N,module,module,,207,9fa0b938-1c69-4367-9791-da42f8ad1341
"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        
        @cache
        def helper(row_index, col_index):
            if(not (0<=row_index and row_index<len(grid) and 0<=col_index and col_index<len(grid[0]))): return 0
            
            ans = 0
            dire = [[-1, 1], [0, 1], [1,1]]
            for dx, dy in dire:
                nx, ny = row_index+dx, col_index+dy
                if(0<=nx and nx<len(grid) and 0<=ny and ny<len(grid[0]) and grid[row_index][col_index]<grid[nx][ny]):
                    sub = 1+helper(nx, ny)
                    ans = max(ans, sub)
            return ans
        
        ans = 0
        for index in range(len(grid)):
            ans = max(ans, helper(index, 0))
        
        return ans",maxMoves_grid.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxMoves_grid.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(20, 18)",N,class_definition,Solution,,205,72dd5b57-4dd1-4216-bbcb-2dedbec89cfa
"def maxMoves(self, grid: List[List[int]]) -> int:
        
        @cache
        def helper(row_index, col_index):
            if(not (0<=row_index and row_index<len(grid) and 0<=col_index and col_index<len(grid[0]))): return 0
            
            ans = 0
            dire = [[-1, 1], [0, 1], [1,1]]
            for dx, dy in dire:
                nx, ny = row_index+dx, col_index+dy
                if(0<=nx and nx<len(grid) and 0<=ny and ny<len(grid[0]) and grid[row_index][col_index]<grid[nx][ny]):
                    sub = 1+helper(nx, ny)
                    ans = max(ans, sub)
            return ans
        
        ans = 0
        for index in range(len(grid)):
            ans = max(ans, helper(index, 0))
        
        return ans",maxMoves_grid.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxMoves_grid.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(20, 18)",N,function_definition,maxMoves,,201,dbeeb737-4816-430f-95c7-ffb85d369948
"@cache
        def helper(row_index, col_index):
            if(not (0<=row_index and row_index<len(grid) and 0<=col_index and col_index<len(grid[0]))): return 0
            
            ans = 0
            dire = [[-1, 1], [0, 1], [1,1]]
            for dx, dy in dire:
                nx, ny = row_index+dx, col_index+dy
                if(0<=nx and nx<len(grid) and 0<=ny and ny<len(grid[0]) and grid[row_index][col_index]<grid[nx][ny]):
                    sub = 1+helper(nx, ny)
                    ans = max(ans, sub)
            return ans",maxMoves_grid.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxMoves_grid.py,module/class_definition-Solution/function_definition-maxMoves/,maxMoves,Previous sibling does not exist,ans = 0,"(3, 8)","(14, 22)",N,function_definition,"def helper(row_index, col_index):
            if(not (0<=row_index and row_index<len(grid) and 0<=col_index and col_index<len(grid[0]))): return 0
            
            ans = 0
            dire = [[-1, 1], [0, 1], [1,1]]
            for dx, dy in dire:
                nx, ny = row_index+dx, col_index+dy
                if(0<=nx and nx<len(grid) and 0<=ny and ny<len(grid[0]) and grid[row_index][col_index]<grid[nx][ny]):
                    sub = 1+helper(nx, ny)
                    ans = max(ans, sub)
            return ans",,154,0c0379dd-0811-4040-9e6b-861cc28461ec
"class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:

        graph = defaultdict(list)
        for [src, dest], prob in zip(edges, succProb):
            graph[src].append([dest, prob])
            graph[dest].append([src, prob])

        heap = []
        heapify(heap)
        heappush(heap, (1, start))
        visited = [False for _ in range(n)]

        while(heap):
            prob, node =  heappop(heap)
            if(visited[node]): continue
            visited[node] = True
            
            if(node == end): return 1/prob
            for child, p in graph[node]:
                if(visited[child]): continue 
                heappush(heap, (prob * 1/p, child))
        
        return 0
",maxProbability.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxProbability.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(24, 0)",N,module,module,,189,15e59c7f-cdda-40a7-9be9-7ecd9c717186
"class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:

        graph = defaultdict(list)
        for [src, dest], prob in zip(edges, succProb):
            graph[src].append([dest, prob])
            graph[dest].append([src, prob])

        heap = []
        heapify(heap)
        heappush(heap, (1, start))
        visited = [False for _ in range(n)]

        while(heap):
            prob, node =  heappop(heap)
            if(visited[node]): continue
            visited[node] = True
            
            if(node == end): return 1/prob
            for child, p in graph[node]:
                if(visited[child]): continue 
                heappush(heap, (prob * 1/p, child))
        
        return 0",maxProbability.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxProbability.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 16)",N,class_definition,Solution,,188,88b6bdad-0775-4f19-9d63-0bdb2014c96a
"def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:

        graph = defaultdict(list)
        for [src, dest], prob in zip(edges, succProb):
            graph[src].append([dest, prob])
            graph[dest].append([src, prob])

        heap = []
        heapify(heap)
        heappush(heap, (1, start))
        visited = [False for _ in range(n)]

        while(heap):
            prob, node =  heappop(heap)
            if(visited[node]): continue
            visited[node] = True
            
            if(node == end): return 1/prob
            for child, p in graph[node]:
                if(visited[child]): continue 
                heappush(heap, (prob * 1/p, child))
        
        return 0",maxProbability.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxProbability.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(23, 16)",N,function_definition,maxProbability,,184,ab6f147c-bd04-410b-81e9-2b1f3198b2e7
"from heapq import heappush,heappop,heapify

class Solution:
    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
        
        N = len(vals)
        graph = [[] for i in range(N)]
        
        for edge in edges:
            heappush(graph[edge[0]], -1 * vals[edge[1]])
            heappush(graph[edge[1]], -1 * vals[edge[0]])
        
        
        ans = -10 ** 10
        for i in range(N):
            temp = k
            curSum = vals[i]
            heap = graph[i]
            ans = max(ans, curSum)
            
            
            while(temp>0 and len(heap)>0):
                curSum += -1 * heappop(heap)
                ans = max(ans, curSum)
                temp-=1
        
        return ans
",maxStarSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxStarSum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(27, 0)",N,module,module,,186,211c94c5-368c-4b0c-bfaf-5e2f01cf4616
"from heapq import heappush,heappop,heapify",maxStarSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxStarSum.py,module/,module,Previous sibling does not exist,"class Solution:
    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
        
        N = len(vals)
        graph = [[] for i in range(N)]
        
        for edge in edges:
            heappush(graph[edge[0]], -1 * vals[edge[1]])
            heappush(graph[edge[1]], -1 * vals[edge[0]])
        
        
        ans = -10 ** 10
        for i in range(N):
            temp = k
            curSum = vals[i]
            heap = graph[i]
            ans = max(ans, curSum)
            
            
            while(temp>0 and len(heap)>0):
                curSum += -1 * heappop(heap)
                ans = max(ans, curSum)
                temp-=1
        
        return ans","(0, 0)","(0, 42)",N,import_from_statement,import_from_statement,,13,4a320837-949d-45a3-84a7-0510efb42e40
"class Solution:
    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
        
        N = len(vals)
        graph = [[] for i in range(N)]
        
        for edge in edges:
            heappush(graph[edge[0]], -1 * vals[edge[1]])
            heappush(graph[edge[1]], -1 * vals[edge[0]])
        
        
        ans = -10 ** 10
        for i in range(N):
            temp = k
            curSum = vals[i]
            heap = graph[i]
            ans = max(ans, curSum)
            
            
            while(temp>0 and len(heap)>0):
                curSum += -1 * heappop(heap)
                ans = max(ans, curSum)
                temp-=1
        
        return ans",maxStarSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxStarSum.py,module/,module,"from heapq import heappush,heappop,heapify",Next sibling does not exist,"(2, 0)","(26, 18)",N,class_definition,Solution,,171,366ccb64-65ac-4ef7-99c7-2edac8b81c70
"def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
        
        N = len(vals)
        graph = [[] for i in range(N)]
        
        for edge in edges:
            heappush(graph[edge[0]], -1 * vals[edge[1]])
            heappush(graph[edge[1]], -1 * vals[edge[0]])
        
        
        ans = -10 ** 10
        for i in range(N):
            temp = k
            curSum = vals[i]
            heap = graph[i]
            ans = max(ans, curSum)
            
            
            while(temp>0 and len(heap)>0):
                curSum += -1 * heappop(heap)
                ans = max(ans, curSum)
                temp-=1
        
        return ans",maxStarSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxStarSum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(3, 4)","(26, 18)",N,function_definition,maxStarSum,,167,1768fc10-f074-4c2e-902a-df544fe32af9
"class Solution:
    def minJumps(self, arr: List[int]) -> int:

        graph = collections.defaultdict(list)
        for index, val in enumerate(arr):
            graph[val].append(index)

        queue = [0]
        size = len(queue)
        depth = 0
        visited = [False for i in range(len(arr))]

        while(queue):
            cur = queue.pop(0)
            size -= 1

            if(cur == len(arr)-1): return depth

            if(cur+1<len(arr) and not visited[cur+1]): 
                queue.append(cur+1)
                visited[cur+1] = True

            if(cur-1>=0 and not visited[cur-1]): 
                queue.append(cur-1)
                visited[cur+1] = True

            for idx in graph[arr[cur]]: 
                if(not visited[idx]):
                    queue.append(idx)
                    visited[idx] = True
            
            graph[arr[cur]] = []



            if(size == 0):
                size = len(queue)
                depth += 1
",minJumps_IV.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\minJumps_IV.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(38, 0)",N,module,module,,221,11cb56b4-8908-4f64-998e-a932fc10836a
"class Solution:
    def minJumps(self, arr: List[int]) -> int:

        graph = collections.defaultdict(list)
        for index, val in enumerate(arr):
            graph[val].append(index)

        queue = [0]
        size = len(queue)
        depth = 0
        visited = [False for i in range(len(arr))]

        while(queue):
            cur = queue.pop(0)
            size -= 1

            if(cur == len(arr)-1): return depth

            if(cur+1<len(arr) and not visited[cur+1]): 
                queue.append(cur+1)
                visited[cur+1] = True

            if(cur-1>=0 and not visited[cur-1]): 
                queue.append(cur-1)
                visited[cur+1] = True

            for idx in graph[arr[cur]]: 
                if(not visited[idx]):
                    queue.append(idx)
                    visited[idx] = True
            
            graph[arr[cur]] = []



            if(size == 0):
                size = len(queue)
                depth += 1",minJumps_IV.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\minJumps_IV.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(37, 26)",N,class_definition,Solution,,220,944357ef-1bec-4f32-b93c-e81ae84f94f9
"def minJumps(self, arr: List[int]) -> int:

        graph = collections.defaultdict(list)
        for index, val in enumerate(arr):
            graph[val].append(index)

        queue = [0]
        size = len(queue)
        depth = 0
        visited = [False for i in range(len(arr))]

        while(queue):
            cur = queue.pop(0)
            size -= 1

            if(cur == len(arr)-1): return depth

            if(cur+1<len(arr) and not visited[cur+1]): 
                queue.append(cur+1)
                visited[cur+1] = True

            if(cur-1>=0 and not visited[cur-1]): 
                queue.append(cur-1)
                visited[cur+1] = True

            for idx in graph[arr[cur]]: 
                if(not visited[idx]):
                    queue.append(idx)
                    visited[idx] = True
            
            graph[arr[cur]] = []



            if(size == 0):
                size = len(queue)
                depth += 1",minJumps_IV.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\minJumps_IV.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(37, 26)",N,function_definition,minJumps,,216,e0d68627-833e-4b22-bb23-697b97e8f363
"class Point{
    int x;
    int y;
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}



class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        
        boolean[][] visited = new boolean[maze.length][maze[0].length];
        Queue<Point> queue = new LinkedList<>();
       
        visited[entrance[0]][entrance[1]] = true;
        queue.add(new Point(entrance[0],entrance[1]));
        
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            if(ans==0){}
            else if(cur.x==0 || cur.y ==0 || cur.x == maze.length-1 || cur.y== maze[0].length-1) return ans;
            
            for(int index = 0;index<4;index++){
                int newx = cur.x + dir[index][0];
                int newy = cur.y + dir[index][1];
                
                if(newx>=0 && newy>=0 && newx<maze.length && newy<maze[0].length && !visited[newx][newy] && maze[newx][newy]=='.'){
                        visited[newx][newy] = true;
                        queue.add(new Point(newx, newy));
                }
                
            }
            
            
            if(l==0){
                l = queue.size();
                ans++;
            }
        }
        
        
        return -1;
    }
}
",NearestExitFromEntranceInMaze.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NearestExitFromEntranceInMaze.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(56, 0)",N,program,program,,354,e6d07923-8760-4d8f-b744-e4033fc919e2
"class Point{
    int x;
    int y;
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}",NearestExitFromEntranceInMaze.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NearestExitFromEntranceInMaze.java,program/,program,Previous sibling does not exist,"class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        
        boolean[][] visited = new boolean[maze.length][maze[0].length];
        Queue<Point> queue = new LinkedList<>();
       
        visited[entrance[0]][entrance[1]] = true;
        queue.add(new Point(entrance[0],entrance[1]));
        
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            if(ans==0){}
            else if(cur.x==0 || cur.y ==0 || cur.x == maze.length-1 || cur.y== maze[0].length-1) return ans;
            
            for(int index = 0;index<4;index++){
                int newx = cur.x + dir[index][0];
                int newy = cur.y + dir[index][1];
                
                if(newx>=0 && newy>=0 && newx<maze.length && newy<maze[0].length && !visited[newx][newy] && maze[newx][newy]=='.'){
                        visited[newx][newy] = true;
                        queue.add(new Point(newx, newy));
                }
                
            }
            
            
            if(l==0){
                l = queue.size();
                ans++;
            }
        }
        
        
        return -1;
    }
}","(0, 0)","(7, 1)",N,class_declaration,Point,,34,372d9a30-6e74-49bb-acaa-38946a79f43f
"Point(int x, int y){
        this.x = x;
        this.y = y;
    }",NearestExitFromEntranceInMaze.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NearestExitFromEntranceInMaze.java,program/class_declaration-Point/,Point,int y;,Next sibling does not exist,"(3, 4)","(6, 5)",N,constructor_declaration,Point,,21,4cb07576-5baf-45e0-a2e2-0062dae15f46
"class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        
        boolean[][] visited = new boolean[maze.length][maze[0].length];
        Queue<Point> queue = new LinkedList<>();
       
        visited[entrance[0]][entrance[1]] = true;
        queue.add(new Point(entrance[0],entrance[1]));
        
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            if(ans==0){}
            else if(cur.x==0 || cur.y ==0 || cur.x == maze.length-1 || cur.y== maze[0].length-1) return ans;
            
            for(int index = 0;index<4;index++){
                int newx = cur.x + dir[index][0];
                int newy = cur.y + dir[index][1];
                
                if(newx>=0 && newy>=0 && newx<maze.length && newy<maze[0].length && !visited[newx][newy] && maze[newx][newy]=='.'){
                        visited[newx][newy] = true;
                        queue.add(new Point(newx, newy));
                }
                
            }
            
            
            if(l==0){
                l = queue.size();
                ans++;
            }
        }
        
        
        return -1;
    }
}",NearestExitFromEntranceInMaze.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NearestExitFromEntranceInMaze.java,program/,program,"class Point{
    int x;
    int y;
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}",Next sibling does not exist,"(11, 0)","(55, 1)",N,class_declaration,Solution,,320,5800a1dd-05ec-4af8-a0a7-91be0dbddfe3
"public int nearestExit(char[][] maze, int[] entrance) {
        
        boolean[][] visited = new boolean[maze.length][maze[0].length];
        Queue<Point> queue = new LinkedList<>();
       
        visited[entrance[0]][entrance[1]] = true;
        queue.add(new Point(entrance[0],entrance[1]));
        
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            if(ans==0){}
            else if(cur.x==0 || cur.y ==0 || cur.x == maze.length-1 || cur.y== maze[0].length-1) return ans;
            
            for(int index = 0;index<4;index++){
                int newx = cur.x + dir[index][0];
                int newy = cur.y + dir[index][1];
                
                if(newx>=0 && newy>=0 && newx<maze.length && newy<maze[0].length && !visited[newx][newy] && maze[newx][newy]=='.'){
                        visited[newx][newy] = true;
                        queue.add(new Point(newx, newy));
                }
                
            }
            
            
            if(l==0){
                l = queue.size();
                ans++;
            }
        }
        
        
        return -1;
    }",NearestExitFromEntranceInMaze.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NearestExitFromEntranceInMaze.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(12, 4)","(54, 5)",N,method_declaration,nearestExit,,315,c7fc4edf-88e2-453c-a2a1-eecd9dc0b1e0
"class Solution {
    
    public int closedIsland(int[][] grid) {
        
        int ans = 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==0 && !visited[i][j] && helper(grid,i,j,visited)==false) 
                {
                    // System.out.println(i + "" "" + j);
                    ans++;
                }
            }
        }
        
        return ans;
    }
    
    public boolean helper(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length){
            if(grid[sr][sc]==1 || visited[sr][sc]) return false;
            visited[sr][sc] = true;
            boolean ans = helper(grid,sr-1,sc,visited);
            ans = helper(grid,sr,sc+1,visited) || ans;
            ans = helper(grid,sr+1,sc,visited) || ans;
            ans = helper(grid,sr,sc-1,visited) || ans;
            return ans;
        } else {
            return true;
        }
    }
    
    
}
",Number of Closed Islands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\Number of Closed Islands.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(36, 0)",N,program,program,,279,9879564b-75a8-40bc-84f7-4793b0071ed5
"class Solution {
    
    public int closedIsland(int[][] grid) {
        
        int ans = 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==0 && !visited[i][j] && helper(grid,i,j,visited)==false) 
                {
                    // System.out.println(i + "" "" + j);
                    ans++;
                }
            }
        }
        
        return ans;
    }
    
    public boolean helper(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length){
            if(grid[sr][sc]==1 || visited[sr][sc]) return false;
            visited[sr][sc] = true;
            boolean ans = helper(grid,sr-1,sc,visited);
            ans = helper(grid,sr,sc+1,visited) || ans;
            ans = helper(grid,sr+1,sc,visited) || ans;
            ans = helper(grid,sr,sc-1,visited) || ans;
            return ans;
        } else {
            return true;
        }
    }
    
    
}",Number of Closed Islands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\Number of Closed Islands.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(35, 1)",N,class_declaration,Solution,,279,9643904a-f66f-41be-86d3-aef7ce123971
"public int closedIsland(int[][] grid) {
        
        int ans = 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==0 && !visited[i][j] && helper(grid,i,j,visited)==false) 
                {
                    // System.out.println(i + "" "" + j);
                    ans++;
                }
            }
        }
        
        return ans;
    }",Number of Closed Islands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\Number of Closed Islands.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public boolean helper(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length){
            if(grid[sr][sc]==1 || visited[sr][sc]) return false;
            visited[sr][sc] = true;
            boolean ans = helper(grid,sr-1,sc,visited);
            ans = helper(grid,sr,sc+1,visited) || ans;
            ans = helper(grid,sr+1,sc,visited) || ans;
            ans = helper(grid,sr,sc-1,visited) || ans;
            return ans;
        } else {
            return true;
        }
    }","(2, 4)","(18, 5)",N,method_declaration,closedIsland,,119,d1f14efd-b4fd-4cee-ada3-a097fd157ea1
"public boolean helper(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length){
            if(grid[sr][sc]==1 || visited[sr][sc]) return false;
            visited[sr][sc] = true;
            boolean ans = helper(grid,sr-1,sc,visited);
            ans = helper(grid,sr,sc+1,visited) || ans;
            ans = helper(grid,sr+1,sc,visited) || ans;
            ans = helper(grid,sr,sc-1,visited) || ans;
            return ans;
        } else {
            return true;
        }
    }",Number of Closed Islands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\Number of Closed Islands.java,program/class_declaration-Solution/,Solution,"public int closedIsland(int[][] grid) {
        
        int ans = 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==0 && !visited[i][j] && helper(grid,i,j,visited)==false) 
                {
                    // System.out.println(i + "" "" + j);
                    ans++;
                }
            }
        }
        
        return ans;
    }",Next sibling does not exist,"(20, 4)","(32, 5)",N,method_declaration,helper,,151,41a09a84-44ff-4517-817a-e57036322991
"class Solution {
    public int findCircleNum(int[][] isConnected) {
        boolean[] visited = new boolean[isConnected.length];
        int ans = 0;
        for(int i=0; i<isConnected.length;i++){
            if(!visited[i]){
                ans++;
                dfs(isConnected, i, visited);
            }
        }
        
        return ans;
    }
    
    
    
    public void dfs(int[][] isConnected, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int i=0;i<isConnected.length;i++){
            if(isConnected[cur][i]==1){
                dfs(isConnected, i, visited);
               }
        }
    }
}
",NumberOfProvinces.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumberOfProvinces.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(26, 0)",N,program,program,,146,91696247-aacf-405a-a784-81527f1783dc
"class Solution {
    public int findCircleNum(int[][] isConnected) {
        boolean[] visited = new boolean[isConnected.length];
        int ans = 0;
        for(int i=0; i<isConnected.length;i++){
            if(!visited[i]){
                ans++;
                dfs(isConnected, i, visited);
            }
        }
        
        return ans;
    }
    
    
    
    public void dfs(int[][] isConnected, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int i=0;i<isConnected.length;i++){
            if(isConnected[cur][i]==1){
                dfs(isConnected, i, visited);
               }
        }
    }
}",NumberOfProvinces.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumberOfProvinces.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 1)",N,class_declaration,Solution,,146,61a5a6e0-f7a9-4cc7-81a7-20c7f316e4a7
"public int findCircleNum(int[][] isConnected) {
        boolean[] visited = new boolean[isConnected.length];
        int ans = 0;
        for(int i=0; i<isConnected.length;i++){
            if(!visited[i]){
                ans++;
                dfs(isConnected, i, visited);
            }
        }
        
        return ans;
    }",NumberOfProvinces.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumberOfProvinces.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public void dfs(int[][] isConnected, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int i=0;i<isConnected.length;i++){
            if(isConnected[cur][i]==1){
                dfs(isConnected, i, visited);
               }
        }
    }","(1, 4)","(12, 5)",N,method_declaration,findCircleNum,,72,4cd07a55-326b-4b89-9202-79d72261d9c7
"public void dfs(int[][] isConnected, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int i=0;i<isConnected.length;i++){
            if(isConnected[cur][i]==1){
                dfs(isConnected, i, visited);
               }
        }
    }",NumberOfProvinces.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumberOfProvinces.java,program/class_declaration-Solution/,Solution,"public int findCircleNum(int[][] isConnected) {
        boolean[] visited = new boolean[isConnected.length];
        int ans = 0;
        for(int i=0; i<isConnected.length;i++){
            if(!visited[i]){
                ans++;
                dfs(isConnected, i, visited);
            }
        }
        
        return ans;
    }",Next sibling does not exist,"(16, 4)","(24, 5)",N,method_declaration,dfs,,67,91a61070-4491-4f49-aa4d-d9d9cc7b3329
"class Solution {
    
    boolean isInBoundary = false;
    
    public int numEnclaves(int[][] grid) {
        int ans = 0;
        
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    int cur = dfs(grid, i, j, visited);
                    
                    // System.out.println(i +"" "" + j + "" ""+ cur + isInBoundary);
                    
                    if(!isInBoundary) ans+=cur;
                    isInBoundary=false;
                }
            }
        }
        return ans;
    }
        
    public int dfs(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc >=0 && sr<grid.length && sc<grid[0].length && grid[sr][sc] == 1 && !visited[sr][sc]){
            if(sr==0 || sc ==0 || sr == grid.length-1 || sc==grid[0].length-1) isInBoundary = true;
            visited[sr][sc] = true;
            return 1 + dfs(grid,sr-1,sc,visited) + dfs(grid,sr,sc+1,visited) + dfs(grid,sr+1,sc,visited) + dfs(grid,sr,sc-1,visited);
        } else {
            return 0;
        }
    }
}
",NumEnclaves.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumEnclaves.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(34, 0)",N,program,program,,314,045b8fae-424c-4d87-ba08-9aac0acabc49
"class Solution {
    
    boolean isInBoundary = false;
    
    public int numEnclaves(int[][] grid) {
        int ans = 0;
        
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    int cur = dfs(grid, i, j, visited);
                    
                    // System.out.println(i +"" "" + j + "" ""+ cur + isInBoundary);
                    
                    if(!isInBoundary) ans+=cur;
                    isInBoundary=false;
                }
            }
        }
        return ans;
    }
        
    public int dfs(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc >=0 && sr<grid.length && sc<grid[0].length && grid[sr][sc] == 1 && !visited[sr][sc]){
            if(sr==0 || sc ==0 || sr == grid.length-1 || sc==grid[0].length-1) isInBoundary = true;
            visited[sr][sc] = true;
            return 1 + dfs(grid,sr-1,sc,visited) + dfs(grid,sr,sc+1,visited) + dfs(grid,sr+1,sc,visited) + dfs(grid,sr,sc-1,visited);
        } else {
            return 0;
        }
    }
}",NumEnclaves.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumEnclaves.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(33, 1)",N,class_declaration,Solution,,314,5c96cc39-bc78-4dd1-98d4-0231d15fbd33
"public int numEnclaves(int[][] grid) {
        int ans = 0;
        
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    int cur = dfs(grid, i, j, visited);
                    
                    // System.out.println(i +"" "" + j + "" ""+ cur + isInBoundary);
                    
                    if(!isInBoundary) ans+=cur;
                    isInBoundary=false;
                }
            }
        }
        return ans;
    }",NumEnclaves.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumEnclaves.java,program/class_declaration-Solution/,Solution,boolean isInBoundary = false;,"public int dfs(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc >=0 && sr<grid.length && sc<grid[0].length && grid[sr][sc] == 1 && !visited[sr][sc]){
            if(sr==0 || sc ==0 || sr == grid.length-1 || sc==grid[0].length-1) isInBoundary = true;
            visited[sr][sc] = true;
            return 1 + dfs(grid,sr-1,sc,visited) + dfs(grid,sr,sc+1,visited) + dfs(grid,sr+1,sc,visited) + dfs(grid,sr,sc-1,visited);
        } else {
            return 0;
        }
    }","(4, 4)","(22, 5)",N,method_declaration,numEnclaves,,134,d619f080-f439-490d-94b4-525d026846ec
"public int dfs(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc >=0 && sr<grid.length && sc<grid[0].length && grid[sr][sc] == 1 && !visited[sr][sc]){
            if(sr==0 || sc ==0 || sr == grid.length-1 || sc==grid[0].length-1) isInBoundary = true;
            visited[sr][sc] = true;
            return 1 + dfs(grid,sr-1,sc,visited) + dfs(grid,sr,sc+1,visited) + dfs(grid,sr+1,sc,visited) + dfs(grid,sr,sc-1,visited);
        } else {
            return 0;
        }
    }",NumEnclaves.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumEnclaves.java,program/class_declaration-Solution/,Solution,"public int numEnclaves(int[][] grid) {
        int ans = 0;
        
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    int cur = dfs(grid, i, j, visited);
                    
                    // System.out.println(i +"" "" + j + "" ""+ cur + isInBoundary);
                    
                    if(!isInBoundary) ans+=cur;
                    isInBoundary=false;
                }
            }
        }
        return ans;
    }",Next sibling does not exist,"(24, 4)","(32, 5)",N,method_declaration,dfs,,164,cfd88dd1-ff1f-4d58-895d-d56d116ab5e7
"class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:

        ans = 0
        N = len(grid)
        M = len(grid[0])

        def dfs(row, col):
            if(row<0 or col<0 or row>=N or col>=M): return True, 0 
            if(grid[row][col] == -1 or grid[row][col] == 0): return False, 0

            grid[row][col] = -1

            onEdge = False
            ans = 1

            for dx, dy in [[-1, 0], [0, 1], [1, 0], [0, -1]]:
                nx, ny = row + dx, col + dy
                a, b = dfs(nx, ny)
                onEdge = onEdge or a
                ans += b
            
            return onEdge, ans

        
        ans = 0
        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == 1):
                    onEdge, count = dfs(row_index, col_index)
                    if(not onEdge): ans += count

        return ans 
",numEnclaves.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\numEnclaves.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(33, 0)",N,module,module,,257,c80b44bb-9604-44f7-83a6-f36f9405864f
"class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:

        ans = 0
        N = len(grid)
        M = len(grid[0])

        def dfs(row, col):
            if(row<0 or col<0 or row>=N or col>=M): return True, 0 
            if(grid[row][col] == -1 or grid[row][col] == 0): return False, 0

            grid[row][col] = -1

            onEdge = False
            ans = 1

            for dx, dy in [[-1, 0], [0, 1], [1, 0], [0, -1]]:
                nx, ny = row + dx, col + dy
                a, b = dfs(nx, ny)
                onEdge = onEdge or a
                ans += b
            
            return onEdge, ans

        
        ans = 0
        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == 1):
                    onEdge, count = dfs(row_index, col_index)
                    if(not onEdge): ans += count

        return ans",numEnclaves.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\numEnclaves.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(32, 18)",N,class_definition,Solution,,256,0943217b-0652-4c30-b7a9-073849a8dbbb
"def numEnclaves(self, grid: List[List[int]]) -> int:

        ans = 0
        N = len(grid)
        M = len(grid[0])

        def dfs(row, col):
            if(row<0 or col<0 or row>=N or col>=M): return True, 0 
            if(grid[row][col] == -1 or grid[row][col] == 0): return False, 0

            grid[row][col] = -1

            onEdge = False
            ans = 1

            for dx, dy in [[-1, 0], [0, 1], [1, 0], [0, -1]]:
                nx, ny = row + dx, col + dy
                a, b = dfs(nx, ny)
                onEdge = onEdge or a
                ans += b
            
            return onEdge, ans

        
        ans = 0
        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == 1):
                    onEdge, count = dfs(row_index, col_index)
                    if(not onEdge): ans += count

        return ans",numEnclaves.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\numEnclaves.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(32, 18)",N,function_definition,numEnclaves,,252,a3dd4ace-df32-44d2-a761-449d757a50c2
"def dfs(row, col):
            if(row<0 or col<0 or row>=N or col>=M): return True, 0 
            if(grid[row][col] == -1 or grid[row][col] == 0): return False, 0

            grid[row][col] = -1

            onEdge = False
            ans = 1

            for dx, dy in [[-1, 0], [0, 1], [1, 0], [0, -1]]:
                nx, ny = row + dx, col + dy
                a, b = dfs(nx, ny)
                onEdge = onEdge or a
                ans += b
            
            return onEdge, ans",numEnclaves.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\numEnclaves.py,module/class_definition-Solution/function_definition-numEnclaves/,numEnclaves,M = len(grid[0]),ans = 0,"(7, 8)","(22, 30)",N,function_definition,dfs,,152,8d04a3ca-0b3a-4d49-b0a1-5ead36877870
"class Solution {
    public int orangesRotting(int[][] grid) {
        
        Queue<CoOrdinate> queue = new LinkedList<>();
        int count = 0;
        
        for(int i=0;i<grid.length; i++){
            for(int j=0; j<grid[0].length; j++){
                if(grid[i][j] == 2) queue.add(new CoOrdinate(i,j));
                if(grid[i][j] == 1) count++;
            }
        }
        
        
        int size = queue.size();
        int level = 0;
        int[][] dir = new int[][]{
            {-1,0},
            {0,1},
            {1,0},
            {0,-1}
        };
        
        
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            // System.out.println(level);
            
            CoOrdinate cur = queue.poll();
            size--;
            
            for(int[] x: dir){
                int dx = cur.x + x[0];
                int dy = cur.y + x[1];
                
                if(dx<0 || dy<0 || dx>=grid.length || dy>=grid[0].length || grid[dx][dy]!=1 ) continue;
                
                queue.add(new CoOrdinate(dx, dy));
                grid[dx][dy] = 2;
                count--;
            }
            
            
            if(size==0 && queue.size()>0){
                size = queue.size();
                level++;
            }
        }
        
        return count == 0 ? level : -1;
        
    }
}


class CoOrdinate{
    int x;
    int y;
    
    CoOrdinate(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    
    public String toString(){
        return this.x + "" "" + this.y; 
    }
    
}
",OrangesRotting.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\OrangesRotting.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(71, 0)",N,program,program,,382,1eb51281-7fce-4ca5-8225-17bc3c4f1583
"class Solution {
    public int orangesRotting(int[][] grid) {
        
        Queue<CoOrdinate> queue = new LinkedList<>();
        int count = 0;
        
        for(int i=0;i<grid.length; i++){
            for(int j=0; j<grid[0].length; j++){
                if(grid[i][j] == 2) queue.add(new CoOrdinate(i,j));
                if(grid[i][j] == 1) count++;
            }
        }
        
        
        int size = queue.size();
        int level = 0;
        int[][] dir = new int[][]{
            {-1,0},
            {0,1},
            {1,0},
            {0,-1}
        };
        
        
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            // System.out.println(level);
            
            CoOrdinate cur = queue.poll();
            size--;
            
            for(int[] x: dir){
                int dx = cur.x + x[0];
                int dy = cur.y + x[1];
                
                if(dx<0 || dy<0 || dx>=grid.length || dy>=grid[0].length || grid[dx][dy]!=1 ) continue;
                
                queue.add(new CoOrdinate(dx, dy));
                grid[dx][dy] = 2;
                count--;
            }
            
            
            if(size==0 && queue.size()>0){
                size = queue.size();
                level++;
            }
        }
        
        return count == 0 ? level : -1;
        
    }
}",OrangesRotting.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\OrangesRotting.java,program/,program,Previous sibling does not exist,"class CoOrdinate{
    int x;
    int y;
    
    CoOrdinate(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    
    public String toString(){
        return this.x + "" "" + this.y; 
    }
    
}","(0, 0)","(53, 1)",N,class_declaration,Solution,,322,1d936473-538f-4f20-add9-55f1362d6a73
"public int orangesRotting(int[][] grid) {
        
        Queue<CoOrdinate> queue = new LinkedList<>();
        int count = 0;
        
        for(int i=0;i<grid.length; i++){
            for(int j=0; j<grid[0].length; j++){
                if(grid[i][j] == 2) queue.add(new CoOrdinate(i,j));
                if(grid[i][j] == 1) count++;
            }
        }
        
        
        int size = queue.size();
        int level = 0;
        int[][] dir = new int[][]{
            {-1,0},
            {0,1},
            {1,0},
            {0,-1}
        };
        
        
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            // System.out.println(level);
            
            CoOrdinate cur = queue.poll();
            size--;
            
            for(int[] x: dir){
                int dx = cur.x + x[0];
                int dy = cur.y + x[1];
                
                if(dx<0 || dy<0 || dx>=grid.length || dy>=grid[0].length || grid[dx][dy]!=1 ) continue;
                
                queue.add(new CoOrdinate(dx, dy));
                grid[dx][dy] = 2;
                count--;
            }
            
            
            if(size==0 && queue.size()>0){
                size = queue.size();
                level++;
            }
        }
        
        return count == 0 ? level : -1;
        
    }",OrangesRotting.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\OrangesRotting.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(52, 5)",N,method_declaration,orangesRotting,,317,eb14fc7d-b10a-47b1-a6f5-e10533fbd1e8
"class CoOrdinate{
    int x;
    int y;
    
    CoOrdinate(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    
    public String toString(){
        return this.x + "" "" + this.y; 
    }
    
}",OrangesRotting.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\OrangesRotting.java,program/,program,"class Solution {
    public int orangesRotting(int[][] grid) {
        
        Queue<CoOrdinate> queue = new LinkedList<>();
        int count = 0;
        
        for(int i=0;i<grid.length; i++){
            for(int j=0; j<grid[0].length; j++){
                if(grid[i][j] == 2) queue.add(new CoOrdinate(i,j));
                if(grid[i][j] == 1) count++;
            }
        }
        
        
        int size = queue.size();
        int level = 0;
        int[][] dir = new int[][]{
            {-1,0},
            {0,1},
            {1,0},
            {0,-1}
        };
        
        
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            // System.out.println(level);
            
            CoOrdinate cur = queue.poll();
            size--;
            
            for(int[] x: dir){
                int dx = cur.x + x[0];
                int dy = cur.y + x[1];
                
                if(dx<0 || dy<0 || dx>=grid.length || dy>=grid[0].length || grid[dx][dy]!=1 ) continue;
                
                queue.add(new CoOrdinate(dx, dy));
                grid[dx][dy] = 2;
                count--;
            }
            
            
            if(size==0 && queue.size()>0){
                size = queue.size();
                level++;
            }
        }
        
        return count == 0 ? level : -1;
        
    }
}",Next sibling does not exist,"(56, 0)","(70, 1)",N,class_declaration,CoOrdinate,,60,4b54b377-6aff-41bb-8f58-290d63d407cd
"CoOrdinate(int x, int y){
        this.x = x;
        this.y = y;
    }",OrangesRotting.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\OrangesRotting.java,program/class_declaration-CoOrdinate/,CoOrdinate,int y;,"public String toString(){
        return this.x + "" "" + this.y; 
    }","(60, 4)","(63, 5)",N,constructor_declaration,CoOrdinate,,23,aa06ac37-4bfb-42d6-8212-1450b2e699a9
"public String toString(){
        return this.x + "" "" + this.y; 
    }",OrangesRotting.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\OrangesRotting.java,program/class_declaration-CoOrdinate/,CoOrdinate,"CoOrdinate(int x, int y){
        this.x = x;
        this.y = y;
    }",Next sibling does not exist,"(66, 4)","(68, 5)",N,method_declaration,toString,,18,30531021-aa43-4b28-9ee2-360b9792594b
"class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
        
        ArrayList<Edge>[] graph = new ArrayList[n];
        int[] ans = new int[n];
        Queue<Node> queue = new LinkedList<>();
        
        for(int i=0;i<n;i++) {
            ans[i] = -1;
            graph[i] = new ArrayList<>();
        }

        
        
        for(int i=0;i<redEdges.length;i++){
            graph[redEdges[i][0]].add(new Edge(redEdges[i][0], redEdges[i][1], 0));
        }
        
        for(int i=0;i<blueEdges.length;i++){
            graph[blueEdges[i][0]].add(new Edge(blueEdges[i][0], blueEdges[i][1], 1));
        }
        
        // System.out.println(Arrays.toString(graph));
        
        
        queue.add(new Node(0,-1));
        int l = queue.size();
        int level = 0;
        
        while(!queue.isEmpty()){
            
            Node cur = queue.poll();
            l--;
            if(ans[cur.vtx]==-1) ans[cur.vtx] = level;
            
            for(Edge edge : graph[cur.vtx]){
                if(edge.visited==true) continue;
                
                if(cur.pathColor == 1 && edge.color==0){ queue.add(new Node(edge.end, 0)); edge.visited = true;}
                if(cur.pathColor == 0 && edge.color==1){ queue.add(new Node(edge.end, 1)); edge.visited = true;}
                if(cur.pathColor==-1){ queue.add(new Node(edge.end, edge.color)); edge.visited = true;}
            }
            
            if(l==0){
                // System.out.println(Arrays.toString(graph));
                // System.out.println(queue);
                l = queue.size();
                level++;
            }
        }
        
        return ans;
    }
}

class Node{
    int vtx;
    int pathColor;
    
    Node(int vtx, int pathColor){
        this.vtx = vtx;
        this.pathColor = pathColor;
    }
    
    public String toString(){
        return this.vtx + "" "" + this.pathColor;
    }
    
}

class Edge{
    
    int start;
    int end;
    int color;
    boolean visited;
    
    Edge(int start, int end, int color){
        this.start = start;
        this.end = end;
        this.color = color;
        this.visited = false;
    }
    
    
    public String toString(){
        return this.start + "" "" + this.end + "" "" +this.color + "" ""+ this.visited;
    }
}
",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(89, 0)",N,program,program,,548,19e79bd6-47b6-47aa-81a9-a0b2abfa3e7e
"class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
        
        ArrayList<Edge>[] graph = new ArrayList[n];
        int[] ans = new int[n];
        Queue<Node> queue = new LinkedList<>();
        
        for(int i=0;i<n;i++) {
            ans[i] = -1;
            graph[i] = new ArrayList<>();
        }

        
        
        for(int i=0;i<redEdges.length;i++){
            graph[redEdges[i][0]].add(new Edge(redEdges[i][0], redEdges[i][1], 0));
        }
        
        for(int i=0;i<blueEdges.length;i++){
            graph[blueEdges[i][0]].add(new Edge(blueEdges[i][0], blueEdges[i][1], 1));
        }
        
        // System.out.println(Arrays.toString(graph));
        
        
        queue.add(new Node(0,-1));
        int l = queue.size();
        int level = 0;
        
        while(!queue.isEmpty()){
            
            Node cur = queue.poll();
            l--;
            if(ans[cur.vtx]==-1) ans[cur.vtx] = level;
            
            for(Edge edge : graph[cur.vtx]){
                if(edge.visited==true) continue;
                
                if(cur.pathColor == 1 && edge.color==0){ queue.add(new Node(edge.end, 0)); edge.visited = true;}
                if(cur.pathColor == 0 && edge.color==1){ queue.add(new Node(edge.end, 1)); edge.visited = true;}
                if(cur.pathColor==-1){ queue.add(new Node(edge.end, edge.color)); edge.visited = true;}
            }
            
            if(l==0){
                // System.out.println(Arrays.toString(graph));
                // System.out.println(queue);
                l = queue.size();
                level++;
            }
        }
        
        return ans;
    }
}",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/,program,Previous sibling does not exist,"class Node{
    int vtx;
    int pathColor;
    
    Node(int vtx, int pathColor){
        this.vtx = vtx;
        this.pathColor = pathColor;
    }
    
    public String toString(){
        return this.vtx + "" "" + this.pathColor;
    }
    
}","(0, 0)","(53, 1)",N,class_declaration,Solution,,395,ccc26f0b-04fa-47e8-888a-5e00764c4e49
"public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
        
        ArrayList<Edge>[] graph = new ArrayList[n];
        int[] ans = new int[n];
        Queue<Node> queue = new LinkedList<>();
        
        for(int i=0;i<n;i++) {
            ans[i] = -1;
            graph[i] = new ArrayList<>();
        }

        
        
        for(int i=0;i<redEdges.length;i++){
            graph[redEdges[i][0]].add(new Edge(redEdges[i][0], redEdges[i][1], 0));
        }
        
        for(int i=0;i<blueEdges.length;i++){
            graph[blueEdges[i][0]].add(new Edge(blueEdges[i][0], blueEdges[i][1], 1));
        }
        
        // System.out.println(Arrays.toString(graph));
        
        
        queue.add(new Node(0,-1));
        int l = queue.size();
        int level = 0;
        
        while(!queue.isEmpty()){
            
            Node cur = queue.poll();
            l--;
            if(ans[cur.vtx]==-1) ans[cur.vtx] = level;
            
            for(Edge edge : graph[cur.vtx]){
                if(edge.visited==true) continue;
                
                if(cur.pathColor == 1 && edge.color==0){ queue.add(new Node(edge.end, 0)); edge.visited = true;}
                if(cur.pathColor == 0 && edge.color==1){ queue.add(new Node(edge.end, 1)); edge.visited = true;}
                if(cur.pathColor==-1){ queue.add(new Node(edge.end, edge.color)); edge.visited = true;}
            }
            
            if(l==0){
                // System.out.println(Arrays.toString(graph));
                // System.out.println(queue);
                l = queue.size();
                level++;
            }
        }
        
        return ans;
    }",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(52, 5)",N,method_declaration,shortestAlternatingPaths,,390,94f9af5f-ea45-42b3-9728-83ca29e4ea56
"class Node{
    int vtx;
    int pathColor;
    
    Node(int vtx, int pathColor){
        this.vtx = vtx;
        this.pathColor = pathColor;
    }
    
    public String toString(){
        return this.vtx + "" "" + this.pathColor;
    }
    
}",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/,program,"class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
        
        ArrayList<Edge>[] graph = new ArrayList[n];
        int[] ans = new int[n];
        Queue<Node> queue = new LinkedList<>();
        
        for(int i=0;i<n;i++) {
            ans[i] = -1;
            graph[i] = new ArrayList<>();
        }

        
        
        for(int i=0;i<redEdges.length;i++){
            graph[redEdges[i][0]].add(new Edge(redEdges[i][0], redEdges[i][1], 0));
        }
        
        for(int i=0;i<blueEdges.length;i++){
            graph[blueEdges[i][0]].add(new Edge(blueEdges[i][0], blueEdges[i][1], 1));
        }
        
        // System.out.println(Arrays.toString(graph));
        
        
        queue.add(new Node(0,-1));
        int l = queue.size();
        int level = 0;
        
        while(!queue.isEmpty()){
            
            Node cur = queue.poll();
            l--;
            if(ans[cur.vtx]==-1) ans[cur.vtx] = level;
            
            for(Edge edge : graph[cur.vtx]){
                if(edge.visited==true) continue;
                
                if(cur.pathColor == 1 && edge.color==0){ queue.add(new Node(edge.end, 0)); edge.visited = true;}
                if(cur.pathColor == 0 && edge.color==1){ queue.add(new Node(edge.end, 1)); edge.visited = true;}
                if(cur.pathColor==-1){ queue.add(new Node(edge.end, edge.color)); edge.visited = true;}
            }
            
            if(l==0){
                // System.out.println(Arrays.toString(graph));
                // System.out.println(queue);
                l = queue.size();
                level++;
            }
        }
        
        return ans;
    }
}","class Edge{
    
    int start;
    int end;
    int color;
    boolean visited;
    
    Edge(int start, int end, int color){
        this.start = start;
        this.end = end;
        this.color = color;
        this.visited = false;
    }
    
    
    public String toString(){
        return this.start + "" "" + this.end + "" "" +this.color + "" ""+ this.visited;
    }
}","(55, 0)","(68, 1)",N,class_declaration,Node,,62,df761422-2b6b-4781-a386-66a83aa71683
"Node(int vtx, int pathColor){
        this.vtx = vtx;
        this.pathColor = pathColor;
    }",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/class_declaration-Node/,Node,int pathColor;,"public String toString(){
        return this.vtx + "" "" + this.pathColor;
    }","(59, 4)","(62, 5)",N,constructor_declaration,Node,,25,59586a55-14ba-453b-af10-89cac10b5ae7
"public String toString(){
        return this.vtx + "" "" + this.pathColor;
    }",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/class_declaration-Node/,Node,"Node(int vtx, int pathColor){
        this.vtx = vtx;
        this.pathColor = pathColor;
    }",Next sibling does not exist,"(64, 4)","(66, 5)",N,method_declaration,toString,,19,df4ffe9f-25e9-4833-aa20-5a39226b3cce
"class Edge{
    
    int start;
    int end;
    int color;
    boolean visited;
    
    Edge(int start, int end, int color){
        this.start = start;
        this.end = end;
        this.color = color;
        this.visited = false;
    }
    
    
    public String toString(){
        return this.start + "" "" + this.end + "" "" +this.color + "" ""+ this.visited;
    }
}",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/,program,"class Node{
    int vtx;
    int pathColor;
    
    Node(int vtx, int pathColor){
        this.vtx = vtx;
        this.pathColor = pathColor;
    }
    
    public String toString(){
        return this.vtx + "" "" + this.pathColor;
    }
    
}",Next sibling does not exist,"(70, 0)","(88, 1)",N,class_declaration,Edge,,91,b23e886a-4984-4bb9-9fe4-13ebdf162f45
"Edge(int start, int end, int color){
        this.start = start;
        this.end = end;
        this.color = color;
        this.visited = false;
    }",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/class_declaration-Edge/,Edge,boolean visited;,"public String toString(){
        return this.start + "" "" + this.end + "" "" +this.color + "" ""+ this.visited;
    }","(77, 4)","(82, 5)",N,constructor_declaration,Edge,,37,22eb704b-2fe1-4a72-af9f-50c10cc6cf69
"public String toString(){
        return this.start + "" "" + this.end + "" "" +this.color + "" ""+ this.visited;
    }",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/class_declaration-Edge/,Edge,"Edge(int start, int end, int color){
        this.start = start;
        this.end = end;
        this.color = color;
        this.visited = false;
    }",Next sibling does not exist,"(85, 4)","(87, 5)",N,method_declaration,toString,,29,3670563f-c703-48aa-9ae8-c2eccc38398b
"class Solution:
    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:

        rgraph = defaultdict(list)
        bgraph = defaultdict(list)

        for src,dest in redEdges: rgraph[src].append(dest)
        for src,dest in blueEdges: bgraph[src].append(dest)
        print(rgraph, bgraph)

        heap = []
        ans = [-1 for i in range(n)]
        rvisited = [False for i in range(n)]
        bvisited = [False for i in range(n)]    
        for node in rgraph[0]: heap.append([node, 1])
        for node in bgraph[0]: heap.append([node, 0])
        dis = 1
        l = len(heap)

        rvisited[0] = True
        bvisited[0] = True
        ans[0] = 0

        # print(heap)
        while(heap):
            node, prevColor = heap.pop(0)
            l -= 1

            if(prevColor == 1):
                visited, nvisited = rvisited, bvisited
                graph = bgraph
            else:
                visited, nvisited = bvisited, rvisited
                graph = rgraph
            
            # print(node, prevColor, dis, ans)
            visited[node] = True

            if(ans[node] == -1): ans[node] = dis
            for neigh in graph[node]:
                if(nvisited[neigh]): continue
                heap.append([neigh, 1 ^ prevColor])

            if(l == 0):
                l = len(heap)
                dis += 1

        return ans

",shortestAlternatingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestAlternatingPaths.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(49, 0)",N,module,module,,360,5bbb3250-de68-487b-8af0-2339d11c84db
"class Solution:
    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:

        rgraph = defaultdict(list)
        bgraph = defaultdict(list)

        for src,dest in redEdges: rgraph[src].append(dest)
        for src,dest in blueEdges: bgraph[src].append(dest)
        print(rgraph, bgraph)

        heap = []
        ans = [-1 for i in range(n)]
        rvisited = [False for i in range(n)]
        bvisited = [False for i in range(n)]    
        for node in rgraph[0]: heap.append([node, 1])
        for node in bgraph[0]: heap.append([node, 0])
        dis = 1
        l = len(heap)

        rvisited[0] = True
        bvisited[0] = True
        ans[0] = 0

        # print(heap)
        while(heap):
            node, prevColor = heap.pop(0)
            l -= 1

            if(prevColor == 1):
                visited, nvisited = rvisited, bvisited
                graph = bgraph
            else:
                visited, nvisited = bvisited, rvisited
                graph = rgraph
            
            # print(node, prevColor, dis, ans)
            visited[node] = True

            if(ans[node] == -1): ans[node] = dis
            for neigh in graph[node]:
                if(nvisited[neigh]): continue
                heap.append([neigh, 1 ^ prevColor])

            if(l == 0):
                l = len(heap)
                dis += 1

        return ans",shortestAlternatingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestAlternatingPaths.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(47, 18)",N,class_definition,Solution,,359,351583e0-6b55-4a40-adc4-636adc950d85
"def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:

        rgraph = defaultdict(list)
        bgraph = defaultdict(list)

        for src,dest in redEdges: rgraph[src].append(dest)
        for src,dest in blueEdges: bgraph[src].append(dest)
        print(rgraph, bgraph)

        heap = []
        ans = [-1 for i in range(n)]
        rvisited = [False for i in range(n)]
        bvisited = [False for i in range(n)]    
        for node in rgraph[0]: heap.append([node, 1])
        for node in bgraph[0]: heap.append([node, 0])
        dis = 1
        l = len(heap)

        rvisited[0] = True
        bvisited[0] = True
        ans[0] = 0

        # print(heap)
        while(heap):
            node, prevColor = heap.pop(0)
            l -= 1

            if(prevColor == 1):
                visited, nvisited = rvisited, bvisited
                graph = bgraph
            else:
                visited, nvisited = bvisited, rvisited
                graph = rgraph
            
            # print(node, prevColor, dis, ans)
            visited[node] = True

            if(ans[node] == -1): ans[node] = dis
            for neigh in graph[node]:
                if(nvisited[neigh]): continue
                heap.append([neigh, 1 ^ prevColor])

            if(l == 0):
                l = len(heap)
                dis += 1

        return ans",shortestAlternatingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestAlternatingPaths.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(47, 18)",N,function_definition,shortestAlternatingPaths,,355,5ffc0ce3-6246-4612-b07e-a759802598db
"class Point{
    int x;
    int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    public String toString(){
        return x + "" "" + y;
    }
}


class Solution {
    
    boolean[][] visited;
    Queue<Point> queue = new LinkedList<>();
        
    
    public int shortestBridge(int[][] grid) {
        
        this.visited = new boolean[grid.length][grid[0].length];
            
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == 1){
                    dfs(grid,i,j);
                    i = grid.length;
                    j = grid[0].length;
                }
            }
        }
        
        // System.out.println(queue);
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int sr = cur.x + dir[i][0];
                int sc = cur.y + dir[i][1];
                
                if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc]){
                    if(grid[sr][sc]==1) return ans;
                    else{
                        visited[sr][sc] = true;
                        queue.add(new Point(sr,sc));
                    }
                }
                
            }
            
            
            if(l==0){
                l=queue.size();
                ans++;
            }
        }
        
        return ans;
        
    }
    
    
    public void dfs(int[][] grid, int sr, int sc){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc] && grid[sr][sc]==1){
            
            queue.add(new Point(sr,sc));
            visited[sr][sc] = true;
            
            dfs(grid, sr-1, sc);
            dfs(grid, sr, sc+1);
            dfs(grid, sr+1, sc);
            dfs(grid, sr, sc-1);
            
        }
    }
    
    
}
",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(89, 0)",N,program,program,,490,467ee9a0-7f7c-4375-b82a-389e8ebc717e
"class Point{
    int x;
    int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    public String toString(){
        return x + "" "" + y;
    }
}",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,program/,program,Previous sibling does not exist,"class Solution {
    
    boolean[][] visited;
    Queue<Point> queue = new LinkedList<>();
        
    
    public int shortestBridge(int[][] grid) {
        
        this.visited = new boolean[grid.length][grid[0].length];
            
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == 1){
                    dfs(grid,i,j);
                    i = grid.length;
                    j = grid[0].length;
                }
            }
        }
        
        // System.out.println(queue);
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int sr = cur.x + dir[i][0];
                int sc = cur.y + dir[i][1];
                
                if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc]){
                    if(grid[sr][sc]==1) return ans;
                    else{
                        visited[sr][sc] = true;
                        queue.add(new Point(sr,sc));
                    }
                }
                
            }
            
            
            if(l==0){
                l=queue.size();
                ans++;
            }
        }
        
        return ans;
        
    }
    
    
    public void dfs(int[][] grid, int sr, int sc){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc] && grid[sr][sc]==1){
            
            queue.add(new Point(sr,sc));
            visited[sr][sc] = true;
            
            dfs(grid, sr-1, sc);
            dfs(grid, sr, sc+1);
            dfs(grid, sr+1, sc);
            dfs(grid, sr, sc-1);
            
        }
    }
    
    
}","(0, 0)","(12, 1)",N,class_declaration,Point,,52,1588b541-baeb-40eb-890d-b331df293b10
"Point(int x, int y){
        this.x = x;
        this.y = y;
    }",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,program/class_declaration-Point/,Point,int y;,"public String toString(){
        return x + "" "" + y;
    }","(4, 4)","(7, 5)",N,constructor_declaration,Point,,21,75b02674-1dbc-423a-8241-37351be451cb
"public String toString(){
        return x + "" "" + y;
    }",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,program/class_declaration-Point/,Point,"Point(int x, int y){
        this.x = x;
        this.y = y;
    }",Next sibling does not exist,"(9, 4)","(11, 5)",N,method_declaration,toString,,15,434e0f62-e2db-4e35-a229-594915278445
"class Solution {
    
    boolean[][] visited;
    Queue<Point> queue = new LinkedList<>();
        
    
    public int shortestBridge(int[][] grid) {
        
        this.visited = new boolean[grid.length][grid[0].length];
            
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == 1){
                    dfs(grid,i,j);
                    i = grid.length;
                    j = grid[0].length;
                }
            }
        }
        
        // System.out.println(queue);
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int sr = cur.x + dir[i][0];
                int sc = cur.y + dir[i][1];
                
                if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc]){
                    if(grid[sr][sc]==1) return ans;
                    else{
                        visited[sr][sc] = true;
                        queue.add(new Point(sr,sc));
                    }
                }
                
            }
            
            
            if(l==0){
                l=queue.size();
                ans++;
            }
        }
        
        return ans;
        
    }
    
    
    public void dfs(int[][] grid, int sr, int sc){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc] && grid[sr][sc]==1){
            
            queue.add(new Point(sr,sc));
            visited[sr][sc] = true;
            
            dfs(grid, sr-1, sc);
            dfs(grid, sr, sc+1);
            dfs(grid, sr+1, sc);
            dfs(grid, sr, sc-1);
            
        }
    }
    
    
}",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,program/,program,"class Point{
    int x;
    int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    public String toString(){
        return x + "" "" + y;
    }
}",Next sibling does not exist,"(15, 0)","(88, 1)",N,class_declaration,Solution,,438,d0cf39be-e7a0-4049-9245-5d4b4ec2b1ab
"public int shortestBridge(int[][] grid) {
        
        this.visited = new boolean[grid.length][grid[0].length];
            
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == 1){
                    dfs(grid,i,j);
                    i = grid.length;
                    j = grid[0].length;
                }
            }
        }
        
        // System.out.println(queue);
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int sr = cur.x + dir[i][0];
                int sc = cur.y + dir[i][1];
                
                if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc]){
                    if(grid[sr][sc]==1) return ans;
                    else{
                        visited[sr][sc] = true;
                        queue.add(new Point(sr,sc));
                    }
                }
                
            }
            
            
            if(l==0){
                l=queue.size();
                ans++;
            }
        }
        
        return ans;
        
    }",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,program/class_declaration-Solution/,Solution,Queue<Point> queue = new LinkedList<>();,"public void dfs(int[][] grid, int sr, int sc){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc] && grid[sr][sc]==1){
            
            queue.add(new Point(sr,sc));
            visited[sr][sc] = true;
            
            dfs(grid, sr-1, sc);
            dfs(grid, sr, sc+1);
            dfs(grid, sr+1, sc);
            dfs(grid, sr, sc-1);
            
        }
    }","(21, 4)","(70, 5)",N,method_declaration,shortestBridge,,296,ec76934e-5958-475a-af9d-583e1cdeb777
"public void dfs(int[][] grid, int sr, int sc){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc] && grid[sr][sc]==1){
            
            queue.add(new Point(sr,sc));
            visited[sr][sc] = true;
            
            dfs(grid, sr-1, sc);
            dfs(grid, sr, sc+1);
            dfs(grid, sr+1, sc);
            dfs(grid, sr, sc-1);
            
        }
    }",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,program/class_declaration-Solution/,Solution,"public int shortestBridge(int[][] grid) {
        
        this.visited = new boolean[grid.length][grid[0].length];
            
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == 1){
                    dfs(grid,i,j);
                    i = grid.length;
                    j = grid[0].length;
                }
            }
        }
        
        // System.out.println(queue);
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int sr = cur.x + dir[i][0];
                int sc = cur.y + dir[i][1];
                
                if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc]){
                    if(grid[sr][sc]==1) return ans;
                    else{
                        visited[sr][sc] = true;
                        queue.add(new Point(sr,sc));
                    }
                }
                
            }
            
            
            if(l==0){
                l=queue.size();
                ans++;
            }
        }
        
        return ans;
        
    }",Next sibling does not exist,"(73, 4)","(85, 5)",N,method_declaration,dfs,,118,60e6bba7-a818-4d60-bf2b-0c7718273b34
"class Solution {

	public int[] shortestPath(int N,int M, int[][] edges) {
		//Code here
		int[] ans = new int[N];
		for(int i=0;i<N;i++) ans[i] = -1;
		
		ArrayList<ArrayList<Edge>> graph = new ArrayList<>();
		
		for(int i=0; i<N;i++) graph.add(new ArrayList<>());
		
		for(int[] edge:edges){
		    graph.get(edge[0]).add(new Edge(edge[0], edge[1], edge[2]));
		}
		
// 		System.out.println(graph);
		
		boolean[] visited = new boolean[N];
		PriorityQueue<Node> queue = new PriorityQueue<>();
		queue.add(new Node(0, 0));
		
		while(!queue.isEmpty()){
		    Node cur = queue.poll();
		    if(visited[cur.val]) continue;
		    
		    visited[cur.val] = true;
		    ans[cur.val] = cur.distance;
		    
		    for(Edge e: graph.get(cur.val)){
		        if(visited[e.dest]) continue;
		        queue.add(new Node(e.dest, cur.distance + e.distance));
		    }
		}
		
		return ans;
	}
}


class Edge {
    int source;
    int dest;
    int distance;
    
    
    public Edge(int source, int dest, int distance){
        this.source = source;
        this.dest = dest;
        this.distance = distance;
    }
    
    public String toString() {
        return this.source  + "" "" + this.dest + "" "" + this.distance;
    }
    
}


class Node implements Comparable<Node> {
    int val;
    int distance;
    
    public Node(int val, int distance) {
        this.val = val;
        this.distance = distance;
    }
    
    
    public int compareTo(Node o){
        return this.distance - o.distance;
    }
}
",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(72, 0)",N,program,program,,378,d55085b3-4b2c-4dd4-ae4a-75a0f21ea804
"class Solution {

	public int[] shortestPath(int N,int M, int[][] edges) {
		//Code here
		int[] ans = new int[N];
		for(int i=0;i<N;i++) ans[i] = -1;
		
		ArrayList<ArrayList<Edge>> graph = new ArrayList<>();
		
		for(int i=0; i<N;i++) graph.add(new ArrayList<>());
		
		for(int[] edge:edges){
		    graph.get(edge[0]).add(new Edge(edge[0], edge[1], edge[2]));
		}
		
// 		System.out.println(graph);
		
		boolean[] visited = new boolean[N];
		PriorityQueue<Node> queue = new PriorityQueue<>();
		queue.add(new Node(0, 0));
		
		while(!queue.isEmpty()){
		    Node cur = queue.poll();
		    if(visited[cur.val]) continue;
		    
		    visited[cur.val] = true;
		    ans[cur.val] = cur.distance;
		    
		    for(Edge e: graph.get(cur.val)){
		        if(visited[e.dest]) continue;
		        queue.add(new Node(e.dest, cur.distance + e.distance));
		    }
		}
		
		return ans;
	}
}",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/,program,Previous sibling does not exist,"class Edge {
    int source;
    int dest;
    int distance;
    
    
    public Edge(int source, int dest, int distance){
        this.source = source;
        this.dest = dest;
        this.distance = distance;
    }
    
    public String toString() {
        return this.source  + "" "" + this.dest + "" "" + this.distance;
    }
    
}","(0, 0)","(36, 1)",N,class_declaration,Solution,,242,c01b5975-59f9-498e-b74d-041f2956a639
"public int[] shortestPath(int N,int M, int[][] edges) {
		//Code here
		int[] ans = new int[N];
		for(int i=0;i<N;i++) ans[i] = -1;
		
		ArrayList<ArrayList<Edge>> graph = new ArrayList<>();
		
		for(int i=0; i<N;i++) graph.add(new ArrayList<>());
		
		for(int[] edge:edges){
		    graph.get(edge[0]).add(new Edge(edge[0], edge[1], edge[2]));
		}
		
// 		System.out.println(graph);
		
		boolean[] visited = new boolean[N];
		PriorityQueue<Node> queue = new PriorityQueue<>();
		queue.add(new Node(0, 0));
		
		while(!queue.isEmpty()){
		    Node cur = queue.poll();
		    if(visited[cur.val]) continue;
		    
		    visited[cur.val] = true;
		    ans[cur.val] = cur.distance;
		    
		    for(Edge e: graph.get(cur.val)){
		        if(visited[e.dest]) continue;
		        queue.add(new Node(e.dest, cur.distance + e.distance));
		    }
		}
		
		return ans;
	}",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(2, 1)","(35, 2)",N,method_declaration,shortestPath,,238,c2fb34ef-41e6-4eff-bcd3-b8d2d516b74e
"class Edge {
    int source;
    int dest;
    int distance;
    
    
    public Edge(int source, int dest, int distance){
        this.source = source;
        this.dest = dest;
        this.distance = distance;
    }
    
    public String toString() {
        return this.source  + "" "" + this.dest + "" "" + this.distance;
    }
    
}",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/,program,"class Solution {

	public int[] shortestPath(int N,int M, int[][] edges) {
		//Code here
		int[] ans = new int[N];
		for(int i=0;i<N;i++) ans[i] = -1;
		
		ArrayList<ArrayList<Edge>> graph = new ArrayList<>();
		
		for(int i=0; i<N;i++) graph.add(new ArrayList<>());
		
		for(int[] edge:edges){
		    graph.get(edge[0]).add(new Edge(edge[0], edge[1], edge[2]));
		}
		
// 		System.out.println(graph);
		
		boolean[] visited = new boolean[N];
		PriorityQueue<Node> queue = new PriorityQueue<>();
		queue.add(new Node(0, 0));
		
		while(!queue.isEmpty()){
		    Node cur = queue.poll();
		    if(visited[cur.val]) continue;
		    
		    visited[cur.val] = true;
		    ans[cur.val] = cur.distance;
		    
		    for(Edge e: graph.get(cur.val)){
		        if(visited[e.dest]) continue;
		        queue.add(new Node(e.dest, cur.distance + e.distance));
		    }
		}
		
		return ans;
	}
}","class Node implements Comparable<Node> {
    int val;
    int distance;
    
    public Node(int val, int distance) {
        this.val = val;
        this.distance = distance;
    }
    
    
    public int compareTo(Node o){
        return this.distance - o.distance;
    }
}","(39, 0)","(55, 1)",N,class_declaration,Edge,,77,df4f37de-b514-4598-a126-20f7e4039d5c
"public Edge(int source, int dest, int distance){
        this.source = source;
        this.dest = dest;
        this.distance = distance;
    }",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/class_declaration-Edge/,Edge,int distance;,"public String toString() {
        return this.source  + "" "" + this.dest + "" "" + this.distance;
    }","(45, 4)","(49, 5)",N,constructor_declaration,Edge,,31,f6b08ca6-7f07-49b8-a78b-e743e2709dac
"public String toString() {
        return this.source  + "" "" + this.dest + "" "" + this.distance;
    }",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/class_declaration-Edge/,Edge,"public Edge(int source, int dest, int distance){
        this.source = source;
        this.dest = dest;
        this.distance = distance;
    }",Next sibling does not exist,"(51, 4)","(53, 5)",N,method_declaration,toString,,25,4e161bb1-be8c-4947-ac8b-1fb543ab40b3
"class Node implements Comparable<Node> {
    int val;
    int distance;
    
    public Node(int val, int distance) {
        this.val = val;
        this.distance = distance;
    }
    
    
    public int compareTo(Node o){
        return this.distance - o.distance;
    }
}",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/,program,"class Edge {
    int source;
    int dest;
    int distance;
    
    
    public Edge(int source, int dest, int distance){
        this.source = source;
        this.dest = dest;
        this.distance = distance;
    }
    
    public String toString() {
        return this.source  + "" "" + this.dest + "" "" + this.distance;
    }
    
}",Next sibling does not exist,"(58, 0)","(71, 1)",N,class_declaration,Node,,59,e18ac065-9291-4311-bfdb-2d101eb670ce
"public Node(int val, int distance) {
        this.val = val;
        this.distance = distance;
    }",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/class_declaration-Node/,Node,int distance;,"public int compareTo(Node o){
        return this.distance - o.distance;
    }","(62, 4)","(65, 5)",N,constructor_declaration,Node,,23,71cc81d8-ad40-4d5c-b0d8-59bbf0a4f649
"public int compareTo(Node o){
        return this.distance - o.distance;
    }",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/class_declaration-Node/,Node,"public Node(int val, int distance) {
        this.val = val;
        this.distance = distance;
    }",Next sibling does not exist,"(68, 4)","(70, 5)",N,method_declaration,compareTo,,16,299ded3c-dc9b-4545-92d8-70764248816d
"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()
        best = [INF for _ in range(6)]

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return [INF for _ in range(6)]
            if(node in stack or grid[x][y] == '#'): return [INF for _ in range(6)]
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): 
                return [INF for _ in range(6)]
            
            if(97 <= ord(grid[x][y]) <= 122): 
                keys.add(grid[x][y])
            

            ans = [INF for _ in range(6)]
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in range(6): ans[index] = min(ans[index], d[index] + 1) 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start))
        print(dfs(start))
        return -1 if(ans >= INF) else ans


class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return {}
            if(node in stack or grid[x][y] == '#'): return {}
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): return {}
            if(97 <= ord(grid[x][y]) <= 122): keys.add(grid[x][y])
            

            ans = {}
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in d: 
                    if(index in ans):
                        ans[index] = min(ans[index], d[index] + 1)
                    else:
                        ans[index] = d[index] + 1 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start).values())
        print(dfs(start))
        return -1 if(ans >= INF) else ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(109, 41)",N,module,module,,964,2e72f78b-32e6-4287-b1fd-61d863159f04
"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()
        best = [INF for _ in range(6)]

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return [INF for _ in range(6)]
            if(node in stack or grid[x][y] == '#'): return [INF for _ in range(6)]
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): 
                return [INF for _ in range(6)]
            
            if(97 <= ord(grid[x][y]) <= 122): 
                keys.add(grid[x][y])
            

            ans = [INF for _ in range(6)]
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in range(6): ans[index] = min(ans[index], d[index] + 1) 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start))
        print(dfs(start))
        return -1 if(ans >= INF) else ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,module/,module,Previous sibling does not exist,"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return {}
            if(node in stack or grid[x][y] == '#'): return {}
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): return {}
            if(97 <= ord(grid[x][y]) <= 122): keys.add(grid[x][y])
            

            ans = {}
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in d: 
                    if(index in ans):
                        ans[index] = min(ans[index], d[index] + 1)
                    else:
                        ans[index] = d[index] + 1 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start).values())
        print(dfs(start))
        return -1 if(ans >= INF) else ans","(0, 0)","(53, 41)",N,class_definition,Solution,,495,d7d075a7-90a2-444d-838e-af92131137b1
"def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()
        best = [INF for _ in range(6)]

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return [INF for _ in range(6)]
            if(node in stack or grid[x][y] == '#'): return [INF for _ in range(6)]
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): 
                return [INF for _ in range(6)]
            
            if(97 <= ord(grid[x][y]) <= 122): 
                keys.add(grid[x][y])
            

            ans = [INF for _ in range(6)]
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in range(6): ans[index] = min(ans[index], d[index] + 1) 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start))
        print(dfs(start))
        return -1 if(ans >= INF) else ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(53, 41)",N,function_definition,shortestPathAllKeys,,491,75c4590d-9bb6-4506-aab3-dad75e8bad0a
"def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return [INF for _ in range(6)]
            if(node in stack or grid[x][y] == '#'): return [INF for _ in range(6)]
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): 
                return [INF for _ in range(6)]
            
            if(97 <= ord(grid[x][y]) <= 122): 
                keys.add(grid[x][y])
            

            ans = [INF for _ in range(6)]
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in range(6): ans[index] = min(ans[index], d[index] + 1) 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,module/class_definition-Solution/function_definition-shortestPathAllKeys/,shortestPathAllKeys,best = [INF for _ in range(6)],ans = sum(dfs(start)),"(24, 8)","(49, 22)",N,function_definition,dfs,,267,aa7311fb-a963-4794-8ef8-333971288ef2
"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return {}
            if(node in stack or grid[x][y] == '#'): return {}
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): return {}
            if(97 <= ord(grid[x][y]) <= 122): keys.add(grid[x][y])
            

            ans = {}
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in d: 
                    if(index in ans):
                        ans[index] = min(ans[index], d[index] + 1)
                    else:
                        ans[index] = d[index] + 1 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start).values())
        print(dfs(start))
        return -1 if(ans >= INF) else ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,module/,module,"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()
        best = [INF for _ in range(6)]

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return [INF for _ in range(6)]
            if(node in stack or grid[x][y] == '#'): return [INF for _ in range(6)]
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): 
                return [INF for _ in range(6)]
            
            if(97 <= ord(grid[x][y]) <= 122): 
                keys.add(grid[x][y])
            

            ans = [INF for _ in range(6)]
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in range(6): ans[index] = min(ans[index], d[index] + 1) 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start))
        print(dfs(start))
        return -1 if(ans >= INF) else ans",Next sibling does not exist,"(56, 0)","(109, 41)",N,class_definition,Solution,,468,d4cdc082-b512-46d2-aad4-efbcb9e3a0b4
"def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return {}
            if(node in stack or grid[x][y] == '#'): return {}
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): return {}
            if(97 <= ord(grid[x][y]) <= 122): keys.add(grid[x][y])
            

            ans = {}
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in d: 
                    if(index in ans):
                        ans[index] = min(ans[index], d[index] + 1)
                    else:
                        ans[index] = d[index] + 1 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start).values())
        print(dfs(start))
        return -1 if(ans >= INF) else ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(57, 4)","(109, 41)",N,function_definition,shortestPathAllKeys,,464,142dcea9-d400-445b-852b-7a5c03a87abe
"def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return {}
            if(node in stack or grid[x][y] == '#'): return {}
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): return {}
            if(97 <= ord(grid[x][y]) <= 122): keys.add(grid[x][y])
            

            ans = {}
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in d: 
                    if(index in ans):
                        ans[index] = min(ans[index], d[index] + 1)
                    else:
                        ans[index] = d[index] + 1 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,module/class_definition-Solution/function_definition-shortestPathAllKeys/,shortestPathAllKeys,keys = set(),ans = sum(dfs(start).values()),"(79, 8)","(105, 22)",N,function_definition,dfs,,250,dbaf70ed-23d3-4449-b402-ef041ad60c5b
"class Point{
    public int x;
    public int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    public String toString(){
        return x+"" ""+y;
    }
}


class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
     
        Queue<Point> queue = new LinkedList<Point>();
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int[][] dir = {
            {-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}
        }; 
        int ans = 1;        
        
        if(grid[0][0]==1) return -1;
        queue.add(new Point(0,0));
        visited[0][0] = true;
        
        int l = queue.size();
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            
            Point cur = queue.poll();
            l--;
            
            if(cur.x == grid.length-1 && cur.y==grid[0].length-1){
                return ans;
            }
            
            for(int i=0;i<8;i++){
                int newRow = cur.x + dir[i][0];
                int newCol = cur.y + dir[i][1];
                
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol<grid[0].length && !visited[newRow][newCol] && grid[newRow][newCol]==0){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
                
            }
            
            if(l==0){
                ans++;
                l = queue.size();
            }
        }
        
        
        return -1;        
    }
}
",ShortestPathInBinaryMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPathInBinaryMatrix.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(62, 0)",N,program,program,,382,2796ae6f-d74c-4ccc-a5a9-2041c3fe9c54
"class Point{
    public int x;
    public int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    public String toString(){
        return x+"" ""+y;
    }
}",ShortestPathInBinaryMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPathInBinaryMatrix.java,program/,program,Previous sibling does not exist,"class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
     
        Queue<Point> queue = new LinkedList<Point>();
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int[][] dir = {
            {-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}
        }; 
        int ans = 1;        
        
        if(grid[0][0]==1) return -1;
        queue.add(new Point(0,0));
        visited[0][0] = true;
        
        int l = queue.size();
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            
            Point cur = queue.poll();
            l--;
            
            if(cur.x == grid.length-1 && cur.y==grid[0].length-1){
                return ans;
            }
            
            for(int i=0;i<8;i++){
                int newRow = cur.x + dir[i][0];
                int newCol = cur.y + dir[i][1];
                
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol<grid[0].length && !visited[newRow][newCol] && grid[newRow][newCol]==0){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
                
            }
            
            if(l==0){
                ans++;
                l = queue.size();
            }
        }
        
        
        return -1;        
    }
}","(0, 0)","(12, 1)",N,class_declaration,Point,,52,efa69b16-7056-4833-8409-e9028a43f3b7
"Point(int x, int y){
        this.x = x;
        this.y = y;
    }",ShortestPathInBinaryMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPathInBinaryMatrix.java,program/class_declaration-Point/,Point,public int y;,"public String toString(){
        return x+"" ""+y;
    }","(4, 4)","(7, 5)",N,constructor_declaration,Point,,21,55381772-999e-4f1c-97e2-26efac80f6c3
"public String toString(){
        return x+"" ""+y;
    }",ShortestPathInBinaryMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPathInBinaryMatrix.java,program/class_declaration-Point/,Point,"Point(int x, int y){
        this.x = x;
        this.y = y;
    }",Next sibling does not exist,"(9, 4)","(11, 5)",N,method_declaration,toString,,13,acc1bc8f-c8a1-4003-9b46-4b811fd16971
"class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
     
        Queue<Point> queue = new LinkedList<Point>();
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int[][] dir = {
            {-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}
        }; 
        int ans = 1;        
        
        if(grid[0][0]==1) return -1;
        queue.add(new Point(0,0));
        visited[0][0] = true;
        
        int l = queue.size();
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            
            Point cur = queue.poll();
            l--;
            
            if(cur.x == grid.length-1 && cur.y==grid[0].length-1){
                return ans;
            }
            
            for(int i=0;i<8;i++){
                int newRow = cur.x + dir[i][0];
                int newCol = cur.y + dir[i][1];
                
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol<grid[0].length && !visited[newRow][newCol] && grid[newRow][newCol]==0){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
                
            }
            
            if(l==0){
                ans++;
                l = queue.size();
            }
        }
        
        
        return -1;        
    }
}",ShortestPathInBinaryMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPathInBinaryMatrix.java,program/,program,"class Point{
    public int x;
    public int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    public String toString(){
        return x+"" ""+y;
    }
}",Next sibling does not exist,"(15, 0)","(61, 1)",N,class_declaration,Solution,,330,c01983a1-cbdc-486a-b315-a0b07ef94c75
"public int shortestPathBinaryMatrix(int[][] grid) {
     
        Queue<Point> queue = new LinkedList<Point>();
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int[][] dir = {
            {-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}
        }; 
        int ans = 1;        
        
        if(grid[0][0]==1) return -1;
        queue.add(new Point(0,0));
        visited[0][0] = true;
        
        int l = queue.size();
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            
            Point cur = queue.poll();
            l--;
            
            if(cur.x == grid.length-1 && cur.y==grid[0].length-1){
                return ans;
            }
            
            for(int i=0;i<8;i++){
                int newRow = cur.x + dir[i][0];
                int newCol = cur.y + dir[i][1];
                
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol<grid[0].length && !visited[newRow][newCol] && grid[newRow][newCol]==0){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
                
            }
            
            if(l==0){
                ans++;
                l = queue.size();
            }
        }
        
        
        return -1;        
    }",ShortestPathInBinaryMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPathInBinaryMatrix.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(16, 4)","(60, 5)",N,method_declaration,shortestPathBinaryMatrix,,325,2013fee8-6dbd-4085-bdb6-a4112f5776be
"class Solution
{
    //Function to find sum of weights of edges of the Minimum Spanning Tree.
    static int spanningTree(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj) 
    {
        // Add your code here
        
        boolean[] visited = new boolean[V];
        PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) ->  o1.distance - o2.distance);
        
        pq.add(new Node(0,0));
        int ans = 0;
        
        while(!pq.isEmpty()){
            Node cur = pq.poll();
            if(visited[cur.val]) continue;
            
            visited[cur.val] = true;
            ans += cur.distance;
            
            for(ArrayList<Integer> neighbour: adj.get(cur.val)){
                if(visited[neighbour.get(0)]) continue;
                pq.add(new Node(neighbour.get(0), neighbour.get(1)));
            }
        }
        
        
        return ans;
        
    }
}


class Node{
    int val;
    int distance;
    
    Node(int val, int distance){
         this.val = val;
         this.distance = distance;
    }
    
    
}
",SpanningTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\SpanningTree.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(44, 0)",N,program,program,,228,84e90feb-05e3-4814-b93f-7ecf32cd98d6
"class Solution
{
    //Function to find sum of weights of edges of the Minimum Spanning Tree.
    static int spanningTree(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj) 
    {
        // Add your code here
        
        boolean[] visited = new boolean[V];
        PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) ->  o1.distance - o2.distance);
        
        pq.add(new Node(0,0));
        int ans = 0;
        
        while(!pq.isEmpty()){
            Node cur = pq.poll();
            if(visited[cur.val]) continue;
            
            visited[cur.val] = true;
            ans += cur.distance;
            
            for(ArrayList<Integer> neighbour: adj.get(cur.val)){
                if(visited[neighbour.get(0)]) continue;
                pq.add(new Node(neighbour.get(0), neighbour.get(1)));
            }
        }
        
        
        return ans;
        
    }
}",SpanningTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\SpanningTree.java,program/,program,Previous sibling does not exist,"class Node{
    int val;
    int distance;
    
    Node(int val, int distance){
         this.val = val;
         this.distance = distance;
    }
    
    
}","(0, 0)","(30, 1)",N,class_declaration,Solution,,192,57968a85-aed3-4143-8029-1ec4d60b5b80
"static int spanningTree(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj) 
    {
        // Add your code here
        
        boolean[] visited = new boolean[V];
        PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) ->  o1.distance - o2.distance);
        
        pq.add(new Node(0,0));
        int ans = 0;
        
        while(!pq.isEmpty()){
            Node cur = pq.poll();
            if(visited[cur.val]) continue;
            
            visited[cur.val] = true;
            ans += cur.distance;
            
            for(ArrayList<Integer> neighbour: adj.get(cur.val)){
                if(visited[neighbour.get(0)]) continue;
                pq.add(new Node(neighbour.get(0), neighbour.get(1)));
            }
        }
        
        
        return ans;
        
    }",SpanningTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\SpanningTree.java,program/class_declaration-Solution/,Solution,//Function to find sum of weights of edges of the Minimum Spanning Tree.,Next sibling does not exist,"(3, 4)","(29, 5)",N,method_declaration,spanningTree,,169,2ab713ba-96a2-49e8-aef8-3661071db6c5
"class Node{
    int val;
    int distance;
    
    Node(int val, int distance){
         this.val = val;
         this.distance = distance;
    }
    
    
}",SpanningTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\SpanningTree.java,program/,program,"class Solution
{
    //Function to find sum of weights of edges of the Minimum Spanning Tree.
    static int spanningTree(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj) 
    {
        // Add your code here
        
        boolean[] visited = new boolean[V];
        PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) ->  o1.distance - o2.distance);
        
        pq.add(new Node(0,0));
        int ans = 0;
        
        while(!pq.isEmpty()){
            Node cur = pq.poll();
            if(visited[cur.val]) continue;
            
            visited[cur.val] = true;
            ans += cur.distance;
            
            for(ArrayList<Integer> neighbour: adj.get(cur.val)){
                if(visited[neighbour.get(0)]) continue;
                pq.add(new Node(neighbour.get(0), neighbour.get(1)));
            }
        }
        
        
        return ans;
        
    }
}",Next sibling does not exist,"(33, 0)","(43, 1)",N,class_declaration,Node,,36,9221cc9a-59ed-4d0a-9223-ac0e832c0bf4
"Node(int val, int distance){
         this.val = val;
         this.distance = distance;
    }",SpanningTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\SpanningTree.java,program/class_declaration-Node/,Node,int distance;,Next sibling does not exist,"(37, 4)","(40, 5)",N,constructor_declaration,Node,,21,a6f33b94-ae84-4478-8e32-89c4ef2f379c
"class Solution {
    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {
        
        boolean[] visited = new boolean[friends.length];
        Queue<Integer> queue = new LinkedList<>();
        
        queue.offer(id);
        visited[id] = true;
        int l = queue.size();
        
        
        while(level>0){
            int node = queue.poll();
            l--;
            
            for(int friend: friends[node]) {
                if(visited[friend]) continue;
                queue.offer(friend);
                visited[friend] = true;
            }
            
            if(l==0) {
                l = queue.size();
                level--;
            }
        }
        
        HashMap<String, Integer> map = new HashMap<>();
        for(int x: queue){
            for(String video: watchedVideos.get(x)){
                if(!map.containsKey(video)) map.put(video, 1);
                else map.put(video, map.get(video)+1);
            }
        }
        
        ArrayList<String> ans = new ArrayList<>(map.keySet());
        Collections.sort(ans, (O1, O2) -> (map.get(O1) == map.get(O2)) ? (O1.compareTo(O2)) : (map.get(O1) - map.get(O2)));
        
        return ans; 
    }
}
",WatchedVideosByFriends.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\WatchedVideosByFriends.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(41, 0)",N,program,program,,271,aa8cc59c-869e-4a8b-a634-d4b952443826
"class Solution {
    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {
        
        boolean[] visited = new boolean[friends.length];
        Queue<Integer> queue = new LinkedList<>();
        
        queue.offer(id);
        visited[id] = true;
        int l = queue.size();
        
        
        while(level>0){
            int node = queue.poll();
            l--;
            
            for(int friend: friends[node]) {
                if(visited[friend]) continue;
                queue.offer(friend);
                visited[friend] = true;
            }
            
            if(l==0) {
                l = queue.size();
                level--;
            }
        }
        
        HashMap<String, Integer> map = new HashMap<>();
        for(int x: queue){
            for(String video: watchedVideos.get(x)){
                if(!map.containsKey(video)) map.put(video, 1);
                else map.put(video, map.get(video)+1);
            }
        }
        
        ArrayList<String> ans = new ArrayList<>(map.keySet());
        Collections.sort(ans, (O1, O2) -> (map.get(O1) == map.get(O2)) ? (O1.compareTo(O2)) : (map.get(O1) - map.get(O2)));
        
        return ans; 
    }
}",WatchedVideosByFriends.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\WatchedVideosByFriends.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(40, 1)",N,class_declaration,Solution,,271,054323ea-1af7-4c3d-9450-3e305b00c848
"public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {
        
        boolean[] visited = new boolean[friends.length];
        Queue<Integer> queue = new LinkedList<>();
        
        queue.offer(id);
        visited[id] = true;
        int l = queue.size();
        
        
        while(level>0){
            int node = queue.poll();
            l--;
            
            for(int friend: friends[node]) {
                if(visited[friend]) continue;
                queue.offer(friend);
                visited[friend] = true;
            }
            
            if(l==0) {
                l = queue.size();
                level--;
            }
        }
        
        HashMap<String, Integer> map = new HashMap<>();
        for(int x: queue){
            for(String video: watchedVideos.get(x)){
                if(!map.containsKey(video)) map.put(video, 1);
                else map.put(video, map.get(video)+1);
            }
        }
        
        ArrayList<String> ans = new ArrayList<>(map.keySet());
        Collections.sort(ans, (O1, O2) -> (map.get(O1) == map.get(O2)) ? (O1.compareTo(O2)) : (map.get(O1) - map.get(O2)));
        
        return ans; 
    }",WatchedVideosByFriends.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\WatchedVideosByFriends.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(39, 5)",N,method_declaration,watchedVideosByFriends,,266,762956c0-cc35-41f3-a372-837e78d86298
"class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:

        points.sort(key = lambda x:x[1])
        # print(points)

        ans = 0
        index = 0
        N = len(points)

        while(index<N):
            _,end = points[index]
            while(index<N and points[index][0]<=end):
                index+=1
            ans+=1
        
        return ans
",findMinArrowShots.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\findMinArrowShots.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 0)",N,module,module,,93,0a990404-c099-40d8-a565-e4f368606b6e
"class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:

        points.sort(key = lambda x:x[1])
        # print(points)

        ans = 0
        index = 0
        N = len(points)

        while(index<N):
            _,end = points[index]
            while(index<N and points[index][0]<=end):
                index+=1
            ans+=1
        
        return ans",findMinArrowShots.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\findMinArrowShots.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 18)",N,class_definition,Solution,,92,6fbcb16d-9fc1-4f3f-8b44-38ea6706d321
"def findMinArrowShots(self, points: List[List[int]]) -> int:

        points.sort(key = lambda x:x[1])
        # print(points)

        ans = 0
        index = 0
        N = len(points)

        while(index<N):
            _,end = points[index]
            while(index<N and points[index][0]<=end):
                index+=1
            ans+=1
        
        return ans",findMinArrowShots.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\findMinArrowShots.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(16, 18)",N,function_definition,findMinArrowShots,,88,51e300be-52e5-4f39-9c2d-a73f44542459
"class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        for i in range(len(nums)-3,-1,-1):
            if(nums[i] + nums[i+1] > nums[i+2]):
                return nums[i] + nums[i+1] + nums[i+2]
        return 0
",LargestPerimeter.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\LargestPerimeter.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(7, 0)",N,module,module,,75,91dac97e-c4e0-48c2-b1a5-4c24bf3c5512
"class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        for i in range(len(nums)-3,-1,-1):
            if(nums[i] + nums[i+1] > nums[i+2]):
                return nums[i] + nums[i+1] + nums[i+2]
        return 0",LargestPerimeter.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\LargestPerimeter.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(6, 16)",N,class_definition,Solution,,74,1a3a07c7-925d-4b6b-92f3-24a07c424532
"def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        for i in range(len(nums)-3,-1,-1):
            if(nums[i] + nums[i+1] > nums[i+2]):
                return nums[i] + nums[i+1] + nums[i+2]
        return 0",LargestPerimeter.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\LargestPerimeter.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(6, 16)",N,function_definition,largestPerimeter,,70,b4228e48-e934-402b-96af-f1047a49a405
"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        
        ans = 0
        
        index = 0
        while(index<len(s)):
            cur = 0
            prev = index
            
            while(index<len(s) and (cur*10 + int(s[index])) <= k):
                cur = cur*10 + int(s[index])
                index += 1
            
            if(prev == index): return -1
            else: ans += 1
        
        return ans
            
                
        
",minimumPartition.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\minimumPartition.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 0)",N,module,module,,110,eb7af319-b3f7-418c-b03d-083763697156
"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        
        ans = 0
        
        index = 0
        while(index<len(s)):
            cur = 0
            prev = index
            
            while(index<len(s) and (cur*10 + int(s[index])) <= k):
                cur = cur*10 + int(s[index])
                index += 1
            
            if(prev == index): return -1
            else: ans += 1
        
        return ans",minimumPartition.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\minimumPartition.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 18)",N,class_definition,Solution,,107,681b9b2e-13b6-44ed-808b-7b4ed44d7c28
"def minimumPartition(self, s: str, k: int) -> int:
        
        ans = 0
        
        index = 0
        while(index<len(s)):
            cur = 0
            prev = index
            
            while(index<len(s) and (cur*10 + int(s[index])) <= k):
                cur = cur*10 + int(s[index])
                index += 1
            
            if(prev == index): return -1
            else: ans += 1
        
        return ans",minimumPartition.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\minimumPartition.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(17, 18)",N,function_definition,minimumPartition,,103,d2a650e7-d983-45c0-bae6-e65659d888d9
"class Solution:
    def canArrange(self, arr: List[int], k: int) -> bool:

        table = {}
        for i in arr:
            if(i%k not in table):
                table[i%k] = 0
            table[i%k] += 1
        

        for i in table:
            if(i==0): 
                if(table[0]%2 == 1): return False
            elif( ((i in table) ^ ((k-i) in table)) or table[i]!=table[k-i]): return False 
        return True
",CheckIfArrayPairsAreDivisibleByk.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\CheckIfArrayPairsAreDivisibleByk.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(15, 0)",N,module,module,,119,cc18694b-08d7-4d27-8f8f-afaab14de774
"class Solution:
    def canArrange(self, arr: List[int], k: int) -> bool:

        table = {}
        for i in arr:
            if(i%k not in table):
                table[i%k] = 0
            table[i%k] += 1
        

        for i in table:
            if(i==0): 
                if(table[0]%2 == 1): return False
            elif( ((i in table) ^ ((k-i) in table)) or table[i]!=table[k-i]): return False 
        return True",CheckIfArrayPairsAreDivisibleByk.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\CheckIfArrayPairsAreDivisibleByk.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 19)",N,class_definition,Solution,,118,1821f798-c575-4b7c-977b-bbafbf0ebfe3
"def canArrange(self, arr: List[int], k: int) -> bool:

        table = {}
        for i in arr:
            if(i%k not in table):
                table[i%k] = 0
            table[i%k] += 1
        

        for i in table:
            if(i==0): 
                if(table[0]%2 == 1): return False
            elif( ((i in table) ^ ((k-i) in table)) or table[i]!=table[k-i]): return False 
        return True",CheckIfArrayPairsAreDivisibleByk.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\CheckIfArrayPairsAreDivisibleByk.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(14, 19)",N,function_definition,canArrange,,114,1bb95cd4-974c-48cf-8792-44ac4671889d
"class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        
        N = len(grid)
        map = defaultdict(int)
        for row in range(N): map[tuple(grid[row])] += 1

        ans = 0    
        for row_index in range(N):
            for col_index in range(row_index+1, N):
                grid[row_index][col_index], grid[col_index][row_index] = grid[col_index][row_index], grid[row_index][col_index]
            ans += map[tuple(grid[row_index])]
        
        return ans
",equalPairs.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\equalPairs.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 0)",N,module,module,,120,c3210bd1-fbaa-49dc-b361-ad4c46da5a38
"class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        
        N = len(grid)
        map = defaultdict(int)
        for row in range(N): map[tuple(grid[row])] += 1

        ans = 0    
        for row_index in range(N):
            for col_index in range(row_index+1, N):
                grid[row_index][col_index], grid[col_index][row_index] = grid[col_index][row_index], grid[row_index][col_index]
            ans += map[tuple(grid[row_index])]
        
        return ans",equalPairs.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\equalPairs.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(13, 18)",N,class_definition,Solution,,119,01c3038f-2e0a-4389-bf80-6b644f97ae9c
"def equalPairs(self, grid: List[List[int]]) -> int:
        
        N = len(grid)
        map = defaultdict(int)
        for row in range(N): map[tuple(grid[row])] += 1

        ans = 0    
        for row_index in range(N):
            for col_index in range(row_index+1, N):
                grid[row_index][col_index], grid[col_index][row_index] = grid[col_index][row_index], grid[row_index][col_index]
            ans += map[tuple(grid[row_index])]
        
        return ans",equalPairs.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\equalPairs.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(13, 18)",N,function_definition,equalPairs,,115,1564f54f-0b14-4dfc-9dc1-049ba2261f18
"class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        
        mapper = {}
        ans = []
        
        for num in nums:
            if(num in mapper): mapper[num] += 1
            else: mapper[num] = 0
            
            if(mapper[num] >= len(ans)): ans.append([])                
            ans[mapper[num]].append(num)
        
        return ans
",findMatrix.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\findMatrix.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 0)",N,module,module,,87,4137e618-6935-4e41-b5f7-b22ab3655e69
"class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        
        mapper = {}
        ans = []
        
        for num in nums:
            if(num in mapper): mapper[num] += 1
            else: mapper[num] = 0
            
            if(mapper[num] >= len(ans)): ans.append([])                
            ans[mapper[num]].append(num)
        
        return ans",findMatrix.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\findMatrix.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(13, 18)",N,class_definition,Solution,,86,bc483184-8ad0-4e65-9970-07185634e147
"def findMatrix(self, nums: List[int]) -> List[List[int]]:
        
        mapper = {}
        ans = []
        
        for num in nums:
            if(num in mapper): mapper[num] += 1
            else: mapper[num] = 0
            
            if(mapper[num] >= len(ans)): ans.append([])                
            ans[mapper[num]].append(num)
        
        return ans",findMatrix.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\findMatrix.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(13, 18)",N,function_definition,findMatrix,,82,a421e10d-f05d-4c33-9a20-46be7f8effee
"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        
        def mapper(arr):
            ans = 0
            for i in arr:
                ans = (ans<<1) | i
            return ans
        
        N = len(img1)
        
        img1 = [mapper(i) for i in img1]
        img2 = [mapper(i) for i in img2]
                
        visited = {}
        
        self.helper(img1, img2, 0, 0, visited)
                 
        return max(visited[i] for i in visited)
    
    # ~O(1)
    def numOfOnes(self,num):
        count = 0
        while(num>0): 
            num = num&(num-1)
            count+=1
        return count
    
    O(4*(N**2)) ~ O(N**2)
    def helper(self, img1, img2, row, col, visited):
        
        key = (row, col)
        
        if(row<=len(img1)*-1 or row>=len(img1) or col<=len(img1)*-1 or col>=len(img1) or key in visited): 
            return
        
        ans = 0
        
        O(N)
        if(row>=0):
            for index in range(0, len(img1)-row):
                val1 = img1[index] >> col if(col>=0) else img1[index] << (-1*col)
                val2 = img2[index+row]
                ans += self.numOfOnes(val1 & val2)
        else:
            for index in range(0, len(img1)+row):
                val1 = img1[index-row] >> col if(col>=0) else img1[index-row] << (-1*col)
                val2 = img2[index]
                ans += self.numOfOnes(val1 & val2)
        
        visited[key] = ans
        # print(key, ans)
         
        self.helper(img1, img2, row-1, col, visited)
        self.helper(img1, img2, row, col+1, visited)
        self.helper(img1, img2, row+1, col, visited)
        self.helper(img1, img2, row, col-1, visited)
",ImageOverlap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\ImageOverlap.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(57, 0)",Y,module,module,,493,8f183555-238e-48e2-a933-e4d770e41f4b
"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        
        def mapper(arr):
            ans = 0
            for i in arr:
                ans = (ans<<1) | i
            return ans
        
        N = len(img1)
        
        img1 = [mapper(i) for i in img1]
        img2 = [mapper(i) for i in img2]
                
        visited = {}
        
        self.helper(img1, img2, 0, 0, visited)
                 
        return max(visited[i] for i in visited)
    
    # ~O(1)
    def numOfOnes(self,num):
        count = 0
        while(num>0): 
            num = num&(num-1)
            count+=1
        return count
    
    O(4*(N**2)) ~ O(N**2)
    def helper(self, img1, img2, row, col, visited):
        
        key = (row, col)
        
        if(row<=len(img1)*-1 or row>=len(img1) or col<=len(img1)*-1 or col>=len(img1) or key in visited): 
            return
        
        ans = 0
        
        O(N)
        if(row>=0):
            for index in range(0, len(img1)-row):
                val1 = img1[index] >> col if(col>=0) else img1[index] << (-1*col)
                val2 = img2[index+row]
                ans += self.numOfOnes(val1 & val2)
        else:
            for index in range(0, len(img1)+row):
                val1 = img1[index-row] >> col if(col>=0) else img1[index-row] << (-1*col)
                val2 = img2[index]
                ans += self.numOfOnes(val1 & val2)
        
        visited[key] = ans
        # print(key, ans)
         
        self.helper(img1, img2, row-1, col, visited)
        self.helper(img1, img2, row, col+1, visited)
        self.helper(img1, img2, row+1, col, visited)
        self.helper(img1, img2, row, col-1, visited)",ImageOverlap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\ImageOverlap.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(56, 52)",Y,class_definition,Solution,,493,60cc3728-3792-4865-81a8-08c705693068
"def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        
        def mapper(arr):
            ans = 0
            for i in arr:
                ans = (ans<<1) | i
            return ans
        
        N = len(img1)
        
        img1 = [mapper(i) for i in img1]
        img2 = [mapper(i) for i in img2]
                
        visited = {}
        
        self.helper(img1, img2, 0, 0, visited)
                 
        return max(visited[i] for i in visited)",ImageOverlap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\ImageOverlap.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,# ~O(1),"(1, 4)","(18, 47)",N,function_definition,largestOverlap,,127,40e79325-bbd0-43b9-9550-9bd86799eaca
"def mapper(arr):
            ans = 0
            for i in arr:
                ans = (ans<<1) | i
            return ans",ImageOverlap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\ImageOverlap.py,module/class_definition-Solution/function_definition-largestOverlap/,largestOverlap,Previous sibling does not exist,N = len(img1),"(3, 8)","(7, 22)",N,function_definition,mapper,,30,7872d089-4e53-4d25-9a90-b62ed1745fb5
"def numOfOnes(self,num):
        count = 0
        while(num>0): 
            num = num&(num-1)
            count+=1
        return count",ImageOverlap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\ImageOverlap.py,module/class_definition-Solution/,Solution,# ~O(1),O(4*(N**2)),"(21, 4)","(26, 20)",N,function_definition,numOfOnes,,37,9e70ffd6-6a53-408e-a061-fc33ad956083
"def helper(self, img1, img2, row, col, visited):
        
        key = (row, col)
        
        if(row<=len(img1)*-1 or row>=len(img1) or col<=len(img1)*-1 or col>=len(img1) or key in visited): 
            return
        
        ans = 0
        
        O(N)
        if(row>=0):
            for index in range(0, len(img1)-row):
                val1 = img1[index] >> col if(col>=0) else img1[index] << (-1*col)
                val2 = img2[index+row]
                ans += self.numOfOnes(val1 & val2)
        else:
            for index in range(0, len(img1)+row):
                val1 = img1[index-row] >> col if(col>=0) else img1[index-row] << (-1*col)
                val2 = img2[index]
                ans += self.numOfOnes(val1 & val2)
        
        visited[key] = ans
        # print(key, ans)
         
        self.helper(img1, img2, row-1, col, visited)
        self.helper(img1, img2, row, col+1, visited)
        self.helper(img1, img2, row+1, col, visited)
        self.helper(img1, img2, row, col-1, visited)",ImageOverlap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\ImageOverlap.py,module/class_definition-Solution/,Solution,~ O(N**2),Next sibling does not exist,"(29, 4)","(56, 52)",N,function_definition,helper,,299,121eb127-6672-41a3-a5e9-32fd1ea0d2ed
"class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        arr = s.split("" "")
        if(len(pattern) != len(arr)): return False

        mapper = {}
        visited = set()

        for index in range(len(arr)):
            if(pattern[index] in mapper and mapper[pattern[index]] != arr[index]): 
                return False
            elif(pattern[index] in mapper): 
                continue
            else:
                if(arr[index] in visited): return False
                mapper[pattern[index]] = arr[index]
                visited.add(arr[index])

        return True
",wordPattern.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\wordPattern.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(19, 0)",N,module,module,,124,8c0388c5-87ca-4bbf-8909-dbf69423c6b9
"class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        arr = s.split("" "")
        if(len(pattern) != len(arr)): return False

        mapper = {}
        visited = set()

        for index in range(len(arr)):
            if(pattern[index] in mapper and mapper[pattern[index]] != arr[index]): 
                return False
            elif(pattern[index] in mapper): 
                continue
            else:
                if(arr[index] in visited): return False
                mapper[pattern[index]] = arr[index]
                visited.add(arr[index])

        return True",wordPattern.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\wordPattern.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 19)",N,class_definition,Solution,,123,a190a66d-ff7a-4d17-bda7-9f0ee0e9c684
"def wordPattern(self, pattern: str, s: str) -> bool:
        arr = s.split("" "")
        if(len(pattern) != len(arr)): return False

        mapper = {}
        visited = set()

        for index in range(len(arr)):
            if(pattern[index] in mapper and mapper[pattern[index]] != arr[index]): 
                return False
            elif(pattern[index] in mapper): 
                continue
            else:
                if(arr[index] in visited): return False
                mapper[pattern[index]] = arr[index]
                visited.add(arr[index])

        return True",wordPattern.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\wordPattern.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(18, 19)",N,function_definition,wordPattern,,119,8f4de448-5373-4ae6-b709-b337bea7aa4d
"class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        
        hashset = set()
        prefix = nums[0] % k
        hashset.add(prefix)
        hashset.add(0) 
        
        count = 0
        for i in nums:
            if((i % k)  == 0): 
                count += 1
            else:
                count = 0
            
            if(count>1): return True
        
        for i in range(1, len(nums)):
            if(nums[i]%k == 0): continue
            prefix = (prefix + nums[i])%k
            if(prefix in hashset):
                return True
            else:
                hashset.add(prefix)
        
        return False
        
        
        
",CheckSubarraySum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\CheckSubarraySum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 0)",N,module,module,,164,c5d32210-a2e4-42f0-baaa-a9c356e780a9
"class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        
        hashset = set()
        prefix = nums[0] % k
        hashset.add(prefix)
        hashset.add(0) 
        
        count = 0
        for i in nums:
            if((i % k)  == 0): 
                count += 1
            else:
                count = 0
            
            if(count>1): return True
        
        for i in range(1, len(nums)):
            if(nums[i]%k == 0): continue
            prefix = (prefix + nums[i])%k
            if(prefix in hashset):
                return True
            else:
                hashset.add(prefix)
        
        return False",CheckSubarraySum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\CheckSubarraySum.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 20)",N,class_definition,Solution,,162,3e94804c-82a1-4352-8585-3d9fd03d6093
"def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        
        hashset = set()
        prefix = nums[0] % k
        hashset.add(prefix)
        hashset.add(0) 
        
        count = 0
        for i in nums:
            if((i % k)  == 0): 
                count += 1
            else:
                count = 0
            
            if(count>1): return True
        
        for i in range(1, len(nums)):
            if(nums[i]%k == 0): continue
            prefix = (prefix + nums[i])%k
            if(prefix in hashset):
                return True
            else:
                hashset.add(prefix)
        
        return False",CheckSubarraySum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\CheckSubarraySum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(25, 20)",N,function_definition,checkSubarraySum,,158,b8ce4d8d-fe32-4efa-b896-b7d771cc06a2
"class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        set_a = set(nums1)
        set_b = set(nums2)
        
        return [[num for num in set_a if(num not in set_b)], [num for num in set_b if(num not in set_a)]]
",findDifference.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\findDifference.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(6, 0)",N,module,module,,74,f013611f-4357-4c5f-afc9-ed5c18a47eb4
"class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        set_a = set(nums1)
        set_b = set(nums2)
        
        return [[num for num in set_a if(num not in set_b)], [num for num in set_b if(num not in set_a)]]",findDifference.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\findDifference.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(5, 105)",N,class_definition,Solution,,74,a00fb807-e4ed-4a99-a6bf-56a74633ea2c
"def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        set_a = set(nums1)
        set_b = set(nums2)
        
        return [[num for num in set_a if(num not in set_b)], [num for num in set_b if(num not in set_a)]]",findDifference.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\findDifference.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(5, 105)",N,function_definition,findDifference,,70,c9523f95-dcf6-43c1-a522-7b8e9c76ab4b
"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        
        
        winner = set()
        runner = set()
        lossers = set()
        
        visited = set()
        
        for w, r in matches:
            
            if(w not in visited): winner.add(w)
            
            if(r not in visited): 
                runner.add(r)
            elif(r in winner): 
                winner.remove(r)
                runner.add(r)
            elif(r in runner):
                runner.remove(r)
                lossers.add(r)
                
            
            visited.add(w)
            visited.add(r)        
        
        return [sorted([i for i in winner]), sorted([i for i in runner])]
",FindPlayersWithZeroOneLosses.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\FindPlayersWithZeroOneLosses.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 0)",N,module,module,,145,565a4bc7-c365-4838-93af-669e2171f924
"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        
        
        winner = set()
        runner = set()
        lossers = set()
        
        visited = set()
        
        for w, r in matches:
            
            if(w not in visited): winner.add(w)
            
            if(r not in visited): 
                runner.add(r)
            elif(r in winner): 
                winner.remove(r)
                runner.add(r)
            elif(r in runner):
                runner.remove(r)
                lossers.add(r)
                
            
            visited.add(w)
            visited.add(r)        
        
        return [sorted([i for i in winner]), sorted([i for i in runner])]",FindPlayersWithZeroOneLosses.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\FindPlayersWithZeroOneLosses.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(27, 73)",N,class_definition,Solution,,145,f892854e-2d41-45cd-958c-b594ebaba464
"def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        
        
        winner = set()
        runner = set()
        lossers = set()
        
        visited = set()
        
        for w, r in matches:
            
            if(w not in visited): winner.add(w)
            
            if(r not in visited): 
                runner.add(r)
            elif(r in winner): 
                winner.remove(r)
                runner.add(r)
            elif(r in runner):
                runner.remove(r)
                lossers.add(r)
                
            
            visited.add(w)
            visited.add(r)        
        
        return [sorted([i for i in winner]), sorted([i for i in runner])]",FindPlayersWithZeroOneLosses.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\FindPlayersWithZeroOneLosses.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(27, 73)",N,function_definition,findWinners,,141,b08a5e0c-cf5b-497b-8afa-f3d533bbc276
"class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        
        a_set = set()
        b_set = set()
        
        ans = []
        prev_ans = 0
        
        for a, b in zip(A, B):
            if(a == b): prev_ans += 1
            if(a in b_set): prev_ans +=1
            if(b in a_set): prev_ans +=1
            
            a_set.add(a)
            b_set.add(b)
            ans.append(prev_ans)
        
        return ans
",findThePrefixCommonArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\findThePrefixCommonArray.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(19, 0)",N,module,module,,121,cceb3200-e9a4-4ddf-bf17-2704068cea45
"class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        
        a_set = set()
        b_set = set()
        
        ans = []
        prev_ans = 0
        
        for a, b in zip(A, B):
            if(a == b): prev_ans += 1
            if(a in b_set): prev_ans +=1
            if(b in a_set): prev_ans +=1
            
            a_set.add(a)
            b_set.add(b)
            ans.append(prev_ans)
        
        return ans",findThePrefixCommonArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\findThePrefixCommonArray.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 18)",N,class_definition,Solution,,120,c263b665-3070-430e-8225-de69d3b99f7e
"def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        
        a_set = set()
        b_set = set()
        
        ans = []
        prev_ans = 0
        
        for a, b in zip(A, B):
            if(a == b): prev_ans += 1
            if(a in b_set): prev_ans +=1
            if(b in a_set): prev_ans +=1
            
            a_set.add(a)
            b_set.add(b)
            ans.append(prev_ans)
        
        return ans",findThePrefixCommonArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\findThePrefixCommonArray.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(18, 18)",N,function_definition,findThePrefixCommonArray,,116,96cc3b79-229c-4a85-a2ca-3190a73c51a2
"class DoubllyLinkedListNode:

    def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next
    
    def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)

class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)

class MyHashSet:

    def __init__(self):
        self.cap = 101
        self.bucket = [DoubllyLinkedList() for i in range(self.cap)]
        

    def getBucketId(self, num):
        return hash(num)%self.cap

    def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))
        

    def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node) 

    def contains(self, key: int) -> bool:
        id = self.getBucketId(key)
        print(id, key)
        return self.bucket[id].contains(key)  


# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)
s = MyHashSet()
s.add(1)
s.add(2)
print(s.contains(1), s.contains(2))
s.remove(1)
print(s.contains(1), s.contains(2))



",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(123, 0)",N,module,module,,730,645d265e-f6e3-4bde-a1fb-fd25035c558e
"class DoubllyLinkedListNode:

    def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next
    
    def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/,module,Previous sibling does not exist,"class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)","(0, 0)","(8, 54)",N,class_definition,DoubllyLinkedListNode,,67,8963e7a2-ee5d-4b95-80b9-938a295a7370
"def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedListNode/,DoubllyLinkedListNode,Previous sibling does not exist,"def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)","(2, 4)","(5, 24)",N,function_definition,__init__,,33,3301c445-6ebe-43ae-b45a-219325ce38ba
"def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedListNode/,DoubllyLinkedListNode,"def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next",Next sibling does not exist,"(7, 4)","(8, 54)",N,function_definition,__str__,,24,e9b3a829-4bdb-4b46-9e3e-f78316fb445a
"class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/,module,"class DoubllyLinkedListNode:

    def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next
    
    def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)","class MyHashSet:

    def __init__(self):
        self.cap = 101
        self.bucket = [DoubllyLinkedList() for i in range(self.cap)]
        

    def getBucketId(self, num):
        return hash(num)%self.cap

    def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))
        

    def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node) 

    def contains(self, key: int) -> bool:
        id = self.getBucketId(key)
        print(id, key)
        return self.bucket[id].contains(key)","(10, 0)","(78, 29)",N,class_definition,DoubllyLinkedList,,392,cb2442bc-86c2-4d29-a6d4-fc1ec245b608
"def __init__(self):
        self.head = None
        self.tail = None",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,Previous sibling does not exist,"def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node","(12, 4)","(14, 24)",N,function_definition,__init__,,17,e90c09ca-e4fe-46c6-97f1-0e2e08d21645
"def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def __init__(self):
        self.head = None
        self.tail = None","def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node","(17, 4)","(24, 28)",N,function_definition,addNodeToHead,,63,63b6d405-b57b-46d5-b859-d065eff4c4a5
"def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node","def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None","(27, 4)","(34, 28)",N,function_definition,addNodeToTail,,63,af13ce69-0268-444f-8a24-93913f143da4
"def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node","def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False","(37, 4)","(47, 40)",N,function_definition,delete,,88,f74c2612-172c-463c-b638-8b47fb85dbb1
"def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None","def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None","(49, 4)","(55, 20)",N,function_definition,contains,,35,d641d3af-8856-4e92-b531-e4d0632990bc
"def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False","def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)","(57, 4)","(63, 19)",N,function_definition,getNode,,35,805a23a8-4994-41b6-b920-f617e1ed2685
"def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None","def __str__(self) -> str:
        return str(self.head)","(68, 4)","(75, 23)",N,function_definition,print,,53,72807588-4829-4e7d-99c5-7c648509ce20
"def __str__(self) -> str:
        return str(self.head)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)",Next sibling does not exist,"(77, 4)","(78, 29)",N,function_definition,__str__,,15,c65e8fca-ebcb-4771-8c03-ff1056edcd91
"class MyHashSet:

    def __init__(self):
        self.cap = 101
        self.bucket = [DoubllyLinkedList() for i in range(self.cap)]
        

    def getBucketId(self, num):
        return hash(num)%self.cap

    def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))
        

    def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node) 

    def contains(self, key: int) -> bool:
        id = self.getBucketId(key)
        print(id, key)
        return self.bucket[id].contains(key)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/,module,"class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)",# Your MyHashSet object will be instantiated and called as such:,"(80, 0)","(106, 44)",N,class_definition,MyHashSet,,189,235c587e-5a36-472e-bbc3-d4787b21efae
"def __init__(self):
        self.cap = 101
        self.bucket = [DoubllyLinkedList() for i in range(self.cap)]",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-MyHashSet/,MyHashSet,Previous sibling does not exist,"def getBucketId(self, num):
        return hash(num)%self.cap","(82, 4)","(84, 68)",N,function_definition,__init__,,30,26d14858-71b4-4177-91aa-e33fbee6c232
"def getBucketId(self, num):
        return hash(num)%self.cap",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-MyHashSet/,MyHashSet,"def __init__(self):
        self.cap = 101
        self.bucket = [DoubllyLinkedList() for i in range(self.cap)]","def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))","(87, 4)","(88, 33)",N,function_definition,getBucketId,,15,878039c5-8a6b-4c09-9528-3053cec5273e
"def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-MyHashSet/,MyHashSet,"def getBucketId(self, num):
        return hash(num)%self.cap","def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node)","(90, 4)","(94, 65)",N,function_definition,add,,51,6a4ed5f9-9802-47a4-9663-bc79437912e5
"def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-MyHashSet/,MyHashSet,"def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))","def contains(self, key: int) -> bool:
        id = self.getBucketId(key)
        print(id, key)
        return self.bucket[id].contains(key)","(97, 4)","(101, 36)",N,function_definition,remove,,45,aa8b60c1-1ff3-4b31-88fb-cf5f1fb97f3a
"def contains(self, key: int) -> bool:
        id = self.getBucketId(key)
        print(id, key)
        return self.bucket[id].contains(key)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-MyHashSet/,MyHashSet,"def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node)","# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)
s = MyHashSet()
s.add(1)
s.add(2)
print(s.contains(1), s.contains(2))
s.remove(1)
print(s.contains(1), s.contains(2))","(103, 4)","(106, 44)",N,function_definition,contains,,35,7d649dff-205f-48d4-9375-7e76b8e9b70c
"# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)
s = MyHashSet()
s.add(1)
s.add(2)
print(s.contains(1), s.contains(2))
s.remove(1)
print(s.contains(1), s.contains(2))",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/,module,"class MyHashSet:

    def __init__(self):
        self.cap = 101
        self.bucket = [DoubllyLinkedList() for i in range(self.cap)]
        

    def getBucketId(self, num):
        return hash(num)%self.cap

    def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))
        

    def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node) 

    def contains(self, key: int) -> bool:
        id = self.getBucketId(key)
        print(id, key)
        return self.bucket[id].contains(key)",Next sibling does not exist,"(109, 0)","(119, 35)",N,"comment,comment,comment,comment,comment,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement",comment,,80,68382fb4-0799-42df-a564-db57baf27b57
"class Solution:
    def __init__(self):
        self.vowles = set(['a', 'e', 'i', 'o', 'u'])
        
    def isVowelString(self, word):
        return word[0] in self.vowles and word[-1] in self.vowles
    
    def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        return sum(list(map(self.isVowelString, words[left:right+1])))
        
",vowelStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\vowelStrings.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(10, 0)",N,module,module,,105,b609b681-3881-4810-8b82-b6f3143515e3
"class Solution:
    def __init__(self):
        self.vowles = set(['a', 'e', 'i', 'o', 'u'])
        
    def isVowelString(self, word):
        return word[0] in self.vowles and word[-1] in self.vowles
    
    def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        return sum(list(map(self.isVowelString, words[left:right+1])))",vowelStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\vowelStrings.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(8, 70)",N,class_definition,Solution,,104,955744bd-0644-40c6-9490-f73e83b70f42
"def __init__(self):
        self.vowles = set(['a', 'e', 'i', 'o', 'u'])",vowelStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\vowelStrings.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def isVowelString(self, word):
        return word[0] in self.vowles and word[-1] in self.vowles","(1, 4)","(2, 52)",N,function_definition,__init__,,28,7f43ef05-9f30-41d4-b7ec-c0cbe18b42b2
"def isVowelString(self, word):
        return word[0] in self.vowles and word[-1] in self.vowles",vowelStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\vowelStrings.py,module/class_definition-Solution/,Solution,"def __init__(self):
        self.vowles = set(['a', 'e', 'i', 'o', 'u'])","def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        return sum(list(map(self.isVowelString, words[left:right+1])))","(4, 4)","(5, 65)",N,function_definition,isVowelString,,30,478f20d7-db31-491e-846b-1a46569d30da
"def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        return sum(list(map(self.isVowelString, words[left:right+1])))",vowelStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\vowelStrings.py,module/class_definition-Solution/,Solution,"def isVowelString(self, word):
        return word[0] in self.vowles and word[-1] in self.vowles",Next sibling does not exist,"(7, 4)","(8, 70)",N,function_definition,vowelStrings,,38,41f76bfa-be3b-4973-9196-fcdd19c541e0
"import java.util.Arrays;

public class Heap {

    private int[] heap;
    private int size;

    public Heap() {
        this.heap = new int[8];
        this.size = 0;
    }

    public Heap(int capacity) {
        this.heap = new int[capacity];
        this.size = 0;
    }

    private int getParentIndex(int index){
        return (index-1)/2;
    }

    private int getLeftChildIndex(int index){
        return 2*index + 1;
    }

    private int getRightChildIndex(int index){
        return 2*index + 2;
    }

    public int peek() {
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        return this.heap[0];
    }

     public int poll(){
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        swapElements(0, this.size-1);
        int val = this.heap[size-1];
        size--;
        heapifyDown();
        return val;
    }

    public void insert(int val){
        increaseSize();
        heap[size] = val;
        size++;
        heapifyUp();
    }

    private void heapifyUp() {
        int curIndex = this.size - 1;
        while (curIndex>0 && this.heap[getParentIndex(curIndex)] > this.heap[curIndex]) {
            swapElements(getParentIndex(curIndex), curIndex);
            curIndex = getParentIndex(curIndex);
        }
    }

    private void heapifyDown() {
        int curIndex = 0;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }

    private void heapifyDown(int index) {
        int curIndex = index;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }

    private void increaseSize() {
        if(size<heap.length) return;

        int curSize = heap.length;
        int[] arr = new int[2*curSize];
        System.arraycopy(heap, 0, arr, 0, curSize);
        heap = arr;
    }

    private void swapElements(int sourceIndex, int destinationIndex) {
        if(sourceIndex>=this.heap.length || destinationIndex>=this.heap.length) throw new IllegalStateException();

        int temp = this.heap[sourceIndex];
        this.heap[sourceIndex] = this.heap[destinationIndex];
        this.heap[destinationIndex] = temp;
    }

    @Override
    public String toString(){
        return Arrays.toString(this.heap);
    }

    public boolean isEmpty() {
        return this.size == 0;
    }
}
",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(126, 0)",N,program,program,,743,13ee4a52-3df2-489a-8b72-a69bf42ab623
import java.util.Arrays;,Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/,program,Previous sibling does not exist,"public class Heap {

    private int[] heap;
    private int size;

    public Heap() {
        this.heap = new int[8];
        this.size = 0;
    }

    public Heap(int capacity) {
        this.heap = new int[capacity];
        this.size = 0;
    }

    private int getParentIndex(int index){
        return (index-1)/2;
    }

    private int getLeftChildIndex(int index){
        return 2*index + 1;
    }

    private int getRightChildIndex(int index){
        return 2*index + 2;
    }

    public int peek() {
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        return this.heap[0];
    }

     public int poll(){
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        swapElements(0, this.size-1);
        int val = this.heap[size-1];
        size--;
        heapifyDown();
        return val;
    }

    public void insert(int val){
        increaseSize();
        heap[size] = val;
        size++;
        heapifyUp();
    }

    private void heapifyUp() {
        int curIndex = this.size - 1;
        while (curIndex>0 && this.heap[getParentIndex(curIndex)] > this.heap[curIndex]) {
            swapElements(getParentIndex(curIndex), curIndex);
            curIndex = getParentIndex(curIndex);
        }
    }

    private void heapifyDown() {
        int curIndex = 0;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }

    private void heapifyDown(int index) {
        int curIndex = index;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }

    private void increaseSize() {
        if(size<heap.length) return;

        int curSize = heap.length;
        int[] arr = new int[2*curSize];
        System.arraycopy(heap, 0, arr, 0, curSize);
        heap = arr;
    }

    private void swapElements(int sourceIndex, int destinationIndex) {
        if(sourceIndex>=this.heap.length || destinationIndex>=this.heap.length) throw new IllegalStateException();

        int temp = this.heap[sourceIndex];
        this.heap[sourceIndex] = this.heap[destinationIndex];
        this.heap[destinationIndex] = temp;
    }

    @Override
    public String toString(){
        return Arrays.toString(this.heap);
    }

    public boolean isEmpty() {
        return this.size == 0;
    }
}","(0, 0)","(0, 24)",N,import_declaration,import_declaration,,5,ed463ac2-50de-437e-be82-0b723f034f94
"public class Heap {

    private int[] heap;
    private int size;

    public Heap() {
        this.heap = new int[8];
        this.size = 0;
    }

    public Heap(int capacity) {
        this.heap = new int[capacity];
        this.size = 0;
    }

    private int getParentIndex(int index){
        return (index-1)/2;
    }

    private int getLeftChildIndex(int index){
        return 2*index + 1;
    }

    private int getRightChildIndex(int index){
        return 2*index + 2;
    }

    public int peek() {
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        return this.heap[0];
    }

     public int poll(){
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        swapElements(0, this.size-1);
        int val = this.heap[size-1];
        size--;
        heapifyDown();
        return val;
    }

    public void insert(int val){
        increaseSize();
        heap[size] = val;
        size++;
        heapifyUp();
    }

    private void heapifyUp() {
        int curIndex = this.size - 1;
        while (curIndex>0 && this.heap[getParentIndex(curIndex)] > this.heap[curIndex]) {
            swapElements(getParentIndex(curIndex), curIndex);
            curIndex = getParentIndex(curIndex);
        }
    }

    private void heapifyDown() {
        int curIndex = 0;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }

    private void heapifyDown(int index) {
        int curIndex = index;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }

    private void increaseSize() {
        if(size<heap.length) return;

        int curSize = heap.length;
        int[] arr = new int[2*curSize];
        System.arraycopy(heap, 0, arr, 0, curSize);
        heap = arr;
    }

    private void swapElements(int sourceIndex, int destinationIndex) {
        if(sourceIndex>=this.heap.length || destinationIndex>=this.heap.length) throw new IllegalStateException();

        int temp = this.heap[sourceIndex];
        this.heap[sourceIndex] = this.heap[destinationIndex];
        this.heap[destinationIndex] = temp;
    }

    @Override
    public String toString(){
        return Arrays.toString(this.heap);
    }

    public boolean isEmpty() {
        return this.size == 0;
    }
}",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/,program,import java.util.Arrays;,"private int[] heap;
private int size;","(2, 0)","(125, 1)",N,class_declaration,Heap,,738,3331f1a8-722c-431a-a903-e02500a34e73
"private int[] heap;
private int size;",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,Previous sibling does not exist,"public Heap() {
        this.heap = new int[8];
        this.size = 0;
    }","(4, 4)","(5, 21)",N,"field_declaration,field_declaration",field_declaration,,9,5306796f-99db-40bf-a6cb-497799a9eab8
"public Heap() {
        this.heap = new int[8];
        this.size = 0;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private int[] heap;
private int size;","public Heap(int capacity) {
        this.heap = new int[capacity];
        this.size = 0;
    }","(7, 4)","(10, 5)",N,constructor_declaration,Heap,,22,a8641ef4-48da-49b3-84de-8e788c272a1c
"public Heap(int capacity) {
        this.heap = new int[capacity];
        this.size = 0;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"public Heap() {
        this.heap = new int[8];
        this.size = 0;
    }","private int getParentIndex(int index){
        return (index-1)/2;
    }","(12, 4)","(15, 5)",N,constructor_declaration,Heap,,24,eba3d6e8-1bc5-46c8-843c-decfffb15a46
"private int getParentIndex(int index){
        return (index-1)/2;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"public Heap(int capacity) {
        this.heap = new int[capacity];
        this.size = 0;
    }","private int getLeftChildIndex(int index){
        return 2*index + 1;
    }","(17, 4)","(19, 5)",N,method_declaration,getParentIndex,,18,5fdf1756-97ce-49e8-a252-15974b4d39ce
"private int getLeftChildIndex(int index){
        return 2*index + 1;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private int getParentIndex(int index){
        return (index-1)/2;
    }","private int getRightChildIndex(int index){
        return 2*index + 2;
    }","(21, 4)","(23, 5)",N,method_declaration,getLeftChildIndex,,20,bced827e-b599-4d9a-aca3-da53ef9dd6cf
"private int getRightChildIndex(int index){
        return 2*index + 2;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private int getLeftChildIndex(int index){
        return 2*index + 1;
    }","public int peek() {
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        return this.heap[0];
    }","(25, 4)","(27, 5)",N,method_declaration,getRightChildIndex,,20,edd2778f-4386-495d-930a-b5ad3808fbb5
"public int peek() {
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        return this.heap[0];
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private int getRightChildIndex(int index){
        return 2*index + 2;
    }","public int poll(){
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        swapElements(0, this.size-1);
        int val = this.heap[size-1];
        size--;
        heapifyDown();
        return val;
    }","(29, 4)","(32, 5)",N,method_declaration,peek,,31,514da02e-440f-4b4b-a91c-c57ed0112df7
"public int poll(){
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        swapElements(0, this.size-1);
        int val = this.heap[size-1];
        size--;
        heapifyDown();
        return val;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"public int peek() {
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        return this.heap[0];
    }","public void insert(int val){
        increaseSize();
        heap[size] = val;
        size++;
        heapifyUp();
    }","(34, 5)","(41, 5)",N,method_declaration,poll,,56,34d53d35-55c7-487b-82d4-9147f5953e8d
"public void insert(int val){
        increaseSize();
        heap[size] = val;
        size++;
        heapifyUp();
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"public int poll(){
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        swapElements(0, this.size-1);
        int val = this.heap[size-1];
        size--;
        heapifyDown();
        return val;
    }","private void heapifyUp() {
        int curIndex = this.size - 1;
        while (curIndex>0 && this.heap[getParentIndex(curIndex)] > this.heap[curIndex]) {
            swapElements(getParentIndex(curIndex), curIndex);
            curIndex = getParentIndex(curIndex);
        }
    }","(43, 4)","(48, 5)",N,method_declaration,insert,,27,0504bc2d-ff72-4a69-a7b6-799d510d8bf8
"private void heapifyUp() {
        int curIndex = this.size - 1;
        while (curIndex>0 && this.heap[getParentIndex(curIndex)] > this.heap[curIndex]) {
            swapElements(getParentIndex(curIndex), curIndex);
            curIndex = getParentIndex(curIndex);
        }
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"public void insert(int val){
        increaseSize();
        heap[size] = val;
        size++;
        heapifyUp();
    }","private void heapifyDown() {
        int curIndex = 0;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }","(50, 4)","(56, 5)",N,method_declaration,heapifyUp,,66,43348c32-7ca6-40ee-89b6-a879e03338f6
"private void heapifyDown() {
        int curIndex = 0;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private void heapifyUp() {
        int curIndex = this.size - 1;
        while (curIndex>0 && this.heap[getParentIndex(curIndex)] > this.heap[curIndex]) {
            swapElements(getParentIndex(curIndex), curIndex);
            curIndex = getParentIndex(curIndex);
        }
    }","private void heapifyDown(int index) {
        int curIndex = index;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }","(58, 4)","(77, 5)",N,method_declaration,heapifyDown,,132,052d2c65-90f2-4704-b7e8-030e1ed45239
"private void heapifyDown(int index) {
        int curIndex = index;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private void heapifyDown() {
        int curIndex = 0;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }","private void increaseSize() {
        if(size<heap.length) return;

        int curSize = heap.length;
        int[] arr = new int[2*curSize];
        System.arraycopy(heap, 0, arr, 0, curSize);
        heap = arr;
    }","(79, 4)","(98, 5)",N,method_declaration,heapifyDown,,133,195aa45b-3bf5-4218-b87b-6e0176b90363
"private void increaseSize() {
        if(size<heap.length) return;

        int curSize = heap.length;
        int[] arr = new int[2*curSize];
        System.arraycopy(heap, 0, arr, 0, curSize);
        heap = arr;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private void heapifyDown(int index) {
        int curIndex = index;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }","private void swapElements(int sourceIndex, int destinationIndex) {
        if(sourceIndex>=this.heap.length || destinationIndex>=this.heap.length) throw new IllegalStateException();

        int temp = this.heap[sourceIndex];
        this.heap[sourceIndex] = this.heap[destinationIndex];
        this.heap[destinationIndex] = temp;
    }","(100, 4)","(107, 5)",N,method_declaration,increaseSize,,59,5f7d233f-65b7-45cc-b53d-4eb100abf494
"private void swapElements(int sourceIndex, int destinationIndex) {
        if(sourceIndex>=this.heap.length || destinationIndex>=this.heap.length) throw new IllegalStateException();

        int temp = this.heap[sourceIndex];
        this.heap[sourceIndex] = this.heap[destinationIndex];
        this.heap[destinationIndex] = temp;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private void increaseSize() {
        if(size<heap.length) return;

        int curSize = heap.length;
        int[] arr = new int[2*curSize];
        System.arraycopy(heap, 0, arr, 0, curSize);
        heap = arr;
    }","@Override
    public String toString(){
        return Arrays.toString(this.heap);
    }","(109, 4)","(115, 5)",N,method_declaration,swapElements,,67,93bfb3c4-6702-4edb-9626-737bb77ca711
"@Override
    public String toString(){
        return Arrays.toString(this.heap);
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private void swapElements(int sourceIndex, int destinationIndex) {
        if(sourceIndex>=this.heap.length || destinationIndex>=this.heap.length) throw new IllegalStateException();

        int temp = this.heap[sourceIndex];
        this.heap[sourceIndex] = this.heap[destinationIndex];
        this.heap[destinationIndex] = temp;
    }","public boolean isEmpty() {
        return this.size == 0;
    }","(117, 4)","(120, 5)",N,method_declaration,toString,,16,e6818d2c-faea-493d-927b-7201465c921d
"public boolean isEmpty() {
        return this.size == 0;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"@Override
    public String toString(){
        return Arrays.toString(this.heap);
    }",Next sibling does not exist,"(122, 4)","(124, 5)",N,method_declaration,isEmpty,,15,817e2e23-c4bc-4234-b0c2-295dc1b55508
"from math import inf


class  Heap:

    def __init__(self, capacity = 8):
        self.capacity = capacity # number of elements it can hold/store currently
        self.size = 0 # number of elements it's actually storing/present currently
        self.heap = [None for _ in range(self.capacity)]

    # main heap operations
    def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)

    def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]
    
    def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]

    def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()

    # heap helper functions
    def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex 

    def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex

    # index calculation helper functions
    @staticmethod
    def leftIndex(index): 
        return 2 * index + 1

    @staticmethod
    def rightIndex(index): 
        return 2 * index + 2

    @staticmethod
    def parentIndex(index): 
        return (index -1)//2

    def isIndexInRange(self, index): 
        return index < self.capacity

    def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))

    def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))

    def hasParent(self, index): 
        return index != 0


heap = Heap()
for i in range(10, -1, -1): 
    heap.add(i)
    print(heap.peek())

heap.decreaseKey(5)
while(heap.size > 0): print(heap.peek(), heap.pop())
",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(100, 0)",N,module,module,,724,a44261f1-9f7c-48bc-b56f-e5ecb479533d
from math import inf,heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/,module,Previous sibling does not exist,"class  Heap:

    def __init__(self, capacity = 8):
        self.capacity = capacity # number of elements it can hold/store currently
        self.size = 0 # number of elements it's actually storing/present currently
        self.heap = [None for _ in range(self.capacity)]

    # main heap operations
    def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)

    def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]
    
    def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]

    def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()

    # heap helper functions
    def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex 

    def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex

    # index calculation helper functions
    @staticmethod
    def leftIndex(index): 
        return 2 * index + 1

    @staticmethod
    def rightIndex(index): 
        return 2 * index + 2

    @staticmethod
    def parentIndex(index): 
        return (index -1)//2

    def isIndexInRange(self, index): 
        return index < self.capacity

    def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))

    def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))

    def hasParent(self, index): 
        return index != 0","(0, 0)","(0, 20)",N,import_from_statement,import_from_statement,,4,bd72dca8-47e7-454f-9f9c-65cab65c3cd9
"class  Heap:

    def __init__(self, capacity = 8):
        self.capacity = capacity # number of elements it can hold/store currently
        self.size = 0 # number of elements it's actually storing/present currently
        self.heap = [None for _ in range(self.capacity)]

    # main heap operations
    def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)

    def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]
    
    def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]

    def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()

    # heap helper functions
    def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex 

    def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex

    # index calculation helper functions
    @staticmethod
    def leftIndex(index): 
        return 2 * index + 1

    @staticmethod
    def rightIndex(index): 
        return 2 * index + 2

    @staticmethod
    def parentIndex(index): 
        return (index -1)//2

    def isIndexInRange(self, index): 
        return index < self.capacity

    def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))

    def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))

    def hasParent(self, index): 
        return index != 0",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/,module,from math import inf,heap = Heap(),"(3, 0)","(90, 25)",N,class_definition,Heap,,669,8b5242b6-4e0c-49e2-9ee6-dfaf392dce09
"def __init__(self, capacity = 8):
        self.capacity = capacity # number of elements it can hold/store currently
        self.size = 0 # number of elements it's actually storing/present currently
        self.heap = [None for _ in range(self.capacity)]",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,Previous sibling does not exist,# main heap operations,"(5, 4)","(8, 56)",N,function_definition,__init__,,57,8a9e7519-e9fa-4f13-b360-e1dd49edff07
# main heap operations,heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def __init__(self, capacity = 8):
        self.capacity = capacity # number of elements it can hold/store currently
        self.size = 0 # number of elements it's actually storing/present currently
        self.heap = [None for _ in range(self.capacity)]","def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)","(10, 4)","(10, 26)",N,comment,comment,,4,02546b43-d8a8-43ed-b0fa-71e082bc53ea
"def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,# main heap operations,"def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]","(11, 4)","(22, 35)",N,function_definition,add,,95,432fcdb1-1d8b-49d0-a48b-1939120ebb3e
"def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)","def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]","(24, 4)","(27, 27)",N,function_definition,peek,,36,ee07eaea-0b83-4852-af54-04ac8c0540d7
"def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]","def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()","(29, 4)","(35, 35)",N,function_definition,pop,,69,b7b274a0-c43a-4aea-aff9-c10b79c02605
"def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]",# heap helper functions,"(37, 4)","(42, 18)",N,function_definition,decreaseKey,,44,7ebb0511-5591-4c0b-8298-42c87bb4beaa
# heap helper functions,heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()","def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex","(44, 4)","(44, 27)",N,comment,comment,,4,88e099cf-7058-4012-af5a-8a9d7868790b
"def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,# heap helper functions,"def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex","(45, 4)","(51, 31)",N,function_definition,heapifyUp,,64,d67882d7-e42f-43c9-a949-0b85291d2493
"def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex",# index calculation helper functions,"(53, 4)","(65, 33)",N,function_definition,heapifyDown,,133,a9e5caf2-0c18-4c67-b870-3ff942ca490c
# index calculation helper functions,heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex","@staticmethod
    def leftIndex(index): 
        return 2 * index + 1","(67, 4)","(67, 40)",N,comment,comment,,5,28f0df60-f63d-42d6-a270-86cd8bb5654f
"@staticmethod
    def leftIndex(index): 
        return 2 * index + 1",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,# index calculation helper functions,"@staticmethod
    def rightIndex(index): 
        return 2 * index + 2","(68, 4)","(70, 28)",N,function_definition,"def leftIndex(index): 
        return 2 * index + 1",,19,c374ca5c-9598-4382-ac18-d1bb31a495fc
"@staticmethod
    def rightIndex(index): 
        return 2 * index + 2",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"@staticmethod
    def leftIndex(index): 
        return 2 * index + 1","@staticmethod
    def parentIndex(index): 
        return (index -1)//2","(72, 4)","(74, 28)",N,function_definition,"def rightIndex(index): 
        return 2 * index + 2",,19,4a8cba07-b31d-4ebc-901a-ebde7cce0bf7
"@staticmethod
    def parentIndex(index): 
        return (index -1)//2",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"@staticmethod
    def rightIndex(index): 
        return 2 * index + 2","def isIndexInRange(self, index): 
        return index < self.capacity","(76, 4)","(78, 28)",N,function_definition,"def parentIndex(index): 
        return (index -1)//2",,18,b6e703e1-8c65-47fe-8e1f-a62945075069
"def isIndexInRange(self, index): 
        return index < self.capacity",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"@staticmethod
    def parentIndex(index): 
        return (index -1)//2","def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))","(80, 4)","(81, 36)",N,function_definition,isIndexInRange,,15,d1135aa0-4cda-468b-a3d4-9d985a5e4060
"def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def isIndexInRange(self, index): 
        return index < self.capacity","def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))","(83, 4)","(84, 57)",N,function_definition,hasLeftChild,,21,60926868-16de-468f-be06-23e89e442666
"def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))","def hasParent(self, index): 
        return index != 0","(86, 4)","(87, 58)",N,function_definition,hasRightChild,,21,d9819aef-096a-425a-b1f2-272307dd799f
"def hasParent(self, index): 
        return index != 0",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))","heap = Heap()
for i in range(10, -1, -1): 
    heap.add(i)
    print(heap.peek())
heap.decreaseKey(5)
while(heap.size > 0): print(heap.peek(), heap.pop())","(89, 4)","(90, 25)",N,function_definition,hasParent,,14,63115f25-1f2c-4ab0-82e1-50936a7270bf
"heap = Heap()
for i in range(10, -1, -1): 
    heap.add(i)
    print(heap.peek())
heap.decreaseKey(5)
while(heap.size > 0): print(heap.peek(), heap.pop())",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/,module,"class  Heap:

    def __init__(self, capacity = 8):
        self.capacity = capacity # number of elements it can hold/store currently
        self.size = 0 # number of elements it's actually storing/present currently
        self.heap = [None for _ in range(self.capacity)]

    # main heap operations
    def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)

    def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]
    
    def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]

    def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()

    # heap helper functions
    def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex 

    def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex

    # index calculation helper functions
    @staticmethod
    def leftIndex(index): 
        return 2 * index + 1

    @staticmethod
    def rightIndex(index): 
        return 2 * index + 2

    @staticmethod
    def parentIndex(index): 
        return (index -1)//2

    def isIndexInRange(self, index): 
        return index < self.capacity

    def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))

    def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))

    def hasParent(self, index): 
        return index != 0",Next sibling does not exist,"(93, 0)","(99, 52)",N,"expression_statement,for_statement,expression_statement,while_statement",expression_statement,,49,44daabf0-14ea-407c-ad6f-c1d3e59ec262
"class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:

        N = len(nums1)
        M = len(nums2)
        
        row_index = 0
        col_index = 0

        ans = []
        visited = set()
        visited.add((0, 0))
        heap = [(nums1[row_index]+nums2[col_index], row_index, col_index)]
        heapify(heap)

        while(k and heap):
            _, x, y = heappop(heap)
            ans.append([nums1[x], nums2[y]])
            k -= 1
            if(k == 0): return ans

            if(x+1 < N and (x+1, y) not in visited): 
                heappush(heap, (nums1[x+1]+nums2[y], x+1, y))
                visited.add((x+1, y))
            if(y+1 < M and (x, y+1) not in visited): 
                heappush(heap, (nums1[x]+nums2[y+1], x, y+1))
                visited.add((x, y+1))
        
        return ans


",kSmallestSumPairs.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\kSmallestSumPairs.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 0)",N,module,module,,261,1fa15b51-3c20-4f5f-8347-161eb7fb7b39
"class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:

        N = len(nums1)
        M = len(nums2)
        
        row_index = 0
        col_index = 0

        ans = []
        visited = set()
        visited.add((0, 0))
        heap = [(nums1[row_index]+nums2[col_index], row_index, col_index)]
        heapify(heap)

        while(k and heap):
            _, x, y = heappop(heap)
            ans.append([nums1[x], nums2[y]])
            k -= 1
            if(k == 0): return ans

            if(x+1 < N and (x+1, y) not in visited): 
                heappush(heap, (nums1[x+1]+nums2[y], x+1, y))
                visited.add((x+1, y))
            if(y+1 < M and (x, y+1) not in visited): 
                heappush(heap, (nums1[x]+nums2[y+1], x, y+1))
                visited.add((x, y+1))
        
        return ans",kSmallestSumPairs.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\kSmallestSumPairs.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 18)",N,class_definition,Solution,,260,ab0e8185-dbe2-4ed4-914c-3a9ffebd25de
"def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:

        N = len(nums1)
        M = len(nums2)
        
        row_index = 0
        col_index = 0

        ans = []
        visited = set()
        visited.add((0, 0))
        heap = [(nums1[row_index]+nums2[col_index], row_index, col_index)]
        heapify(heap)

        while(k and heap):
            _, x, y = heappop(heap)
            ans.append([nums1[x], nums2[y]])
            k -= 1
            if(k == 0): return ans

            if(x+1 < N and (x+1, y) not in visited): 
                heappush(heap, (nums1[x+1]+nums2[y], x+1, y))
                visited.add((x+1, y))
            if(y+1 < M and (x, y+1) not in visited): 
                heappush(heap, (nums1[x]+nums2[y+1], x, y+1))
                visited.add((x, y+1))
        
        return ans",kSmallestSumPairs.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\kSmallestSumPairs.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(28, 18)",N,function_definition,kSmallestPairs,,256,0ff2cce5-20ce-4d78-8154-56305240dd16
"class Solution {
    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {
            long[] prefixsum = new long[runningCosts.length];
            PriorityQueue<Long> queue = new PriorityQueue<>(Collections.reverseOrder());

            prefixsum[0] = runningCosts[0];
            for(int i=1;i<runningCosts.length;i++){
                prefixsum[i] += prefixsum[i-1] + runningCosts[i];
            }


            int start = 0;
            int end = 1;
            int ans = 0;
            queue.add((long) chargeTimes[0]);


            while(start <= end && start<prefixsum.length && end<=prefixsum.length){

                long chargeCost = queue.peek() == null ? 0 : queue.peek();
                long curCost = chargeCost + (end-start) * (prefixsum[end-1]-prefixsum[start]+runningCosts[start]);

                if(curCost<=budget) {
                    ans = Math.max(ans, end-start);
                    if(end<chargeTimes.length) queue.add((long) chargeTimes[end]);
                    end++;
                }
                else {
                    queue.remove((long) chargeTimes[start]);
                    start++;
                }
            }

            return ans;
    }
}
",MaximumRobots.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\MaximumRobots.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(36, 0)",N,program,program,,262,141fb377-ec00-4acc-8b57-5d53239b0005
"class Solution {
    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {
            long[] prefixsum = new long[runningCosts.length];
            PriorityQueue<Long> queue = new PriorityQueue<>(Collections.reverseOrder());

            prefixsum[0] = runningCosts[0];
            for(int i=1;i<runningCosts.length;i++){
                prefixsum[i] += prefixsum[i-1] + runningCosts[i];
            }


            int start = 0;
            int end = 1;
            int ans = 0;
            queue.add((long) chargeTimes[0]);


            while(start <= end && start<prefixsum.length && end<=prefixsum.length){

                long chargeCost = queue.peek() == null ? 0 : queue.peek();
                long curCost = chargeCost + (end-start) * (prefixsum[end-1]-prefixsum[start]+runningCosts[start]);

                if(curCost<=budget) {
                    ans = Math.max(ans, end-start);
                    if(end<chargeTimes.length) queue.add((long) chargeTimes[end]);
                    end++;
                }
                else {
                    queue.remove((long) chargeTimes[start]);
                    start++;
                }
            }

            return ans;
    }
}",MaximumRobots.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\MaximumRobots.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(35, 1)",N,class_declaration,Solution,,262,93d2b1f5-9ff1-4672-b204-4f3b8d5fe29d
"public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {
            long[] prefixsum = new long[runningCosts.length];
            PriorityQueue<Long> queue = new PriorityQueue<>(Collections.reverseOrder());

            prefixsum[0] = runningCosts[0];
            for(int i=1;i<runningCosts.length;i++){
                prefixsum[i] += prefixsum[i-1] + runningCosts[i];
            }


            int start = 0;
            int end = 1;
            int ans = 0;
            queue.add((long) chargeTimes[0]);


            while(start <= end && start<prefixsum.length && end<=prefixsum.length){

                long chargeCost = queue.peek() == null ? 0 : queue.peek();
                long curCost = chargeCost + (end-start) * (prefixsum[end-1]-prefixsum[start]+runningCosts[start]);

                if(curCost<=budget) {
                    ans = Math.max(ans, end-start);
                    if(end<chargeTimes.length) queue.add((long) chargeTimes[end]);
                    end++;
                }
                else {
                    queue.remove((long) chargeTimes[start]);
                    start++;
                }
            }

            return ans;
    }",MaximumRobots.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\MaximumRobots.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(34, 5)",N,method_declaration,maximumRobots,,257,8a376cf1-11d1-47b2-979b-a9c857478b41
"class Solution:
    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:
        
        N = len(reward1) 
        heap = []
        heapify(heap)
        visited = [False for i in range(N)]
        ans = 0
        
        for index, [rewarda, rewardb] in enumerate(zip(reward1, reward2)):
            heappush(heap, [rewardb-rewarda, index])
        
        while(k>0):
            diff, index = heappop(heap)
            visited[index] = True
            ans += reward1[index]
            k-=1
        
        for index in range(N):
            if(not visited[index]): ans += reward2[index]
        
        return ans
        
",miceAndCheese.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\miceAndCheese.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,module,module,,162,ebe5d01d-3e77-4221-a71d-6dc73e4dda06
"class Solution:
    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:
        
        N = len(reward1) 
        heap = []
        heapify(heap)
        visited = [False for i in range(N)]
        ans = 0
        
        for index, [rewarda, rewardb] in enumerate(zip(reward1, reward2)):
            heappush(heap, [rewardb-rewarda, index])
        
        while(k>0):
            diff, index = heappop(heap)
            visited[index] = True
            ans += reward1[index]
            k-=1
        
        for index in range(N):
            if(not visited[index]): ans += reward2[index]
        
        return ans",miceAndCheese.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\miceAndCheese.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 18)",N,class_definition,Solution,,161,525bb01b-72c8-441a-beb9-1db639931b76
"def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:
        
        N = len(reward1) 
        heap = []
        heapify(heap)
        visited = [False for i in range(N)]
        ans = 0
        
        for index, [rewarda, rewardb] in enumerate(zip(reward1, reward2)):
            heappush(heap, [rewardb-rewarda, index])
        
        while(k>0):
            diff, index = heappop(heap)
            visited[index] = True
            ans += reward1[index]
            k-=1
        
        for index in range(N):
            if(not visited[index]): ans += reward2[index]
        
        return ans",miceAndCheese.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\miceAndCheese.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(21, 18)",N,function_definition,miceAndCheese,,157,5aa89a00-4611-479f-b2bf-8ae6f689b146
"# just playing with Comparable classes in python
class Person:

    def __init__(self, name, age, nationality):
        self.name = name
        self.age = age
        self.nationality = nationality
    

    def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'
    
    def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0 
    
    def __lt__(self, __value):
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + str(type(__value)))
        return self.age - __value.age < 0 

Person1 = Person(""akarsh"", 22, ""indian"")
Person2 = Person(""maitrey"", 21, ""american"")
Person3 = Person(""Elon Musk"", 50, ""South African"")


persons = [Person1, Person2, Person3]
for person in persons: print(person)
persons.sort()
for person in persons: print(person)
print(Person1 > Person2, Person2 > Person3)
",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 0)",N,module,module,,265,d60c5eef-c686-4c58-a7e2-482a92677f0a
# just playing with Comparable classes in python,person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/,module,Previous sibling does not exist,"class Person:

    def __init__(self, name, age, nationality):
        self.name = name
        self.age = age
        self.nationality = nationality
    

    def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'
    
    def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0 
    
    def __lt__(self, __value):
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + str(type(__value)))
        return self.age - __value.age < 0","(0, 0)","(0, 48)",N,comment,comment,,8,9328d559-f7e1-426d-8462-f0ccbf1cef40
"class Person:

    def __init__(self, name, age, nationality):
        self.name = name
        self.age = age
        self.nationality = nationality
    

    def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'
    
    def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0 
    
    def __lt__(self, __value):
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + str(type(__value)))
        return self.age - __value.age < 0",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/,module,# just playing with Comparable classes in python,"Person1 = Person(""akarsh"", 22, ""indian"")","(1, 0)","(18, 41)",N,class_definition,Person,,164,719b8637-a72c-4f6f-a999-d412c511db2c
"def __init__(self, name, age, nationality):
        self.name = name
        self.age = age
        self.nationality = nationality",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/class_definition-Person/,Person,Previous sibling does not exist,"def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'","(3, 4)","(6, 38)",N,function_definition,__init__,,31,acdb70fa-0476-4b22-8619-7a471ed9ce16
"def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/class_definition-Person/,Person,"def __init__(self, name, age, nationality):
        self.name = name
        self.age = age
        self.nationality = nationality","def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0","(9, 4)","(10, 94)",N,function_definition,__str__,,33,46e551d7-47c5-4661-8553-6889c20a8a38
"def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/class_definition-Person/,Person,"def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'","def __lt__(self, __value):
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + str(type(__value)))
        return self.age - __value.age < 0","(12, 4)","(14, 42)",N,function_definition,__eq__,,47,f2a0c3ad-ba86-4850-8edb-4bc014473b0a
"def __lt__(self, __value):
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + str(type(__value)))
        return self.age - __value.age < 0",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/class_definition-Person/,Person,"def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0","Person1 = Person(""akarsh"", 22, ""indian"")
Person2 = Person(""maitrey"", 21, ""american"")
Person3 = Person(""Elon Musk"", 50, ""South African"")
persons = [Person1, Person2, Person3]
for person in persons: print(person)
persons.sort()
for person in persons: print(person)
print(Person1 > Person2, Person2 > Person3)","(16, 4)","(18, 41)",N,function_definition,__lt__,,43,efa56280-b290-4796-934e-fb03e7210a34
"Person1 = Person(""akarsh"", 22, ""indian"")
Person2 = Person(""maitrey"", 21, ""american"")
Person3 = Person(""Elon Musk"", 50, ""South African"")
persons = [Person1, Person2, Person3]
for person in persons: print(person)
persons.sort()
for person in persons: print(person)
print(Person1 > Person2, Person2 > Person3)",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/,module,"class Person:

    def __init__(self, name, age, nationality):
        self.name = name
        self.age = age
        self.nationality = nationality
    

    def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'
    
    def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0 
    
    def __lt__(self, __value):
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + str(type(__value)))
        return self.age - __value.age < 0",Next sibling does not exist,"(20, 0)","(29, 43)",N,"expression_statement,expression_statement,expression_statement,expression_statement,for_statement,expression_statement,for_statement,expression_statement",expression_statement,,91,d231a095-377a-45cd-8c7b-e8658a74d810
"class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:

        def scheduleTask(heap, t, ans):
            taskProcesstingTime, index = heappop(heap)
            t += taskProcesstingTime
            ans.append(index)
            return t

        new = []
        for index,task in enumerate(tasks):
            task.append(index)
            new.append(task)
        tasks = new
    
        tasks.sort(key=lambda x:(x[0]))
        index = 0
        N = len(tasks)

        t = 1
        heap = []
        heapify(heap)
        ans = []

        while(index<N):
            # tasks whose enqueue time is less than equal to t 
            # add them to pq
            while(index<N and tasks[index][0]<=t):
                heappush(heap, [tasks[index][1], tasks[index][2]])
                index += 1
            
            if(heap): t = scheduleTask(heap, t, ans)
            else: t = tasks[index][0]
        
        while(heap): t = scheduleTask(heap, t, ans)

        return ans



",SingleThreadedCPU.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\SingleThreadedCPU.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(40, 0)",N,module,module,,235,35c07452-0655-4081-ac2b-b7817ce25880
"class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:

        def scheduleTask(heap, t, ans):
            taskProcesstingTime, index = heappop(heap)
            t += taskProcesstingTime
            ans.append(index)
            return t

        new = []
        for index,task in enumerate(tasks):
            task.append(index)
            new.append(task)
        tasks = new
    
        tasks.sort(key=lambda x:(x[0]))
        index = 0
        N = len(tasks)

        t = 1
        heap = []
        heapify(heap)
        ans = []

        while(index<N):
            # tasks whose enqueue time is less than equal to t 
            # add them to pq
            while(index<N and tasks[index][0]<=t):
                heappush(heap, [tasks[index][1], tasks[index][2]])
                index += 1
            
            if(heap): t = scheduleTask(heap, t, ans)
            else: t = tasks[index][0]
        
        while(heap): t = scheduleTask(heap, t, ans)

        return ans",SingleThreadedCPU.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\SingleThreadedCPU.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(36, 18)",N,class_definition,Solution,,234,0dd1a407-00a1-4873-a6d6-f98d2857b12a
"def getOrder(self, tasks: List[List[int]]) -> List[int]:

        def scheduleTask(heap, t, ans):
            taskProcesstingTime, index = heappop(heap)
            t += taskProcesstingTime
            ans.append(index)
            return t

        new = []
        for index,task in enumerate(tasks):
            task.append(index)
            new.append(task)
        tasks = new
    
        tasks.sort(key=lambda x:(x[0]))
        index = 0
        N = len(tasks)

        t = 1
        heap = []
        heapify(heap)
        ans = []

        while(index<N):
            # tasks whose enqueue time is less than equal to t 
            # add them to pq
            while(index<N and tasks[index][0]<=t):
                heappush(heap, [tasks[index][1], tasks[index][2]])
                index += 1
            
            if(heap): t = scheduleTask(heap, t, ans)
            else: t = tasks[index][0]
        
        while(heap): t = scheduleTask(heap, t, ans)

        return ans",SingleThreadedCPU.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\SingleThreadedCPU.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(36, 18)",N,function_definition,getOrder,,230,c9b02062-3e75-45a4-9430-aafdf3de2c77
"def scheduleTask(heap, t, ans):
            taskProcesstingTime, index = heappop(heap)
            t += taskProcesstingTime
            ans.append(index)
            return t",SingleThreadedCPU.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\SingleThreadedCPU.py,module/class_definition-Solution/function_definition-getOrder/,getOrder,Previous sibling does not exist,new = [],"(3, 8)","(7, 20)",N,function_definition,scheduleTask,,42,9361428d-21f5-4970-af43-c6666acbefe4
"from linkedlist.DoubllyLinkedList import DoubllyLinkedList, DoubllyLinkedListNode

class AuthenticationManager:

    def __init__(self, timeToLive: int):
        self.dll = DoubllyLinkedList()
        self.count = 0
        self.timeToLive = timeToLive
        self.map = {}

    def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1

    def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()


    def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1

    def countUnexpiredTokens(self, currentTime: int) -> int:
        self.cleanup(currentTime)
        return self.count   


# Your AuthenticationManager object will be instantiated and called as such:
# obj = AuthenticationManager(timeToLive)
# obj.generate(tokenId,currentTime)
# obj.renew(tokenId,currentTime)
# param_3 = obj.countUnexpiredTokens(currentTime)
",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(50, 0)",N,module,module,,350,2bc864a0-527d-428c-a6ca-d7832529df3e
"from linkedlist.DoubllyLinkedList import DoubllyLinkedList, DoubllyLinkedListNode",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/,module,Previous sibling does not exist,"class AuthenticationManager:

    def __init__(self, timeToLive: int):
        self.dll = DoubllyLinkedList()
        self.count = 0
        self.timeToLive = timeToLive
        self.map = {}

    def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1

    def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()


    def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1

    def countUnexpiredTokens(self, currentTime: int) -> int:
        self.cleanup(currentTime)
        return self.count","(0, 0)","(0, 81)",N,import_from_statement,import_from_statement,,19,25908b2a-14da-4c53-9997-cb430ad6151e
"class AuthenticationManager:

    def __init__(self, timeToLive: int):
        self.dll = DoubllyLinkedList()
        self.count = 0
        self.timeToLive = timeToLive
        self.map = {}

    def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1

    def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()


    def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1

    def countUnexpiredTokens(self, currentTime: int) -> int:
        self.cleanup(currentTime)
        return self.count",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/,module,"from linkedlist.DoubllyLinkedList import DoubllyLinkedList, DoubllyLinkedListNode",# Your AuthenticationManager object will be instantiated and called as such:,"(2, 0)","(42, 25)",N,class_definition,AuthenticationManager,,276,eb327384-f3b9-46e2-a3e7-3d11f446fa00
"def __init__(self, timeToLive: int):
        self.dll = DoubllyLinkedList()
        self.count = 0
        self.timeToLive = timeToLive
        self.map = {}",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/class_definition-AuthenticationManager/,AuthenticationManager,Previous sibling does not exist,"def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1","(4, 4)","(8, 21)",N,function_definition,__init__,,43,62e28367-b91b-480e-831c-d708776b6200
"def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/class_definition-AuthenticationManager/,AuthenticationManager,"def __init__(self, timeToLive: int):
        self.dll = DoubllyLinkedList()
        self.count = 0
        self.timeToLive = timeToLive
        self.map = {}","def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()","(10, 4)","(16, 23)",N,function_definition,generate,,67,996d81d7-14e6-4a46-8ec6-63509fd84bb8
"def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/class_definition-AuthenticationManager/,AuthenticationManager,"def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1","def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1","(18, 4)","(26, 26)",N,function_definition,renew,,73,b52296fb-1812-4247-bd6f-08639a3ba8de
"def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/class_definition-AuthenticationManager/,AuthenticationManager,"def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()","def countUnexpiredTokens(self, currentTime: int) -> int:
        self.cleanup(currentTime)
        return self.count","(29, 4)","(38, 27)",N,function_definition,cleanup,,58,65a366ea-65a9-4246-b1e2-454e52ba2d6a
"def countUnexpiredTokens(self, currentTime: int) -> int:
        self.cleanup(currentTime)
        return self.count",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/class_definition-AuthenticationManager/,AuthenticationManager,"def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1","# Your AuthenticationManager object will be instantiated and called as such:
# obj = AuthenticationManager(timeToLive)
# obj.generate(tokenId,currentTime)
# obj.renew(tokenId,currentTime)
# param_3 = obj.countUnexpiredTokens(currentTime)","(40, 4)","(42, 25)",N,function_definition,countUnexpiredTokens,,24,63025384-1191-4395-9651-18b8f7f01e04
"# Your AuthenticationManager object will be instantiated and called as such:
# obj = AuthenticationManager(timeToLive)
# obj.generate(tokenId,currentTime)
# obj.renew(tokenId,currentTime)
# param_3 = obj.countUnexpiredTokens(currentTime)",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/,module,"class AuthenticationManager:

    def __init__(self, timeToLive: int):
        self.dll = DoubllyLinkedList()
        self.count = 0
        self.timeToLive = timeToLive
        self.map = {}

    def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1

    def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()


    def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1

    def countUnexpiredTokens(self, currentTime: int) -> int:
        self.cleanup(currentTime)
        return self.count",Next sibling does not exist,"(45, 0)","(49, 49)",N,"comment,comment,comment,comment,comment",comment,,52,f83172f6-1b97-4645-a602-5563133ac572
"class DoubllyLinkedListNode:

    def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next
    
    def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)

class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)

dll = DoubllyLinkedList()
node1 = DoubllyLinkedListNode(1)
dll.addNodeToTail(node1)
dll.delete(node1)
dll.addNodeToTail(DoubllyLinkedListNode(2))
dll.addNodeToTail(DoubllyLinkedListNode(3))
node4 = DoubllyLinkedListNode(4)
dll.addNodeToTail(node4)
dll.addNodeToTail(DoubllyLinkedListNode(5))

dll.print()
dll.print(forward=False)

dll.delete(node4)
dll.print()
dll.print(forward=False)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(95, 24)",N,module,module,,569,1aab9296-c24c-4f26-bed0-70ce5403e37c
"class DoubllyLinkedListNode:

    def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next
    
    def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/,module,Previous sibling does not exist,"class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)","(0, 0)","(8, 54)",N,class_definition,DoubllyLinkedListNode,,67,7f89f863-bfd6-443d-874d-a7a2781a1d9b
"def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedListNode/,DoubllyLinkedListNode,Previous sibling does not exist,"def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)","(2, 4)","(5, 24)",N,function_definition,__init__,,33,76bc29a4-46f3-4288-848c-c42dab46c5f8
"def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedListNode/,DoubllyLinkedListNode,"def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next",Next sibling does not exist,"(7, 4)","(8, 54)",N,function_definition,__str__,,24,04f323f3-86b5-4c75-b56c-5810a0c2b7f6
"class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/,module,"class DoubllyLinkedListNode:

    def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next
    
    def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)",dll = DoubllyLinkedList(),"(10, 0)","(78, 29)",N,class_definition,DoubllyLinkedList,,392,5d8704cc-d86b-4184-b4d0-2e9771d2b960
"def __init__(self):
        self.head = None
        self.tail = None",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,Previous sibling does not exist,"def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node","(12, 4)","(14, 24)",N,function_definition,__init__,,17,81ebe22e-ac86-45b4-9167-d70c78520c0e
"def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def __init__(self):
        self.head = None
        self.tail = None","def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node","(17, 4)","(24, 28)",N,function_definition,addNodeToHead,,63,95359ae4-0b19-4e2e-a833-558137626e4b
"def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node","def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None","(27, 4)","(34, 28)",N,function_definition,addNodeToTail,,63,e0659cf8-4df3-41c6-aa4c-b6d866001c44
"def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node","def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False","(37, 4)","(47, 40)",N,function_definition,delete,,88,33c1c941-ebc3-49f3-be31-697ccf446d37
"def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None","def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None","(49, 4)","(55, 20)",N,function_definition,contains,,35,ee06fd7e-a10b-4490-800a-e8c8b7866cd3
"def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False","def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)","(57, 4)","(63, 19)",N,function_definition,getNode,,35,fda94aa0-f6a3-42b1-b4bb-129ab232c5b7
"def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None","def __str__(self) -> str:
        return str(self.head)","(68, 4)","(75, 23)",N,function_definition,print,,53,2e4612c5-4f51-4ceb-8554-6aa6300dc22e
"def __str__(self) -> str:
        return str(self.head)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)","dll = DoubllyLinkedList()
node1 = DoubllyLinkedListNode(1)
dll.addNodeToTail(node1)
dll.delete(node1)
dll.addNodeToTail(DoubllyLinkedListNode(2))
dll.addNodeToTail(DoubllyLinkedListNode(3))
node4 = DoubllyLinkedListNode(4)
dll.addNodeToTail(node4)
dll.addNodeToTail(DoubllyLinkedListNode(5))
dll.print()
dll.print(forward=False)
dll.delete(node4)
dll.print()
dll.print(forward=False)","(77, 4)","(78, 29)",N,function_definition,__str__,,15,1f6a85dc-b106-4eb0-ad9b-a823e573fd78
"dll = DoubllyLinkedList()
node1 = DoubllyLinkedListNode(1)
dll.addNodeToTail(node1)
dll.delete(node1)
dll.addNodeToTail(DoubllyLinkedListNode(2))
dll.addNodeToTail(DoubllyLinkedListNode(3))
node4 = DoubllyLinkedListNode(4)
dll.addNodeToTail(node4)
dll.addNodeToTail(DoubllyLinkedListNode(5))
dll.print()
dll.print(forward=False)
dll.delete(node4)
dll.print()
dll.print(forward=False)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/,module,"class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)",Next sibling does not exist,"(80, 0)","(95, 24)",N,"expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement",expression_statement,,110,7e3fc9b7-3bd5-473f-972b-2fb997335bd2
"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        heap = []
        heapify(heap)
        counter = 0

        for node in lists: 
            if(node): 
                heappush(heap, [node.val, counter, node])
                counter += 1

        
        head = ListNode(-10**10)
        temp = head

        while(heap):
            _, _, node = heappop(heap)
            next_node = node.next
            if(next_node): 
                heappush(heap, [next_node.val, counter, next_node])
                counter += 1

            node.next = None
            temp.next = node
            temp = temp.next
        return head.next

",mergeKLists.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\mergeKLists.py,,NA,Previous sibling does not exist,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next","(0, 0)","(33, 0)",N,module,module,,197,80bd1b2f-f728-4092-983e-5ecd7d9c27b3
"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next",mergeKLists.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\mergeKLists.py,module/,module,Previous sibling does not exist,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        heap = []
        heapify(heap)
        counter = 0

        for node in lists: 
            if(node): 
                heappush(heap, [node.val, counter, node])
                counter += 1

        
        head = ListNode(-10**10)
        temp = head

        while(heap):
            _, _, node = heappop(heap)
            next_node = node.next
            if(next_node): 
                heappush(heap, [next_node.val, counter, next_node])
                counter += 1

            node.next = None
            temp.next = node
            temp = temp.next
        return head.next","(0, 0)","(4, 26)",N,"comment,comment,comment,comment,comment",comment,,38,f7e73ae8-7af2-4298-9c5e-a1a7cd5e05a5
"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        heap = []
        heapify(heap)
        counter = 0

        for node in lists: 
            if(node): 
                heappush(heap, [node.val, counter, node])
                counter += 1

        
        head = ListNode(-10**10)
        temp = head

        while(heap):
            _, _, node = heappop(heap)
            next_node = node.next
            if(next_node): 
                heappush(heap, [next_node.val, counter, next_node])
                counter += 1

            node.next = None
            temp.next = node
            temp = temp.next
        return head.next",mergeKLists.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\mergeKLists.py,module/,module,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next",Next sibling does not exist,"(5, 0)","(31, 24)",N,class_definition,Solution,,156,c1de1d60-f2fc-47c2-81dc-06dca48e7dfd
"def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        heap = []
        heapify(heap)
        counter = 0

        for node in lists: 
            if(node): 
                heappush(heap, [node.val, counter, node])
                counter += 1

        
        head = ListNode(-10**10)
        temp = head

        while(heap):
            _, _, node = heappop(heap)
            next_node = node.next
            if(next_node): 
                heappush(heap, [next_node.val, counter, next_node])
                counter += 1

            node.next = None
            temp.next = node
            temp = temp.next
        return head.next",mergeKLists.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\mergeKLists.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(6, 4)","(31, 24)",N,function_definition,mergeKLists,,152,ee94b9a7-5210-4a7f-b2cd-cba54292f4d1
"class MyCircularQueue {

    private int size;
    private int capacity;
    private Node head;
    private Node tail;
    
    
    public MyCircularQueue(int k) {
        this.size = 0;
        this.capacity = k;
    }
    
    public boolean enQueue(int value) {
        if(capacity <= size) return false;
        
        if(tail == null){
            head = tail = new Node(value, null, null);
            size++;
        } else {
            Node newNode = new Node(value, tail, null);
            tail.next = newNode;
            tail = tail.next;
            size++;
        }
        
        return true;
    }
    
    public boolean deQueue() {
        if(isEmpty()) return false;
                
        head = head.next;
        size--;
        if(size == 0) tail = null;
        return true;
    }
    
    public int Front() {
        if(head == null) return -1;
        return head.val;
    }
    
    public int Rear() {
        if(tail == null) return -1;
        return tail.val;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
}

class Node{
    int val;
    Node prev;
    Node next;
    
    public Node(int val){
        this.val = val;
    }
    
    public Node(int val, Node prev, Node next){
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}



/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */
",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(85, 0)",N,program,program,,411,08e3931c-cf55-4f53-9acc-b382184622b8
"class MyCircularQueue {

    private int size;
    private int capacity;
    private Node head;
    private Node tail;
    
    
    public MyCircularQueue(int k) {
        this.size = 0;
        this.capacity = k;
    }
    
    public boolean enQueue(int value) {
        if(capacity <= size) return false;
        
        if(tail == null){
            head = tail = new Node(value, null, null);
            size++;
        } else {
            Node newNode = new Node(value, tail, null);
            tail.next = newNode;
            tail = tail.next;
            size++;
        }
        
        return true;
    }
    
    public boolean deQueue() {
        if(isEmpty()) return false;
                
        head = head.next;
        size--;
        if(size == 0) tail = null;
        return true;
    }
    
    public int Front() {
        if(head == null) return -1;
        return head.val;
    }
    
    public int Rear() {
        if(tail == null) return -1;
        return tail.val;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
}",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/,program,Previous sibling does not exist,"class Node{
    int val;
    Node prev;
    Node next;
    
    public Node(int val){
        this.val = val;
    }
    
    public Node(int val, Node prev, Node next){
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}","(0, 0)","(55, 1)",N,class_declaration,MyCircularQueue,,259,5f3580e6-d9d5-456b-a651-752f64456066
"public MyCircularQueue(int k) {
        this.size = 0;
        this.capacity = k;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,private Node tail;,"public boolean enQueue(int value) {
        if(capacity <= size) return false;
        
        if(tail == null){
            head = tail = new Node(value, null, null);
            size++;
        } else {
            Node newNode = new Node(value, tail, null);
            tail.next = newNode;
            tail = tail.next;
            size++;
        }
        
        return true;
    }","(8, 4)","(11, 5)",N,constructor_declaration,MyCircularQueue,,23,3b482847-2afa-41c9-afe9-721074436b8c
"public boolean enQueue(int value) {
        if(capacity <= size) return false;
        
        if(tail == null){
            head = tail = new Node(value, null, null);
            size++;
        } else {
            Node newNode = new Node(value, tail, null);
            tail.next = newNode;
            tail = tail.next;
            size++;
        }
        
        return true;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,"public MyCircularQueue(int k) {
        this.size = 0;
        this.capacity = k;
    }","public boolean deQueue() {
        if(isEmpty()) return false;
                
        head = head.next;
        size--;
        if(size == 0) tail = null;
        return true;
    }","(13, 4)","(27, 5)",N,method_declaration,enQueue,,82,a9cb13de-38dd-445f-a4d5-270408cf984c
"public boolean deQueue() {
        if(isEmpty()) return false;
                
        head = head.next;
        size--;
        if(size == 0) tail = null;
        return true;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,"public boolean enQueue(int value) {
        if(capacity <= size) return false;
        
        if(tail == null){
            head = tail = new Node(value, null, null);
            size++;
        } else {
            Node newNode = new Node(value, tail, null);
            tail.next = newNode;
            tail = tail.next;
            size++;
        }
        
        return true;
    }","public int Front() {
        if(head == null) return -1;
        return head.val;
    }","(29, 4)","(36, 5)",N,method_declaration,deQueue,,41,0a2b47f9-4a2b-4170-a442-cb9bdca3f528
"public int Front() {
        if(head == null) return -1;
        return head.val;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,"public boolean deQueue() {
        if(isEmpty()) return false;
                
        head = head.next;
        size--;
        if(size == 0) tail = null;
        return true;
    }","public int Rear() {
        if(tail == null) return -1;
        return tail.val;
    }","(38, 4)","(41, 5)",N,method_declaration,Front,,22,bced0fb6-f0b1-4c3f-8155-542f0d32ccf2
"public int Rear() {
        if(tail == null) return -1;
        return tail.val;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,"public int Front() {
        if(head == null) return -1;
        return head.val;
    }","public boolean isEmpty() {
        return size == 0;
    }","(43, 4)","(46, 5)",N,method_declaration,Rear,,23,b48f7f1a-0de9-47b1-bfc7-28869c367c8a
"public boolean isEmpty() {
        return size == 0;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,"public int Rear() {
        if(tail == null) return -1;
        return tail.val;
    }","public boolean isFull() {
        return size == capacity;
    }","(48, 4)","(50, 5)",N,method_declaration,isEmpty,,14,ef75a044-ae19-4674-8951-bb4ce73e08b3
"public boolean isFull() {
        return size == capacity;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,"public boolean isEmpty() {
        return size == 0;
    }",Next sibling does not exist,"(52, 4)","(54, 5)",N,method_declaration,isFull,,14,164a56c8-1181-474b-b7d1-716be93d2d1d
"class Node{
    int val;
    Node prev;
    Node next;
    
    public Node(int val){
        this.val = val;
    }
    
    public Node(int val, Node prev, Node next){
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/,program,"class MyCircularQueue {

    private int size;
    private int capacity;
    private Node head;
    private Node tail;
    
    
    public MyCircularQueue(int k) {
        this.size = 0;
        this.capacity = k;
    }
    
    public boolean enQueue(int value) {
        if(capacity <= size) return false;
        
        if(tail == null){
            head = tail = new Node(value, null, null);
            size++;
        } else {
            Node newNode = new Node(value, tail, null);
            tail.next = newNode;
            tail = tail.next;
            size++;
        }
        
        return true;
    }
    
    public boolean deQueue() {
        if(isEmpty()) return false;
                
        head = head.next;
        size--;
        if(size == 0) tail = null;
        return true;
    }
    
    public int Front() {
        if(head == null) return -1;
        return head.val;
    }
    
    public int Rear() {
        if(tail == null) return -1;
        return tail.val;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
}","/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */","(57, 0)","(71, 1)",N,class_declaration,Node,,64,dadbd65b-614a-44b7-896e-f54041f872dc
"public Node(int val){
        this.val = val;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-Node/,Node,Node next;,"public Node(int val, Node prev, Node next){
        this.val = val;
        this.prev = prev;
        this.next = next;
    }","(62, 4)","(64, 5)",N,constructor_declaration,Node,,13,11f577b6-431f-468b-bb29-78a593463eea
"public Node(int val, Node prev, Node next){
        this.val = val;
        this.prev = prev;
        this.next = next;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-Node/,Node,"public Node(int val){
        this.val = val;
    }",Next sibling does not exist,"(66, 4)","(70, 5)",N,constructor_declaration,Node,,31,b7aab718-f37a-4e80-b097-19a9b3b34c09
"/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/,program,"class Node{
    int val;
    Node prev;
    Node next;
    
    public Node(int val){
        this.val = val;
    }
    
    public Node(int val, Node prev, Node next){
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}",Next sibling does not exist,"(75, 0)","(84, 3)",N,block_comment,block_comment,,88,58004a72-4a88-422b-9a4e-128b3e0238b8
"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        length = 0
        temp = head
        while(temp):
            temp = temp.next
            length+=1
        
        rounds = length//k

        def helper(head, k, offset, rounds):
            if(not head or offset>rounds): 
                return head

            prev = None
            nextNode = None
            cur = head
            count = k

            while(cur and count>0):
                nextNode = cur.next 
                cur.next = prev

                prev = cur
                cur = nextNode
                count-=1

            head.next = helper(nextNode, k, offset+1, rounds)
            return prev
        
        return helper(head, k, 1, rounds)
",reverseKGroup.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\reverseKGroup.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(32, 0)",N,module,module,,175,e561bc6c-34c5-4425-a027-9e0a3dbd5090
"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        length = 0
        temp = head
        while(temp):
            temp = temp.next
            length+=1
        
        rounds = length//k

        def helper(head, k, offset, rounds):
            if(not head or offset>rounds): 
                return head

            prev = None
            nextNode = None
            cur = head
            count = k

            while(cur and count>0):
                nextNode = cur.next 
                cur.next = prev

                prev = cur
                cur = nextNode
                count-=1

            head.next = helper(nextNode, k, offset+1, rounds)
            return prev
        
        return helper(head, k, 1, rounds)",reverseKGroup.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\reverseKGroup.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 41)",N,class_definition,Solution,,175,fdb16084-7178-4247-8c44-ac9b8a9100b5
"def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        length = 0
        temp = head
        while(temp):
            temp = temp.next
            length+=1
        
        rounds = length//k

        def helper(head, k, offset, rounds):
            if(not head or offset>rounds): 
                return head

            prev = None
            nextNode = None
            cur = head
            count = k

            while(cur and count>0):
                nextNode = cur.next 
                cur.next = prev

                prev = cur
                cur = nextNode
                count-=1

            head.next = helper(nextNode, k, offset+1, rounds)
            return prev
        
        return helper(head, k, 1, rounds)",reverseKGroup.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\reverseKGroup.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(31, 41)",N,function_definition,reverseKGroup,,171,1d717978-0a89-4906-84fc-30a16a6fa09b
"def helper(head, k, offset, rounds):
            if(not head or offset>rounds): 
                return head

            prev = None
            nextNode = None
            cur = head
            count = k

            while(cur and count>0):
                nextNode = cur.next 
                cur.next = prev

                prev = cur
                cur = nextNode
                count-=1

            head.next = helper(nextNode, k, offset+1, rounds)
            return prev",reverseKGroup.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\reverseKGroup.py,module/class_definition-Solution/function_definition-reverseKGroup/,reverseKGroup,rounds = length//k,"return helper(head, k, 1, rounds)","(11, 8)","(29, 23)",N,function_definition,helper,,102,449a4f10-79cd-42e1-b2b3-354111cdac98
,__init__.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\__init__.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(0, 0)",N,module,module,,0,a2d840e5-f43f-440a-bc0c-11738f0a2e56
"class Solution:
    def countOdds(self, low: int, high: int) -> int:
        if(low>high): return 0
        if(low%2 == 1): return 1 + self.countOdds(low+1, high)
        if(high%2 == 1): return 1 + self.countOdds(low, high-1)
        return (high-low)//2
",countOdds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\countOdds.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(6, 0)",N,module,module,,85,3fcfce39-98c0-4cdf-bd5c-71f084606b6f
"class Solution:
    def countOdds(self, low: int, high: int) -> int:
        if(low>high): return 0
        if(low%2 == 1): return 1 + self.countOdds(low+1, high)
        if(high%2 == 1): return 1 + self.countOdds(low, high-1)
        return (high-low)//2",countOdds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\countOdds.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(5, 28)",N,class_definition,Solution,,84,abb9b001-4cdc-4679-adb6-21cf92f33aa4
"def countOdds(self, low: int, high: int) -> int:
        if(low>high): return 0
        if(low%2 == 1): return 1 + self.countOdds(low+1, high)
        if(high%2 == 1): return 1 + self.countOdds(low, high-1)
        return (high-low)//2",countOdds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\countOdds.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(5, 28)",N,function_definition,countOdds,,80,fb4e1235-46f4-4d38-8b81-ab6bc9e42bb3
"class Solution:
    def sumOfPower(self, nums: List[int]) -> int:
        
        ans = 0
        N = len(nums)
        mod = 10**9 + 7
        nums.sort() 

        def mul(a, b): return (a%mod * b%mod)%mod
        def sum(a, b): return (a%mod + b%mod)%mod

        cur = 0
        for index in range(N):
            cur = mul(cur, 2)
            if(index-1>=0): cur = sum(cur, nums[index-1])
            ans = sum(ans, nums[index] ** 3)
            ans = sum(ans, nums[index]**2 * cur)

        return ans


sol = Solution()
arr = [1 for i in range(10**5)]
ans = sol.sumOfPower(arr)
print(ans)",sumOfPower.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\sumOfPower.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(24, 10)",N,module,module,,183,6367c397-863d-4ce5-8b76-d3b829678187
"class Solution:
    def sumOfPower(self, nums: List[int]) -> int:
        
        ans = 0
        N = len(nums)
        mod = 10**9 + 7
        nums.sort() 

        def mul(a, b): return (a%mod * b%mod)%mod
        def sum(a, b): return (a%mod + b%mod)%mod

        cur = 0
        for index in range(N):
            cur = mul(cur, 2)
            if(index-1>=0): cur = sum(cur, nums[index-1])
            ans = sum(ans, nums[index] ** 3)
            ans = sum(ans, nums[index]**2 * cur)

        return ans",sumOfPower.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\sumOfPower.py,module/,module,Previous sibling does not exist,sol = Solution(),"(0, 0)","(18, 18)",N,class_definition,Solution,,154,e4b14d57-ee5b-45f3-a4cb-c6102650386a
"def sumOfPower(self, nums: List[int]) -> int:
        
        ans = 0
        N = len(nums)
        mod = 10**9 + 7
        nums.sort() 

        def mul(a, b): return (a%mod * b%mod)%mod
        def sum(a, b): return (a%mod + b%mod)%mod

        cur = 0
        for index in range(N):
            cur = mul(cur, 2)
            if(index-1>=0): cur = sum(cur, nums[index-1])
            ans = sum(ans, nums[index] ** 3)
            ans = sum(ans, nums[index]**2 * cur)

        return ans",sumOfPower.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\sumOfPower.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(18, 18)",N,function_definition,sumOfPower,,150,894af6d8-f110-4665-8569-7cc9cfd4d05f
"def mul(a, b): return (a%mod * b%mod)%mod",sumOfPower.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\sumOfPower.py,module/class_definition-Solution/function_definition-sumOfPower/,sumOfPower,nums.sort(),"def sum(a, b): return (a%mod + b%mod)%mod","(8, 8)","(8, 49)",N,function_definition,mul,,17,d41dc531-2516-48a4-9abf-a9fd26ac3b6b
"def sum(a, b): return (a%mod + b%mod)%mod",sumOfPower.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\sumOfPower.py,module/class_definition-Solution/function_definition-sumOfPower/,sumOfPower,"def mul(a, b): return (a%mod * b%mod)%mod","sol = Solution()
arr = [1 for i in range(10**5)]
ans = sol.sumOfPower(arr)
print(ans)","(9, 8)","(9, 49)",N,function_definition,sum,,17,b2ac2856-ad01-48c5-b225-ceb268df2e86
"sol = Solution()
arr = [1 for i in range(10**5)]
ans = sol.sumOfPower(arr)
print(ans)",sumOfPower.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\sumOfPower.py,module/,module,"class Solution:
    def sumOfPower(self, nums: List[int]) -> int:
        
        ans = 0
        N = len(nums)
        mod = 10**9 + 7
        nums.sort() 

        def mul(a, b): return (a%mod * b%mod)%mod
        def sum(a, b): return (a%mod + b%mod)%mod

        cur = 0
        for index in range(N):
            cur = mul(cur, 2)
            if(index-1>=0): cur = sum(cur, nums[index-1])
            ans = sum(ans, nums[index] ** 3)
            ans = sum(ans, nums[index]**2 * cur)

        return ans",Next sibling does not exist,"(21, 0)","(24, 10)",N,"expression_statement,expression_statement,expression_statement,expression_statement",expression_statement,,28,2bfba13a-ac67-4d90-8da6-ef08b5fc538e
"class Solution:
    def PredictTheWinner(self, nums: List[int]) -> bool:

        @cache
        def helper(startIndex, endIndex):
            if(startIndex > endIndex): return 0

            return max(
                nums[startIndex] - helper(startIndex+1, endIndex), 
                nums[endIndex] - helper(startIndex, endIndex-1)
                )

        
        return helper(0, len(nums)-1) >= 0
",PredictTheWinner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\PredictTheWinner.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 0)",N,module,module,,92,dbd8f7c8-5155-41f5-b803-6a8cf5688695
"class Solution:
    def PredictTheWinner(self, nums: List[int]) -> bool:

        @cache
        def helper(startIndex, endIndex):
            if(startIndex > endIndex): return 0

            return max(
                nums[startIndex] - helper(startIndex+1, endIndex), 
                nums[endIndex] - helper(startIndex, endIndex-1)
                )

        
        return helper(0, len(nums)-1) >= 0",PredictTheWinner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\PredictTheWinner.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(13, 42)",N,class_definition,Solution,,91,60e0af4f-a097-446e-a43b-b18505b0ec19
"def PredictTheWinner(self, nums: List[int]) -> bool:

        @cache
        def helper(startIndex, endIndex):
            if(startIndex > endIndex): return 0

            return max(
                nums[startIndex] - helper(startIndex+1, endIndex), 
                nums[endIndex] - helper(startIndex, endIndex-1)
                )

        
        return helper(0, len(nums)-1) >= 0",PredictTheWinner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\PredictTheWinner.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(13, 42)",N,function_definition,PredictTheWinner,,87,d81c83ce-3d99-41df-be30-c20ffb3c7be7
"@cache
        def helper(startIndex, endIndex):
            if(startIndex > endIndex): return 0

            return max(
                nums[startIndex] - helper(startIndex+1, endIndex), 
                nums[endIndex] - helper(startIndex, endIndex-1)
                )",PredictTheWinner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\PredictTheWinner.py,module/class_definition-Solution/function_definition-PredictTheWinner/,PredictTheWinner,Previous sibling does not exist,"return helper(0, len(nums)-1) >= 0","(3, 8)","(10, 17)",N,function_definition,"def helper(startIndex, endIndex):
            if(startIndex > endIndex): return 0

            return max(
                nums[startIndex] - helper(startIndex+1, endIndex), 
                nums[endIndex] - helper(startIndex, endIndex-1)
                )",,57,bd7e07ad-1bba-4a7a-bdb0-7e7d20293aa6
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:

        @cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans
        
        return (sum(piles) + helper(0, 1))//2
",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\stoneGameII.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 0)",N,module,module,,147,848e2d9b-f94e-424f-bf27-3c9ca541a89f
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:

        @cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans
        
        return (sum(piles) + helper(0, 1))//2",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\stoneGameII.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 45)",N,class_definition,Solution,,146,0918800d-fcb6-45f5-b8ec-c83bf21844a3
"def stoneGameII(self, piles: List[int]) -> int:

        @cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans
        
        return (sum(piles) + helper(0, 1))//2",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\stoneGameII.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(17, 45)",N,function_definition,stoneGameII,,142,d52f8dc1-f9fc-4611-a1f7-987f305b7188
"@cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\stoneGameII.py,module/class_definition-Solution/function_definition-stoneGameII/,stoneGameII,Previous sibling does not exist,"return (sum(piles) + helper(0, 1))//2","(3, 8)","(15, 22)",N,function_definition,"def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans",,109,55b8f633-ce60-4b2b-9b85-0f1bf83efbe7
"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        
        def getVal(num):
            num+=1
            if(num<3): return 0
            else: return (num * num)//2 - (3*num)//2 + 1
        
        N = len(nums)
        if(N<3): return 0
        
        prevdiff = nums[1] - nums[0]
        curCount = 1
        ans = 0
        
        for index in range(2, N):
            diff  = nums[index] - nums[index-1]
            if(diff == prevdiff): 
                curCount += 1
            else:
                # print(curCount)
                ans += getVal(curCount) #something with cur count
                curCount = 1
            
            prevdiff = diff
        
        # print(curCount)
        ans += getVal(curCount)
        return ans
",ArithmeticSlices.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\ArithmeticSlices.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 0)",N,module,module,,196,e5aa6b8b-235e-4cec-b694-323f600c46eb
"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        
        def getVal(num):
            num+=1
            if(num<3): return 0
            else: return (num * num)//2 - (3*num)//2 + 1
        
        N = len(nums)
        if(N<3): return 0
        
        prevdiff = nums[1] - nums[0]
        curCount = 1
        ans = 0
        
        for index in range(2, N):
            diff  = nums[index] - nums[index-1]
            if(diff == prevdiff): 
                curCount += 1
            else:
                # print(curCount)
                ans += getVal(curCount) #something with cur count
                curCount = 1
            
            prevdiff = diff
        
        # print(curCount)
        ans += getVal(curCount)
        return ans",ArithmeticSlices.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\ArithmeticSlices.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 18)",N,class_definition,Solution,,195,1becf6ae-6ee0-4c18-a079-ec37a83afc7a
"def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        
        def getVal(num):
            num+=1
            if(num<3): return 0
            else: return (num * num)//2 - (3*num)//2 + 1
        
        N = len(nums)
        if(N<3): return 0
        
        prevdiff = nums[1] - nums[0]
        curCount = 1
        ans = 0
        
        for index in range(2, N):
            diff  = nums[index] - nums[index-1]
            if(diff == prevdiff): 
                curCount += 1
            else:
                # print(curCount)
                ans += getVal(curCount) #something with cur count
                curCount = 1
            
            prevdiff = diff
        
        # print(curCount)
        ans += getVal(curCount)
        return ans",ArithmeticSlices.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\ArithmeticSlices.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(28, 18)",N,function_definition,numberOfArithmeticSlices,,191,3a46f273-f7b0-4e5f-9c88-bc4d48160a5d
"def getVal(num):
            num+=1
            if(num<3): return 0
            else: return (num * num)//2 - (3*num)//2 + 1",ArithmeticSlices.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\ArithmeticSlices.py,module/class_definition-Solution/function_definition-numberOfArithmeticSlices/,numberOfArithmeticSlices,Previous sibling does not exist,N = len(nums),"(3, 8)","(6, 56)",N,function_definition,getVal,,39,d3b21051-68cb-4b98-9770-9d634eb75a9c
"class Solution:
    def closestPrimes(self, left: int, right: int) -> List[int]:
        prime = [True for i in range(right+1)]
        
        def SieveOfEratosthenes(prime):
            N = len(prime)
            p = 2
            while (p * p <= N-1):
                if (prime[p] == True):
                    for i in range(p * p, N, p):
                        prime[i] = False
                p += 1
        
        SieveOfEratosthenes(prime)
        
        ans = 10**10
        prev = -1
        arr = [-1, -1]
        
        for p in range(max(2, left), len(prime)):
            if prime[p]:
                if(prev != -1):
                    cur = p - prev
                    if(cur<ans):
                        ans = cur
                        arr = [prev, p]
                prev = p
        
        return arr
",closestPrimes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\closestPrimes.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 0)",N,module,module,,207,0e00f281-b7d7-485b-afa2-12242bb7b369
"class Solution:
    def closestPrimes(self, left: int, right: int) -> List[int]:
        prime = [True for i in range(right+1)]
        
        def SieveOfEratosthenes(prime):
            N = len(prime)
            p = 2
            while (p * p <= N-1):
                if (prime[p] == True):
                    for i in range(p * p, N, p):
                        prime[i] = False
                p += 1
        
        SieveOfEratosthenes(prime)
        
        ans = 10**10
        prev = -1
        arr = [-1, -1]
        
        for p in range(max(2, left), len(prime)):
            if prime[p]:
                if(prev != -1):
                    cur = p - prev
                    if(cur<ans):
                        ans = cur
                        arr = [prev, p]
                prev = p
        
        return arr",closestPrimes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\closestPrimes.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 18)",N,class_definition,Solution,,206,73801703-cdd4-498b-b162-ae0534b5cec9
"def closestPrimes(self, left: int, right: int) -> List[int]:
        prime = [True for i in range(right+1)]
        
        def SieveOfEratosthenes(prime):
            N = len(prime)
            p = 2
            while (p * p <= N-1):
                if (prime[p] == True):
                    for i in range(p * p, N, p):
                        prime[i] = False
                p += 1
        
        SieveOfEratosthenes(prime)
        
        ans = 10**10
        prev = -1
        arr = [-1, -1]
        
        for p in range(max(2, left), len(prime)):
            if prime[p]:
                if(prev != -1):
                    cur = p - prev
                    if(cur<ans):
                        ans = cur
                        arr = [prev, p]
                prev = p
        
        return arr",closestPrimes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\closestPrimes.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(28, 18)",N,function_definition,closestPrimes,,202,7f3120c0-e52e-4f0f-9c34-f745f3b229a4
"def SieveOfEratosthenes(prime):
            N = len(prime)
            p = 2
            while (p * p <= N-1):
                if (prime[p] == True):
                    for i in range(p * p, N, p):
                        prime[i] = False
                p += 1",closestPrimes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\closestPrimes.py,module/class_definition-Solution/function_definition-closestPrimes/,closestPrimes,prime = [True for i in range(right+1)],SieveOfEratosthenes(prime),"(4, 8)","(11, 22)",N,function_definition,SieveOfEratosthenes,,70,90f64d20-bffe-4ad7-afab-de94c348b4cb
"class Solution {
    public int commonFactors(int a, int b) {
        int ans=0;
        for(int i=1; i<=Math.min(a,b); i++){
            if(a%i ==0 && b%i==0) ans++;
        }
        
        return ans;
    }
}
",CommonFactors.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\CommonFactors.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(10, 0)",N,program,program,,61,a09b7e84-9f9b-4e71-8c24-c562d26d287f
"class Solution {
    public int commonFactors(int a, int b) {
        int ans=0;
        for(int i=1; i<=Math.min(a,b); i++){
            if(a%i ==0 && b%i==0) ans++;
        }
        
        return ans;
    }
}",CommonFactors.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\CommonFactors.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(9, 1)",N,class_declaration,Solution,,61,1c793876-ddd7-4490-ae67-9e90809e8bb7
"public int commonFactors(int a, int b) {
        int ans=0;
        for(int i=1; i<=Math.min(a,b); i++){
            if(a%i ==0 && b%i==0) ans++;
        }
        
        return ans;
    }",CommonFactors.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\CommonFactors.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(8, 5)",N,method_declaration,commonFactors,,56,54b25bd8-046c-4a7c-b073-d087e4f6d0c9
"class Solution:
    def maximizeSum(self, nums: List[int], k: int) -> int:
        def sumOfn(num): return (num * (num+1))//2
        
        m = max(nums)
        return sumOfn(m+k-1) - sumOfn(m-1)
",maximizeSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\maximizeSum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(6, 0)",N,module,module,,64,813470db-0671-43a3-82ca-23284d0c38c9
"class Solution:
    def maximizeSum(self, nums: List[int], k: int) -> int:
        def sumOfn(num): return (num * (num+1))//2
        
        m = max(nums)
        return sumOfn(m+k-1) - sumOfn(m-1)",maximizeSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\maximizeSum.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(5, 42)",N,class_definition,Solution,,64,f84991bf-3153-4678-b1cf-401ea605c78e
"def maximizeSum(self, nums: List[int], k: int) -> int:
        def sumOfn(num): return (num * (num+1))//2
        
        m = max(nums)
        return sumOfn(m+k-1) - sumOfn(m-1)",maximizeSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\maximizeSum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(5, 42)",N,function_definition,maximizeSum,,60,fa72d421-a03d-46f7-8cfb-f3e8f53fdd2d
def sumOfn(num): return (num * (num+1))//2,maximizeSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\maximizeSum.py,module/class_definition-Solution/function_definition-maximizeSum/,maximizeSum,Previous sibling does not exist,m = max(nums),"(2, 8)","(2, 50)",N,function_definition,sumOfn,,17,7b0045b9-587a-4047-a7cd-acfd63e5a73b
"class Solution {
    public int maxSum(int[][] grid) {
        int ans = 0;
        for(int i=0; i<grid.length-2; i++){
            for(int j=0; j<grid[0].length-2;j++){
                ans = Math.max(ans, getValue(grid, i, j));
            }
        }
        return ans;
    }
    
    public int getValue(int[][] grid, int index1, int index2){
        return grid[index1][index2] + grid[index1][index2+1] + grid[index1][index2+2] + 
            grid[index1+1][index2+1] + 
            grid[index1+2][index2] + grid[index1+2][index2+1] + grid[index1+2][index2+2];
    }
}
",MaxSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\MaxSum.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 0)",N,program,program,,177,b77de455-5a32-4e9e-b082-71fcf9cd18ad
"class Solution {
    public int maxSum(int[][] grid) {
        int ans = 0;
        for(int i=0; i<grid.length-2; i++){
            for(int j=0; j<grid[0].length-2;j++){
                ans = Math.max(ans, getValue(grid, i, j));
            }
        }
        return ans;
    }
    
    public int getValue(int[][] grid, int index1, int index2){
        return grid[index1][index2] + grid[index1][index2+1] + grid[index1][index2+2] + 
            grid[index1+1][index2+1] + 
            grid[index1+2][index2] + grid[index1+2][index2+1] + grid[index1+2][index2+2];
    }
}",MaxSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\MaxSum.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 1)",N,class_declaration,Solution,,177,1dd8f5dd-8f81-4502-b60b-e7b804227a3f
"public int maxSum(int[][] grid) {
        int ans = 0;
        for(int i=0; i<grid.length-2; i++){
            for(int j=0; j<grid[0].length-2;j++){
                ans = Math.max(ans, getValue(grid, i, j));
            }
        }
        return ans;
    }",MaxSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\MaxSum.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public int getValue(int[][] grid, int index1, int index2){
        return grid[index1][index2] + grid[index1][index2+1] + grid[index1][index2+2] + 
            grid[index1+1][index2+1] + 
            grid[index1+2][index2] + grid[index1+2][index2+1] + grid[index1+2][index2+2];
    }","(1, 4)","(9, 5)",N,method_declaration,maxSum,,74,344d6101-619e-43d0-8677-683e5b1d46f9
"public int getValue(int[][] grid, int index1, int index2){
        return grid[index1][index2] + grid[index1][index2+1] + grid[index1][index2+2] + 
            grid[index1+1][index2+1] + 
            grid[index1+2][index2] + grid[index1+2][index2+1] + grid[index1+2][index2+2];
    }",MaxSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\MaxSum.java,program/class_declaration-Solution/,Solution,"public int maxSum(int[][] grid) {
        int ans = 0;
        for(int i=0; i<grid.length-2; i++){
            for(int j=0; j<grid[0].length-2;j++){
                ans = Math.max(ans, getValue(grid, i, j));
            }
        }
        return ans;
    }",Next sibling does not exist,"(11, 4)","(15, 5)",N,method_declaration,getValue,,96,14f31acf-89e8-47e3-a961-d02783db30f4
"from SegmentTree import SegmentTree


class MinimumComputingTime:

    def findMinimumTime(self, tasks) -> int:
        timeline = SegmentTree([0 for i in range(10)], operator=lambda x, y : x+y, operationIdentity=0)
        ans = 0
        for start, end, duration in tasks:
            onTime =  timeline.query(start, end)
            if(onTime >= duration): continue

            remaining = duration - onTime
            ans += remaining
            timeline.rightfill(remaining, start, end)
        
        return ans

MinimumComputingTime = MinimumComputingTime()
MinimumComputingTime.findMinimumTime([[2,3,1],[4,5,1],[1,5,2]])",MinimumComputingTime.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\MinimumComputingTime.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(19, 63)",N,module,module,,154,2bf03c6c-3c88-4aaf-83a7-a58c89aeffa5
from SegmentTree import SegmentTree,MinimumComputingTime.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\MinimumComputingTime.py,module/,module,Previous sibling does not exist,"class MinimumComputingTime:

    def findMinimumTime(self, tasks) -> int:
        timeline = SegmentTree([0 for i in range(10)], operator=lambda x, y : x+y, operationIdentity=0)
        ans = 0
        for start, end, duration in tasks:
            onTime =  timeline.query(start, end)
            if(onTime >= duration): continue

            remaining = duration - onTime
            ans += remaining
            timeline.rightfill(remaining, start, end)
        
        return ans","(0, 0)","(0, 35)",N,import_from_statement,import_from_statement,,6,c9f46f65-b697-443d-b8cc-f7894c6f5873
"class MinimumComputingTime:

    def findMinimumTime(self, tasks) -> int:
        timeline = SegmentTree([0 for i in range(10)], operator=lambda x, y : x+y, operationIdentity=0)
        ans = 0
        for start, end, duration in tasks:
            onTime =  timeline.query(start, end)
            if(onTime >= duration): continue

            remaining = duration - onTime
            ans += remaining
            timeline.rightfill(remaining, start, end)
        
        return ans",MinimumComputingTime.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\MinimumComputingTime.py,module/,module,from SegmentTree import SegmentTree,MinimumComputingTime = MinimumComputingTime(),"(3, 0)","(16, 18)",N,class_definition,MinimumComputingTime,,110,11dc93f1-0547-4fe9-b25a-6edb23ddb28d
"def findMinimumTime(self, tasks) -> int:
        timeline = SegmentTree([0 for i in range(10)], operator=lambda x, y : x+y, operationIdentity=0)
        ans = 0
        for start, end, duration in tasks:
            onTime =  timeline.query(start, end)
            if(onTime >= duration): continue

            remaining = duration - onTime
            ans += remaining
            timeline.rightfill(remaining, start, end)
        
        return ans",MinimumComputingTime.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\MinimumComputingTime.py,module/class_definition-MinimumComputingTime/,MinimumComputingTime,Previous sibling does not exist,"MinimumComputingTime = MinimumComputingTime()
MinimumComputingTime.findMinimumTime([[2,3,1],[4,5,1],[1,5,2]])","(5, 4)","(16, 18)",N,function_definition,findMinimumTime,,103,5bd68903-4628-4a91-9154-f732293f15ec
"MinimumComputingTime = MinimumComputingTime()
MinimumComputingTime.findMinimumTime([[2,3,1],[4,5,1],[1,5,2]])",MinimumComputingTime.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\MinimumComputingTime.py,module/,module,"class MinimumComputingTime:

    def findMinimumTime(self, tasks) -> int:
        timeline = SegmentTree([0 for i in range(10)], operator=lambda x, y : x+y, operationIdentity=0)
        ans = 0
        for start, end, duration in tasks:
            onTime =  timeline.query(start, end)
            if(onTime >= duration): continue

            remaining = duration - onTime
            ans += remaining
            timeline.rightfill(remaining, start, end)
        
        return ans",Next sibling does not exist,"(18, 0)","(19, 63)",N,"expression_statement,expression_statement",expression_statement,,36,0f3e5913-990a-4517-aed6-2020011fd57e
"package com.akarsh.codechef.segmentTree;

import java.util.Arrays;

public class SegmentTree<T extends Number> {

    private final int n;
    private final double[] segmentTree;
    private final T[] arr;

    SegmentTree(int n, T[] arr){
        this.n = n;
        int modifiedChildCount = (int) Math.pow(2, Math.ceil(Math.log(n)/Math.log(2)));
        int size = 2 * modifiedChildCount - 1;
        this.segmentTree = new double[size];
        this.arr = arr;
        buildSegmentTree(arr);
    }

    public void buildSegmentTree(T[] arr){
        helper(0, arr.length-1, 0);
    }

    public void helper(int start, int end, int index){

        if(start == end){
            this.segmentTree[index] = arr[start].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        helper(start, mid, 2*index + 1);
        helper(mid+1, end, 2*index + 2);
        this.segmentTree[index] = this.segmentTree[2*index+1] + this.segmentTree[2*index+2];
    }

    public void updateHelper(int start, int end, int arrIndex, int segIndex) {

        if(start == end){
            this.segmentTree[segIndex] = this.arr[arrIndex].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        if(arrIndex <= mid) updateHelper(start, mid, arrIndex, segIndex*2 + 1);
        else updateHelper(mid+1, end, arrIndex, segIndex*2 + 2);

        this.segmentTree[segIndex] = this.segmentTree[2*segIndex+1] + this.segmentTree[2*segIndex+2];
    }

    public void update(int index, T newValue){
        this.arr[index] = newValue;
        updateHelper(0,n-1, index, 0);
    }

    public Double query(int start, int end){
        return query(start, end, 0, n-1,0);
    }

    private Double query(int start, int end, int vStart, int vEnd, int index){

        System.out.println(start + "" "" + end + "" "" + vStart + "" "" + vEnd + "" "" + index);
        if(start>end) return 0.0;

        if(start == vStart && end == vEnd) return segmentTree[index];
        if(start>vEnd || end<vStart) return 0.0;

        int mid = vStart + (vEnd - vStart)/2;

        if(end<=mid) return query(start, end, vStart, mid, 2*index+1);
        if(start>mid) return query(start, end, mid+1, vEnd, 2*index+2);

        return query(start, mid, vStart, mid, 2*index+1) +  query(mid+1, end, mid+1, vEnd, 2*index+2);
    }



    @Override
    public String toString() {
        return ""SegmentTree{"" +
                ""segmentTree="" + Arrays.toString(segmentTree) +
                "", arr="" + Arrays.toString(arr) +
                '}';
    }
}
",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,,NA,Previous sibling does not exist,"package com.akarsh.codechef.segmentTree;
import java.util.Arrays;","(0, 0)","(85, 0)",N,program,program,,706,028b3880-75c5-49d6-bfa9-3b78755062cf
"package com.akarsh.codechef.segmentTree;
import java.util.Arrays;",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/,program,Previous sibling does not exist,"public class SegmentTree<T extends Number> {

    private final int n;
    private final double[] segmentTree;
    private final T[] arr;

    SegmentTree(int n, T[] arr){
        this.n = n;
        int modifiedChildCount = (int) Math.pow(2, Math.ceil(Math.log(n)/Math.log(2)));
        int size = 2 * modifiedChildCount - 1;
        this.segmentTree = new double[size];
        this.arr = arr;
        buildSegmentTree(arr);
    }

    public void buildSegmentTree(T[] arr){
        helper(0, arr.length-1, 0);
    }

    public void helper(int start, int end, int index){

        if(start == end){
            this.segmentTree[index] = arr[start].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        helper(start, mid, 2*index + 1);
        helper(mid+1, end, 2*index + 2);
        this.segmentTree[index] = this.segmentTree[2*index+1] + this.segmentTree[2*index+2];
    }

    public void updateHelper(int start, int end, int arrIndex, int segIndex) {

        if(start == end){
            this.segmentTree[segIndex] = this.arr[arrIndex].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        if(arrIndex <= mid) updateHelper(start, mid, arrIndex, segIndex*2 + 1);
        else updateHelper(mid+1, end, arrIndex, segIndex*2 + 2);

        this.segmentTree[segIndex] = this.segmentTree[2*segIndex+1] + this.segmentTree[2*segIndex+2];
    }

    public void update(int index, T newValue){
        this.arr[index] = newValue;
        updateHelper(0,n-1, index, 0);
    }

    public Double query(int start, int end){
        return query(start, end, 0, n-1,0);
    }

    private Double query(int start, int end, int vStart, int vEnd, int index){

        System.out.println(start + "" "" + end + "" "" + vStart + "" "" + vEnd + "" "" + index);
        if(start>end) return 0.0;

        if(start == vStart && end == vEnd) return segmentTree[index];
        if(start>vEnd || end<vStart) return 0.0;

        int mid = vStart + (vEnd - vStart)/2;

        if(end<=mid) return query(start, end, vStart, mid, 2*index+1);
        if(start>mid) return query(start, end, mid+1, vEnd, 2*index+2);

        return query(start, mid, vStart, mid, 2*index+1) +  query(mid+1, end, mid+1, vEnd, 2*index+2);
    }



    @Override
    public String toString() {
        return ""SegmentTree{"" +
                ""segmentTree="" + Arrays.toString(segmentTree) +
                "", arr="" + Arrays.toString(arr) +
                '}';
    }
}","(0, 0)","(2, 24)",N,"package_declaration,import_declaration",package_declaration,,15,b131d79c-9986-4bf9-8b7a-c43601f897b5
"public class SegmentTree<T extends Number> {

    private final int n;
    private final double[] segmentTree;
    private final T[] arr;

    SegmentTree(int n, T[] arr){
        this.n = n;
        int modifiedChildCount = (int) Math.pow(2, Math.ceil(Math.log(n)/Math.log(2)));
        int size = 2 * modifiedChildCount - 1;
        this.segmentTree = new double[size];
        this.arr = arr;
        buildSegmentTree(arr);
    }

    public void buildSegmentTree(T[] arr){
        helper(0, arr.length-1, 0);
    }

    public void helper(int start, int end, int index){

        if(start == end){
            this.segmentTree[index] = arr[start].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        helper(start, mid, 2*index + 1);
        helper(mid+1, end, 2*index + 2);
        this.segmentTree[index] = this.segmentTree[2*index+1] + this.segmentTree[2*index+2];
    }

    public void updateHelper(int start, int end, int arrIndex, int segIndex) {

        if(start == end){
            this.segmentTree[segIndex] = this.arr[arrIndex].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        if(arrIndex <= mid) updateHelper(start, mid, arrIndex, segIndex*2 + 1);
        else updateHelper(mid+1, end, arrIndex, segIndex*2 + 2);

        this.segmentTree[segIndex] = this.segmentTree[2*segIndex+1] + this.segmentTree[2*segIndex+2];
    }

    public void update(int index, T newValue){
        this.arr[index] = newValue;
        updateHelper(0,n-1, index, 0);
    }

    public Double query(int start, int end){
        return query(start, end, 0, n-1,0);
    }

    private Double query(int start, int end, int vStart, int vEnd, int index){

        System.out.println(start + "" "" + end + "" "" + vStart + "" "" + vEnd + "" "" + index);
        if(start>end) return 0.0;

        if(start == vStart && end == vEnd) return segmentTree[index];
        if(start>vEnd || end<vStart) return 0.0;

        int mid = vStart + (vEnd - vStart)/2;

        if(end<=mid) return query(start, end, vStart, mid, 2*index+1);
        if(start>mid) return query(start, end, mid+1, vEnd, 2*index+2);

        return query(start, mid, vStart, mid, 2*index+1) +  query(mid+1, end, mid+1, vEnd, 2*index+2);
    }



    @Override
    public String toString() {
        return ""SegmentTree{"" +
                ""segmentTree="" + Arrays.toString(segmentTree) +
                "", arr="" + Arrays.toString(arr) +
                '}';
    }
}",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/,program,"package com.akarsh.codechef.segmentTree;
import java.util.Arrays;","private final int n;
private final double[] segmentTree;
private final T[] arr;","(4, 0)","(84, 1)",N,class_declaration,SegmentTree,,691,0f4e886f-8c7d-42a5-8620-de3114beeb54
"private final int n;
private final double[] segmentTree;
private final T[] arr;",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,Previous sibling does not exist,"SegmentTree(int n, T[] arr){
        this.n = n;
        int modifiedChildCount = (int) Math.pow(2, Math.ceil(Math.log(n)/Math.log(2)));
        int size = 2 * modifiedChildCount - 1;
        this.segmentTree = new double[size];
        this.arr = arr;
        buildSegmentTree(arr);
    }","(6, 4)","(8, 26)",N,"field_declaration,field_declaration,field_declaration",field_declaration,,18,fefc9484-6289-43ee-9227-7a6baf362b5a
"SegmentTree(int n, T[] arr){
        this.n = n;
        int modifiedChildCount = (int) Math.pow(2, Math.ceil(Math.log(n)/Math.log(2)));
        int size = 2 * modifiedChildCount - 1;
        this.segmentTree = new double[size];
        this.arr = arr;
        buildSegmentTree(arr);
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"private final int n;
private final double[] segmentTree;
private final T[] arr;","public void buildSegmentTree(T[] arr){
        helper(0, arr.length-1, 0);
    }","(10, 4)","(17, 5)",N,constructor_declaration,SegmentTree,,77,ec9ed90e-be58-4a64-9473-a9548595a20b
"public void buildSegmentTree(T[] arr){
        helper(0, arr.length-1, 0);
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"SegmentTree(int n, T[] arr){
        this.n = n;
        int modifiedChildCount = (int) Math.pow(2, Math.ceil(Math.log(n)/Math.log(2)));
        int size = 2 * modifiedChildCount - 1;
        this.segmentTree = new double[size];
        this.arr = arr;
        buildSegmentTree(arr);
    }","public void helper(int start, int end, int index){

        if(start == end){
            this.segmentTree[index] = arr[start].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        helper(start, mid, 2*index + 1);
        helper(mid+1, end, 2*index + 2);
        this.segmentTree[index] = this.segmentTree[2*index+1] + this.segmentTree[2*index+2];
    }","(19, 4)","(21, 5)",N,method_declaration,buildSegmentTree,,24,906415fa-93f2-4d9e-a775-319c0e4f8a83
"public void helper(int start, int end, int index){

        if(start == end){
            this.segmentTree[index] = arr[start].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        helper(start, mid, 2*index + 1);
        helper(mid+1, end, 2*index + 2);
        this.segmentTree[index] = this.segmentTree[2*index+1] + this.segmentTree[2*index+2];
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"public void buildSegmentTree(T[] arr){
        helper(0, arr.length-1, 0);
    }","public void updateHelper(int start, int end, int arrIndex, int segIndex) {

        if(start == end){
            this.segmentTree[segIndex] = this.arr[arrIndex].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        if(arrIndex <= mid) updateHelper(start, mid, arrIndex, segIndex*2 + 1);
        else updateHelper(mid+1, end, arrIndex, segIndex*2 + 2);

        this.segmentTree[segIndex] = this.segmentTree[2*segIndex+1] + this.segmentTree[2*segIndex+2];
    }","(23, 4)","(34, 5)",N,method_declaration,helper,,108,4687ef75-33c3-4801-a92b-f1f02aa6994b
"public void updateHelper(int start, int end, int arrIndex, int segIndex) {

        if(start == end){
            this.segmentTree[segIndex] = this.arr[arrIndex].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        if(arrIndex <= mid) updateHelper(start, mid, arrIndex, segIndex*2 + 1);
        else updateHelper(mid+1, end, arrIndex, segIndex*2 + 2);

        this.segmentTree[segIndex] = this.segmentTree[2*segIndex+1] + this.segmentTree[2*segIndex+2];
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"public void helper(int start, int end, int index){

        if(start == end){
            this.segmentTree[index] = arr[start].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        helper(start, mid, 2*index + 1);
        helper(mid+1, end, 2*index + 2);
        this.segmentTree[index] = this.segmentTree[2*index+1] + this.segmentTree[2*index+2];
    }","public void update(int index, T newValue){
        this.arr[index] = newValue;
        updateHelper(0,n-1, index, 0);
    }","(36, 4)","(48, 5)",N,method_declaration,updateHelper,,138,b35bf459-c96b-4350-a6f9-bfbdd5a89593
"public void update(int index, T newValue){
        this.arr[index] = newValue;
        updateHelper(0,n-1, index, 0);
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"public void updateHelper(int start, int end, int arrIndex, int segIndex) {

        if(start == end){
            this.segmentTree[segIndex] = this.arr[arrIndex].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        if(arrIndex <= mid) updateHelper(start, mid, arrIndex, segIndex*2 + 1);
        else updateHelper(mid+1, end, arrIndex, segIndex*2 + 2);

        this.segmentTree[segIndex] = this.segmentTree[2*segIndex+1] + this.segmentTree[2*segIndex+2];
    }","public Double query(int start, int end){
        return query(start, end, 0, n-1,0);
    }","(50, 4)","(53, 5)",N,method_declaration,update,,33,ee4f2271-012d-4cef-b046-5bbc1ee3eaba
"public Double query(int start, int end){
        return query(start, end, 0, n-1,0);
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"public void update(int index, T newValue){
        this.arr[index] = newValue;
        updateHelper(0,n-1, index, 0);
    }","private Double query(int start, int end, int vStart, int vEnd, int index){

        System.out.println(start + "" "" + end + "" "" + vStart + "" "" + vEnd + "" "" + index);
        if(start>end) return 0.0;

        if(start == vStart && end == vEnd) return segmentTree[index];
        if(start>vEnd || end<vStart) return 0.0;

        int mid = vStart + (vEnd - vStart)/2;

        if(end<=mid) return query(start, end, vStart, mid, 2*index+1);
        if(start>mid) return query(start, end, mid+1, vEnd, 2*index+2);

        return query(start, mid, vStart, mid, 2*index+1) +  query(mid+1, end, mid+1, vEnd, 2*index+2);
    }","(55, 4)","(57, 5)",N,method_declaration,query,,27,bcf7377e-3c31-4e27-9d90-7e264b4f8bf9
"private Double query(int start, int end, int vStart, int vEnd, int index){

        System.out.println(start + "" "" + end + "" "" + vStart + "" "" + vEnd + "" "" + index);
        if(start>end) return 0.0;

        if(start == vStart && end == vEnd) return segmentTree[index];
        if(start>vEnd || end<vStart) return 0.0;

        int mid = vStart + (vEnd - vStart)/2;

        if(end<=mid) return query(start, end, vStart, mid, 2*index+1);
        if(start>mid) return query(start, end, mid+1, vEnd, 2*index+2);

        return query(start, mid, vStart, mid, 2*index+1) +  query(mid+1, end, mid+1, vEnd, 2*index+2);
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"public Double query(int start, int end){
        return query(start, end, 0, n-1,0);
    }","@Override
    public String toString() {
        return ""SegmentTree{"" +
                ""segmentTree="" + Arrays.toString(segmentTree) +
                "", arr="" + Arrays.toString(arr) +
                '}';
    }","(59, 4)","(73, 5)",N,method_declaration,query,,203,9b874add-db1d-442d-8798-3a04b4a28329
"@Override
    public String toString() {
        return ""SegmentTree{"" +
                ""segmentTree="" + Arrays.toString(segmentTree) +
                "", arr="" + Arrays.toString(arr) +
                '}';
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"private Double query(int start, int end, int vStart, int vEnd, int index){

        System.out.println(start + "" "" + end + "" "" + vStart + "" "" + vEnd + "" "" + index);
        if(start>end) return 0.0;

        if(start == vStart && end == vEnd) return segmentTree[index];
        if(start>vEnd || end<vStart) return 0.0;

        int mid = vStart + (vEnd - vStart)/2;

        if(end<=mid) return query(start, end, vStart, mid, 2*index+1);
        if(start>mid) return query(start, end, mid+1, vEnd, 2*index+2);

        return query(start, mid, vStart, mid, 2*index+1) +  query(mid+1, end, mid+1, vEnd, 2*index+2);
    }",Next sibling does not exist,"(77, 4)","(83, 5)",N,method_declaration,toString,,41,04e73246-9c1f-4723-86e8-b166cc274cf9
"import math


class SegmentTree:

    def __init__(self, arr, operator, operationIdentity) -> None:
        self.arrLength = len(arr)
        self.arr = arr
        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))
        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1
        self.segmentTree = [None for i in range(self.segmentTreeLength)]
        self.operationIdentity = operationIdentity
        self.operation = operator
        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)
    
    
    def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]


    def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)
    
    def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)

    def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])
    
    def rightfill(self, num, start, end, fillNum = None):    
        if(not fillNum): fillNum = self.operationIdentity 
        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)

tree = SegmentTree([1,2,3,4,5,6], operator=lambda x, y : x*y, operationIdentity=1)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))

tree.update(0, 6)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))



tree.update(0,1)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))



tree.update(5, 0)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))


tree = SegmentTree([0 for i in range(6)], operator=lambda x, y : x+y, operationIdentity=0)

tree.rightfill(2, 0, 4, fillNum=1)
print(tree.segmentTree)

tree.rightfill(2, 0, 5, fillNum=1)
print(tree.segmentTree)

tree.rightfill(1, 0, 5, fillNum=1)
print(tree.segmentTree)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(127, 23)",N,module,module,,1237,5dfb0a86-41b2-4251-a1dc-175549894bb4
import math,SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/,module,Previous sibling does not exist,"class SegmentTree:

    def __init__(self, arr, operator, operationIdentity) -> None:
        self.arrLength = len(arr)
        self.arr = arr
        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))
        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1
        self.segmentTree = [None for i in range(self.segmentTreeLength)]
        self.operationIdentity = operationIdentity
        self.operation = operator
        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)
    
    
    def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]


    def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)
    
    def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)

    def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])
    
    def rightfill(self, num, start, end, fillNum = None):    
        if(not fillNum): fillNum = self.operationIdentity 
        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)","(0, 0)","(0, 11)",N,import_statement,import_statement,,2,a5515917-a196-404b-85b5-ae8b163b7a21
"class SegmentTree:

    def __init__(self, arr, operator, operationIdentity) -> None:
        self.arrLength = len(arr)
        self.arr = arr
        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))
        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1
        self.segmentTree = [None for i in range(self.segmentTreeLength)]
        self.operationIdentity = operationIdentity
        self.operation = operator
        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)
    
    
    def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]


    def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)
    
    def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)

    def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])
    
    def rightfill(self, num, start, end, fillNum = None):    
        if(not fillNum): fillNum = self.operationIdentity 
        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/,module,import math,"tree = SegmentTree([1,2,3,4,5,6], operator=lambda x, y : x*y, operationIdentity=1)","(3, 0)","(83, 88)",N,class_definition,SegmentTree,,937,a8e141c2-7e31-44ba-a941-58f2f7358297
"def __init__(self, arr, operator, operationIdentity) -> None:
        self.arrLength = len(arr)
        self.arr = arr
        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))
        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1
        self.segmentTree = [None for i in range(self.segmentTreeLength)]
        self.operationIdentity = operationIdentity
        self.operation = operator
        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/,SegmentTree,Previous sibling does not exist,"def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]","(5, 4)","(13, 67)",N,function_definition,__init__,,113,3dacca4d-d60c-4d75-a61b-f0830095774e
"def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/,SegmentTree,"def __init__(self, arr, operator, operationIdentity) -> None:
        self.arrLength = len(arr)
        self.arr = arr
        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))
        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1
        self.segmentTree = [None for i in range(self.segmentTreeLength)]
        self.operationIdentity = operationIdentity
        self.operation = operator
        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)","def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)","(16, 4)","(25, 38)",N,function_definition,buildSegmentTree,,128,43419651-cbd2-4142-a693-7f9dff6077d0
"def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/,SegmentTree,"def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]","def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)","(28, 4)","(38, 77)",N,function_definition,query,,148,03cfc7a5-c4c2-44b4-979f-e2c644118d10
"def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/function_definition-query/,query,Previous sibling does not exist,"return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)","(30, 8)","(36, 97)",N,function_definition,queryHelper,,118,75a087d7-e027-40a3-b259-bc3fd3ff6d6b
"def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/,SegmentTree,"def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)","def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])","(40, 4)","(56, 77)",N,function_definition,update,,169,6df87dcf-e775-4f30-a4f4-2d31cff7c905
"def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/function_definition-update/,update,Previous sibling does not exist,self.arr[index] = newValue,"(42, 8)","(51, 119)",N,function_definition,updateHelper,,131,e55bc6d0-db4e-43f6-a8db-db87150b2a6d
"def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/,SegmentTree,"def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)","def rightfill(self, num, start, end, fillNum = None):    
        if(not fillNum): fillNum = self.operationIdentity 
        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)","(58, 4)","(79, 106)",N,function_definition,fillhelper,,310,929fdbf2-0685-4b4d-acd1-879c09709c5f
"def rightfill(self, num, start, end, fillNum = None):    
        if(not fillNum): fillNum = self.operationIdentity 
        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/,SegmentTree,"def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])","tree = SegmentTree([1,2,3,4,5,6], operator=lambda x, y : x*y, operationIdentity=1)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree.update(0, 6)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree.update(0,1)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree.update(5, 0)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree = SegmentTree([0 for i in range(6)], operator=lambda x, y : x+y, operationIdentity=0)
tree.rightfill(2, 0, 4, fillNum=1)
print(tree.segmentTree)
tree.rightfill(2, 0, 5, fillNum=1)
print(tree.segmentTree)
tree.rightfill(1, 0, 5, fillNum=1)
print(tree.segmentTree)","(81, 4)","(83, 88)",N,function_definition,rightfill,,56,e416ef3a-a65c-4900-a641-c179b0c382a1
"tree = SegmentTree([1,2,3,4,5,6], operator=lambda x, y : x*y, operationIdentity=1)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree.update(0, 6)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree.update(0,1)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree.update(5, 0)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree = SegmentTree([0 for i in range(6)], operator=lambda x, y : x+y, operationIdentity=0)
tree.rightfill(2, 0, 4, fillNum=1)
print(tree.segmentTree)
tree.rightfill(2, 0, 5, fillNum=1)
print(tree.segmentTree)
tree.rightfill(1, 0, 5, fillNum=1)
print(tree.segmentTree)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/,module,"class SegmentTree:

    def __init__(self, arr, operator, operationIdentity) -> None:
        self.arrLength = len(arr)
        self.arr = arr
        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))
        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1
        self.segmentTree = [None for i in range(self.segmentTreeLength)]
        self.operationIdentity = operationIdentity
        self.operation = operator
        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)
    
    
    def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]


    def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)
    
    def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)

    def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])
    
    def rightfill(self, num, start, end, fillNum = None):    
        if(not fillNum): fillNum = self.operationIdentity 
        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)",Next sibling does not exist,"(85, 0)","(127, 23)",N,"expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement",expression_statement,,295,99088dfd-3d79-4869-bc8b-cba82cb588db
,__init__.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\__init__.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(0, 0)",N,module,module,,0,128f35c4-7c92-4b91-b9e3-d10d0f77741c
"public class BubbleSort implements SortingAlgorithm{

    @Override
    public int[] sort(int[] arr) {
        for(int i=0; i < arr.length-1; i++){
            for(int j=0; j < arr.length-i-1; j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        return arr;
    }

}

// time: theta(n^2)
// space : theta(1)



// can use swap flag to check if ( arr is sorted before all the comparison ) to break out of the loop;

// in one iteration if no swaps
// arr is sorted
// break out of loop
",BubbleSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\BubbleSort.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 0)",N,program,program,,163,37b4e15e-c7a9-41c2-b9cb-23ea650b3a1e
"public class BubbleSort implements SortingAlgorithm{

    @Override
    public int[] sort(int[] arr) {
        for(int i=0; i < arr.length-1; i++){
            for(int j=0; j < arr.length-i-1; j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        return arr;
    }

}",BubbleSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\BubbleSort.java,program/,program,Previous sibling does not exist,// time: theta(n^2),"(0, 0)","(16, 1)",N,class_declaration,BubbleSort,,105,2819c1c7-251f-40a5-8068-1e7445dc5ea0
"@Override
    public int[] sort(int[] arr) {
        for(int i=0; i < arr.length-1; i++){
            for(int j=0; j < arr.length-i-1; j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        return arr;
    }",BubbleSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\BubbleSort.java,program/class_declaration-BubbleSort/,BubbleSort,Previous sibling does not exist,"// time: theta(n^2)
// space : theta(1)
// can use swap flag to check if ( arr is sorted before all the comparison ) to break out of the loop;
// in one iteration if no swaps
// arr is sorted
// break out of loop","(2, 4)","(14, 5)",N,method_declaration,sort,,94,4e534951-f5bb-428d-bb6f-68a8e35a722a
"// time: theta(n^2)
// space : theta(1)
// can use swap flag to check if ( arr is sorted before all the comparison ) to break out of the loop;
// in one iteration if no swaps
// arr is sorted
// break out of loop",BubbleSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\BubbleSort.java,program/,program,"public class BubbleSort implements SortingAlgorithm{

    @Override
    public int[] sort(int[] arr) {
        for(int i=0; i < arr.length-1; i++){
            for(int j=0; j < arr.length-i-1; j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        return arr;
    }

}",Next sibling does not exist,"(18, 0)","(27, 20)",N,"line_comment,line_comment,line_comment,line_comment,line_comment,line_comment",line_comment,,55,bcd760eb-0fd6-4b2d-8b8d-9b28efd9ab24
"class Solution:
    def maxScore(self, arr: List[int]) -> int:
        arr.sort(reverse = True)
        
        count = 0
        running_sum = 0
        
        for i in arr:
            running_sum += i
            if(running_sum>0): count+=1
        
        return count
",maxScore.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\maxScore.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(12, 0)",N,module,module,,66,8e17ebf2-0d46-4325-b1dd-00599b82ef43
"class Solution:
    def maxScore(self, arr: List[int]) -> int:
        arr.sort(reverse = True)
        
        count = 0
        running_sum = 0
        
        for i in arr:
            running_sum += i
            if(running_sum>0): count+=1
        
        return count",maxScore.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\maxScore.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(11, 20)",N,class_definition,Solution,,65,93c99ef8-72bb-4a80-a8ce-5ef6354062e9
"def maxScore(self, arr: List[int]) -> int:
        arr.sort(reverse = True)
        
        count = 0
        running_sum = 0
        
        for i in arr:
            running_sum += i
            if(running_sum>0): count+=1
        
        return count",maxScore.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\maxScore.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(11, 20)",N,function_definition,maxScore,,61,cd2d4546-817d-4934-aa11-29475045e839
"public class QuickSort implements SortingAlgorithm{

    @Override
    public int[] sort(int[] arr) {
        System.out.println(""using quick sort"");
        quicksort(arr,0, arr.length-1);
        return arr;
    }

    public void quicksort(int[] arr, int start, int end){

        if(start >= end) return;

        int pivot = arr[end];

        int left = start;
        int right = end-1;

        while(left<=right){
            if(arr[left]<=pivot) {
                left++;
            } else {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                right--;
            }
        }

        arr[end] = arr[left];
        arr[left] = pivot;

        quicksort(arr, start, left-1);
        quicksort(arr, left+1, end);
    }

}
",Quicksort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\Quicksort.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(37, 0)",N,program,program,,183,9e4d626a-ae84-4b74-ad30-15d22a186f95
"public class QuickSort implements SortingAlgorithm{

    @Override
    public int[] sort(int[] arr) {
        System.out.println(""using quick sort"");
        quicksort(arr,0, arr.length-1);
        return arr;
    }

    public void quicksort(int[] arr, int start, int end){

        if(start >= end) return;

        int pivot = arr[end];

        int left = start;
        int right = end-1;

        while(left<=right){
            if(arr[left]<=pivot) {
                left++;
            } else {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                right--;
            }
        }

        arr[end] = arr[left];
        arr[left] = pivot;

        quicksort(arr, start, left-1);
        quicksort(arr, left+1, end);
    }

}",Quicksort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\Quicksort.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(36, 1)",N,class_declaration,QuickSort,,183,85111b36-4d9a-494d-b9a9-0ed511f1a786
"@Override
    public int[] sort(int[] arr) {
        System.out.println(""using quick sort"");
        quicksort(arr,0, arr.length-1);
        return arr;
    }",Quicksort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\Quicksort.java,program/class_declaration-QuickSort/,QuickSort,Previous sibling does not exist,"public void quicksort(int[] arr, int start, int end){

        if(start >= end) return;

        int pivot = arr[end];

        int left = start;
        int right = end-1;

        while(left<=right){
            if(arr[left]<=pivot) {
                left++;
            } else {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                right--;
            }
        }

        arr[end] = arr[left];
        arr[left] = pivot;

        quicksort(arr, start, left-1);
        quicksort(arr, left+1, end);
    }","(2, 4)","(7, 5)",N,method_declaration,sort,,39,7e5eb011-5336-46cb-a59f-e6d35fe6fa69
"public void quicksort(int[] arr, int start, int end){

        if(start >= end) return;

        int pivot = arr[end];

        int left = start;
        int right = end-1;

        while(left<=right){
            if(arr[left]<=pivot) {
                left++;
            } else {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                right--;
            }
        }

        arr[end] = arr[left];
        arr[left] = pivot;

        quicksort(arr, start, left-1);
        quicksort(arr, left+1, end);
    }",Quicksort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\Quicksort.java,program/class_declaration-QuickSort/,QuickSort,"@Override
    public int[] sort(int[] arr) {
        System.out.println(""using quick sort"");
        quicksort(arr,0, arr.length-1);
        return arr;
    }",Next sibling does not exist,"(9, 4)","(34, 5)",N,method_declaration,quicksort,,132,e84900b6-18d6-450f-a030-4b0a1d094e92
"public class SelectionSort implements SortingAlgorithm{
    @Override
    public int[] sort(int[] arr) {

        for(int i=arr.length-1; i>=1; i--){
            int max = Integer.MIN_VALUE;
            int index = -1;

            for(int j=0; j<=i; j++){
                if(arr[j]>max){
                    max = arr[j];
                    index = j;
                }
            }

            arr[index] = arr[i];
            arr[i] = max;

        }

        return arr;
    }
}

//time: theta(n^2) space: O(1)
",SelectionSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\SelectionSort.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 0)",N,program,program,,126,3c53897c-bfc5-4b59-93e2-cbe5ed56a201
"public class SelectionSort implements SortingAlgorithm{
    @Override
    public int[] sort(int[] arr) {

        for(int i=arr.length-1; i>=1; i--){
            int max = Integer.MIN_VALUE;
            int index = -1;

            for(int j=0; j<=i; j++){
                if(arr[j]>max){
                    max = arr[j];
                    index = j;
                }
            }

            arr[index] = arr[i];
            arr[i] = max;

        }

        return arr;
    }
}",SelectionSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\SelectionSort.java,program/,program,Previous sibling does not exist,//time: theta(n^2) space: O(1),"(0, 0)","(22, 1)",N,class_declaration,SelectionSort,,112,ec6b49fc-de79-47af-b354-67d759968b6e
"@Override
    public int[] sort(int[] arr) {

        for(int i=arr.length-1; i>=1; i--){
            int max = Integer.MIN_VALUE;
            int index = -1;

            for(int j=0; j<=i; j++){
                if(arr[j]>max){
                    max = arr[j];
                    index = j;
                }
            }

            arr[index] = arr[i];
            arr[i] = max;

        }

        return arr;
    }",SelectionSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\SelectionSort.java,program/class_declaration-SelectionSort/,SelectionSort,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(21, 5)",N,method_declaration,sort,,101,6a7a2943-2f38-41b5-bfee-faa1b2078ff1
//time: theta(n^2) space: O(1),SelectionSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\SelectionSort.java,program/,program,"public class SelectionSort implements SortingAlgorithm{
    @Override
    public int[] sort(int[] arr) {

        for(int i=arr.length-1; i>=1; i--){
            int max = Integer.MIN_VALUE;
            int index = -1;

            for(int j=0; j<=i; j++){
                if(arr[j]>max){
                    max = arr[j];
                    index = j;
                }
            }

            arr[index] = arr[i];
            arr[i] = max;

        }

        return arr;
    }
}",Next sibling does not exist,"(24, 0)","(24, 30)",N,line_comment,line_comment,,14,696d1b20-1a34-4673-9279-cb23c7a892b4
"public interface SortingAlgorithm {
    int[] sort(int[] arr);
}
",SortingAlgorithm.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\SortingAlgorithm.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(3, 0)",N,program,program,,14,ee2dcfb4-d247-417b-afd8-5c8ac7cf922e
"public interface SortingAlgorithm {
    int[] sort(int[] arr);
}",SortingAlgorithm.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\SortingAlgorithm.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(2, 1)",N,interface_declaration,interface_declaration,,14,fb9f6592-6823-42eb-99f3-bacbc78248a9
"# using bucket sort -- O(n logk)
# another way it to use a heap of size k -- O(n)
# quickselect (loop this up) -- O(n)
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)
        counter = defaultdict(int)
        for num in nums: counter[num] += 1

        buckets = [[] for i in range(N+1)]
        for key in counter: buckets[counter[key]].append(key)

        ans = []
        index = N
        count = k
        while(count>0):
            bucket = buckets[index]
            for i in bucket: ans.append(i)
            index -= 1
            count -= len(bucket)

        return ans[:k]
",topKFrequent.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\topKFrequent.py,,NA,Previous sibling does not exist,"# using bucket sort -- O(n logk)
# another way it to use a heap of size k -- O(n)
# quickselect (loop this up) -- O(n)","(0, 0)","(23, 0)",N,module,module,,164,a657c255-015e-446e-907d-4977fdfdef8c
"# using bucket sort -- O(n logk)
# another way it to use a heap of size k -- O(n)
# quickselect (loop this up) -- O(n)",topKFrequent.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\topKFrequent.py,module/,module,Previous sibling does not exist,"class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)
        counter = defaultdict(int)
        for num in nums: counter[num] += 1

        buckets = [[] for i in range(N+1)]
        for key in counter: buckets[counter[key]].append(key)

        ans = []
        index = N
        count = k
        while(count>0):
            bucket = buckets[index]
            for i in bucket: ans.append(i)
            index -= 1
            count -= len(bucket)

        return ans[:k]","(0, 0)","(2, 36)",N,"comment,comment,comment",comment,,37,8fd44364-fe76-4d4d-bcfc-1e38f49c9d5c
"class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)
        counter = defaultdict(int)
        for num in nums: counter[num] += 1

        buckets = [[] for i in range(N+1)]
        for key in counter: buckets[counter[key]].append(key)

        ans = []
        index = N
        count = k
        while(count>0):
            bucket = buckets[index]
            for i in bucket: ans.append(i)
            index -= 1
            count -= len(bucket)

        return ans[:k]",topKFrequent.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\topKFrequent.py,module/,module,"# using bucket sort -- O(n logk)
# another way it to use a heap of size k -- O(n)
# quickselect (loop this up) -- O(n)",Next sibling does not exist,"(3, 0)","(22, 22)",N,class_definition,Solution,,127,b4d97faf-c458-44d5-8be5-81b5fb8c0d9f
"def topKFrequent(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)
        counter = defaultdict(int)
        for num in nums: counter[num] += 1

        buckets = [[] for i in range(N+1)]
        for key in counter: buckets[counter[key]].append(key)

        ans = []
        index = N
        count = k
        while(count>0):
            bucket = buckets[index]
            for i in bucket: ans.append(i)
            index -= 1
            count -= len(bucket)

        return ans[:k]",topKFrequent.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\topKFrequent.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(4, 4)","(22, 22)",N,function_definition,topKFrequent,,123,4c34192f-38e2-4a0a-a677-8a37e2c9f918
"class Solution {
    public String removeStars(String s) {
        Stack<Character> stack = new Stack();
        
        for(char ch: s.toCharArray()){
            if(ch=='*' && stack.isEmpty()) return """";
            else if(ch=='*') stack.pop();
            else stack.push(ch);
        }
        
        StringBuffer sb = new StringBuffer();
        
        while(!stack.isEmpty()) sb.append(stack.pop());
        
        return sb.reverse().toString();
        
    }
}
",RemoveStars.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\RemoveStars.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 0)",N,program,program,,91,5829eb0d-e472-46dd-ba16-0f7ee2f7ccf7
"class Solution {
    public String removeStars(String s) {
        Stack<Character> stack = new Stack();
        
        for(char ch: s.toCharArray()){
            if(ch=='*' && stack.isEmpty()) return """";
            else if(ch=='*') stack.pop();
            else stack.push(ch);
        }
        
        StringBuffer sb = new StringBuffer();
        
        while(!stack.isEmpty()) sb.append(stack.pop());
        
        return sb.reverse().toString();
        
    }
}",RemoveStars.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\RemoveStars.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 1)",N,class_declaration,Solution,,91,0a7626ee-9822-4e92-b978-8d247a247c70
"public String removeStars(String s) {
        Stack<Character> stack = new Stack();
        
        for(char ch: s.toCharArray()){
            if(ch=='*' && stack.isEmpty()) return """";
            else if(ch=='*') stack.pop();
            else stack.push(ch);
        }
        
        StringBuffer sb = new StringBuffer();
        
        while(!stack.isEmpty()) sb.append(stack.pop());
        
        return sb.reverse().toString();
        
    }",RemoveStars.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\RemoveStars.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(16, 5)",N,method_declaration,removeStars,,86,c0d53e35-3ce6-4e25-aa72-9e67f3479a80
"class Solution:
    def simplifyPath(self, path: str) -> str:

        arr = path.split('/')
        stack = []

        for op in arr:
            if(op == '' or op == '.'): continue
            elif(op == ""..""):
                if(stack): stack.pop()
            else:
                stack.append(op)

        return '/' + ""/"".join(stack)
",simplifyPath.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\simplifyPath.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 0)",N,module,module,,74,bc47ebf6-4ec7-412e-85c2-2a0c954f4725
"class Solution:
    def simplifyPath(self, path: str) -> str:

        arr = path.split('/')
        stack = []

        for op in arr:
            if(op == '' or op == '.'): continue
            elif(op == ""..""):
                if(stack): stack.pop()
            else:
                stack.append(op)

        return '/' + ""/"".join(stack)",simplifyPath.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\simplifyPath.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(13, 36)",N,class_definition,Solution,,74,ce10a40b-bbd7-4bcc-9cae-2191c1406282
"def simplifyPath(self, path: str) -> str:

        arr = path.split('/')
        stack = []

        for op in arr:
            if(op == '' or op == '.'): continue
            elif(op == ""..""):
                if(stack): stack.pop()
            else:
                stack.append(op)

        return '/' + ""/"".join(stack)",simplifyPath.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\simplifyPath.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(13, 36)",N,function_definition,simplifyPath,,70,797513ac-e307-42eb-b2ad-95cf1da92ff0
"class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        
        stack = set()
        pop_index = 0
        push_index = 0
        N = len(pushed)
        arr = []

        while(pop_index < N):
            val = popped[pop_index]

            while(push_index<N and val not in stack):
                arr.append(pushed[push_index])
                stack.add(pushed[push_index])
                push_index += 1
            
            # print(val, stack, arr)


            if(val in stack):
                if(arr[-1] == val):
                    arr.pop()
                    stack.remove(val)
                    pop_index += 1
                else:
                    return False
        
        return True

",validateStackSequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\validateStackSequences.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 0)",N,module,module,,157,316902b4-dbfe-4733-8ef6-b40fb5c2e500
"class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        
        stack = set()
        pop_index = 0
        push_index = 0
        N = len(pushed)
        arr = []

        while(pop_index < N):
            val = popped[pop_index]

            while(push_index<N and val not in stack):
                arr.append(pushed[push_index])
                stack.add(pushed[push_index])
                push_index += 1
            
            # print(val, stack, arr)


            if(val in stack):
                if(arr[-1] == val):
                    arr.pop()
                    stack.remove(val)
                    pop_index += 1
                else:
                    return False
        
        return True",validateStackSequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\validateStackSequences.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 19)",N,class_definition,Solution,,156,95dddd08-3d4c-45b8-b7f3-0c791a7c5798
"def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        
        stack = set()
        pop_index = 0
        push_index = 0
        N = len(pushed)
        arr = []

        while(pop_index < N):
            val = popped[pop_index]

            while(push_index<N and val not in stack):
                arr.append(pushed[push_index])
                stack.add(pushed[push_index])
                push_index += 1
            
            # print(val, stack, arr)


            if(val in stack):
                if(arr[-1] == val):
                    arr.pop()
                    stack.remove(val)
                    pop_index += 1
                else:
                    return False
        
        return True",validateStackSequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\validateStackSequences.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(28, 19)",N,function_definition,validateStackSequences,,152,8c2040e9-a1bb-46f6-8106-2612a2297908
"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;

public class NextGraterTemp {

    public static <T extends Comparable> List<Integer> getNextGraterTemp(List<T> tempartures){
        
        ArrayList<Integer> ans = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        
        for(int index = tempartures.size() -1; index>=0; index--){
            T temp = tempartures.get(index);
            
            while(!stack.empty() && tempartures.get(stack.peek()).compareTo(temp) != 1){
                stack.pop();
            }
            
            if(stack.isEmpty()) {
                ans.add(-1);
            } else {
                ans.add(stack.peek() - index);
            }
            
            stack.push(index);
        }

        Collections.reverse(ans);
        return ans;
    }

    public static void main(String[] args) {
        ArrayList<Double> input  = new ArrayList<>();
        // Arrays.asList()
        // input.add(73);
        // input.add(74);
        // input.add(75);
        // input.add(71);
        // input.add(69);
        // input.add(72);
        // input.add(76);
        // input.add(73);

        // 78.6,25.2,36.5,83.5,71.5
        input.add(78.6);
        input.add(25.2);
        input.add(36.5);
        input.add(83.5);
        input.add(71.5);


        List<Integer> ans = getNextGraterTemp(input);
        System.out.println(ans);
    }

}",NextGraterTemp.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\NextGraterTemp.java,,NA,Previous sibling does not exist,"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;","(0, 0)","(56, 1)",N,program,program,,338,9f839171-f758-47c7-a768-f4202f274b5e
"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;",NextGraterTemp.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\NextGraterTemp.java,program/,program,Previous sibling does not exist,"public class NextGraterTemp {

    public static <T extends Comparable> List<Integer> getNextGraterTemp(List<T> tempartures){
        
        ArrayList<Integer> ans = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        
        for(int index = tempartures.size() -1; index>=0; index--){
            T temp = tempartures.get(index);
            
            while(!stack.empty() && tempartures.get(stack.peek()).compareTo(temp) != 1){
                stack.pop();
            }
            
            if(stack.isEmpty()) {
                ans.add(-1);
            } else {
                ans.add(stack.peek() - index);
            }
            
            stack.push(index);
        }

        Collections.reverse(ans);
        return ans;
    }

    public static void main(String[] args) {
        ArrayList<Double> input  = new ArrayList<>();
        // Arrays.asList()
        // input.add(73);
        // input.add(74);
        // input.add(75);
        // input.add(71);
        // input.add(69);
        // input.add(72);
        // input.add(76);
        // input.add(73);

        // 78.6,25.2,36.5,83.5,71.5
        input.add(78.6);
        input.add(25.2);
        input.add(36.5);
        input.add(83.5);
        input.add(71.5);


        List<Integer> ans = getNextGraterTemp(input);
        System.out.println(ans);
    }

}","(0, 0)","(3, 23)",N,"import_declaration,import_declaration,import_declaration,import_declaration",import_declaration,,20,93fcadd4-0482-4678-9680-7ed58ce36eb1
"public class NextGraterTemp {

    public static <T extends Comparable> List<Integer> getNextGraterTemp(List<T> tempartures){
        
        ArrayList<Integer> ans = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        
        for(int index = tempartures.size() -1; index>=0; index--){
            T temp = tempartures.get(index);
            
            while(!stack.empty() && tempartures.get(stack.peek()).compareTo(temp) != 1){
                stack.pop();
            }
            
            if(stack.isEmpty()) {
                ans.add(-1);
            } else {
                ans.add(stack.peek() - index);
            }
            
            stack.push(index);
        }

        Collections.reverse(ans);
        return ans;
    }

    public static void main(String[] args) {
        ArrayList<Double> input  = new ArrayList<>();
        // Arrays.asList()
        // input.add(73);
        // input.add(74);
        // input.add(75);
        // input.add(71);
        // input.add(69);
        // input.add(72);
        // input.add(76);
        // input.add(73);

        // 78.6,25.2,36.5,83.5,71.5
        input.add(78.6);
        input.add(25.2);
        input.add(36.5);
        input.add(83.5);
        input.add(71.5);


        List<Integer> ans = getNextGraterTemp(input);
        System.out.println(ans);
    }

}",NextGraterTemp.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\NextGraterTemp.java,program/,program,"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;",Next sibling does not exist,"(5, 0)","(56, 1)",N,class_declaration,NextGraterTemp,,318,a2810b82-3523-4cef-b5b4-f773837625c9
"public static <T extends Comparable> List<Integer> getNextGraterTemp(List<T> tempartures){
        
        ArrayList<Integer> ans = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        
        for(int index = tempartures.size() -1; index>=0; index--){
            T temp = tempartures.get(index);
            
            while(!stack.empty() && tempartures.get(stack.peek()).compareTo(temp) != 1){
                stack.pop();
            }
            
            if(stack.isEmpty()) {
                ans.add(-1);
            } else {
                ans.add(stack.peek() - index);
            }
            
            stack.push(index);
        }

        Collections.reverse(ans);
        return ans;
    }",NextGraterTemp.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\NextGraterTemp.java,program/class_declaration-NextGraterTemp/,NextGraterTemp,Previous sibling does not exist,"public static void main(String[] args) {
        ArrayList<Double> input  = new ArrayList<>();
        // Arrays.asList()
        // input.add(73);
        // input.add(74);
        // input.add(75);
        // input.add(71);
        // input.add(69);
        // input.add(72);
        // input.add(76);
        // input.add(73);

        // 78.6,25.2,36.5,83.5,71.5
        input.add(78.6);
        input.add(25.2);
        input.add(36.5);
        input.add(83.5);
        input.add(71.5);


        List<Integer> ans = getNextGraterTemp(input);
        System.out.println(ans);
    }","(7, 4)","(30, 5)",N,method_declaration,getNextGraterTemp,,145,899bcfcf-4bda-40b6-8fe6-725b0d1506de
"public static void main(String[] args) {
        ArrayList<Double> input  = new ArrayList<>();
        // Arrays.asList()
        // input.add(73);
        // input.add(74);
        // input.add(75);
        // input.add(71);
        // input.add(69);
        // input.add(72);
        // input.add(76);
        // input.add(73);

        // 78.6,25.2,36.5,83.5,71.5
        input.add(78.6);
        input.add(25.2);
        input.add(36.5);
        input.add(83.5);
        input.add(71.5);


        List<Integer> ans = getNextGraterTemp(input);
        System.out.println(ans);
    }",NextGraterTemp.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\NextGraterTemp.java,program/class_declaration-NextGraterTemp/,NextGraterTemp,"public static <T extends Comparable> List<Integer> getNextGraterTemp(List<T> tempartures){
        
        ArrayList<Integer> ans = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        
        for(int index = tempartures.size() -1; index>=0; index--){
            T temp = tempartures.get(index);
            
            while(!stack.empty() && tempartures.get(stack.peek()).compareTo(temp) != 1){
                stack.pop();
            }
            
            if(stack.isEmpty()) {
                ans.add(-1);
            } else {
                ans.add(stack.peek() - index);
            }
            
            stack.push(index);
        }

        Collections.reverse(ans);
        return ans;
    }",Next sibling does not exist,"(32, 4)","(54, 5)",N,method_declaration,main,,163,23a20836-2dbd-42c8-b4b8-28d713d9ff9a
"class StockSpanner:

    def __init__(self):
        self.arr=[]
        self.count = 0

    def next(self, price: int) -> int:
        self.count += 1
        
        while(self.arr and self.arr[-1][0]<=price): self.arr.pop()
        self.arr.append([price, self.count])
        
        # print(self. count, self.arr)
        
        return self.count - self.arr[-2][1]  if(len(self.arr)>=2) else self.count
            


# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)
",StockSpanner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\StockSpanner.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 0)",N,module,module,,138,b25c2d19-a97b-4359-8b99-a0be239f1372
"class StockSpanner:

    def __init__(self):
        self.arr=[]
        self.count = 0

    def next(self, price: int) -> int:
        self.count += 1
        
        while(self.arr and self.arr[-1][0]<=price): self.arr.pop()
        self.arr.append([price, self.count])
        
        # print(self. count, self.arr)
        
        return self.count - self.arr[-2][1]  if(len(self.arr)>=2) else self.count",StockSpanner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\StockSpanner.py,module/,module,Previous sibling does not exist,# Your StockSpanner object will be instantiated and called as such:,"(0, 0)","(14, 81)",N,class_definition,StockSpanner,,105,38453505-9dc3-46c3-a7cb-31d8a5bdf394
"def __init__(self):
        self.arr=[]
        self.count = 0",StockSpanner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\StockSpanner.py,module/class_definition-StockSpanner/,StockSpanner,Previous sibling does not exist,"def next(self, price: int) -> int:
        self.count += 1
        
        while(self.arr and self.arr[-1][0]<=price): self.arr.pop()
        self.arr.append([price, self.count])
        
        # print(self. count, self.arr)
        
        return self.count - self.arr[-2][1]  if(len(self.arr)>=2) else self.count","(2, 4)","(4, 22)",N,function_definition,__init__,,16,910a1104-7572-42ea-a931-c7b824934fd3
"def next(self, price: int) -> int:
        self.count += 1
        
        while(self.arr and self.arr[-1][0]<=price): self.arr.pop()
        self.arr.append([price, self.count])
        
        # print(self. count, self.arr)
        
        return self.count - self.arr[-2][1]  if(len(self.arr)>=2) else self.count",StockSpanner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\StockSpanner.py,module/class_definition-StockSpanner/,StockSpanner,"def __init__(self):
        self.arr=[]
        self.count = 0","# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)","(6, 4)","(14, 81)",N,function_definition,next,,81,00923306-b6a6-4fe1-99d9-fe9316ea3588
"# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)",StockSpanner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\StockSpanner.py,module/,module,"class StockSpanner:

    def __init__(self):
        self.arr=[]
        self.count = 0

    def next(self, price: int) -> int:
        self.count += 1
        
        while(self.arr and self.arr[-1][0]<=price): self.arr.pop()
        self.arr.append([price, self.count])
        
        # print(self. count, self.arr)
        
        return self.count - self.arr[-2][1]  if(len(self.arr)>=2) else self.count",Next sibling does not exist,"(18, 0)","(20, 27)",N,"comment,comment,comment",comment,,30,103ce339-efce-4c43-9704-06857dcbc1a6
"class Solution {
    public int trap(int[] height) {
     
        int ans = 0;
        int index = 0;
        
        Stack<StackNode> stack = new Stack<>();
        
        while(index<height.length){
            
            int popedHeight = 0;
            
            while(!stack.empty() && height[index]>stack.peek().height) {
                ans += (stack.peek().height - popedHeight) * (index - stack.peek().index - 1);
                popedHeight = stack.peek().height;
                stack.pop();
            }
            
            if(!stack.empty()) ans += (height[index] - popedHeight) * (index - stack.peek().index - 1);
            stack.push(new StackNode(height[index], index));
            index++;
        }
        
        
        return ans;
    }
}


class StackNode{
    int height;
    int index;
    
    public StackNode(int height, int index){
        this.height = height;
        this.index = index;
    }
    
    public String toString(){
        return this.height + "" "" + this.index;
    }
    
}
",TrappingRainWater.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\TrappingRainWater.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(43, 0)",N,program,program,,227,bc582385-add6-4934-a7c0-5770ed2fe75c
"class Solution {
    public int trap(int[] height) {
     
        int ans = 0;
        int index = 0;
        
        Stack<StackNode> stack = new Stack<>();
        
        while(index<height.length){
            
            int popedHeight = 0;
            
            while(!stack.empty() && height[index]>stack.peek().height) {
                ans += (stack.peek().height - popedHeight) * (index - stack.peek().index - 1);
                popedHeight = stack.peek().height;
                stack.pop();
            }
            
            if(!stack.empty()) ans += (height[index] - popedHeight) * (index - stack.peek().index - 1);
            stack.push(new StackNode(height[index], index));
            index++;
        }
        
        
        return ans;
    }
}",TrappingRainWater.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\TrappingRainWater.java,program/,program,Previous sibling does not exist,"class StackNode{
    int height;
    int index;
    
    public StackNode(int height, int index){
        this.height = height;
        this.index = index;
    }
    
    public String toString(){
        return this.height + "" "" + this.index;
    }
    
}","(0, 0)","(26, 1)",N,class_declaration,Solution,,169,9ec341a5-f5f8-4ae3-b7ed-3f59b4eef81f
"public int trap(int[] height) {
     
        int ans = 0;
        int index = 0;
        
        Stack<StackNode> stack = new Stack<>();
        
        while(index<height.length){
            
            int popedHeight = 0;
            
            while(!stack.empty() && height[index]>stack.peek().height) {
                ans += (stack.peek().height - popedHeight) * (index - stack.peek().index - 1);
                popedHeight = stack.peek().height;
                stack.pop();
            }
            
            if(!stack.empty()) ans += (height[index] - popedHeight) * (index - stack.peek().index - 1);
            stack.push(new StackNode(height[index], index));
            index++;
        }
        
        
        return ans;
    }",TrappingRainWater.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\TrappingRainWater.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(25, 5)",N,method_declaration,trap,,164,7dd62ebe-6465-4331-940d-7d07c8337131
"class StackNode{
    int height;
    int index;
    
    public StackNode(int height, int index){
        this.height = height;
        this.index = index;
    }
    
    public String toString(){
        return this.height + "" "" + this.index;
    }
    
}",TrappingRainWater.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\TrappingRainWater.java,program/,program,"class Solution {
    public int trap(int[] height) {
     
        int ans = 0;
        int index = 0;
        
        Stack<StackNode> stack = new Stack<>();
        
        while(index<height.length){
            
            int popedHeight = 0;
            
            while(!stack.empty() && height[index]>stack.peek().height) {
                ans += (stack.peek().height - popedHeight) * (index - stack.peek().index - 1);
                popedHeight = stack.peek().height;
                stack.pop();
            }
            
            if(!stack.empty()) ans += (height[index] - popedHeight) * (index - stack.peek().index - 1);
            stack.push(new StackNode(height[index], index));
            index++;
        }
        
        
        return ans;
    }
}",Next sibling does not exist,"(29, 0)","(42, 1)",N,class_declaration,StackNode,,58,2e702a40-5fcd-4d37-bf24-af22a28e4486
"public StackNode(int height, int index){
        this.height = height;
        this.index = index;
    }",TrappingRainWater.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\TrappingRainWater.java,program/class_declaration-StackNode/,StackNode,int index;,"public String toString(){
        return this.height + "" "" + this.index;
    }","(33, 4)","(36, 5)",N,constructor_declaration,StackNode,,23,a73b160e-86bd-4177-9edc-462c12e7c0d4
"public String toString(){
        return this.height + "" "" + this.index;
    }",TrappingRainWater.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\TrappingRainWater.java,program/class_declaration-StackNode/,StackNode,"public StackNode(int height, int index){
        this.height = height;
        this.index = index;
    }",Next sibling does not exist,"(38, 4)","(40, 5)",N,method_declaration,toString,,17,2d5945b2-4b3b-479f-a30d-ea76709ddb39
"class PatternMatcher:

    def __init__(self):
        self.mod = 10**9 + 9
        self.p = 31
        self.pow_p = []

        self.pattern = None
        self.s = None

        self.n = None
        self.m = None
        self.strHash = {}
    
    def fill_pow_p(self, num):
        cur = 1

        while(num>=0):
            self.pow_p.append(cur)
            cur *= self.p
            num -= 1
    
    def getStrHash(self, index):
        if(index == 0):
            ans = 0
            for index, ch in enumerate(self.s[:self.m]):
                ans = (ans%self.mod +  ((ord(ch) - 96) * self.pow_p[self.m-1-index])%self.mod) % self.mod 
        
            self.strHash[0] = ans
            return ans

        if(index in self.strHash): return  self.strHash[index]
        
        prevHash = self.getStrHash(index-1)
        ans = (
            (prevHash * self.p) 
            - ( (ord(self.s[index-1]) - 96) * self.pow_p[self.m]) 
            + (ord(self.s[index+self.m-1]) - 96)
            ) % self.mod
        self.strHash[index] = ans
        return ans

    def patternMatching(self, s, pattern):
        ans = []

        self.pattern = pattern
        self.s = s
        self.m = len(pattern)
        self.n = len(s)
        self.fill_pow_p(self.m)

        patternHash = 0
        for pi, pc in enumerate(self.pattern):
            patternHash = (patternHash%self.mod +  ((ord(pc) - 96) * self.pow_p[self.m-1-pi])%self.mod) % self.mod
    
        strHash = None

        endIndex = (self.n-self.m+1)
        index = 0
        while(index < endIndex):
            strHash = self.getStrHash(index)
            if(patternHash == strHash): ans.append(index)
            index += 1

        return ans


sol = PatternMatcher()
print(sol.patternMatching(""hellohello"", ""llo""))
print(sol.strHash)
print(sol.pow_p)
",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(71, 0)",N,module,module,,483,6835c63f-ba61-4ee9-a766-80ffa7055d5c
"class PatternMatcher:

    def __init__(self):
        self.mod = 10**9 + 9
        self.p = 31
        self.pow_p = []

        self.pattern = None
        self.s = None

        self.n = None
        self.m = None
        self.strHash = {}
    
    def fill_pow_p(self, num):
        cur = 1

        while(num>=0):
            self.pow_p.append(cur)
            cur *= self.p
            num -= 1
    
    def getStrHash(self, index):
        if(index == 0):
            ans = 0
            for index, ch in enumerate(self.s[:self.m]):
                ans = (ans%self.mod +  ((ord(ch) - 96) * self.pow_p[self.m-1-index])%self.mod) % self.mod 
        
            self.strHash[0] = ans
            return ans

        if(index in self.strHash): return  self.strHash[index]
        
        prevHash = self.getStrHash(index-1)
        ans = (
            (prevHash * self.p) 
            - ( (ord(self.s[index-1]) - 96) * self.pow_p[self.m]) 
            + (ord(self.s[index+self.m-1]) - 96)
            ) % self.mod
        self.strHash[index] = ans
        return ans

    def patternMatching(self, s, pattern):
        ans = []

        self.pattern = pattern
        self.s = s
        self.m = len(pattern)
        self.n = len(s)
        self.fill_pow_p(self.m)

        patternHash = 0
        for pi, pc in enumerate(self.pattern):
            patternHash = (patternHash%self.mod +  ((ord(pc) - 96) * self.pow_p[self.m-1-pi])%self.mod) % self.mod
    
        strHash = None

        endIndex = (self.n-self.m+1)
        index = 0
        while(index < endIndex):
            strHash = self.getStrHash(index)
            if(patternHash == strHash): ans.append(index)
            index += 1

        return ans",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,module/,module,Previous sibling does not exist,sol = PatternMatcher(),"(0, 0)","(64, 18)",N,class_definition,PatternMatcher,,455,a4cbfdd8-86b2-4e5f-881f-04b519ab31fd
"def __init__(self):
        self.mod = 10**9 + 9
        self.p = 31
        self.pow_p = []

        self.pattern = None
        self.s = None

        self.n = None
        self.m = None
        self.strHash = {}",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,module/class_definition-PatternMatcher/,PatternMatcher,Previous sibling does not exist,"def fill_pow_p(self, num):
        cur = 1

        while(num>=0):
            self.pow_p.append(cur)
            cur *= self.p
            num -= 1","(2, 4)","(12, 25)",N,function_definition,__init__,,61,6d126c10-cd8a-4d0c-9bfc-9f93c8898eef
"def fill_pow_p(self, num):
        cur = 1

        while(num>=0):
            self.pow_p.append(cur)
            cur *= self.p
            num -= 1",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,module/class_definition-PatternMatcher/,PatternMatcher,"def __init__(self):
        self.mod = 10**9 + 9
        self.p = 31
        self.pow_p = []

        self.pattern = None
        self.s = None

        self.n = None
        self.m = None
        self.strHash = {}","def getStrHash(self, index):
        if(index == 0):
            ans = 0
            for index, ch in enumerate(self.s[:self.m]):
                ans = (ans%self.mod +  ((ord(ch) - 96) * self.pow_p[self.m-1-index])%self.mod) % self.mod 
        
            self.strHash[0] = ans
            return ans

        if(index in self.strHash): return  self.strHash[index]
        
        prevHash = self.getStrHash(index-1)
        ans = (
            (prevHash * self.p) 
            - ( (ord(self.s[index-1]) - 96) * self.pow_p[self.m]) 
            + (ord(self.s[index+self.m-1]) - 96)
            ) % self.mod
        self.strHash[index] = ans
        return ans","(14, 4)","(20, 20)",N,function_definition,fill_pow_p,,38,d31056c7-cbdd-4b4f-a5e5-58f774a31dd2
"def getStrHash(self, index):
        if(index == 0):
            ans = 0
            for index, ch in enumerate(self.s[:self.m]):
                ans = (ans%self.mod +  ((ord(ch) - 96) * self.pow_p[self.m-1-index])%self.mod) % self.mod 
        
            self.strHash[0] = ans
            return ans

        if(index in self.strHash): return  self.strHash[index]
        
        prevHash = self.getStrHash(index-1)
        ans = (
            (prevHash * self.p) 
            - ( (ord(self.s[index-1]) - 96) * self.pow_p[self.m]) 
            + (ord(self.s[index+self.m-1]) - 96)
            ) % self.mod
        self.strHash[index] = ans
        return ans",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,module/class_definition-PatternMatcher/,PatternMatcher,"def fill_pow_p(self, num):
        cur = 1

        while(num>=0):
            self.pow_p.append(cur)
            cur *= self.p
            num -= 1","def patternMatching(self, s, pattern):
        ans = []

        self.pattern = pattern
        self.s = s
        self.m = len(pattern)
        self.n = len(s)
        self.fill_pow_p(self.m)

        patternHash = 0
        for pi, pc in enumerate(self.pattern):
            patternHash = (patternHash%self.mod +  ((ord(pc) - 96) * self.pow_p[self.m-1-pi])%self.mod) % self.mod
    
        strHash = None

        endIndex = (self.n-self.m+1)
        index = 0
        while(index < endIndex):
            strHash = self.getStrHash(index)
            if(patternHash == strHash): ans.append(index)
            index += 1

        return ans","(22, 4)","(40, 18)",N,function_definition,getStrHash,,182,ccf30a94-ffd6-44b2-8fe3-0d1a51f6b694
"def patternMatching(self, s, pattern):
        ans = []

        self.pattern = pattern
        self.s = s
        self.m = len(pattern)
        self.n = len(s)
        self.fill_pow_p(self.m)

        patternHash = 0
        for pi, pc in enumerate(self.pattern):
            patternHash = (patternHash%self.mod +  ((ord(pc) - 96) * self.pow_p[self.m-1-pi])%self.mod) % self.mod
    
        strHash = None

        endIndex = (self.n-self.m+1)
        index = 0
        while(index < endIndex):
            strHash = self.getStrHash(index)
            if(patternHash == strHash): ans.append(index)
            index += 1

        return ans",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,module/class_definition-PatternMatcher/,PatternMatcher,"def getStrHash(self, index):
        if(index == 0):
            ans = 0
            for index, ch in enumerate(self.s[:self.m]):
                ans = (ans%self.mod +  ((ord(ch) - 96) * self.pow_p[self.m-1-index])%self.mod) % self.mod 
        
            self.strHash[0] = ans
            return ans

        if(index in self.strHash): return  self.strHash[index]
        
        prevHash = self.getStrHash(index-1)
        ans = (
            (prevHash * self.p) 
            - ( (ord(self.s[index-1]) - 96) * self.pow_p[self.m]) 
            + (ord(self.s[index+self.m-1]) - 96)
            ) % self.mod
        self.strHash[index] = ans
        return ans","sol = PatternMatcher()
print(sol.patternMatching(""hellohello"", ""llo""))
print(sol.strHash)
print(sol.pow_p)","(42, 4)","(64, 18)",N,function_definition,patternMatching,,163,8b331957-071b-4713-b65c-ac801dac881f
"sol = PatternMatcher()
print(sol.patternMatching(""hellohello"", ""llo""))
print(sol.strHash)
print(sol.pow_p)",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,module/,module,"class PatternMatcher:

    def __init__(self):
        self.mod = 10**9 + 9
        self.p = 31
        self.pow_p = []

        self.pattern = None
        self.s = None

        self.n = None
        self.m = None
        self.strHash = {}
    
    def fill_pow_p(self, num):
        cur = 1

        while(num>=0):
            self.pow_p.append(cur)
            cur *= self.p
            num -= 1
    
    def getStrHash(self, index):
        if(index == 0):
            ans = 0
            for index, ch in enumerate(self.s[:self.m]):
                ans = (ans%self.mod +  ((ord(ch) - 96) * self.pow_p[self.m-1-index])%self.mod) % self.mod 
        
            self.strHash[0] = ans
            return ans

        if(index in self.strHash): return  self.strHash[index]
        
        prevHash = self.getStrHash(index-1)
        ans = (
            (prevHash * self.p) 
            - ( (ord(self.s[index-1]) - 96) * self.pow_p[self.m]) 
            + (ord(self.s[index+self.m-1]) - 96)
            ) % self.mod
        self.strHash[index] = ans
        return ans

    def patternMatching(self, s, pattern):
        ans = []

        self.pattern = pattern
        self.s = s
        self.m = len(pattern)
        self.n = len(s)
        self.fill_pow_p(self.m)

        patternHash = 0
        for pi, pc in enumerate(self.pattern):
            patternHash = (patternHash%self.mod +  ((ord(pc) - 96) * self.pow_p[self.m-1-pi])%self.mod) % self.mod
    
        strHash = None

        endIndex = (self.n-self.m+1)
        index = 0
        while(index < endIndex):
            strHash = self.getStrHash(index)
            if(patternHash == strHash): ans.append(index)
            index += 1

        return ans",Next sibling does not exist,"(67, 0)","(70, 16)",N,"expression_statement,expression_statement,expression_statement,expression_statement",expression_statement,,27,a9d830d4-f705-4555-9bfc-86f3700adcca
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
        ans = []
        visited = collections.defaultdict(int)

        def inorder(root):
            if(not root): return (""null"", ""null"")

            in_l, pre_l = inorder(root.left)
            in_r, pre_r = inorder(root.right)

            cur_in = in_l + str(root.val) + in_r
            cur_pre = str(root.val) + pre_l + pre_r
            cur = (cur_in, cur_pre)

            if(cur in visited and visited[cur] == 1):
                # print(cur)
                ans.append(root)
                visited[cur] += 1
            else:
                visited[cur] += 1
            return cur
        
        inorder(root)
        return ans
",findDuplicateSubtrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\findDuplicateSubtrees.py,,NA,Previous sibling does not exist,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right","(0, 0)","(31, 0)",N,module,module,,220,7463e9f9-ebad-4065-a53b-fca85ed5363a
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",findDuplicateSubtrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\findDuplicateSubtrees.py,module/,module,Previous sibling does not exist,"class Solution:
    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
        ans = []
        visited = collections.defaultdict(int)

        def inorder(root):
            if(not root): return (""null"", ""null"")

            in_l, pre_l = inorder(root.left)
            in_r, pre_r = inorder(root.right)

            cur_in = in_l + str(root.val) + in_r
            cur_pre = str(root.val) + pre_l + pre_r
            cur = (cur_in, cur_pre)

            if(cur in visited and visited[cur] == 1):
                # print(cur)
                ans.append(root)
                visited[cur] += 1
            else:
                visited[cur] += 1
            return cur
        
        inorder(root)
        return ans","(0, 0)","(5, 28)",N,"comment,comment,comment,comment,comment,comment",comment,,48,8a4b53f7-6d6a-4591-b8e0-3da2aba77221
"class Solution:
    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
        ans = []
        visited = collections.defaultdict(int)

        def inorder(root):
            if(not root): return (""null"", ""null"")

            in_l, pre_l = inorder(root.left)
            in_r, pre_r = inorder(root.right)

            cur_in = in_l + str(root.val) + in_r
            cur_pre = str(root.val) + pre_l + pre_r
            cur = (cur_in, cur_pre)

            if(cur in visited and visited[cur] == 1):
                # print(cur)
                ans.append(root)
                visited[cur] += 1
            else:
                visited[cur] += 1
            return cur
        
        inorder(root)
        return ans",findDuplicateSubtrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\findDuplicateSubtrees.py,module/,module,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",Next sibling does not exist,"(6, 0)","(30, 18)",N,class_definition,Solution,,168,5db4bec0-7448-48ab-9292-a7e05eb889be
"def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
        ans = []
        visited = collections.defaultdict(int)

        def inorder(root):
            if(not root): return (""null"", ""null"")

            in_l, pre_l = inorder(root.left)
            in_r, pre_r = inorder(root.right)

            cur_in = in_l + str(root.val) + in_r
            cur_pre = str(root.val) + pre_l + pre_r
            cur = (cur_in, cur_pre)

            if(cur in visited and visited[cur] == 1):
                # print(cur)
                ans.append(root)
                visited[cur] += 1
            else:
                visited[cur] += 1
            return cur
        
        inorder(root)
        return ans",findDuplicateSubtrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\findDuplicateSubtrees.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(7, 4)","(30, 18)",N,function_definition,findDuplicateSubtrees,,164,daa13233-d286-44b4-b2bd-546cadf2e3d1
"def inorder(root):
            if(not root): return (""null"", ""null"")

            in_l, pre_l = inorder(root.left)
            in_r, pre_r = inorder(root.right)

            cur_in = in_l + str(root.val) + in_r
            cur_pre = str(root.val) + pre_l + pre_r
            cur = (cur_in, cur_pre)

            if(cur in visited and visited[cur] == 1):
                # print(cur)
                ans.append(root)
                visited[cur] += 1
            else:
                visited[cur] += 1
            return cur",findDuplicateSubtrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\findDuplicateSubtrees.py,module/class_definition-Solution/function_definition-findDuplicateSubtrees/,findDuplicateSubtrees,visited = collections.defaultdict(int),inorder(root),"(11, 8)","(27, 22)",N,function_definition,inorder,,123,7a4096e5-dc96-4869-b366-30f94512ef07
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:

        def helper(low, high):
            if(low > high): return []
            if(low == high): return [TreeNode(low)]

            ans = []
            for cur in range(low, high+1):
                left = helper(low, cur-1)
                right = helper(cur+1, high)

                if(not left):
                    for r in right:
                        node = TreeNode(cur)
                        node.right = r
                        ans.append(node)
                
                if(not right):
                    for l in left:
                        node = TreeNode(cur)
                        node.left = l
                        ans.append(node)
                    
                
                for l in left:
                    for r in right:
                        node = TreeNode(cur)
                        node.left, node.right = l, r
                        ans.append(node)
            
            return ans
        
        return helper(1, n)
",generateTrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\generateTrees.py,,NA,Previous sibling does not exist,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right","(0, 0)","(40, 0)",N,module,module,,239,c5c01452-6f3a-4e26-a4fa-6028f43ebbcb
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",generateTrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\generateTrees.py,module/,module,Previous sibling does not exist,"class Solution:
    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:

        def helper(low, high):
            if(low > high): return []
            if(low == high): return [TreeNode(low)]

            ans = []
            for cur in range(low, high+1):
                left = helper(low, cur-1)
                right = helper(cur+1, high)

                if(not left):
                    for r in right:
                        node = TreeNode(cur)
                        node.right = r
                        ans.append(node)
                
                if(not right):
                    for l in left:
                        node = TreeNode(cur)
                        node.left = l
                        ans.append(node)
                    
                
                for l in left:
                    for r in right:
                        node = TreeNode(cur)
                        node.left, node.right = l, r
                        ans.append(node)
            
            return ans
        
        return helper(1, n)","(0, 0)","(5, 28)",N,"comment,comment,comment,comment,comment,comment",comment,,48,67c6b12c-00fb-4ab5-b0a5-c977dc90113e
"class Solution:
    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:

        def helper(low, high):
            if(low > high): return []
            if(low == high): return [TreeNode(low)]

            ans = []
            for cur in range(low, high+1):
                left = helper(low, cur-1)
                right = helper(cur+1, high)

                if(not left):
                    for r in right:
                        node = TreeNode(cur)
                        node.right = r
                        ans.append(node)
                
                if(not right):
                    for l in left:
                        node = TreeNode(cur)
                        node.left = l
                        ans.append(node)
                    
                
                for l in left:
                    for r in right:
                        node = TreeNode(cur)
                        node.left, node.right = l, r
                        ans.append(node)
            
            return ans
        
        return helper(1, n)",generateTrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\generateTrees.py,module/,module,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",Next sibling does not exist,"(6, 0)","(39, 27)",N,class_definition,Solution,,188,e9213fce-b76b-4734-a7f7-678bb1bcc25a
"def generateTrees(self, n: int) -> List[Optional[TreeNode]]:

        def helper(low, high):
            if(low > high): return []
            if(low == high): return [TreeNode(low)]

            ans = []
            for cur in range(low, high+1):
                left = helper(low, cur-1)
                right = helper(cur+1, high)

                if(not left):
                    for r in right:
                        node = TreeNode(cur)
                        node.right = r
                        ans.append(node)
                
                if(not right):
                    for l in left:
                        node = TreeNode(cur)
                        node.left = l
                        ans.append(node)
                    
                
                for l in left:
                    for r in right:
                        node = TreeNode(cur)
                        node.left, node.right = l, r
                        ans.append(node)
            
            return ans
        
        return helper(1, n)",generateTrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\generateTrees.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(7, 4)","(39, 27)",N,function_definition,generateTrees,,184,31d40858-c356-496d-b0ec-b23e7340caff
"def helper(low, high):
            if(low > high): return []
            if(low == high): return [TreeNode(low)]

            ans = []
            for cur in range(low, high+1):
                left = helper(low, cur-1)
                right = helper(cur+1, high)

                if(not left):
                    for r in right:
                        node = TreeNode(cur)
                        node.right = r
                        ans.append(node)
                
                if(not right):
                    for l in left:
                        node = TreeNode(cur)
                        node.left = l
                        ans.append(node)
                    
                
                for l in left:
                    for r in right:
                        node = TreeNode(cur)
                        node.left, node.right = l, r
                        ans.append(node)
            
            return ans",generateTrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\generateTrees.py,module/class_definition-Solution/function_definition-generateTrees/,generateTrees,Previous sibling does not exist,"return helper(1, n)","(9, 8)","(37, 22)",N,function_definition,helper,,157,d22e4428-c1a8-4708-983d-7feb726ec092
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && targetSum == root.val) return true;
        
        return hasPathSum(root.left, targetSum-root.val) || hasPathSum(root.right, targetSum-root.val);
    }
}
",HasPathSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\HasPathSum.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(24, 0)",N,program,program,,163,a0ebbccd-f7f6-491b-a50a-4de3630915f6
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",HasPathSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\HasPathSum.java,program/,program,Previous sibling does not exist,"class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && targetSum == root.val) return true;
        
        return hasPathSum(root.left, targetSum-root.val) || hasPathSum(root.right, targetSum-root.val);
    }
}","(0, 0)","(14, 3)",N,block_comment,block_comment,,87,10ff15d9-03e7-44fe-8302-c9e3398f1a0a
"class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && targetSum == root.val) return true;
        
        return hasPathSum(root.left, targetSum-root.val) || hasPathSum(root.right, targetSum-root.val);
    }
}",HasPathSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\HasPathSum.java,program/,program,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",Next sibling does not exist,"(16, 0)","(23, 1)",N,class_declaration,Solution,,76,e1225638-1853-4d92-9866-06ec31b46a00
"public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && targetSum == root.val) return true;
        
        return hasPathSum(root.left, targetSum-root.val) || hasPathSum(root.right, targetSum-root.val);
    }",HasPathSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\HasPathSum.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(17, 4)","(22, 5)",N,method_declaration,hasPathSum,,71,5a55000c-c28a-42d4-981b-cca5379d776f
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        helper(root, ans);
        return ans;
    }
    
    
    public void helper(TreeNode root, List<Integer> ans){
        if(root==null) return;
        helper(root.left, ans);
        ans.add(root.val);
        helper(root.right, ans);
    }
}
",InorderTraversal.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\InorderTraversal.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 0)",N,program,program,,167,b7282be8-6406-4267-b750-f5d024c13fd5
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",InorderTraversal.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\InorderTraversal.java,program/,program,Previous sibling does not exist,"class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        helper(root, ans);
        return ans;
    }
    
    
    public void helper(TreeNode root, List<Integer> ans){
        if(root==null) return;
        helper(root.left, ans);
        ans.add(root.val);
        helper(root.right, ans);
    }
}","(0, 0)","(14, 3)",N,block_comment,block_comment,,87,32b7b339-c6f9-4719-82e8-3737f2cd86e1
"class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        helper(root, ans);
        return ans;
    }
    
    
    public void helper(TreeNode root, List<Integer> ans){
        if(root==null) return;
        helper(root.left, ans);
        ans.add(root.val);
        helper(root.right, ans);
    }
}",InorderTraversal.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\InorderTraversal.java,program/,program,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",Next sibling does not exist,"(15, 0)","(29, 1)",N,class_declaration,Solution,,80,b9a2cb36-1de7-429b-9413-178382be79f5
"public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        helper(root, ans);
        return ans;
    }",InorderTraversal.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\InorderTraversal.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public void helper(TreeNode root, List<Integer> ans){
        if(root==null) return;
        helper(root.left, ans);
        ans.add(root.val);
        helper(root.right, ans);
    }","(16, 4)","(20, 5)",N,method_declaration,inorderTraversal,,32,fc8d5fb9-afd7-47fb-98ab-49f643882f4e
"public void helper(TreeNode root, List<Integer> ans){
        if(root==null) return;
        helper(root.left, ans);
        ans.add(root.val);
        helper(root.right, ans);
    }",InorderTraversal.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\InorderTraversal.java,program/class_declaration-Solution/,Solution,"public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        helper(root, ans);
        return ans;
    }",Next sibling does not exist,"(23, 4)","(28, 5)",N,method_declaration,helper,,41,421e3b0c-de6f-4103-b86f-2626400a5e3c
"class Solution:
    def getLeaves(self, root):
        if(not root): return []


        left = []
        right = []

        if(not root.left and not root.right): return [root.val]
        if(root.left): left = self.getLeaves(root.left)
        if(root.right): right = self.getLeaves(root.right)

        return left + right


    
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:

        a = self.getLeaves(root1)
        b = self.getLeaves(root2)

        if(len(a)!=len(b)): return False

        return all(i == j for i, j in zip(a,b))
",leafSimilar.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\leafSimilar.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(24, 0)",N,module,module,,146,b0e36527-5e8a-46b4-bb05-2b2938e1b5ef
"class Solution:
    def getLeaves(self, root):
        if(not root): return []


        left = []
        right = []

        if(not root.left and not root.right): return [root.val]
        if(root.left): left = self.getLeaves(root.left)
        if(root.right): right = self.getLeaves(root.right)

        return left + right


    
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:

        a = self.getLeaves(root1)
        b = self.getLeaves(root2)

        if(len(a)!=len(b)): return False

        return all(i == j for i, j in zip(a,b))",leafSimilar.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\leafSimilar.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 47)",N,class_definition,Solution,,146,876ef93b-10b5-453d-8aa8-1d84c7be50c8
"def getLeaves(self, root):
        if(not root): return []


        left = []
        right = []

        if(not root.left and not root.right): return [root.val]
        if(root.left): left = self.getLeaves(root.left)
        if(root.right): right = self.getLeaves(root.right)

        return left + right",leafSimilar.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\leafSimilar.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:

        a = self.getLeaves(root1)
        b = self.getLeaves(root2)

        if(len(a)!=len(b)): return False

        return all(i == j for i, j in zip(a,b))","(1, 4)","(12, 27)",N,function_definition,getLeaves,,71,2b7a2953-5668-4519-bb86-3462bea3f04c
"def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:

        a = self.getLeaves(root1)
        b = self.getLeaves(root2)

        if(len(a)!=len(b)): return False

        return all(i == j for i, j in zip(a,b))",leafSimilar.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\leafSimilar.py,module/class_definition-Solution/,Solution,"def getLeaves(self, root):
        if(not root): return []


        left = []
        right = []

        if(not root.left and not root.right): return [root.val]
        if(root.left): left = self.getLeaves(root.left)
        if(root.right): right = self.getLeaves(root.right)

        return left + right",Next sibling does not exist,"(16, 4)","(23, 47)",N,function_definition,leafSimilar,,68,23dd69bf-0b89-4d40-b96b-101d6bc8f550
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:

    def helper(self, root):
        if(not root): return [0, 0]
        left, right = self.helper(root.left), self.helper(root.right)
        cur = [1 + left[1], 1 + right[0]]
        self.ans = max(self.ans, left[0], right[1], max(cur))
        return cur



    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.helper(root)
        return self.ans -1
        

",longestZigZag.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\longestZigZag.py,,NA,Previous sibling does not exist,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right","(0, 0)","(23, 0)",N,module,module,,170,a079660c-aacd-4d20-aa3a-b1bacf9f2c62
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",longestZigZag.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\longestZigZag.py,module/,module,Previous sibling does not exist,"class Solution:

    def helper(self, root):
        if(not root): return [0, 0]
        left, right = self.helper(root.left), self.helper(root.right)
        cur = [1 + left[1], 1 + right[0]]
        self.ans = max(self.ans, left[0], right[1], max(cur))
        return cur



    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.helper(root)
        return self.ans -1","(0, 0)","(5, 28)",N,"comment,comment,comment,comment,comment,comment",comment,,48,ae167078-5658-4768-b9ad-b27b831f4414
"class Solution:

    def helper(self, root):
        if(not root): return [0, 0]
        left, right = self.helper(root.left), self.helper(root.right)
        cur = [1 + left[1], 1 + right[0]]
        self.ans = max(self.ans, left[0], right[1], max(cur))
        return cur



    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.helper(root)
        return self.ans -1",longestZigZag.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\longestZigZag.py,module/,module,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",Next sibling does not exist,"(6, 0)","(20, 26)",N,class_definition,Solution,,117,eaef311f-b602-44a7-a214-2d4c82657950
"def helper(self, root):
        if(not root): return [0, 0]
        left, right = self.helper(root.left), self.helper(root.right)
        cur = [1 + left[1], 1 + right[0]]
        self.ans = max(self.ans, left[0], right[1], max(cur))
        return cur",longestZigZag.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\longestZigZag.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def longestZigZag(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.helper(root)
        return self.ans -1","(8, 4)","(13, 18)",N,function_definition,helper,,74,c1c07a27-24af-4cc4-a969-606d518792bb
"def longestZigZag(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.helper(root)
        return self.ans -1",longestZigZag.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\longestZigZag.py,module/class_definition-Solution/,Solution,"def helper(self, root):
        if(not root): return [0, 0]
        left, right = self.helper(root.left), self.helper(root.right)
        cur = [1 + left[1], 1 + right[0]]
        self.ans = max(self.ans, left[0], right[1], max(cur))
        return cur",Next sibling does not exist,"(17, 4)","(20, 26)",N,function_definition,longestZigZag,,37,f849a3ae-74ac-491a-b595-751d5bed26ab
"class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:

        def helper(root, minVal, maxVal):
            if(not root): return -1

            a = abs(root.val - maxVal)
            b = abs(root.val - minVal)
            cur = max(a, b)

            left = helper(root.left, min(minVal, root.val), max(maxVal, root.val))
            right = helper(root.right, min(minVal, root.val), max(maxVal, root.val))

            return max(left, right, cur)
        
        return helper(root, root.val, root.val)
",maxAncestorDiff.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxAncestorDiff.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 0)",N,module,module,,131,387ace8b-7347-4037-8b72-5408cf0d799f
"class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:

        def helper(root, minVal, maxVal):
            if(not root): return -1

            a = abs(root.val - maxVal)
            b = abs(root.val - minVal)
            cur = max(a, b)

            left = helper(root.left, min(minVal, root.val), max(maxVal, root.val))
            right = helper(root.right, min(minVal, root.val), max(maxVal, root.val))

            return max(left, right, cur)
        
        return helper(root, root.val, root.val)",maxAncestorDiff.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxAncestorDiff.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(15, 47)",N,class_definition,Solution,,131,a939464e-8228-455b-bc2e-a988b08b1049
"def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:

        def helper(root, minVal, maxVal):
            if(not root): return -1

            a = abs(root.val - maxVal)
            b = abs(root.val - minVal)
            cur = max(a, b)

            left = helper(root.left, min(minVal, root.val), max(maxVal, root.val))
            right = helper(root.right, min(minVal, root.val), max(maxVal, root.val))

            return max(left, right, cur)
        
        return helper(root, root.val, root.val)",maxAncestorDiff.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxAncestorDiff.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(15, 47)",N,function_definition,maxAncestorDiff,,127,1737a3b0-471a-4379-bd6c-345ac24f00ab
"def helper(root, minVal, maxVal):
            if(not root): return -1

            a = abs(root.val - maxVal)
            b = abs(root.val - minVal)
            cur = max(a, b)

            left = helper(root.left, min(minVal, root.val), max(maxVal, root.val))
            right = helper(root.right, min(minVal, root.val), max(maxVal, root.val))

            return max(left, right, cur)",maxAncestorDiff.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxAncestorDiff.py,module/class_definition-Solution/function_definition-maxAncestorDiff/,maxAncestorDiff,Previous sibling does not exist,"return helper(root, root.val, root.val)","(3, 8)","(13, 40)",N,function_definition,helper,,98,2c604a4f-32fe-41a8-9ead-5a7325b4cc7c
"class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:

        def helper(root):
            if(not root): return -10001,-10001

            leftx, leftmax  = helper(root.left)
            rightx, rightmax = helper(root.right)
            val = root.val

            ansx = max(val, val+leftx, val+rightx)
            ans = max(ansx, val + leftx + rightx, leftmax, rightmax) 
            return (ansx, ans)

        
        return max(helper(root))
",maxPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxPathSum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 0)",N,module,module,,120,23764b10-09f1-438e-afdb-2b82a52d3e7b
"class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:

        def helper(root):
            if(not root): return -10001,-10001

            leftx, leftmax  = helper(root.left)
            rightx, rightmax = helper(root.right)
            val = root.val

            ansx = max(val, val+leftx, val+rightx)
            ans = max(ansx, val + leftx + rightx, leftmax, rightmax) 
            return (ansx, ans)

        
        return max(helper(root))",maxPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxPathSum.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(15, 32)",N,class_definition,Solution,,120,9d82ddcf-6be3-4291-af80-1baca76c7c55
"def maxPathSum(self, root: Optional[TreeNode]) -> int:

        def helper(root):
            if(not root): return -10001,-10001

            leftx, leftmax  = helper(root.left)
            rightx, rightmax = helper(root.right)
            val = root.val

            ansx = max(val, val+leftx, val+rightx)
            ans = max(ansx, val + leftx + rightx, leftmax, rightmax) 
            return (ansx, ans)

        
        return max(helper(root))",maxPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxPathSum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(15, 32)",N,function_definition,maxPathSum,,116,e0f4c635-11e2-4428-9294-023f1cfdf4ec
"def helper(root):
            if(not root): return -10001,-10001

            leftx, leftmax  = helper(root.left)
            rightx, rightmax = helper(root.right)
            val = root.val

            ansx = max(val, val+leftx, val+rightx)
            ans = max(ansx, val + leftx + rightx, leftmax, rightmax) 
            return (ansx, ans)",maxPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxPathSum.py,module/class_definition-Solution/function_definition-maxPathSum/,maxPathSum,Previous sibling does not exist,return max(helper(root)),"(3, 8)","(12, 30)",N,function_definition,helper,,93,93e31270-d540-4d5d-a3fb-af8e92866403
"# Approach

# Two pass
# - first pass to get the sum of the tree
# - second pass to find the max product 


# Complexity
# - Time complexity: $$O(n)$$
# - Space complexity: $$O(n)$$


# Code

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:

        cache = {}
        mod = 10**9 + 7

        def getSumOfTree(root):
            if(root in cache): return cache[root]
            if not root: return 0

            left = getSumOfTree(root.left)
            right = getSumOfTree(root.right)
            
            ans = left + right + root.val

            cache[root] = ans
            return ans
        
        def ans(root, totalSum):
            if(not root): return -1

            sumVal = getSumOfTree(root)
            cur = (totalSum-sumVal) * (sumVal%mod)

            return max(cur, ans(root.left, totalSum), ans(root.right, totalSum))
        
        return ans(root, getSumOfTree(root))%mod
",maxProduct.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxProduct.py,,NA,Previous sibling does not exist,"# Approach
# Two pass
# - first pass to get the sum of the tree
# - second pass to find the max product 
# Complexity
# - Time complexity: $$O(n)$$
# - Space complexity: $$O(n)$$
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right","(0, 0)","(48, 0)",N,module,module,,287,066104d5-4314-412c-8033-ed9c2a15f596
"# Approach
# Two pass
# - first pass to get the sum of the tree
# - second pass to find the max product 
# Complexity
# - Time complexity: $$O(n)$$
# - Space complexity: $$O(n)$$
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",maxProduct.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxProduct.py,module/,module,Previous sibling does not exist,"class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:

        cache = {}
        mod = 10**9 + 7

        def getSumOfTree(root):
            if(root in cache): return cache[root]
            if not root: return 0

            left = getSumOfTree(root.left)
            right = getSumOfTree(root.right)
            
            ans = left + right + root.val

            cache[root] = ans
            return ans
        
        def ans(root, totalSum):
            if(not root): return -1

            sumVal = getSumOfTree(root)
            cur = (totalSum-sumVal) * (sumVal%mod)

            return max(cur, ans(root.left, totalSum), ans(root.right, totalSum))
        
        return ans(root, getSumOfTree(root))%mod","(0, 0)","(19, 28)",N,"comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment",comment,,98,70bd53c9-7813-48f8-a8b0-966ae2975d0e
"class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:

        cache = {}
        mod = 10**9 + 7

        def getSumOfTree(root):
            if(root in cache): return cache[root]
            if not root: return 0

            left = getSumOfTree(root.left)
            right = getSumOfTree(root.right)
            
            ans = left + right + root.val

            cache[root] = ans
            return ans
        
        def ans(root, totalSum):
            if(not root): return -1

            sumVal = getSumOfTree(root)
            cur = (totalSum-sumVal) * (sumVal%mod)

            return max(cur, ans(root.left, totalSum), ans(root.right, totalSum))
        
        return ans(root, getSumOfTree(root))%mod",maxProduct.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxProduct.py,module/,module,"# Approach
# Two pass
# - first pass to get the sum of the tree
# - second pass to find the max product 
# Complexity
# - Time complexity: $$O(n)$$
# - Space complexity: $$O(n)$$
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",Next sibling does not exist,"(21, 0)","(47, 48)",N,class_definition,Solution,,178,3596f3ad-f40d-4e25-a4e0-1f38e9ab9432
"def maxProduct(self, root: Optional[TreeNode]) -> int:

        cache = {}
        mod = 10**9 + 7

        def getSumOfTree(root):
            if(root in cache): return cache[root]
            if not root: return 0

            left = getSumOfTree(root.left)
            right = getSumOfTree(root.right)
            
            ans = left + right + root.val

            cache[root] = ans
            return ans
        
        def ans(root, totalSum):
            if(not root): return -1

            sumVal = getSumOfTree(root)
            cur = (totalSum-sumVal) * (sumVal%mod)

            return max(cur, ans(root.left, totalSum), ans(root.right, totalSum))
        
        return ans(root, getSumOfTree(root))%mod",maxProduct.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxProduct.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(22, 4)","(47, 48)",N,function_definition,maxProduct,,174,5cd734ca-f12d-41f5-aebd-2bc603537e49
"def getSumOfTree(root):
            if(root in cache): return cache[root]
            if not root: return 0

            left = getSumOfTree(root.left)
            right = getSumOfTree(root.right)
            
            ans = left + right + root.val

            cache[root] = ans
            return ans",maxProduct.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxProduct.py,module/class_definition-Solution/function_definition-maxProduct/,maxProduct,mod = 10**9 + 7,"def ans(root, totalSum):
            if(not root): return -1

            sumVal = getSumOfTree(root)
            cur = (totalSum-sumVal) * (sumVal%mod)

            return max(cur, ans(root.left, totalSum), ans(root.right, totalSum))","(27, 8)","(37, 22)",N,function_definition,getSumOfTree,,67,b0ca1bd8-1e80-44df-b964-1dbb49d12b6c
"def ans(root, totalSum):
            if(not root): return -1

            sumVal = getSumOfTree(root)
            cur = (totalSum-sumVal) * (sumVal%mod)

            return max(cur, ans(root.left, totalSum), ans(root.right, totalSum))",maxProduct.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxProduct.py,module/class_definition-Solution/function_definition-maxProduct/,maxProduct,"def getSumOfTree(root):
            if(root in cache): return cache[root]
            if not root: return 0

            left = getSumOfTree(root.left)
            right = getSumOfTree(root.right)
            
            ans = left + right + root.val

            cache[root] = ans
            return ans","return ans(root, getSumOfTree(root))%mod","(39, 8)","(45, 80)",N,function_definition,ans,,61,d37d30b3-18d4-45bb-8db5-30c4fc320192
"class Node:
    def  __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
    
    def __str__(self):
        return f""{{val: {self.val}, left: {self.left}, right: {self.right}}}""
    
class BST:

    def __init__(self):
        self.root = None
    
    def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)
    
    def __str__(self):
        return str(self.root)

class Solution:
    def numOfWays(self, nums: List[int]) -> int:
        bst = BST()
        for num in nums: bst.add(num)

        mod = 10**9 + 7

        @cache
        def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)


        def helper(node):
            if(not node): return 0, 1

            left, lp = helper(node.left)
            right, rp = helper(node.right)
            
            curp = (getPossiblePermutations(left, right)%mod * lp%mod * rp%mod)%mod
            return (left + 1 + right, curp)
        
        _, ans = helper(bst.root)
        return ans-1
",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(58, 0)",N,module,module,,394,957dc5ae-dfea-4125-8513-c235c4b122cf
"class Node:
    def  __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
    
    def __str__(self):
        return f""{{val: {self.val}, left: {self.left}, right: {self.right}}}""",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/,module,Previous sibling does not exist,"class BST:

    def __init__(self):
        self.root = None
    
    def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)
    
    def __str__(self):
        return str(self.root)","(0, 0)","(7, 77)",N,class_definition,Node,,62,e0d40914-0691-4f42-b618-19540586ce1d
"def  __init__(self, val):
        self.val = val
        self.left = None
        self.right = None",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-Node/,Node,Previous sibling does not exist,"def __str__(self):
        return f""{{val: {self.val}, left: {self.left}, right: {self.right}}}""","(1, 4)","(4, 25)",N,function_definition,__init__,,26,46c09786-3705-48bf-bf28-bb47c611471d
"def __str__(self):
        return f""{{val: {self.val}, left: {self.left}, right: {self.right}}}""",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-Node/,Node,"def  __init__(self, val):
        self.val = val
        self.left = None
        self.right = None",Next sibling does not exist,"(6, 4)","(7, 77)",N,function_definition,__str__,,30,5352a77e-4300-4ac8-853f-67eabf52f125
"class BST:

    def __init__(self):
        self.root = None
    
    def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)
    
    def __str__(self):
        return str(self.root)",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/,module,"class Node:
    def  __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
    
    def __str__(self):
        return f""{{val: {self.val}, left: {self.left}, right: {self.right}}}""","class Solution:
    def numOfWays(self, nums: List[int]) -> int:
        bst = BST()
        for num in nums: bst.add(num)

        mod = 10**9 + 7

        @cache
        def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)


        def helper(node):
            if(not node): return 0, 1

            left, lp = helper(node.left)
            right, rp = helper(node.right)
            
            curp = (getPossiblePermutations(left, right)%mod * lp%mod * rp%mod)%mod
            return (left + 1 + right, curp)
        
        _, ans = helper(bst.root)
        return ans-1","(9, 0)","(29, 29)",N,class_definition,BST,,119,6aa5407a-d5c1-4a50-8b4f-67b05517df63
"def __init__(self):
        self.root = None",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-BST/,BST,Previous sibling does not exist,"def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)","(11, 4)","(12, 24)",N,function_definition,__init__,,11,38f84246-87ce-48d5-afdf-5b522040b5e2
"def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-BST/,BST,"def __init__(self):
        self.root = None","def __str__(self):
        return str(self.root)","(14, 4)","(26, 37)",N,function_definition,add,,88,c8b82903-00fc-4076-b510-048c7de1620f
"def __str__(self):
        return str(self.root)",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-BST/,BST,"def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)",Next sibling does not exist,"(28, 4)","(29, 29)",N,function_definition,__str__,,12,22a2bcec-1911-4281-a8fe-53b9da47d9bd
"class Solution:
    def numOfWays(self, nums: List[int]) -> int:
        bst = BST()
        for num in nums: bst.add(num)

        mod = 10**9 + 7

        @cache
        def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)


        def helper(node):
            if(not node): return 0, 1

            left, lp = helper(node.left)
            right, rp = helper(node.right)
            
            curp = (getPossiblePermutations(left, right)%mod * lp%mod * rp%mod)%mod
            return (left + 1 + right, curp)
        
        _, ans = helper(bst.root)
        return ans-1",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/,module,"class BST:

    def __init__(self):
        self.root = None
    
    def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)
    
    def __str__(self):
        return str(self.root)",Next sibling does not exist,"(31, 0)","(57, 20)",N,class_definition,Solution,,211,3aa6da77-c1e7-4aac-b80e-d84085d9bb58
"def numOfWays(self, nums: List[int]) -> int:
        bst = BST()
        for num in nums: bst.add(num)

        mod = 10**9 + 7

        @cache
        def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)


        def helper(node):
            if(not node): return 0, 1

            left, lp = helper(node.left)
            right, rp = helper(node.right)
            
            curp = (getPossiblePermutations(left, right)%mod * lp%mod * rp%mod)%mod
            return (left + 1 + right, curp)
        
        _, ans = helper(bst.root)
        return ans-1",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(32, 4)","(57, 20)",N,function_definition,numOfWays,,207,be5577b7-8af8-4c00-86be-0ab55b238539
"@cache
        def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-Solution/function_definition-numOfWays/,numOfWays,mod = 10**9 + 7,"def helper(node):
            if(not node): return 0, 1

            left, lp = helper(node.left)
            right, rp = helper(node.right)
            
            curp = (getPossiblePermutations(left, right)%mod * lp%mod * rp%mod)%mod
            return (left + 1 + right, curp)","(38, 8)","(44, 96)",N,function_definition,"def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)",,77,819ee1a9-2dfd-4a72-b38b-8846c08f1431
"def helper(node):
            if(not node): return 0, 1

            left, lp = helper(node.left)
            right, rp = helper(node.right)
            
            curp = (getPossiblePermutations(left, right)%mod * lp%mod * rp%mod)%mod
            return (left + 1 + right, curp)",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-Solution/function_definition-numOfWays/,numOfWays,"@cache
        def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)","_, ans = helper(bst.root)","(47, 8)","(54, 43)",N,function_definition,helper,,73,05250687-a99b-49af-a2bd-08f52202647e
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode pruneTree(TreeNode root) {
        return helper(root) ? root : null;
    }
    
    public boolean helper(TreeNode root){
        if(root == null ) return false;
        
        boolean leftSubTreeHasOnes = helper(root.left);
        boolean rightSubTreeHasOnes = helper(root.right);
        
        if(!leftSubTreeHasOnes) root.left = null;
        if(!rightSubTreeHasOnes) root.right = null;
        
        return root.val == 1 || leftSubTreeHasOnes || rightSubTreeHasOnes;
    } 
    
    
}
",PruneTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\PruneTree.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(34, 0)",N,program,program,,214,4171b22f-7843-49b4-9eab-365ab3f34dbf
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",PruneTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\PruneTree.java,program/,program,Previous sibling does not exist,"class Solution {
    public TreeNode pruneTree(TreeNode root) {
        return helper(root) ? root : null;
    }
    
    public boolean helper(TreeNode root){
        if(root == null ) return false;
        
        boolean leftSubTreeHasOnes = helper(root.left);
        boolean rightSubTreeHasOnes = helper(root.right);
        
        if(!leftSubTreeHasOnes) root.left = null;
        if(!rightSubTreeHasOnes) root.right = null;
        
        return root.val == 1 || leftSubTreeHasOnes || rightSubTreeHasOnes;
    } 
    
    
}","(0, 0)","(14, 3)",N,block_comment,block_comment,,87,aa9a044f-b7f9-45a6-a2cf-cc3a924b4cce
"class Solution {
    public TreeNode pruneTree(TreeNode root) {
        return helper(root) ? root : null;
    }
    
    public boolean helper(TreeNode root){
        if(root == null ) return false;
        
        boolean leftSubTreeHasOnes = helper(root.left);
        boolean rightSubTreeHasOnes = helper(root.right);
        
        if(!leftSubTreeHasOnes) root.left = null;
        if(!rightSubTreeHasOnes) root.right = null;
        
        return root.val == 1 || leftSubTreeHasOnes || rightSubTreeHasOnes;
    } 
    
    
}",PruneTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\PruneTree.java,program/,program,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",Next sibling does not exist,"(15, 0)","(33, 1)",N,class_declaration,Solution,,127,dc1f2ddc-6ab3-492e-817a-e5919b11c74f
"public TreeNode pruneTree(TreeNode root) {
        return helper(root) ? root : null;
    }",PruneTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\PruneTree.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public boolean helper(TreeNode root){
        if(root == null ) return false;
        
        boolean leftSubTreeHasOnes = helper(root.left);
        boolean rightSubTreeHasOnes = helper(root.right);
        
        if(!leftSubTreeHasOnes) root.left = null;
        if(!rightSubTreeHasOnes) root.right = null;
        
        return root.val == 1 || leftSubTreeHasOnes || rightSubTreeHasOnes;
    }","(16, 4)","(18, 5)",N,method_declaration,pruneTree,,20,e485a059-eae6-4609-af68-58073325c716
"public boolean helper(TreeNode root){
        if(root == null ) return false;
        
        boolean leftSubTreeHasOnes = helper(root.left);
        boolean rightSubTreeHasOnes = helper(root.right);
        
        if(!leftSubTreeHasOnes) root.left = null;
        if(!rightSubTreeHasOnes) root.right = null;
        
        return root.val == 1 || leftSubTreeHasOnes || rightSubTreeHasOnes;
    }",PruneTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\PruneTree.java,program/class_declaration-Solution/,Solution,"public TreeNode pruneTree(TreeNode root) {
        return helper(root) ? root : null;
    }",Next sibling does not exist,"(20, 4)","(30, 5)",N,method_declaration,helper,,98,4dd4ec0f-77f1-46af-b78f-3dc0a0b74d9e
"class Solution:
    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:

        if(not root): 
            return 0
        
        ans = 0
        val = root.val

        if(low<=val<=high): 
            ans += val
        if(low<=val):
            ans += self.rangeSumBST(root.left, low, high)
        if(val<=high):
            ans += self.rangeSumBST(root.right, low, high)
        
        return ans
",rangeSumBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\rangeSumBST.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 0)",N,module,module,,109,1080e2da-d326-49e4-953e-ac7acc9b8aa9
"class Solution:
    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:

        if(not root): 
            return 0
        
        ans = 0
        val = root.val

        if(low<=val<=high): 
            ans += val
        if(low<=val):
            ans += self.rangeSumBST(root.left, low, high)
        if(val<=high):
            ans += self.rangeSumBST(root.right, low, high)
        
        return ans",rangeSumBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\rangeSumBST.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 18)",N,class_definition,Solution,,108,bff0cbfc-5af1-4cd1-90cf-67282903b5ab
"def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:

        if(not root): 
            return 0
        
        ans = 0
        val = root.val

        if(low<=val<=high): 
            ans += val
        if(low<=val):
            ans += self.rangeSumBST(root.left, low, high)
        if(val<=high):
            ans += self.rangeSumBST(root.right, low, high)
        
        return ans",rangeSumBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\rangeSumBST.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(16, 18)",N,function_definition,rangeSumBST,,104,a2404cf4-3c58-4ad1-b75c-710098da1bc1
"# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right



class Solution:
    def getMiddleNode(self, head):
        slow = head
        fast = head
        prev = None

        while(slow and fast and fast.next):
            prev = slow
            slow = slow.next
            fast = fast.next.next
        return prev


    def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root
    
    def inorder(self, node):
        if(not node): return
        self.inorder(node.left)
        print(node.val)
        self.inorder(node.right)

node = ListNode(-10)
node.next  = ListNode(-2)
node.next.next  = ListNode(3)
node.next.next.next  = ListNode(5)
node.next.next.next.next  = ListNode(10)
node.next.next.next.next.next  = ListNode(12)

Solution = Solution()
root = Solution.sortedListToBST(node)
Solution.inorder(root)",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(58, 22)",N,module,module,,348,7b14b536-6805-4134-b204-59784decede4
# Definition for singly-linked list.,sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/,module,Previous sibling does not exist,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next","(0, 0)","(0, 36)",N,comment,comment,,7,a4cef053-3715-4323-88c8-c19941b00a42
"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/,module,# Definition for singly-linked list.,# Definition for a binary tree node.,"(1, 0)","(4, 24)",N,class_definition,ListNode,,28,b6fcb47e-f9c5-4b9f-80d6-931552119269
"def __init__(self, val=0, next=None):
        self.val = val
        self.next = next",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/class_definition-ListNode/,ListNode,Previous sibling does not exist,Next sibling does not exist,"(2, 4)","(4, 24)",N,function_definition,__init__,,24,6ad2ba51-4579-45ac-ba77-ba06c06e1812
# Definition for a binary tree node.,sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/,module,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next","class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right","(5, 0)","(5, 36)",N,comment,comment,,8,e37221f9-3261-4705-821f-3c64d82240ce
"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/,module,# Definition for a binary tree node.,"class Solution:
    def getMiddleNode(self, head):
        slow = head
        fast = head
        prev = None

        while(slow and fast and fast.next):
            prev = slow
            slow = slow.next
            fast = fast.next.next
        return prev


    def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root
    
    def inorder(self, node):
        if(not node): return
        self.inorder(node.left)
        print(node.val)
        self.inorder(node.right)","(6, 0)","(10, 26)",N,class_definition,TreeNode,,37,b83ce51d-ae9b-4fa6-a660-6f36d0d01a0b
"def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/class_definition-TreeNode/,TreeNode,Previous sibling does not exist,Next sibling does not exist,"(7, 4)","(10, 26)",N,function_definition,__init__,,33,90b85c05-9ee1-4fbc-b5e0-79328b69ff63
"class Solution:
    def getMiddleNode(self, head):
        slow = head
        fast = head
        prev = None

        while(slow and fast and fast.next):
            prev = slow
            slow = slow.next
            fast = fast.next.next
        return prev


    def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root
    
    def inorder(self, node):
        if(not node): return
        self.inorder(node.left)
        print(node.val)
        self.inorder(node.right)",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/,module,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right",node = ListNode(-10),"(14, 0)","(47, 32)",N,class_definition,Solution,,192,568d68e1-41d2-43b4-a2db-00ddb610a6fa
"def getMiddleNode(self, head):
        slow = head
        fast = head
        prev = None

        while(slow and fast and fast.next):
            prev = slow
            slow = slow.next
            fast = fast.next.next
        return prev",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root","(15, 4)","(24, 19)",N,function_definition,getMiddleNode,,54,964877ac-0361-4a3c-96fd-7a24a8f4e925
"def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/class_definition-Solution/,Solution,"def getMiddleNode(self, head):
        slow = head
        fast = head
        prev = None

        while(slow and fast and fast.next):
            prev = slow
            slow = slow.next
            fast = fast.next.next
        return prev","def inorder(self, node):
        if(not node): return
        self.inorder(node.left)
        print(node.val)
        self.inorder(node.right)","(27, 4)","(41, 19)",N,function_definition,sortedListToBST,,98,55f6eb39-b37a-474d-bd7b-356e9251d155
"def inorder(self, node):
        if(not node): return
        self.inorder(node.left)
        print(node.val)
        self.inorder(node.right)",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/class_definition-Solution/,Solution,"def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root","node = ListNode(-10)
node.next  = ListNode(-2)
node.next.next  = ListNode(3)
node.next.next.next  = ListNode(5)
node.next.next.next.next  = ListNode(10)
node.next.next.next.next.next  = ListNode(12)
Solution = Solution()
root = Solution.sortedListToBST(node)
Solution.inorder(root)","(43, 4)","(47, 32)",N,function_definition,inorder,,32,b8b96993-a6da-4a2e-8877-ad4caa7efc60
"node = ListNode(-10)
node.next  = ListNode(-2)
node.next.next  = ListNode(3)
node.next.next.next  = ListNode(5)
node.next.next.next.next  = ListNode(10)
node.next.next.next.next.next  = ListNode(12)
Solution = Solution()
root = Solution.sortedListToBST(node)
Solution.inorder(root)",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/,module,"class Solution:
    def getMiddleNode(self, head):
        slow = head
        fast = head
        prev = None

        while(slow and fast and fast.next):
            prev = slow
            slow = slow.next
            fast = fast.next.next
        return prev


    def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root
    
    def inorder(self, node):
        if(not node): return
        self.inorder(node.left)
        print(node.val)
        self.inorder(node.right)",Next sibling does not exist,"(49, 0)","(58, 22)",N,"expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement",expression_statement,,74,e826bbf2-d2af-4ebc-83b2-a52c86474f81
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public String tree2str(TreeNode root) {
        String ans = helper(root);
        return ans.substring(1, ans.length()-1);
    }
    
    public String helper(TreeNode node){
        if(node==null) return ""()"";
        
        String ans = """";
        ans = ans + node.val;
        
        String left = helper(node.left);
        String right = helper(node.right);
        
        if(left.length()>=2 && right.length()>2) {
            ans = ans + left; 
            ans = ans + right;
        } else if(left.length()>2) ans = ans + left;
        
        return ""("" + ans + "")"";
    };
}
",Tree2Str.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\Tree2Str.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(38, 0)",N,program,program,,225,78154745-4b24-4f6e-883d-b25aedf8e870
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",Tree2Str.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\Tree2Str.java,program/,program,Previous sibling does not exist,"class Solution {
    public String tree2str(TreeNode root) {
        String ans = helper(root);
        return ans.substring(1, ans.length()-1);
    }
    
    public String helper(TreeNode node){
        if(node==null) return ""()"";
        
        String ans = """";
        ans = ans + node.val;
        
        String left = helper(node.left);
        String right = helper(node.right);
        
        if(left.length()>=2 && right.length()>2) {
            ans = ans + left; 
            ans = ans + right;
        } else if(left.length()>2) ans = ans + left;
        
        return ""("" + ans + "")"";
    };
}","(0, 0)","(14, 3)",N,block_comment,block_comment,,87,18033e81-7ceb-42cb-9336-a0c2ca82b73f
"class Solution {
    public String tree2str(TreeNode root) {
        String ans = helper(root);
        return ans.substring(1, ans.length()-1);
    }
    
    public String helper(TreeNode node){
        if(node==null) return ""()"";
        
        String ans = """";
        ans = ans + node.val;
        
        String left = helper(node.left);
        String right = helper(node.right);
        
        if(left.length()>=2 && right.length()>2) {
            ans = ans + left; 
            ans = ans + right;
        } else if(left.length()>2) ans = ans + left;
        
        return ""("" + ans + "")"";
    };
}",Tree2Str.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\Tree2Str.java,program/,program,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",Next sibling does not exist,"(15, 0)","(37, 1)",N,class_declaration,Solution,,138,1aca82d3-3456-4de2-abb9-3517d4237f0d
"public String tree2str(TreeNode root) {
        String ans = helper(root);
        return ans.substring(1, ans.length()-1);
    }",Tree2Str.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\Tree2Str.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public String helper(TreeNode node){
        if(node==null) return ""()"";
        
        String ans = """";
        ans = ans + node.val;
        
        String left = helper(node.left);
        String right = helper(node.right);
        
        if(left.length()>=2 && right.length()>2) {
            ans = ans + left; 
            ans = ans + right;
        } else if(left.length()>2) ans = ans + left;
        
        return ""("" + ans + "")"";
    }","(16, 4)","(19, 5)",N,method_declaration,tree2str,,30,6636a2e3-3448-446f-a6e0-336a6f300d5c
"public String helper(TreeNode node){
        if(node==null) return ""()"";
        
        String ans = """";
        ans = ans + node.val;
        
        String left = helper(node.left);
        String right = helper(node.right);
        
        if(left.length()>=2 && right.length()>2) {
            ans = ans + left; 
            ans = ans + right;
        } else if(left.length()>2) ans = ans + left;
        
        return ""("" + ans + "")"";
    }",Tree2Str.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\Tree2Str.java,program/class_declaration-Solution/,Solution,"public String tree2str(TreeNode root) {
        String ans = helper(root);
        return ans.substring(1, ans.length()-1);
    }",},"(21, 4)","(36, 5)",N,method_declaration,helper,,101,a0d052a2-2e09-45ab-8fac-3a45d2baff89
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:

        def appendNone(queue, count):
            while(queue and queue[-1][0] == None):
                node, sub_count = queue.pop()
                count += sub_count
            queue.append([None, count])

        if(not root): return 0

        ans = 1
        queue = [[root, 1]]
        l = 1

        while(queue):
            cur, count = queue.pop(0)
            l -= 1

            if(not cur): appendNone(queue, count*2)
            else:
                if(cur.left): queue.append([cur.left, 1])
                else: appendNone(queue, 1)
                
                if(cur.right): queue.append([cur.right, 1])
                else: appendNone(queue, 1)
            

            if(l == 0):
                while(queue and not queue[0][0]): queue.pop(0)
                while(queue and not queue[-1][0]): queue.pop()
                
                l = len(queue)
                ans = max(ans, sum([i[-1] for i in queue]))

        
        return ans


",widthOfBinaryTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\widthOfBinaryTree.py,,NA,Previous sibling does not exist,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right","(0, 0)","(45, 0)",N,module,module,,297,4813b11d-87a4-4084-9927-04e231512030
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",widthOfBinaryTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\widthOfBinaryTree.py,module/,module,Previous sibling does not exist,"class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:

        def appendNone(queue, count):
            while(queue and queue[-1][0] == None):
                node, sub_count = queue.pop()
                count += sub_count
            queue.append([None, count])

        if(not root): return 0

        ans = 1
        queue = [[root, 1]]
        l = 1

        while(queue):
            cur, count = queue.pop(0)
            l -= 1

            if(not cur): appendNone(queue, count*2)
            else:
                if(cur.left): queue.append([cur.left, 1])
                else: appendNone(queue, 1)
                
                if(cur.right): queue.append([cur.right, 1])
                else: appendNone(queue, 1)
            

            if(l == 0):
                while(queue and not queue[0][0]): queue.pop(0)
                while(queue and not queue[-1][0]): queue.pop()
                
                l = len(queue)
                ans = max(ans, sum([i[-1] for i in queue]))

        
        return ans","(0, 0)","(5, 28)",N,"comment,comment,comment,comment,comment,comment",comment,,48,64a63763-2b56-40ea-9da6-dae8e1e49238
"class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:

        def appendNone(queue, count):
            while(queue and queue[-1][0] == None):
                node, sub_count = queue.pop()
                count += sub_count
            queue.append([None, count])

        if(not root): return 0

        ans = 1
        queue = [[root, 1]]
        l = 1

        while(queue):
            cur, count = queue.pop(0)
            l -= 1

            if(not cur): appendNone(queue, count*2)
            else:
                if(cur.left): queue.append([cur.left, 1])
                else: appendNone(queue, 1)
                
                if(cur.right): queue.append([cur.right, 1])
                else: appendNone(queue, 1)
            

            if(l == 0):
                while(queue and not queue[0][0]): queue.pop(0)
                while(queue and not queue[-1][0]): queue.pop()
                
                l = len(queue)
                ans = max(ans, sum([i[-1] for i in queue]))

        
        return ans",widthOfBinaryTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\widthOfBinaryTree.py,module/,module,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",Next sibling does not exist,"(6, 0)","(42, 18)",N,class_definition,Solution,,245,917d1f7b-93f6-4d24-9bf1-5dbf40d0add0
"def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:

        def appendNone(queue, count):
            while(queue and queue[-1][0] == None):
                node, sub_count = queue.pop()
                count += sub_count
            queue.append([None, count])

        if(not root): return 0

        ans = 1
        queue = [[root, 1]]
        l = 1

        while(queue):
            cur, count = queue.pop(0)
            l -= 1

            if(not cur): appendNone(queue, count*2)
            else:
                if(cur.left): queue.append([cur.left, 1])
                else: appendNone(queue, 1)
                
                if(cur.right): queue.append([cur.right, 1])
                else: appendNone(queue, 1)
            

            if(l == 0):
                while(queue and not queue[0][0]): queue.pop(0)
                while(queue and not queue[-1][0]): queue.pop()
                
                l = len(queue)
                ans = max(ans, sum([i[-1] for i in queue]))

        
        return ans",widthOfBinaryTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\widthOfBinaryTree.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(7, 4)","(42, 18)",N,function_definition,widthOfBinaryTree,,241,cf64e1e8-267d-4484-a2b7-2c42f2afefbb
"def appendNone(queue, count):
            while(queue and queue[-1][0] == None):
                node, sub_count = queue.pop()
                count += sub_count
            queue.append([None, count])",widthOfBinaryTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\widthOfBinaryTree.py,module/class_definition-Solution/function_definition-widthOfBinaryTree/,widthOfBinaryTree,Previous sibling does not exist,if(not root): return 0,"(9, 8)","(13, 39)",N,function_definition,appendNone,,43,172f9b63-2cbe-4ccd-a221-3d270f3fced7
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if(not root): return []

        ans = []
        cur_ans = []
        queue = [root]
        l = 1
        reverse_flag = False

        while(queue):
            # print([i.val for i in queue])
            cur = queue.pop(0)
            l -= 1
            cur_ans.append(cur.val)

            if(cur.left): queue.append(cur.left)
            if(cur.right): queue.append(cur.right)

            if(l == 0):
                ans.append(cur_ans if not reverse_flag else cur_ans[::-1])
                cur_ans = []
                l = len(queue)
                reverse_flag = True ^ reverse_flag
        
        return ans
",zigzagLevelOrder.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\zigzagLevelOrder.py,,NA,Previous sibling does not exist,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right","(0, 0)","(32, 0)",N,module,module,,209,46e692c5-98bb-416b-ab6b-c497f3277013
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",zigzagLevelOrder.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\zigzagLevelOrder.py,module/,module,Previous sibling does not exist,"class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if(not root): return []

        ans = []
        cur_ans = []
        queue = [root]
        l = 1
        reverse_flag = False

        while(queue):
            # print([i.val for i in queue])
            cur = queue.pop(0)
            l -= 1
            cur_ans.append(cur.val)

            if(cur.left): queue.append(cur.left)
            if(cur.right): queue.append(cur.right)

            if(l == 0):
                ans.append(cur_ans if not reverse_flag else cur_ans[::-1])
                cur_ans = []
                l = len(queue)
                reverse_flag = True ^ reverse_flag
        
        return ans","(0, 0)","(5, 28)",N,"comment,comment,comment,comment,comment,comment",comment,,48,01909650-78e8-4240-989a-04fa3b9f2a5d
"class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if(not root): return []

        ans = []
        cur_ans = []
        queue = [root]
        l = 1
        reverse_flag = False

        while(queue):
            # print([i.val for i in queue])
            cur = queue.pop(0)
            l -= 1
            cur_ans.append(cur.val)

            if(cur.left): queue.append(cur.left)
            if(cur.right): queue.append(cur.right)

            if(l == 0):
                ans.append(cur_ans if not reverse_flag else cur_ans[::-1])
                cur_ans = []
                l = len(queue)
                reverse_flag = True ^ reverse_flag
        
        return ans",zigzagLevelOrder.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\zigzagLevelOrder.py,module/,module,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",Next sibling does not exist,"(6, 0)","(31, 18)",N,class_definition,Solution,,157,63f3b23a-3dee-4842-8542-6b4c3235bff5
"def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if(not root): return []

        ans = []
        cur_ans = []
        queue = [root]
        l = 1
        reverse_flag = False

        while(queue):
            # print([i.val for i in queue])
            cur = queue.pop(0)
            l -= 1
            cur_ans.append(cur.val)

            if(cur.left): queue.append(cur.left)
            if(cur.right): queue.append(cur.right)

            if(l == 0):
                ans.append(cur_ans if not reverse_flag else cur_ans[::-1])
                cur_ans = []
                l = len(queue)
                reverse_flag = True ^ reverse_flag
        
        return ans",zigzagLevelOrder.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\zigzagLevelOrder.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(7, 4)","(31, 18)",N,function_definition,zigzagLevelOrder,,153,6be5f665-2832-495d-aa69-ec4ed1261fd1
"package com.akarsh.codechef.TreeMap;

import java.util.Arrays;
import java.util.TreeMap;

public class MaximumProfitJobScheduling {
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {

        int n = startTime.length;
        int[][] jobs = new int[n][3];
        TreeMap<Integer, Integer> dp = new TreeMap<Integer, Integer>();

        for (int i = 0; i < n; i++) {
            jobs[i] = new int[] { startTime[i], endTime[i], profit[i] };
        }
        Arrays.sort(jobs, (o1, o2) -> Integer.compare(o1[1], o2[1]));
        dp.put(0, 0);

        for (int i = 0; i < n; i++) {
            int start = jobs[i][0];
            int end = jobs[i][1];
            int p = jobs[i][2];

            int maxProfitEarnedBeforeStart = dp.floorEntry(start).getValue();

            if(dp.lastEntry().getValue() < maxProfitEarnedBeforeStart + p){
                dp.put(end, p);
            }
        }

        return dp.lastEntry().getValue();
    }
}
",MaximumProfitJobScheduling.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MaximumProfitJobScheduling.java,,NA,Previous sibling does not exist,"package com.akarsh.codechef.TreeMap;
import java.util.Arrays;
import java.util.TreeMap;","(0, 0)","(33, 0)",N,program,program,,251,172b35c3-7790-420a-9966-487bc3f11533
"package com.akarsh.codechef.TreeMap;
import java.util.Arrays;
import java.util.TreeMap;",MaximumProfitJobScheduling.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MaximumProfitJobScheduling.java,program/,program,Previous sibling does not exist,"public class MaximumProfitJobScheduling {
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {

        int n = startTime.length;
        int[][] jobs = new int[n][3];
        TreeMap<Integer, Integer> dp = new TreeMap<Integer, Integer>();

        for (int i = 0; i < n; i++) {
            jobs[i] = new int[] { startTime[i], endTime[i], profit[i] };
        }
        Arrays.sort(jobs, (o1, o2) -> Integer.compare(o1[1], o2[1]));
        dp.put(0, 0);

        for (int i = 0; i < n; i++) {
            int start = jobs[i][0];
            int end = jobs[i][1];
            int p = jobs[i][2];

            int maxProfitEarnedBeforeStart = dp.floorEntry(start).getValue();

            if(dp.lastEntry().getValue() < maxProfitEarnedBeforeStart + p){
                dp.put(end, p);
            }
        }

        return dp.lastEntry().getValue();
    }
}","(0, 0)","(3, 25)",N,"package_declaration,import_declaration,import_declaration",package_declaration,,21,2943914b-7d2b-43b8-85fa-8fe2eab92080
"public class MaximumProfitJobScheduling {
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {

        int n = startTime.length;
        int[][] jobs = new int[n][3];
        TreeMap<Integer, Integer> dp = new TreeMap<Integer, Integer>();

        for (int i = 0; i < n; i++) {
            jobs[i] = new int[] { startTime[i], endTime[i], profit[i] };
        }
        Arrays.sort(jobs, (o1, o2) -> Integer.compare(o1[1], o2[1]));
        dp.put(0, 0);

        for (int i = 0; i < n; i++) {
            int start = jobs[i][0];
            int end = jobs[i][1];
            int p = jobs[i][2];

            int maxProfitEarnedBeforeStart = dp.floorEntry(start).getValue();

            if(dp.lastEntry().getValue() < maxProfitEarnedBeforeStart + p){
                dp.put(end, p);
            }
        }

        return dp.lastEntry().getValue();
    }
}",MaximumProfitJobScheduling.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MaximumProfitJobScheduling.java,program/,program,"package com.akarsh.codechef.TreeMap;
import java.util.Arrays;
import java.util.TreeMap;",Next sibling does not exist,"(5, 0)","(32, 1)",N,class_declaration,MaximumProfitJobScheduling,,230,ec9dcc46-bb0f-4ea1-9d14-a5305d759323
"public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {

        int n = startTime.length;
        int[][] jobs = new int[n][3];
        TreeMap<Integer, Integer> dp = new TreeMap<Integer, Integer>();

        for (int i = 0; i < n; i++) {
            jobs[i] = new int[] { startTime[i], endTime[i], profit[i] };
        }
        Arrays.sort(jobs, (o1, o2) -> Integer.compare(o1[1], o2[1]));
        dp.put(0, 0);

        for (int i = 0; i < n; i++) {
            int start = jobs[i][0];
            int end = jobs[i][1];
            int p = jobs[i][2];

            int maxProfitEarnedBeforeStart = dp.floorEntry(start).getValue();

            if(dp.lastEntry().getValue() < maxProfitEarnedBeforeStart + p){
                dp.put(end, p);
            }
        }

        return dp.lastEntry().getValue();
    }",MaximumProfitJobScheduling.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MaximumProfitJobScheduling.java,program/class_declaration-MaximumProfitJobScheduling/,MaximumProfitJobScheduling,Previous sibling does not exist,Next sibling does not exist,"(6, 4)","(31, 5)",N,method_declaration,jobScheduling,,220,42572fad-ba5e-40e9-a6a4-4085d0262d0d
"// line sweep


class MyCalendarThree {

    TreeMap<Integer, Integer> map;
    
    public MyCalendarThree() {
        map = new TreeMap<>();
    }
    
    public int book(int start, int end) {
        map.put(start, map.getOrDefault(start, 0)+1);
        map.put(end, map.getOrDefault(end, 0)-1);
        
        int ans = 0;
        int cur = 0;
        
        for(int x: map.values()){
            cur += x;
            ans = Math.max(ans, cur);
        }
        
        return ans;
    }
}

/**
 * Your MyCalendarThree object will be instantiated and called as such:
 * MyCalendarThree obj = new MyCalendarThree();
 * int param_1 = obj.book(start,end);
 */
",MyCalendarThree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MyCalendarThree.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(32, 0)",N,program,program,,161,f7f9c5ab-4f4a-4ee4-ba43-ae3f81d888af
// line sweep,MyCalendarThree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MyCalendarThree.java,program/,program,Previous sibling does not exist,"class MyCalendarThree {

    TreeMap<Integer, Integer> map;
    
    public MyCalendarThree() {
        map = new TreeMap<>();
    }
    
    public int book(int start, int end) {
        map.put(start, map.getOrDefault(start, 0)+1);
        map.put(end, map.getOrDefault(end, 0)-1);
        
        int ans = 0;
        int cur = 0;
        
        for(int x: map.values()){
            cur += x;
            ans = Math.max(ans, cur);
        }
        
        return ans;
    }
}","(0, 0)","(0, 13)",N,line_comment,line_comment,,3,1d5418e2-7402-4a84-85c7-a6b6d858ff8a
"class MyCalendarThree {

    TreeMap<Integer, Integer> map;
    
    public MyCalendarThree() {
        map = new TreeMap<>();
    }
    
    public int book(int start, int end) {
        map.put(start, map.getOrDefault(start, 0)+1);
        map.put(end, map.getOrDefault(end, 0)-1);
        
        int ans = 0;
        int cur = 0;
        
        for(int x: map.values()){
            cur += x;
            ans = Math.max(ans, cur);
        }
        
        return ans;
    }
}",MyCalendarThree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MyCalendarThree.java,program/,program,// line sweep,"/**
 * Your MyCalendarThree object will be instantiated and called as such:
 * MyCalendarThree obj = new MyCalendarThree();
 * int param_1 = obj.book(start,end);
 */","(3, 0)","(25, 1)",N,class_declaration,MyCalendarThree,,119,0090e0a6-5356-4ea7-8060-8abe526a5694
"public MyCalendarThree() {
        map = new TreeMap<>();
    }",MyCalendarThree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MyCalendarThree.java,program/class_declaration-MyCalendarThree/,MyCalendarThree,"TreeMap<Integer, Integer> map;","public int book(int start, int end) {
        map.put(start, map.getOrDefault(start, 0)+1);
        map.put(end, map.getOrDefault(end, 0)-1);
        
        int ans = 0;
        int cur = 0;
        
        for(int x: map.values()){
            cur += x;
            ans = Math.max(ans, cur);
        }
        
        return ans;
    }","(7, 4)","(9, 5)",N,constructor_declaration,MyCalendarThree,,14,f89ab8ed-7b72-48d9-82cf-4ecbf34d70d0
"public int book(int start, int end) {
        map.put(start, map.getOrDefault(start, 0)+1);
        map.put(end, map.getOrDefault(end, 0)-1);
        
        int ans = 0;
        int cur = 0;
        
        for(int x: map.values()){
            cur += x;
            ans = Math.max(ans, cur);
        }
        
        return ans;
    }",MyCalendarThree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MyCalendarThree.java,program/class_declaration-MyCalendarThree/,MyCalendarThree,"public MyCalendarThree() {
        map = new TreeMap<>();
    }",Next sibling does not exist,"(11, 4)","(24, 5)",N,method_declaration,book,,87,b10ec607-6199-4bc6-a8e1-3e7db0bfadff
"/**
 * Your MyCalendarThree object will be instantiated and called as such:
 * MyCalendarThree obj = new MyCalendarThree();
 * int param_1 = obj.book(start,end);
 */",MyCalendarThree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MyCalendarThree.java,program/,program,"class MyCalendarThree {

    TreeMap<Integer, Integer> map;
    
    public MyCalendarThree() {
        map = new TreeMap<>();
    }
    
    public int book(int start, int end) {
        map.put(start, map.getOrDefault(start, 0)+1);
        map.put(end, map.getOrDefault(end, 0)-1);
        
        int ans = 0;
        int cur = 0;
        
        for(int x: map.values()){
            cur += x;
            ans = Math.max(ans, cur);
        }
        
        return ans;
    }
}",Next sibling does not exist,"(27, 0)","(31, 3)",N,block_comment,block_comment,,38,928a5805-ece8-45c3-a1f0-502d4e473bcc
"class TrieNode:
    def __init__(self) -> None:
        self.children = [None for i in range(26)]
        self.isWord = False

class Trie:

    def __init__(self) -> None:
        self. root = TrieNode()
    
    def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True


    def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord
 

    def startsWith(self, prefix):
        arr = [] 

        def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])

        temp =  self.root
        for ch in prefix:
            if(not temp.children[ord(ch) - 97]): return
            temp = temp.children[ord(ch) - 97]
        
        dfs(prefix, temp)
        return arr


class Solution:

    def isConcatWord(self, word, trie, count):
        if((not word or word == '') and count>=2): return True
        
        root = trie.root
        for index in range(len(word)):
            ch = word[index]
            root = root.children[ord(ch) - 97]
            if(not root): return False
            if(root.isWord and self.isConcatWord(word[index+1:], trie, count+1)): return True
        
        return False


    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        trie = Trie()
        for word in words: trie.insert(word)

        ans  = []
        for word in words:
            if(self.isConcatWord(word, trie, 0)):
                ans.append(word)
        
        return ans



        
",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(78, 0)",N,module,module,,461,72e56b25-ba2a-447b-9c3a-423d0598eb06
"class TrieNode:
    def __init__(self) -> None:
        self.children = [None for i in range(26)]
        self.isWord = False",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/,module,Previous sibling does not exist,"class Trie:

    def __init__(self) -> None:
        self. root = TrieNode()
    
    def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True


    def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord
 

    def startsWith(self, prefix):
        arr = [] 

        def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])

        temp =  self.root
        for ch in prefix:
            if(not temp.children[ord(ch) - 97]): return
            temp = temp.children[ord(ch) - 97]
        
        dfs(prefix, temp)
        return arr","(0, 0)","(3, 27)",N,class_definition,TrieNode,,33,e4a44eec-f388-4cb8-8e1e-488bb18070e6
"def __init__(self) -> None:
        self.children = [None for i in range(26)]
        self.isWord = False",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-TrieNode/,TrieNode,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(3, 27)",N,function_definition,__init__,,28,7672eb45-505b-47e9-9fba-8bc7ca5d8102
"class Trie:

    def __init__(self) -> None:
        self. root = TrieNode()
    
    def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True


    def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord
 

    def startsWith(self, prefix):
        arr = [] 

        def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])

        temp =  self.root
        for ch in prefix:
            if(not temp.children[ord(ch) - 97]): return
            temp = temp.children[ord(ch) - 97]
        
        dfs(prefix, temp)
        return arr",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/,module,"class TrieNode:
    def __init__(self) -> None:
        self.children = [None for i in range(26)]
        self.isWord = False","class Solution:

    def isConcatWord(self, word, trie, count):
        if((not word or word == '') and count>=2): return True
        
        root = trie.root
        for index in range(len(word)):
            ch = word[index]
            root = root.children[ord(ch) - 97]
            if(not root): return False
            if(root.isWord and self.isConcatWord(word[index+1:], trie, count+1)): return True
        
        return False


    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        trie = Trie()
        for word in words: trie.insert(word)

        ans  = []
        for word in words:
            if(self.isConcatWord(word, trie, 0)):
                ans.append(word)
        
        return ans","(5, 0)","(46, 18)",N,class_definition,Trie,,253,897a3371-2776-4faa-91f3-2abd8a09379d
"def __init__(self) -> None:
        self. root = TrieNode()",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Trie/,Trie,Previous sibling does not exist,"def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True","(7, 4)","(8, 31)",N,function_definition,__init__,,17,6f143d3f-7013-4331-a038-1ccc65686610
"def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Trie/,Trie,"def __init__(self) -> None:
        self. root = TrieNode()","def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord","(10, 4)","(17, 26)",N,function_definition,insert,,64,564b789f-b8b5-4179-9e3b-a48ce8c99c00
"def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Trie/,Trie,"def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True","def startsWith(self, prefix):
        arr = [] 

        def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])

        temp =  self.root
        for ch in prefix:
            if(not temp.children[ord(ch) - 97]): return
            temp = temp.children[ord(ch) - 97]
        
        dfs(prefix, temp)
        return arr","(20, 4)","(27, 26)",N,function_definition,containsWord,,53,d380abe3-efbb-4f9d-9a5a-ab4a05aa1d7d
"def startsWith(self, prefix):
        arr = [] 

        def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])

        temp =  self.root
        for ch in prefix:
            if(not temp.children[ord(ch) - 97]): return
            temp = temp.children[ord(ch) - 97]
        
        dfs(prefix, temp)
        return arr",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Trie/,Trie,"def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord",Next sibling does not exist,"(30, 4)","(46, 18)",N,function_definition,startsWith,,108,33e3f543-821f-4a1a-95af-a24dad8b61ee
"def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Trie/function_definition-startsWith/,startsWith,arr = [],temp =  self.root,"(33, 8)","(38, 54)",N,function_definition,dfs,,44,83ae38b8-c641-47c2-8cc2-854e415b991e
"class Solution:

    def isConcatWord(self, word, trie, count):
        if((not word or word == '') and count>=2): return True
        
        root = trie.root
        for index in range(len(word)):
            ch = word[index]
            root = root.children[ord(ch) - 97]
            if(not root): return False
            if(root.isWord and self.isConcatWord(word[index+1:], trie, count+1)): return True
        
        return False


    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        trie = Trie()
        for word in words: trie.insert(word)

        ans  = []
        for word in words:
            if(self.isConcatWord(word, trie, 0)):
                ans.append(word)
        
        return ans",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/,module,"class Trie:

    def __init__(self) -> None:
        self. root = TrieNode()
    
    def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True


    def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord
 

    def startsWith(self, prefix):
        arr = [] 

        def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])

        temp =  self.root
        for ch in prefix:
            if(not temp.children[ord(ch) - 97]): return
            temp = temp.children[ord(ch) - 97]
        
        dfs(prefix, temp)
        return arr",Next sibling does not exist,"(49, 0)","(73, 18)",N,class_definition,Solution,,171,239dd277-f81b-4f5b-bc21-f4bc38f77155
"def isConcatWord(self, word, trie, count):
        if((not word or word == '') and count>=2): return True
        
        root = trie.root
        for index in range(len(word)):
            ch = word[index]
            root = root.children[ord(ch) - 97]
            if(not root): return False
            if(root.isWord and self.isConcatWord(word[index+1:], trie, count+1)): return True
        
        return False",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        trie = Trie()
        for word in words: trie.insert(word)

        ans  = []
        for word in words:
            if(self.isConcatWord(word, trie, 0)):
                ans.append(word)
        
        return ans","(51, 4)","(61, 20)",N,function_definition,isConcatWord,,97,3d773d36-7a04-4ff3-8dc5-b8c8b36244d7
"def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        trie = Trie()
        for word in words: trie.insert(word)

        ans  = []
        for word in words:
            if(self.isConcatWord(word, trie, 0)):
                ans.append(word)
        
        return ans",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Solution/,Solution,"def isConcatWord(self, word, trie, count):
        if((not word or word == '') and count>=2): return True
        
        root = trie.root
        for index in range(len(word)):
            ch = word[index]
            root = root.children[ord(ch) - 97]
            if(not root): return False
            if(root.isWord and self.isConcatWord(word[index+1:], trie, count+1)): return True
        
        return False",Next sibling does not exist,"(64, 4)","(73, 18)",N,function_definition,findAllConcatenatedWordsInADict,,68,21f91e02-9c7e-4d5c-a9a1-ef3b52ae6513
"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.word = None


class Trie:
    def __init__(self):
        self.root = TrieNode()
    

    def add(self, word):
        node = self.root
        index = 0

        while(index<len(word)):
            idx = word[index]
            if(idx not in node.childern): node.childern[idx] = TrieNode()
            node = node.childern[idx]
            index += 1
        
        node.word = word


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        N = len(board)
        M = len(board[0])

        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]
        def dfs(rowIndex, colIndex, node):
            if(not node): return
            if(rowIndex<0 or rowIndex>=N or colIndex<0 or colIndex>=M or board[rowIndex][colIndex] == '.'): return

            ch = board[rowIndex][colIndex]
            if(ch not in node.childern): return

            parent = node
            node = node.childern[ch]
            if('$' in node.childern):
                ans.add(node.childern['$'].word[:-1])
                del node.childern['$']

            board[rowIndex][colIndex] = '.'            
            for dx, dy in dir:
                newx, newy = rowIndex + dx, colIndex + dy
                dfs(newx, newy, node)
                if(len(node.childern) == 0):
                    del parent.childern[ch]
                    break
            board[rowIndex][colIndex] = ch

            

        trie = Trie()
        for word in words: trie.add(word+'$')
        ans = set()

        for rowIndex in range(N):
            for colIndex in range(M):
                dfs(rowIndex, colIndex, trie.root)
        
        return list(ans)
",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(63, 0)",N,module,module,,420,57c68885-fbf7-4c8e-864e-1e4e3569e2a4
"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.word = None",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/,module,Previous sibling does not exist,"class Trie:
    def __init__(self):
        self.root = TrieNode()
    

    def add(self, word):
        node = self.root
        index = 0

        while(index<len(word)):
            idx = word[index]
            if(idx not in node.childern): node.childern[idx] = TrieNode()
            node = node.childern[idx]
            index += 1
        
        node.word = word","(0, 0)","(3, 24)",N,class_definition,TrieNode,,22,331bf959-4ed5-4d9c-89da-170243aa1280
"def __init__(self):
        self.childern = {}
        self.word = None",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/class_definition-TrieNode/,TrieNode,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(3, 24)",N,function_definition,__init__,,17,33758f55-4f97-40d0-813c-4d83613ab428
"class Trie:
    def __init__(self):
        self.root = TrieNode()
    

    def add(self, word):
        node = self.root
        index = 0

        while(index<len(word)):
            idx = word[index]
            if(idx not in node.childern): node.childern[idx] = TrieNode()
            node = node.childern[idx]
            index += 1
        
        node.word = word",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/,module,"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.word = None","class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        N = len(board)
        M = len(board[0])

        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]
        def dfs(rowIndex, colIndex, node):
            if(not node): return
            if(rowIndex<0 or rowIndex>=N or colIndex<0 or colIndex>=M or board[rowIndex][colIndex] == '.'): return

            ch = board[rowIndex][colIndex]
            if(ch not in node.childern): return

            parent = node
            node = node.childern[ch]
            if('$' in node.childern):
                ans.add(node.childern['$'].word[:-1])
                del node.childern['$']

            board[rowIndex][colIndex] = '.'            
            for dx, dy in dir:
                newx, newy = rowIndex + dx, colIndex + dy
                dfs(newx, newy, node)
                if(len(node.childern) == 0):
                    del parent.childern[ch]
                    break
            board[rowIndex][colIndex] = ch

            

        trie = Trie()
        for word in words: trie.add(word+'$')
        ans = set()

        for rowIndex in range(N):
            for colIndex in range(M):
                dfs(rowIndex, colIndex, trie.root)
        
        return list(ans)","(6, 0)","(21, 24)",N,class_definition,Trie,,86,e9837213-0848-44ea-90b3-7178876793a5
"def __init__(self):
        self.root = TrieNode()",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/class_definition-Trie/,Trie,Previous sibling does not exist,"def add(self, word):
        node = self.root
        index = 0

        while(index<len(word)):
            idx = word[index]
            if(idx not in node.childern): node.childern[idx] = TrieNode()
            node = node.childern[idx]
            index += 1
        
        node.word = word","(7, 4)","(8, 30)",N,function_definition,__init__,,13,47379ff8-17f6-4be3-a6cc-73a44350759b
"def add(self, word):
        node = self.root
        index = 0

        while(index<len(word)):
            idx = word[index]
            if(idx not in node.childern): node.childern[idx] = TrieNode()
            node = node.childern[idx]
            index += 1
        
        node.word = word",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/class_definition-Trie/,Trie,"def __init__(self):
        self.root = TrieNode()",Next sibling does not exist,"(11, 4)","(21, 24)",N,function_definition,add,,67,d15fc5d8-1cb6-4436-8467-f3b61be4e900
"class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        N = len(board)
        M = len(board[0])

        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]
        def dfs(rowIndex, colIndex, node):
            if(not node): return
            if(rowIndex<0 or rowIndex>=N or colIndex<0 or colIndex>=M or board[rowIndex][colIndex] == '.'): return

            ch = board[rowIndex][colIndex]
            if(ch not in node.childern): return

            parent = node
            node = node.childern[ch]
            if('$' in node.childern):
                ans.add(node.childern['$'].word[:-1])
                del node.childern['$']

            board[rowIndex][colIndex] = '.'            
            for dx, dy in dir:
                newx, newy = rowIndex + dx, colIndex + dy
                dfs(newx, newy, node)
                if(len(node.childern) == 0):
                    del parent.childern[ch]
                    break
            board[rowIndex][colIndex] = ch

            

        trie = Trie()
        for word in words: trie.add(word+'$')
        ans = set()

        for rowIndex in range(N):
            for colIndex in range(M):
                dfs(rowIndex, colIndex, trie.root)
        
        return list(ans)",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/,module,"class Trie:
    def __init__(self):
        self.root = TrieNode()
    

    def add(self, word):
        node = self.root
        index = 0

        while(index<len(word)):
            idx = word[index]
            if(idx not in node.childern): node.childern[idx] = TrieNode()
            node = node.childern[idx]
            index += 1
        
        node.word = word",Next sibling does not exist,"(24, 0)","(62, 24)",N,class_definition,Solution,,310,79d93577-a30a-45f2-8e73-7954cfd99253
"def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        N = len(board)
        M = len(board[0])

        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]
        def dfs(rowIndex, colIndex, node):
            if(not node): return
            if(rowIndex<0 or rowIndex>=N or colIndex<0 or colIndex>=M or board[rowIndex][colIndex] == '.'): return

            ch = board[rowIndex][colIndex]
            if(ch not in node.childern): return

            parent = node
            node = node.childern[ch]
            if('$' in node.childern):
                ans.add(node.childern['$'].word[:-1])
                del node.childern['$']

            board[rowIndex][colIndex] = '.'            
            for dx, dy in dir:
                newx, newy = rowIndex + dx, colIndex + dy
                dfs(newx, newy, node)
                if(len(node.childern) == 0):
                    del parent.childern[ch]
                    break
            board[rowIndex][colIndex] = ch

            

        trie = Trie()
        for word in words: trie.add(word+'$')
        ans = set()

        for rowIndex in range(N):
            for colIndex in range(M):
                dfs(rowIndex, colIndex, trie.root)
        
        return list(ans)",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(25, 4)","(62, 24)",N,function_definition,findWords,,306,fae02d1d-ca16-45a9-88de-a81fbd44e111
"def dfs(rowIndex, colIndex, node):
            if(not node): return
            if(rowIndex<0 or rowIndex>=N or colIndex<0 or colIndex>=M or board[rowIndex][colIndex] == '.'): return

            ch = board[rowIndex][colIndex]
            if(ch not in node.childern): return

            parent = node
            node = node.childern[ch]
            if('$' in node.childern):
                ans.add(node.childern['$'].word[:-1])
                del node.childern['$']

            board[rowIndex][colIndex] = '.'            
            for dx, dy in dir:
                newx, newy = rowIndex + dx, colIndex + dy
                dfs(newx, newy, node)
                if(len(node.childern) == 0):
                    del parent.childern[ch]
                    break
            board[rowIndex][colIndex] = ch",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/class_definition-Solution/function_definition-findWords/,findWords,"dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]",trie = Trie(),"(30, 8)","(50, 42)",N,function_definition,dfs,,188,a582f0e8-1e46-49a2-8f29-43b22f555225
"class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for s, d in edges:
            graph[s].append(d)
            graph[d].append(s)
        
        uf = UnionFind(n)
        for source, dest in edges: uf.merge(source, dest)
        
        def sumOfN(n): return (n*(n-1))//2
        count = 0
        for index in range(n):
            if(uf.idx[index] == index):
                ec = 0
                for ne in range(n):
                    if(uf.connected(index, ne)):
                        ec += len(graph[ne])
                
                x = uf.componentSize(index)
                if(ec//2 == sumOfN(x)): count+=1
        
        return count
        
",countCompleteComponents.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\countCompleteComponents.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(24, 0)",N,module,module,,173,48d5529e-eaca-44d9-849a-300828d4511a
"class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for s, d in edges:
            graph[s].append(d)
            graph[d].append(s)
        
        uf = UnionFind(n)
        for source, dest in edges: uf.merge(source, dest)
        
        def sumOfN(n): return (n*(n-1))//2
        count = 0
        for index in range(n):
            if(uf.idx[index] == index):
                ec = 0
                for ne in range(n):
                    if(uf.connected(index, ne)):
                        ec += len(graph[ne])
                
                x = uf.componentSize(index)
                if(ec//2 == sumOfN(x)): count+=1
        
        return count",countCompleteComponents.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\countCompleteComponents.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 20)",N,class_definition,Solution,,172,4396944a-adeb-41e1-a93f-2e25214f335e
"def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for s, d in edges:
            graph[s].append(d)
            graph[d].append(s)
        
        uf = UnionFind(n)
        for source, dest in edges: uf.merge(source, dest)
        
        def sumOfN(n): return (n*(n-1))//2
        count = 0
        for index in range(n):
            if(uf.idx[index] == index):
                ec = 0
                for ne in range(n):
                    if(uf.connected(index, ne)):
                        ec += len(graph[ne])
                
                x = uf.componentSize(index)
                if(ec//2 == sumOfN(x)): count+=1
        
        return count",countCompleteComponents.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\countCompleteComponents.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(22, 20)",N,function_definition,countCompleteComponents,,168,511d9f3e-6564-4a58-99d1-a5ac4f9906cc
def sumOfN(n): return (n*(n-1))//2,countCompleteComponents.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\countCompleteComponents.py,module/class_definition-Solution/function_definition-countCompleteComponents/,countCompleteComponents,"for source, dest in edges: uf.merge(source, dest)",count = 0,"(10, 8)","(10, 42)",N,function_definition,sumOfN,,16,934c79f5-fbed-4653-a0da-24421016350b
"from SimilarStringGroups import UnionFind

class Solution:
    def distanceLimitedPathsExist(self, n: int, edgeList, queries):

        for index, query in enumerate(queries): query.append(index)
        queries.sort(key = lambda x: x[2])
        uf = UnionFind(n)
        index = 0
        queriesLength = len(queries)
        ans = [None for i in range(queriesLength)]

        edgeList.sort(key = lambda x: x[-1])
        edgesLength = len(edgeList)
        edgesIndex = 0

        while(index < queriesLength):
            source, dest, limit, qindex = queries[index]
            while(edgesIndex<edgesLength and edgeList[edgesIndex][-1]<limit):
                uf.merge(edgeList[edgesIndex][0], edgeList[edgesIndex][1])
                edgesIndex += 1
            ans[qindex] = uf.areConnected(source, dest)
            index += 1
        
        return ans",distanceLimitedPathsExist.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\distanceLimitedPathsExist.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(24, 18)",N,module,module,,202,a9779d49-f163-4c6b-913c-67e5dc6a9f93
from SimilarStringGroups import UnionFind,distanceLimitedPathsExist.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\distanceLimitedPathsExist.py,module/,module,Previous sibling does not exist,"class Solution:
    def distanceLimitedPathsExist(self, n: int, edgeList, queries):

        for index, query in enumerate(queries): query.append(index)
        queries.sort(key = lambda x: x[2])
        uf = UnionFind(n)
        index = 0
        queriesLength = len(queries)
        ans = [None for i in range(queriesLength)]

        edgeList.sort(key = lambda x: x[-1])
        edgesLength = len(edgeList)
        edgesIndex = 0

        while(index < queriesLength):
            source, dest, limit, qindex = queries[index]
            while(edgesIndex<edgesLength and edgeList[edgesIndex][-1]<limit):
                uf.merge(edgeList[edgesIndex][0], edgeList[edgesIndex][1])
                edgesIndex += 1
            ans[qindex] = uf.areConnected(source, dest)
            index += 1
        
        return ans","(0, 0)","(0, 41)",N,import_from_statement,import_from_statement,,7,6f612eb6-c132-43ec-8e8e-1a3dce91a1be
"class Solution:
    def distanceLimitedPathsExist(self, n: int, edgeList, queries):

        for index, query in enumerate(queries): query.append(index)
        queries.sort(key = lambda x: x[2])
        uf = UnionFind(n)
        index = 0
        queriesLength = len(queries)
        ans = [None for i in range(queriesLength)]

        edgeList.sort(key = lambda x: x[-1])
        edgesLength = len(edgeList)
        edgesIndex = 0

        while(index < queriesLength):
            source, dest, limit, qindex = queries[index]
            while(edgesIndex<edgesLength and edgeList[edgesIndex][-1]<limit):
                uf.merge(edgeList[edgesIndex][0], edgeList[edgesIndex][1])
                edgesIndex += 1
            ans[qindex] = uf.areConnected(source, dest)
            index += 1
        
        return ans",distanceLimitedPathsExist.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\distanceLimitedPathsExist.py,module/,module,from SimilarStringGroups import UnionFind,Next sibling does not exist,"(2, 0)","(24, 18)",N,class_definition,Solution,,194,4bbb6995-cdb9-42fe-b43a-c2b0f8f4a367
"def distanceLimitedPathsExist(self, n: int, edgeList, queries):

        for index, query in enumerate(queries): query.append(index)
        queries.sort(key = lambda x: x[2])
        uf = UnionFind(n)
        index = 0
        queriesLength = len(queries)
        ans = [None for i in range(queriesLength)]

        edgeList.sort(key = lambda x: x[-1])
        edgesLength = len(edgeList)
        edgesIndex = 0

        while(index < queriesLength):
            source, dest, limit, qindex = queries[index]
            while(edgesIndex<edgesLength and edgeList[edgesIndex][-1]<limit):
                uf.merge(edgeList[edgesIndex][0], edgeList[edgesIndex][1])
                edgesIndex += 1
            ans[qindex] = uf.areConnected(source, dest)
            index += 1
        
        return ans",distanceLimitedPathsExist.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\distanceLimitedPathsExist.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(3, 4)","(24, 18)",N,function_definition,distanceLimitedPathsExist,,190,c7fab38b-cd9e-428e-8568-e0aed9b04498
"class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        uf = UnionFind(26)
        passedIndexs = []
        
        for index,equation in enumerate(equations):
            
            if(equation[1] == '!'):
                passedIndexs.append(index)
                continue
                
            char1 = ord(equation[0]) -97
            char2 = ord(equation[-1]) -97
            uf.merge(char1, char2)
        
        for index in passedIndexs:
            char1 = ord(equations[index][0]) -97
            char2 = ord(equations[index][-1]) -97
            
            if(uf.connected(char1, char2)): 
                return False
        
        return True
            

        
        
        
        
class UnionFind:
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.idx = [i for i in range(self.capacity)]
        self.sz = [1 for i in range(self.capacity)]
        self.numComponents = self.capacity
        
    def find(self, index):
        rootIndex = index
        while(self.idx[rootIndex]!=rootIndex):
            rootIndex = self.idx[rootIndex]
            
        while(index!=rootIndex):
            curParent = self.idx[index]
            self.idx[index] = rootIndex
            index = curParent
        return rootIndex
    
    def connected(self, index1, index2):
        return self.find(index1) == self.find(index2)
    
    def componentSize(self, index):
        return self.sz[self.find(index)]

    def getNumberOfComponents(self):
        return self.numComponents
    
    def merge(self, index1, index2):
        
        root1 = self.find(index1)
        root2 = self.find(index2)        
        
        if(root1 == root2): return
        
        if(self.componentSize(root1) <= self.componentSize(root2)):
            self.idx[root1] = root2
            self.sz[root2] += self.sz[root1]
        else:
            self.idx[root2] = root1
            self.sz[root1] += self.sz[root2]
            
        self.numComponents -= 1

            
",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(74, 0)",N,module,module,,454,ae735eab-1b44-4657-a715-29a3bc71a063
"class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        uf = UnionFind(26)
        passedIndexs = []
        
        for index,equation in enumerate(equations):
            
            if(equation[1] == '!'):
                passedIndexs.append(index)
                continue
                
            char1 = ord(equation[0]) -97
            char2 = ord(equation[-1]) -97
            uf.merge(char1, char2)
        
        for index in passedIndexs:
            char1 = ord(equations[index][0]) -97
            char2 = ord(equations[index][-1]) -97
            
            if(uf.connected(char1, char2)): 
                return False
        
        return True",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/,module,Previous sibling does not exist,"class UnionFind:
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.idx = [i for i in range(self.capacity)]
        self.sz = [1 for i in range(self.capacity)]
        self.numComponents = self.capacity
        
    def find(self, index):
        rootIndex = index
        while(self.idx[rootIndex]!=rootIndex):
            rootIndex = self.idx[rootIndex]
            
        while(index!=rootIndex):
            curParent = self.idx[index]
            self.idx[index] = rootIndex
            index = curParent
        return rootIndex
    
    def connected(self, index1, index2):
        return self.find(index1) == self.find(index2)
    
    def componentSize(self, index):
        return self.sz[self.find(index)]

    def getNumberOfComponents(self):
        return self.numComponents
    
    def merge(self, index1, index2):
        
        root1 = self.find(index1)
        root2 = self.find(index2)        
        
        if(root1 == root2): return
        
        if(self.componentSize(root1) <= self.componentSize(root2)):
            self.idx[root1] = root2
            self.sz[root2] += self.sz[root1]
        else:
            self.idx[root2] = root1
            self.sz[root1] += self.sz[root2]
            
        self.numComponents -= 1","(0, 0)","(22, 19)",N,class_definition,Solution,,161,4d9a78f0-b3c2-411c-aaed-905bba46d325
"def equationsPossible(self, equations: List[str]) -> bool:
        uf = UnionFind(26)
        passedIndexs = []
        
        for index,equation in enumerate(equations):
            
            if(equation[1] == '!'):
                passedIndexs.append(index)
                continue
                
            char1 = ord(equation[0]) -97
            char2 = ord(equation[-1]) -97
            uf.merge(char1, char2)
        
        for index in passedIndexs:
            char1 = ord(equations[index][0]) -97
            char2 = ord(equations[index][-1]) -97
            
            if(uf.connected(char1, char2)): 
                return False
        
        return True",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(22, 19)",N,function_definition,equationsPossible,,157,17634a4f-0807-447e-8de4-501634d1404c
"class UnionFind:
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.idx = [i for i in range(self.capacity)]
        self.sz = [1 for i in range(self.capacity)]
        self.numComponents = self.capacity
        
    def find(self, index):
        rootIndex = index
        while(self.idx[rootIndex]!=rootIndex):
            rootIndex = self.idx[rootIndex]
            
        while(index!=rootIndex):
            curParent = self.idx[index]
            self.idx[index] = rootIndex
            index = curParent
        return rootIndex
    
    def connected(self, index1, index2):
        return self.find(index1) == self.find(index2)
    
    def componentSize(self, index):
        return self.sz[self.find(index)]

    def getNumberOfComponents(self):
        return self.numComponents
    
    def merge(self, index1, index2):
        
        root1 = self.find(index1)
        root2 = self.find(index2)        
        
        if(root1 == root2): return
        
        if(self.componentSize(root1) <= self.componentSize(root2)):
            self.idx[root1] = root2
            self.sz[root2] += self.sz[root1]
        else:
            self.idx[root2] = root1
            self.sz[root1] += self.sz[root2]
            
        self.numComponents -= 1",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/,module,"class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        uf = UnionFind(26)
        passedIndexs = []
        
        for index,equation in enumerate(equations):
            
            if(equation[1] == '!'):
                passedIndexs.append(index)
                continue
                
            char1 = ord(equation[0]) -97
            char2 = ord(equation[-1]) -97
            uf.merge(char1, char2)
        
        for index in passedIndexs:
            char1 = ord(equations[index][0]) -97
            char2 = ord(equations[index][-1]) -97
            
            if(uf.connected(char1, char2)): 
                return False
        
        return True",Next sibling does not exist,"(29, 0)","(71, 31)",N,class_definition,UnionFind,,287,a1015d88-bd48-4b35-9b3d-5f26f9259a4b
"def __init__(self, capacity):
        self.capacity = capacity
        self.idx = [i for i in range(self.capacity)]
        self.sz = [1 for i in range(self.capacity)]
        self.numComponents = self.capacity",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-UnionFind/,UnionFind,Previous sibling does not exist,"def find(self, index):
        rootIndex = index
        while(self.idx[rootIndex]!=rootIndex):
            rootIndex = self.idx[rootIndex]
            
        while(index!=rootIndex):
            curParent = self.idx[index]
            self.idx[index] = rootIndex
            index = curParent
        return rootIndex","(31, 4)","(35, 42)",N,function_definition,__init__,,47,e80d2948-730b-4ddf-b2c0-e1af05e4a5b0
"def find(self, index):
        rootIndex = index
        while(self.idx[rootIndex]!=rootIndex):
            rootIndex = self.idx[rootIndex]
            
        while(index!=rootIndex):
            curParent = self.idx[index]
            self.idx[index] = rootIndex
            index = curParent
        return rootIndex",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-UnionFind/,UnionFind,"def __init__(self, capacity):
        self.capacity = capacity
        self.idx = [i for i in range(self.capacity)]
        self.sz = [1 for i in range(self.capacity)]
        self.numComponents = self.capacity","def connected(self, index1, index2):
        return self.find(index1) == self.find(index2)","(37, 4)","(46, 24)",N,function_definition,find,,66,7fa6d31e-3a9e-4867-87f9-4bc3071e05b7
"def connected(self, index1, index2):
        return self.find(index1) == self.find(index2)",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-UnionFind/,UnionFind,"def find(self, index):
        rootIndex = index
        while(self.idx[rootIndex]!=rootIndex):
            rootIndex = self.idx[rootIndex]
            
        while(index!=rootIndex):
            curParent = self.idx[index]
            self.idx[index] = rootIndex
            index = curParent
        return rootIndex","def componentSize(self, index):
        return self.sz[self.find(index)]","(48, 4)","(49, 53)",N,function_definition,connected,,23,92d66cb7-c38d-433a-9da6-aa7f5c6fddf0
"def componentSize(self, index):
        return self.sz[self.find(index)]",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-UnionFind/,UnionFind,"def connected(self, index1, index2):
        return self.find(index1) == self.find(index2)","def getNumberOfComponents(self):
        return self.numComponents","(51, 4)","(52, 40)",N,function_definition,componentSize,,15,5ed7d4fc-4d63-4280-953b-b6772fe8c568
"def getNumberOfComponents(self):
        return self.numComponents",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-UnionFind/,UnionFind,"def componentSize(self, index):
        return self.sz[self.find(index)]","def merge(self, index1, index2):
        
        root1 = self.find(index1)
        root2 = self.find(index2)        
        
        if(root1 == root2): return
        
        if(self.componentSize(root1) <= self.componentSize(root2)):
            self.idx[root1] = root2
            self.sz[root2] += self.sz[root1]
        else:
            self.idx[root2] = root1
            self.sz[root1] += self.sz[root2]
            
        self.numComponents -= 1","(54, 4)","(55, 33)",N,function_definition,getNumberOfComponents,,11,c5f68fe1-3812-4c22-82af-02ba07b19ff8
"def merge(self, index1, index2):
        
        root1 = self.find(index1)
        root2 = self.find(index2)        
        
        if(root1 == root2): return
        
        if(self.componentSize(root1) <= self.componentSize(root2)):
            self.idx[root1] = root2
            self.sz[root2] += self.sz[root1]
        else:
            self.idx[root2] = root1
            self.sz[root1] += self.sz[root2]
            
        self.numComponents -= 1",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-UnionFind/,UnionFind,"def getNumberOfComponents(self):
        return self.numComponents",Next sibling does not exist,"(57, 4)","(71, 31)",N,function_definition,merge,,110,9c97b965-b4b5-481b-8e59-af50654603c2
"class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
      
        n = len(isConnected)
        uf = UnionFind(n)
        for index1 in range(n):
            for index2 in range(index1+1, n):
                if(isConnected[index1][index2]==1):
                    uf.merge(index1, index2)
        
        return uf.getNumberOfComponents()
",findCircleNum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\findCircleNum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(11, 0)",N,module,module,,84,34b2570b-b079-4b2a-bd8e-41ef72085d74
"class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
      
        n = len(isConnected)
        uf = UnionFind(n)
        for index1 in range(n):
            for index2 in range(index1+1, n):
                if(isConnected[index1][index2]==1):
                    uf.merge(index1, index2)
        
        return uf.getNumberOfComponents()",findCircleNum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\findCircleNum.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(10, 41)",N,class_definition,Solution,,84,fd2b972a-f0bf-43f8-a5a0-fa3aafe8eea9
"def findCircleNum(self, isConnected: List[List[int]]) -> int:
      
        n = len(isConnected)
        uf = UnionFind(n)
        for index1 in range(n):
            for index2 in range(index1+1, n):
                if(isConnected[index1][index2]==1):
                    uf.merge(index1, index2)
        
        return uf.getNumberOfComponents()",findCircleNum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\findCircleNum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(10, 41)",N,function_definition,findCircleNum,,80,35722480-53ca-47d3-8100-dc29cceabb19
"class LUPrefix {

    UnionFind uf;
    boolean[] uploaded;
    
    public LUPrefix(int n) {
        uf = new UnionFind(n+1);
        uploaded = new boolean[n+1];
    }
    
    public void upload(int video) {
        
        if(video>0 && uploaded[video-1]) uf.merge(video, video-1);
        if(video<uploaded.length-1 && uploaded[video+1]) uf.merge(video, video+1);
        
        uploaded[video] = true;
    }
    
    public int longest() {
        return uploaded[1] ? uf.componentSize(1) :  0;
    }
}

",LUPrefix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\LUPrefix.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,program,program,,138,1ae00bf8-f998-4c83-aaaa-b3f4cea34785
"class LUPrefix {

    UnionFind uf;
    boolean[] uploaded;
    
    public LUPrefix(int n) {
        uf = new UnionFind(n+1);
        uploaded = new boolean[n+1];
    }
    
    public void upload(int video) {
        
        if(video>0 && uploaded[video-1]) uf.merge(video, video-1);
        if(video<uploaded.length-1 && uploaded[video+1]) uf.merge(video, video+1);
        
        uploaded[video] = true;
    }
    
    public int longest() {
        return uploaded[1] ? uf.componentSize(1) :  0;
    }
}",LUPrefix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\LUPrefix.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 1)",N,class_declaration,LUPrefix,,138,d1f6db08-ddca-4f04-9680-d3a2c6ab7e35
"public LUPrefix(int n) {
        uf = new UnionFind(n+1);
        uploaded = new boolean[n+1];
    }",LUPrefix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\LUPrefix.java,program/class_declaration-LUPrefix/,LUPrefix,boolean[] uploaded;,"public void upload(int video) {
        
        if(video>0 && uploaded[video-1]) uf.merge(video, video-1);
        if(video<uploaded.length-1 && uploaded[video+1]) uf.merge(video, video+1);
        
        uploaded[video] = true;
    }","(5, 4)","(8, 5)",N,constructor_declaration,LUPrefix,,29,dd24f327-31e1-4a25-b6de-197fc23ccbad
"public void upload(int video) {
        
        if(video>0 && uploaded[video-1]) uf.merge(video, video-1);
        if(video<uploaded.length-1 && uploaded[video+1]) uf.merge(video, video+1);
        
        uploaded[video] = true;
    }",LUPrefix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\LUPrefix.java,program/class_declaration-LUPrefix/,LUPrefix,"public LUPrefix(int n) {
        uf = new UnionFind(n+1);
        uploaded = new boolean[n+1];
    }","public int longest() {
        return uploaded[1] ? uf.componentSize(1) :  0;
    }","(10, 4)","(16, 5)",N,method_declaration,upload,,62,366d43d2-6c48-47de-ab83-82f543b52020
"public int longest() {
        return uploaded[1] ? uf.componentSize(1) :  0;
    }",LUPrefix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\LUPrefix.java,program/class_declaration-LUPrefix/,LUPrefix,"public void upload(int video) {
        
        if(video>0 && uploaded[video-1]) uf.merge(video, video-1);
        if(video<uploaded.length-1 && uploaded[video+1]) uf.merge(video, video+1);
        
        uploaded[video] = true;
    }",Next sibling does not exist,"(18, 4)","(20, 5)",N,method_declaration,longest,,25,93ef1280-f1a8-4dc3-9c39-2015be39b1c4
"from SimilarStringGroups import UnionFind


class Solution:
    def maxNumEdgesToRemove(self, n, edges):

        alice = UnionFind(n)
        count = 0
        numEdges = len(edges)

        for edgeType, source, dest in edges:
            if(edgeType == 3):
                alice.merge(source-1, dest-1)
                count += 1
                if(alice.getNumberOfComponents() == 1): return numEdges - count

        bob = alice.clone()

        graph = [alice, bob]

        for edgeType, source, dest in edges:
            if(edgeType == 3): continue
            if(edgeType == 1 and alice.areConnected(source-1, dest-1)): continue 
            if(edgeType == 2 and bob.areConnected(source-1, dest-1)): continue
            
            graph[edgeType].merge(source-1, dest-1)
            count += 1
            if(alice.getNumberOfComponents() == 1 and bob.getNumberOfComponents() == 1): return numEdges - count
        
        return -1",maxNumEdgesToRemove.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\maxNumEdgesToRemove.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 17)",N,module,module,,225,874fdf30-be73-46bd-b1a0-43fba27528bf
from SimilarStringGroups import UnionFind,maxNumEdgesToRemove.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\maxNumEdgesToRemove.py,module/,module,Previous sibling does not exist,"class Solution:
    def maxNumEdgesToRemove(self, n, edges):

        alice = UnionFind(n)
        count = 0
        numEdges = len(edges)

        for edgeType, source, dest in edges:
            if(edgeType == 3):
                alice.merge(source-1, dest-1)
                count += 1
                if(alice.getNumberOfComponents() == 1): return numEdges - count

        bob = alice.clone()

        graph = [alice, bob]

        for edgeType, source, dest in edges:
            if(edgeType == 3): continue
            if(edgeType == 1 and alice.areConnected(source-1, dest-1)): continue 
            if(edgeType == 2 and bob.areConnected(source-1, dest-1)): continue
            
            graph[edgeType].merge(source-1, dest-1)
            count += 1
            if(alice.getNumberOfComponents() == 1 and bob.getNumberOfComponents() == 1): return numEdges - count
        
        return -1","(0, 0)","(0, 41)",N,import_from_statement,import_from_statement,,7,439f0a39-30bf-4c73-a341-aa1c2b48db3a
"class Solution:
    def maxNumEdgesToRemove(self, n, edges):

        alice = UnionFind(n)
        count = 0
        numEdges = len(edges)

        for edgeType, source, dest in edges:
            if(edgeType == 3):
                alice.merge(source-1, dest-1)
                count += 1
                if(alice.getNumberOfComponents() == 1): return numEdges - count

        bob = alice.clone()

        graph = [alice, bob]

        for edgeType, source, dest in edges:
            if(edgeType == 3): continue
            if(edgeType == 1 and alice.areConnected(source-1, dest-1)): continue 
            if(edgeType == 2 and bob.areConnected(source-1, dest-1)): continue
            
            graph[edgeType].merge(source-1, dest-1)
            count += 1
            if(alice.getNumberOfComponents() == 1 and bob.getNumberOfComponents() == 1): return numEdges - count
        
        return -1",maxNumEdgesToRemove.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\maxNumEdgesToRemove.py,module/,module,from SimilarStringGroups import UnionFind,Next sibling does not exist,"(3, 0)","(29, 17)",N,class_definition,Solution,,217,4c996e6a-f138-47e8-9b8f-49410668a723
"def maxNumEdgesToRemove(self, n, edges):

        alice = UnionFind(n)
        count = 0
        numEdges = len(edges)

        for edgeType, source, dest in edges:
            if(edgeType == 3):
                alice.merge(source-1, dest-1)
                count += 1
                if(alice.getNumberOfComponents() == 1): return numEdges - count

        bob = alice.clone()

        graph = [alice, bob]

        for edgeType, source, dest in edges:
            if(edgeType == 3): continue
            if(edgeType == 1 and alice.areConnected(source-1, dest-1)): continue 
            if(edgeType == 2 and bob.areConnected(source-1, dest-1)): continue
            
            graph[edgeType].merge(source-1, dest-1)
            count += 1
            if(alice.getNumberOfComponents() == 1 and bob.getNumberOfComponents() == 1): return numEdges - count
        
        return -1",maxNumEdgesToRemove.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\maxNumEdgesToRemove.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(4, 4)","(29, 17)",N,function_definition,maxNumEdgesToRemove,,213,b10ca310-af34-4a9e-8fe8-1488aaec2f25
"class Solution:
    def minMalwareSpread(self, graph, initial):

        N = len(graph)
        uf = UnionFind(N)
        

        for i in initial: uf.numOfMalwareSources[i] = 1

        for i in range(N):
            for j in range(i+1, N):
                if(graph[i][j] == 1): uf.merge(i, j)
        

        print(uf.id, uf.numOfMalwareSources, uf.size)

        ans_index = -1
        ans_component_size = -1

        for comp_index in initial:
            comp_root = uf.find(comp_index)
            if(uf.numOfMalwareSources[comp_root] == 1):
                cur_comp_size = uf.getComponentSize(comp_root)
                if(cur_comp_size > ans_component_size):
                    ans_component_size = cur_comp_size
                    ans_index = comp_index
                elif(cur_comp_size == ans_component_size):
                    ans_index = min(ans_index, comp_index)
        
        if(ans_index == -1): return min(initial)
        return ans_index





class UnionFind:

    def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]


    def getNumberOfComponents(self): return self.numOfComponents

    def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root

    def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)

    def getComponentSize(self, component): return self.size[self.find(component)]

    def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot


solution = Solution()
# solution.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1])
ans = solution.minMalwareSpread([[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,1,0],[0,0,0,1,1,0],[0,0,0,0,0,1]], [5,0])
print(ans)

",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(89, 0)",N,module,module,,745,fce4bf88-cc7f-4d85-99fb-5590e7642a61
"class Solution:
    def minMalwareSpread(self, graph, initial):

        N = len(graph)
        uf = UnionFind(N)
        

        for i in initial: uf.numOfMalwareSources[i] = 1

        for i in range(N):
            for j in range(i+1, N):
                if(graph[i][j] == 1): uf.merge(i, j)
        

        print(uf.id, uf.numOfMalwareSources, uf.size)

        ans_index = -1
        ans_component_size = -1

        for comp_index in initial:
            comp_root = uf.find(comp_index)
            if(uf.numOfMalwareSources[comp_root] == 1):
                cur_comp_size = uf.getComponentSize(comp_root)
                if(cur_comp_size > ans_component_size):
                    ans_component_size = cur_comp_size
                    ans_index = comp_index
                elif(cur_comp_size == ans_component_size):
                    ans_index = min(ans_index, comp_index)
        
        if(ans_index == -1): return min(initial)
        return ans_index",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/,module,Previous sibling does not exist,"class UnionFind:

    def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]


    def getNumberOfComponents(self): return self.numOfComponents

    def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root

    def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)

    def getComponentSize(self, component): return self.size[self.find(component)]

    def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot","(0, 0)","(30, 24)",N,class_definition,Solution,,222,ca9543f4-f5f0-42c8-a463-13791a845255
"def minMalwareSpread(self, graph, initial):

        N = len(graph)
        uf = UnionFind(N)
        

        for i in initial: uf.numOfMalwareSources[i] = 1

        for i in range(N):
            for j in range(i+1, N):
                if(graph[i][j] == 1): uf.merge(i, j)
        

        print(uf.id, uf.numOfMalwareSources, uf.size)

        ans_index = -1
        ans_component_size = -1

        for comp_index in initial:
            comp_root = uf.find(comp_index)
            if(uf.numOfMalwareSources[comp_root] == 1):
                cur_comp_size = uf.getComponentSize(comp_root)
                if(cur_comp_size > ans_component_size):
                    ans_component_size = cur_comp_size
                    ans_index = comp_index
                elif(cur_comp_size == ans_component_size):
                    ans_index = min(ans_index, comp_index)
        
        if(ans_index == -1): return min(initial)
        return ans_index",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(30, 24)",N,function_definition,minMalwareSpread,,218,d873d585-e796-4c33-9d66-4ef1cc902dfe
"class UnionFind:

    def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]


    def getNumberOfComponents(self): return self.numOfComponents

    def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root

    def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)

    def getComponentSize(self, component): return self.size[self.find(component)]

    def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/,module,"class Solution:
    def minMalwareSpread(self, graph, initial):

        N = len(graph)
        uf = UnionFind(N)
        

        for i in initial: uf.numOfMalwareSources[i] = 1

        for i in range(N):
            for j in range(i+1, N):
                if(graph[i][j] == 1): uf.merge(i, j)
        

        print(uf.id, uf.numOfMalwareSources, uf.size)

        ans_index = -1
        ans_component_size = -1

        for comp_index in initial:
            comp_root = uf.find(comp_index)
            if(uf.numOfMalwareSources[comp_root] == 1):
                cur_comp_size = uf.getComponentSize(comp_root)
                if(cur_comp_size > ans_component_size):
                    ans_component_size = cur_comp_size
                    ans_index = comp_index
                elif(cur_comp_size == ans_component_size):
                    ans_index = min(ans_index, comp_index)
        
        if(ans_index == -1): return min(initial)
        return ans_index",solution = Solution(),"(36, 0)","(81, 61)",N,class_definition,UnionFind,,399,bfd7ca48-77ca-4f82-9b84-7667b1cbcb91
"def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-UnionFind/,UnionFind,Previous sibling does not exist,def getNumberOfComponents(self): return self.numOfComponents,"(38, 4)","(43, 76)",N,function_definition,__init__,,69,34977436-9563-4165-808a-2ccb2d4244e2
def getNumberOfComponents(self): return self.numOfComponents,MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-UnionFind/,UnionFind,"def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]","def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root","(46, 4)","(46, 64)",N,function_definition,getNumberOfComponents,,11,7bb278a2-571a-4bfb-8c49-7fac2f37acbe
"def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-UnionFind/,UnionFind,def getNumberOfComponents(self): return self.numOfComponents,"def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)","(48, 4)","(56, 19)",N,function_definition,find,,67,8499aa92-ee69-4f43-b3b3-49dd31f5193b
"def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-UnionFind/,UnionFind,"def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root","def getComponentSize(self, component): return self.size[self.find(component)]","(58, 4)","(58, 104)",N,function_definition,isConnected,,22,c62e177c-258d-4620-8001-dbeaee515f1c
"def getComponentSize(self, component): return self.size[self.find(component)]",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-UnionFind/,UnionFind,"def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)","def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot","(60, 4)","(60, 81)",N,function_definition,getComponentSize,,15,7dba97be-c2e4-4a03-bb12-623ee4b457a0
"def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-UnionFind/,UnionFind,"def getComponentSize(self, component): return self.size[self.find(component)]","solution = Solution()
# solution.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1])
ans = solution.minMalwareSpread([[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,1,0],[0,0,0,1,1,0],[0,0,0,0,0,1]], [5,0])
print(ans)","(62, 4)","(81, 61)",N,function_definition,merge,,202,399fc665-aca2-4a74-b100-7f753f4e0294
"solution = Solution()
# solution.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1])
ans = solution.minMalwareSpread([[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,1,0],[0,0,0,1,1,0],[0,0,0,0,0,1]], [5,0])
print(ans)",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/,module,"class UnionFind:

    def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]


    def getNumberOfComponents(self): return self.numOfComponents

    def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root

    def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)

    def getComponentSize(self, component): return self.size[self.find(component)]

    def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot",Next sibling does not exist,"(84, 0)","(87, 10)",N,"expression_statement,comment,expression_statement,expression_statement",expression_statement,,122,9b14ff66-a4ca-4135-8ea1-af5aa2f6c549
"class UnionFind:

    def __init__(self, size):
        self.size = size
        self.componentSize = [1 for i in range(size)]
        self.id = [i for i in range(size)]
        self.numberOfComponents = size
    

    def getNumberOfComponents(self): return self.numberOfComponents
    
    def find(self, index):
        temp = index
        while(self.id[index] != index): index = self.id[index]

        
        # path compression
        while(self.id[temp] != index):
            temp = self.id[temp]
            self.id[temp] = index 
        
        return index

    def getComponentSize(self, index): return self.componentSize(self.find(index))
    def areConnected(self, index1, index2): return self.find(index1) == self.find(index2)

    def merge(self, index1, index2):
        if(self.areConnected(index1, index2)): return

        root1 = self.find(index1)
        root2 = self.find(index2)

        if(self.componentSize[root1] >= self.componentSize[root2]): 
            self.id[root2] = root1
            self.componentSize[root1] += self.componentSize[root2]
        else: 
            self.id[root1] = root2
            self.componentSize[root2] += self.componentSize[root1]
        
        self.numberOfComponents -= 1
    
    def clone(self):
        new = UnionFind(self.size)
        new.componentSize = [i for i in self.componentSize]
        new.id = [i for i in self.id]
        new.numberOfComponents = self.numberOfComponents

        return new


class Solution:
    def numSimilarGroups(self, strs):

        N = len(strs)
        uf = UnionFind(N)


        def similar(s1, s2):
            count = 0
            
            for ch1, ch2 in zip(s1, s2):
                if(ch1 != ch2): 
                    count += 1
                    if(count>2): return False
            
            return True

        for index1 in range(N):
            for index2 in range(index1+1, N):
                if(similar(strs[index1], strs[index2]) and not uf.areConnected(index1, index2)):
                    uf.merge(index1, index2) 
        
        return uf.getNumberOfComponents()",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(72, 41)",N,module,module,,482,6fd17bc1-18e4-4bf3-95e0-0f5eb21077fe
"class UnionFind:

    def __init__(self, size):
        self.size = size
        self.componentSize = [1 for i in range(size)]
        self.id = [i for i in range(size)]
        self.numberOfComponents = size
    

    def getNumberOfComponents(self): return self.numberOfComponents
    
    def find(self, index):
        temp = index
        while(self.id[index] != index): index = self.id[index]

        
        # path compression
        while(self.id[temp] != index):
            temp = self.id[temp]
            self.id[temp] = index 
        
        return index

    def getComponentSize(self, index): return self.componentSize(self.find(index))
    def areConnected(self, index1, index2): return self.find(index1) == self.find(index2)

    def merge(self, index1, index2):
        if(self.areConnected(index1, index2)): return

        root1 = self.find(index1)
        root2 = self.find(index2)

        if(self.componentSize[root1] >= self.componentSize[root2]): 
            self.id[root2] = root1
            self.componentSize[root1] += self.componentSize[root2]
        else: 
            self.id[root1] = root2
            self.componentSize[root2] += self.componentSize[root1]
        
        self.numberOfComponents -= 1
    
    def clone(self):
        new = UnionFind(self.size)
        new.componentSize = [i for i in self.componentSize]
        new.id = [i for i in self.id]
        new.numberOfComponents = self.numberOfComponents

        return new",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/,module,Previous sibling does not exist,"class Solution:
    def numSimilarGroups(self, strs):

        N = len(strs)
        uf = UnionFind(N)


        def similar(s1, s2):
            count = 0
            
            for ch1, ch2 in zip(s1, s2):
                if(ch1 != ch2): 
                    count += 1
                    if(count>2): return False
            
            return True

        for index1 in range(N):
            for index2 in range(index1+1, N):
                if(similar(strs[index1], strs[index2]) and not uf.areConnected(index1, index2)):
                    uf.merge(index1, index2) 
        
        return uf.getNumberOfComponents()","(0, 0)","(47, 18)",N,class_definition,UnionFind,,335,2efffff8-9d9d-427a-b78e-21b1c713d4cc
"def __init__(self, size):
        self.size = size
        self.componentSize = [1 for i in range(size)]
        self.id = [i for i in range(size)]
        self.numberOfComponents = size",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,Previous sibling does not exist,def getNumberOfComponents(self): return self.numberOfComponents,"(2, 4)","(6, 38)",N,function_definition,__init__,,45,6306f420-9067-40b4-a7ab-6600dffee962
def getNumberOfComponents(self): return self.numberOfComponents,SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,"def __init__(self, size):
        self.size = size
        self.componentSize = [1 for i in range(size)]
        self.id = [i for i in range(size)]
        self.numberOfComponents = size","def find(self, index):
        temp = index
        while(self.id[index] != index): index = self.id[index]

        
        # path compression
        while(self.id[temp] != index):
            temp = self.id[temp]
            self.id[temp] = index 
        
        return index","(9, 4)","(9, 67)",N,function_definition,getNumberOfComponents,,10,0b3f9eb0-845f-404d-b821-a967535266ee
"def find(self, index):
        temp = index
        while(self.id[index] != index): index = self.id[index]

        
        # path compression
        while(self.id[temp] != index):
            temp = self.id[temp]
            self.id[temp] = index 
        
        return index",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,def getNumberOfComponents(self): return self.numberOfComponents,"def getComponentSize(self, index): return self.componentSize(self.find(index))","(11, 4)","(21, 20)",N,function_definition,find,,59,969b3f89-3dc2-4f60-9535-a251a7e9c6b6
"def getComponentSize(self, index): return self.componentSize(self.find(index))",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,"def find(self, index):
        temp = index
        while(self.id[index] != index): index = self.id[index]

        
        # path compression
        while(self.id[temp] != index):
            temp = self.id[temp]
            self.id[temp] = index 
        
        return index","def areConnected(self, index1, index2): return self.find(index1) == self.find(index2)","(23, 4)","(23, 82)",N,function_definition,getComponentSize,,16,a8769d56-4107-44c9-9fd0-10b819dd80e2
"def areConnected(self, index1, index2): return self.find(index1) == self.find(index2)",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,"def getComponentSize(self, index): return self.componentSize(self.find(index))","def merge(self, index1, index2):
        if(self.areConnected(index1, index2)): return

        root1 = self.find(index1)
        root2 = self.find(index2)

        if(self.componentSize[root1] >= self.componentSize[root2]): 
            self.id[root2] = root1
            self.componentSize[root1] += self.componentSize[root2]
        else: 
            self.id[root1] = root2
            self.componentSize[root2] += self.componentSize[root1]
        
        self.numberOfComponents -= 1","(24, 4)","(24, 89)",N,function_definition,areConnected,,23,d0463b95-7dec-4181-85be-d3c967fb15fa
"def merge(self, index1, index2):
        if(self.areConnected(index1, index2)): return

        root1 = self.find(index1)
        root2 = self.find(index2)

        if(self.componentSize[root1] >= self.componentSize[root2]): 
            self.id[root2] = root1
            self.componentSize[root1] += self.componentSize[root2]
        else: 
            self.id[root1] = root2
            self.componentSize[root2] += self.componentSize[root1]
        
        self.numberOfComponents -= 1",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,"def areConnected(self, index1, index2): return self.find(index1) == self.find(index2)","def clone(self):
        new = UnionFind(self.size)
        new.componentSize = [i for i in self.componentSize]
        new.id = [i for i in self.id]
        new.numberOfComponents = self.numberOfComponents

        return new","(26, 4)","(39, 36)",N,function_definition,merge,,117,e6495a43-0ffb-4937-85f9-24f6cceabe41
"def clone(self):
        new = UnionFind(self.size)
        new.componentSize = [i for i in self.componentSize]
        new.id = [i for i in self.id]
        new.numberOfComponents = self.numberOfComponents

        return new",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,"def merge(self, index1, index2):
        if(self.areConnected(index1, index2)): return

        root1 = self.find(index1)
        root2 = self.find(index2)

        if(self.componentSize[root1] >= self.componentSize[root2]): 
            self.id[root2] = root1
            self.componentSize[root1] += self.componentSize[root2]
        else: 
            self.id[root1] = root2
            self.componentSize[root2] += self.componentSize[root1]
        
        self.numberOfComponents -= 1",Next sibling does not exist,"(41, 4)","(47, 18)",N,function_definition,clone,,50,ad791fe5-a270-4809-8737-2a200893232c
"class Solution:
    def numSimilarGroups(self, strs):

        N = len(strs)
        uf = UnionFind(N)


        def similar(s1, s2):
            count = 0
            
            for ch1, ch2 in zip(s1, s2):
                if(ch1 != ch2): 
                    count += 1
                    if(count>2): return False
            
            return True

        for index1 in range(N):
            for index2 in range(index1+1, N):
                if(similar(strs[index1], strs[index2]) and not uf.areConnected(index1, index2)):
                    uf.merge(index1, index2) 
        
        return uf.getNumberOfComponents()",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/,module,"class UnionFind:

    def __init__(self, size):
        self.size = size
        self.componentSize = [1 for i in range(size)]
        self.id = [i for i in range(size)]
        self.numberOfComponents = size
    

    def getNumberOfComponents(self): return self.numberOfComponents
    
    def find(self, index):
        temp = index
        while(self.id[index] != index): index = self.id[index]

        
        # path compression
        while(self.id[temp] != index):
            temp = self.id[temp]
            self.id[temp] = index 
        
        return index

    def getComponentSize(self, index): return self.componentSize(self.find(index))
    def areConnected(self, index1, index2): return self.find(index1) == self.find(index2)

    def merge(self, index1, index2):
        if(self.areConnected(index1, index2)): return

        root1 = self.find(index1)
        root2 = self.find(index2)

        if(self.componentSize[root1] >= self.componentSize[root2]): 
            self.id[root2] = root1
            self.componentSize[root1] += self.componentSize[root2]
        else: 
            self.id[root1] = root2
            self.componentSize[root2] += self.componentSize[root1]
        
        self.numberOfComponents -= 1
    
    def clone(self):
        new = UnionFind(self.size)
        new.componentSize = [i for i in self.componentSize]
        new.id = [i for i in self.id]
        new.numberOfComponents = self.numberOfComponents

        return new",Next sibling does not exist,"(50, 0)","(72, 41)",N,class_definition,Solution,,146,d6ea9272-1bfb-41ee-9f37-ecbf010cadeb
"def numSimilarGroups(self, strs):

        N = len(strs)
        uf = UnionFind(N)


        def similar(s1, s2):
            count = 0
            
            for ch1, ch2 in zip(s1, s2):
                if(ch1 != ch2): 
                    count += 1
                    if(count>2): return False
            
            return True

        for index1 in range(N):
            for index2 in range(index1+1, N):
                if(similar(strs[index1], strs[index2]) and not uf.areConnected(index1, index2)):
                    uf.merge(index1, index2) 
        
        return uf.getNumberOfComponents()",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(51, 4)","(72, 41)",N,function_definition,numSimilarGroups,,142,1b8afa2a-c819-4704-8309-cc51aa0d73da
"def similar(s1, s2):
            count = 0
            
            for ch1, ch2 in zip(s1, s2):
                if(ch1 != ch2): 
                    count += 1
                    if(count>2): return False
            
            return True",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-Solution/function_definition-numSimilarGroups/,numSimilarGroups,uf = UnionFind(N),"for index1 in range(N):
            for index2 in range(index1+1, N):
                if(similar(strs[index1], strs[index2]) and not uf.areConnected(index1, index2)):
                    uf.merge(index1, index2)","(57, 8)","(65, 23)",N,function_definition,similar,,56,22a4f000-0f9b-4000-8b83-d6749f6fc1d6
"package com.akarsh.codechef.unionfind;

// ds which tracks elements of split into one or more disjoint group/sets


// primary operation:
// find -> returns which set the element belongs to
// union -> merges two sets


public class UnionFind {
    private int size; // number of elements in union find
    private int[] sz; // size of each component
    private int[] id; // id[idx] -> has parent index of idx
    private int numComponents;

    public UnionFind(int size){
        if(size<=0) throw new IllegalArgumentException(""size should be greater than zero"");
        this.size = size;
        this.numComponents = size;
        this.id = new int[size];
        this.sz = new int[size];

        for(int index=0; index<size; index++) {
            id[index] = index;
            sz[index] = 1;
        }
    }

    public int find(int index){
        int root = index;
        while(this.id[root] != root) root = this.id[root];

        while(index!=root){
            int temp = this.id[index];
            this.id[index] = root;
            index = temp;
        }
        return root;
    }

    public boolean isConnected(int index1, int index2){
        return find(index1) == find(index2);
    }

    public int componentSize(int index){
        return this.sz[find(index)];
    }

    public int getSize(){
        return this.size;
    }

    public int getNumComponents(){
        return this.numComponents;
    }

    public void merge(int index1, int index2){
        int root1 = find(index1);
        int root2 = find(index2);

        if(root1 == root2) return;


        if(this.sz[root1]<=this.sz[root2]){
            sz[root2] +=  sz[root1];
            id[root1] = root2;
        } else {
            sz[root1] +=  sz[root2];
            id[root2] = root1;
        }

        numComponents--;
    }

}
",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,,NA,Previous sibling does not exist,"package com.akarsh.codechef.unionfind;
// ds which tracks elements of split into one or more disjoint group/sets
// primary operation:
// find -> returns which set the element belongs to
// union -> merges two sets","(0, 0)","(76, 0)",N,program,program,,424,fb239a66-377b-48f1-8f34-6f8b8c60e2f0
"package com.akarsh.codechef.unionfind;
// ds which tracks elements of split into one or more disjoint group/sets
// primary operation:
// find -> returns which set the element belongs to
// union -> merges two sets",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/,program,Previous sibling does not exist,"public class UnionFind {
    private int size; // number of elements in union find
    private int[] sz; // size of each component
    private int[] id; // id[idx] -> has parent index of idx
    private int numComponents;

    public UnionFind(int size){
        if(size<=0) throw new IllegalArgumentException(""size should be greater than zero"");
        this.size = size;
        this.numComponents = size;
        this.id = new int[size];
        this.sz = new int[size];

        for(int index=0; index<size; index++) {
            id[index] = index;
            sz[index] = 1;
        }
    }

    public int find(int index){
        int root = index;
        while(this.id[root] != root) root = this.id[root];

        while(index!=root){
            int temp = this.id[index];
            this.id[index] = root;
            index = temp;
        }
        return root;
    }

    public boolean isConnected(int index1, int index2){
        return find(index1) == find(index2);
    }

    public int componentSize(int index){
        return this.sz[find(index)];
    }

    public int getSize(){
        return this.size;
    }

    public int getNumComponents(){
        return this.numComponents;
    }

    public void merge(int index1, int index2){
        int root1 = find(index1);
        int root2 = find(index2);

        if(root1 == root2) return;


        if(this.sz[root1]<=this.sz[root2]){
            sz[root2] +=  sz[root1];
            id[root1] = root2;
        } else {
            sz[root1] +=  sz[root2];
            id[root2] = root1;
        }

        numComponents--;
    }

}","(0, 0)","(7, 27)",N,"package_declaration,line_comment,line_comment,line_comment,line_comment",package_declaration,,45,ae1a1c41-6570-4539-976c-79131a070518
"public class UnionFind {
    private int size; // number of elements in union find
    private int[] sz; // size of each component
    private int[] id; // id[idx] -> has parent index of idx
    private int numComponents;

    public UnionFind(int size){
        if(size<=0) throw new IllegalArgumentException(""size should be greater than zero"");
        this.size = size;
        this.numComponents = size;
        this.id = new int[size];
        this.sz = new int[size];

        for(int index=0; index<size; index++) {
            id[index] = index;
            sz[index] = 1;
        }
    }

    public int find(int index){
        int root = index;
        while(this.id[root] != root) root = this.id[root];

        while(index!=root){
            int temp = this.id[index];
            this.id[index] = root;
            index = temp;
        }
        return root;
    }

    public boolean isConnected(int index1, int index2){
        return find(index1) == find(index2);
    }

    public int componentSize(int index){
        return this.sz[find(index)];
    }

    public int getSize(){
        return this.size;
    }

    public int getNumComponents(){
        return this.numComponents;
    }

    public void merge(int index1, int index2){
        int root1 = find(index1);
        int root2 = find(index2);

        if(root1 == root2) return;


        if(this.sz[root1]<=this.sz[root2]){
            sz[root2] +=  sz[root1];
            id[root1] = root2;
        } else {
            sz[root1] +=  sz[root2];
            id[root2] = root1;
        }

        numComponents--;
    }

}",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/,program,"package com.akarsh.codechef.unionfind;
// ds which tracks elements of split into one or more disjoint group/sets
// primary operation:
// find -> returns which set the element belongs to
// union -> merges two sets",Next sibling does not exist,"(10, 0)","(75, 1)",N,class_declaration,UnionFind,,376,97a8d9f2-0d8d-49a1-b863-67ca285485df
"public UnionFind(int size){
        if(size<=0) throw new IllegalArgumentException(""size should be greater than zero"");
        this.size = size;
        this.numComponents = size;
        this.id = new int[size];
        this.sz = new int[size];

        for(int index=0; index<size; index++) {
            id[index] = index;
            sz[index] = 1;
        }
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,private int numComponents;,"public int find(int index){
        int root = index;
        while(this.id[root] != root) root = this.id[root];

        while(index!=root){
            int temp = this.id[index];
            this.id[index] = root;
            index = temp;
        }
        return root;
    }","(16, 4)","(27, 5)",N,constructor_declaration,UnionFind,,84,63f0dcc9-3cf4-467f-a84b-1e521e8f0c58
"public int find(int index){
        int root = index;
        while(this.id[root] != root) root = this.id[root];

        while(index!=root){
            int temp = this.id[index];
            this.id[index] = root;
            index = temp;
        }
        return root;
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,"public UnionFind(int size){
        if(size<=0) throw new IllegalArgumentException(""size should be greater than zero"");
        this.size = size;
        this.numComponents = size;
        this.id = new int[size];
        this.sz = new int[size];

        for(int index=0; index<size; index++) {
            id[index] = index;
            sz[index] = 1;
        }
    }","public boolean isConnected(int index1, int index2){
        return find(index1) == find(index2);
    }","(29, 4)","(39, 5)",N,method_declaration,find,,62,3160adce-f303-40c8-8389-e95884918cbf
"public boolean isConnected(int index1, int index2){
        return find(index1) == find(index2);
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,"public int find(int index){
        int root = index;
        while(this.id[root] != root) root = this.id[root];

        while(index!=root){
            int temp = this.id[index];
            this.id[index] = root;
            index = temp;
        }
        return root;
    }","public int componentSize(int index){
        return this.sz[find(index)];
    }","(41, 4)","(43, 5)",N,method_declaration,isConnected,,24,f59753ea-35c6-4cb0-854c-8613b324feea
"public int componentSize(int index){
        return this.sz[find(index)];
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,"public boolean isConnected(int index1, int index2){
        return find(index1) == find(index2);
    }","public int getSize(){
        return this.size;
    }","(45, 4)","(47, 5)",N,method_declaration,componentSize,,17,78fd77cf-7934-4bb1-90c0-fdd31a473899
"public int getSize(){
        return this.size;
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,"public int componentSize(int index){
        return this.sz[find(index)];
    }","public int getNumComponents(){
        return this.numComponents;
    }","(49, 4)","(51, 5)",N,method_declaration,getSize,,11,bbf6f354-0d18-46eb-8f7c-c044e37e4e63
"public int getNumComponents(){
        return this.numComponents;
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,"public int getSize(){
        return this.size;
    }","public void merge(int index1, int index2){
        int root1 = find(index1);
        int root2 = find(index2);

        if(root1 == root2) return;


        if(this.sz[root1]<=this.sz[root2]){
            sz[root2] +=  sz[root1];
            id[root1] = root2;
        } else {
            sz[root1] +=  sz[root2];
            id[root2] = root1;
        }

        numComponents--;
    }","(53, 4)","(55, 5)",N,method_declaration,getNumComponents,,14,82e45a39-45bb-4631-a3fc-df4a4471c40f
"public void merge(int index1, int index2){
        int root1 = find(index1);
        int root2 = find(index2);

        if(root1 == root2) return;


        if(this.sz[root1]<=this.sz[root2]){
            sz[root2] +=  sz[root1];
            id[root1] = root2;
        } else {
            sz[root1] +=  sz[root2];
            id[root2] = root1;
        }

        numComponents--;
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,"public int getNumComponents(){
        return this.numComponents;
    }",Next sibling does not exist,"(57, 4)","(73, 5)",N,method_declaration,merge,,103,847ef2db-4164-4e2c-b75d-afe717802644
