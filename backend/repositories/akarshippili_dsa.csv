code_chunk,file_name,file_path,path_to_code_chunk,parent,prev_sibling,next_sibling,start_point,end_point,has_error,code_node_type,code_identifier,is_chunked,num_tokens,uuid_str
"class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)

        if(N < 2*k+1): return [-1]*N
        if(k==0): return nums

        ans = []
        prefix_sum = 0
        index = 0

        while(index <= 2*k and index<N):
            prefix_sum += nums[index]
            index += 1
        
        start = 0
        ans.append(prefix_sum//(2*k+1))

        while(index < N):
            prefix_sum += nums[index]
            prefix_sum -= nums[start]
            ans.append(prefix_sum//(2*k+1))
            index += 1
            start += 1
        
        return [-1]*k + ans + [-1]*k
",getAverages.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\getAverages.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(27, 0)",N,module,module,,169,030d233c-4393-4852-81a9-abdd4404005f
"class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)

        if(N < 2*k+1): return [-1]*N
        if(k==0): return nums

        ans = []
        prefix_sum = 0
        index = 0

        while(index <= 2*k and index<N):
            prefix_sum += nums[index]
            index += 1
        
        start = 0
        ans.append(prefix_sum//(2*k+1))

        while(index < N):
            prefix_sum += nums[index]
            prefix_sum -= nums[start]
            ans.append(prefix_sum//(2*k+1))
            index += 1
            start += 1
        
        return [-1]*k + ans + [-1]*k",getAverages.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\getAverages.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(26, 36)",N,class_definition,Solution,,168,b20350bc-e29a-420e-9c27-e4094228f578
"def getAverages(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)

        if(N < 2*k+1): return [-1]*N
        if(k==0): return nums

        ans = []
        prefix_sum = 0
        index = 0

        while(index <= 2*k and index<N):
            prefix_sum += nums[index]
            index += 1
        
        start = 0
        ans.append(prefix_sum//(2*k+1))

        while(index < N):
            prefix_sum += nums[index]
            prefix_sum -= nums[start]
            ans.append(prefix_sum//(2*k+1))
            index += 1
            start += 1
        
        return [-1]*k + ans + [-1]*k",getAverages.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\getAverages.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(26, 36)",N,function_definition,getAverages,,164,c552acb3-f9bc-43ca-8dea-973417ff9a47
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
    
        curIndex = 0
        allowed = curIndex + nums[0]

        while(curIndex<=allowed and curIndex<len(nums)):
            allowed = max(allowed, curIndex + nums[curIndex])
            curIndex+=1
        
        # print(curIndex)
        return curIndex == len(nums)
",Jump Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\Jump Game.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(12, 0)",N,module,module,,81,768657b7-945c-4f7c-b790-bd38080cbfce
"class Solution:
    def canJump(self, nums: List[int]) -> bool:
    
        curIndex = 0
        allowed = curIndex + nums[0]

        while(curIndex<=allowed and curIndex<len(nums)):
            allowed = max(allowed, curIndex + nums[curIndex])
            curIndex+=1
        
        # print(curIndex)
        return curIndex == len(nums)",Jump Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\Jump Game.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(11, 36)",N,class_definition,Solution,,81,08c32f9a-6e30-4e8e-b3f2-151ad9651d66
"def canJump(self, nums: List[int]) -> bool:
    
        curIndex = 0
        allowed = curIndex + nums[0]

        while(curIndex<=allowed and curIndex<len(nums)):
            allowed = max(allowed, curIndex + nums[curIndex])
            curIndex+=1
        
        # print(curIndex)
        return curIndex == len(nums)",Jump Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\Jump Game.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(11, 36)",N,function_definition,canJump,,77,02080401-01b3-4891-9cd1-e132a82bd451
"class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:

        max_candies = max(candies)
        return [i+extraCandies >= max_candies for i in candies]
",kidsWithCandies.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\kidsWithCandies.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(5, 0)",N,module,module,,59,9336a1ec-293e-4072-91b7-16bedbd660c0
"class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:

        max_candies = max(candies)
        return [i+extraCandies >= max_candies for i in candies]",kidsWithCandies.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\kidsWithCandies.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(4, 63)",N,class_definition,Solution,,59,ba468b9e-97d6-4396-947d-2d1d8a6ec3e9
"def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:

        max_candies = max(candies)
        return [i+extraCandies >= max_candies for i in candies]",kidsWithCandies.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\kidsWithCandies.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(4, 63)",N,function_definition,kidsWithCandies,,55,2645bec8-92e8-4a62-a2f1-3bbd111d8081
"class Solution:
    def answerQueries(self, arr: List[int], queries: List[int]) -> List[int]:
        arr.sort()
        N = len(arr)
        for i in range(1, N): arr[i] += arr[i-1]


        def binarySearch(num, low=0 , high=N-1):
            if(low>high): return low
            mid = low + (high - low)//2
            if(arr[mid] == num): return mid+1
            if(arr[mid]>num): return binarySearch(num, 0, mid-1)
            return binarySearch(num, mid+1, high)
        
        return list(map(binarySearch, queries))
",LongestSubsequenceWithLimitedSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\LongestSubsequenceWithLimitedSum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(15, 0)",N,module,module,,142,d459f684-3605-4cdc-9c09-c7acfeff1c44
"class Solution:
    def answerQueries(self, arr: List[int], queries: List[int]) -> List[int]:
        arr.sort()
        N = len(arr)
        for i in range(1, N): arr[i] += arr[i-1]


        def binarySearch(num, low=0 , high=N-1):
            if(low>high): return low
            mid = low + (high - low)//2
            if(arr[mid] == num): return mid+1
            if(arr[mid]>num): return binarySearch(num, 0, mid-1)
            return binarySearch(num, mid+1, high)
        
        return list(map(binarySearch, queries))",LongestSubsequenceWithLimitedSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\LongestSubsequenceWithLimitedSum.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 47)",N,class_definition,Solution,,142,42819b1b-1adf-4706-90ce-c30b7b6b4a93
"def answerQueries(self, arr: List[int], queries: List[int]) -> List[int]:
        arr.sort()
        N = len(arr)
        for i in range(1, N): arr[i] += arr[i-1]


        def binarySearch(num, low=0 , high=N-1):
            if(low>high): return low
            mid = low + (high - low)//2
            if(arr[mid] == num): return mid+1
            if(arr[mid]>num): return binarySearch(num, 0, mid-1)
            return binarySearch(num, mid+1, high)
        
        return list(map(binarySearch, queries))",LongestSubsequenceWithLimitedSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\LongestSubsequenceWithLimitedSum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(14, 47)",N,function_definition,answerQueries,,138,0bdddbfd-9d87-4f92-a0f8-b96bc49ad1a5
"def binarySearch(num, low=0 , high=N-1):
            if(low>high): return low
            mid = low + (high - low)//2
            if(arr[mid] == num): return mid+1
            if(arr[mid]>num): return binarySearch(num, 0, mid-1)
            return binarySearch(num, mid+1, high)",LongestSubsequenceWithLimitedSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\LongestSubsequenceWithLimitedSum.py,module/class_definition-Solution/function_definition-answerQueries/,answerQueries,"for i in range(1, N): arr[i] += arr[i-1]","return list(map(binarySearch, queries))","(7, 8)","(12, 49)",N,function_definition,binarySearch,,79,ccad7841-3ec9-46fb-b644-126605b3b668
"class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:

        arr = []
        for val, freq in groupby([i for i in s]):
            arr.append([val, len(list(freq))])        


        N = len(arr)

        if(N == 1): return 0
        start = 1 if(arr[0][0] == '0') else 0
        end = N-1 if(arr[-1][0] == '0') else N-2
        if(start>end): return 0

        zero = 0
        one = 0
        prefix = []
        for i in range(start, end, 2):
            one += arr[i][1]
            zero += arr[i+1][1]
            prefix.append([one, zero])
        
        ans = 10**10
        for i in range(len(prefix)):
            ans = min(ans, prefix[i][0] + prefix[-1][1]-prefix[i][1])
        
        ans = min(ans, prefix[-1][0])
        ans = min(ans, prefix[-1][1])
        return ans
",minFlipsMonoIncr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\minFlipsMonoIncr.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 0)",N,module,module,,244,2e880081-1630-4dd6-8edb-5085f950b766
"class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:

        arr = []
        for val, freq in groupby([i for i in s]):
            arr.append([val, len(list(freq))])        


        N = len(arr)

        if(N == 1): return 0
        start = 1 if(arr[0][0] == '0') else 0
        end = N-1 if(arr[-1][0] == '0') else N-2
        if(start>end): return 0

        zero = 0
        one = 0
        prefix = []
        for i in range(start, end, 2):
            one += arr[i][1]
            zero += arr[i+1][1]
            prefix.append([one, zero])
        
        ans = 10**10
        for i in range(len(prefix)):
            ans = min(ans, prefix[i][0] + prefix[-1][1]-prefix[i][1])
        
        ans = min(ans, prefix[-1][0])
        ans = min(ans, prefix[-1][1])
        return ans",minFlipsMonoIncr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\minFlipsMonoIncr.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 18)",N,class_definition,Solution,,243,fc1647b0-f453-49fa-ab48-7f1bf8a2fec9
"def minFlipsMonoIncr(self, s: str) -> int:

        arr = []
        for val, freq in groupby([i for i in s]):
            arr.append([val, len(list(freq))])        


        N = len(arr)

        if(N == 1): return 0
        start = 1 if(arr[0][0] == '0') else 0
        end = N-1 if(arr[-1][0] == '0') else N-2
        if(start>end): return 0

        zero = 0
        one = 0
        prefix = []
        for i in range(start, end, 2):
            one += arr[i][1]
            zero += arr[i+1][1]
            prefix.append([one, zero])
        
        ans = 10**10
        for i in range(len(prefix)):
            ans = min(ans, prefix[i][0] + prefix[-1][1]-prefix[i][1])
        
        ans = min(ans, prefix[-1][0])
        ans = min(ans, prefix[-1][1])
        return ans",minFlipsMonoIncr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\minFlipsMonoIncr.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(29, 18)",N,function_definition,minFlipsMonoIncr,,239,1d4bdb1d-87c7-4bce-9c4e-6469de19ecd0
"class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        
        if(nums1 == nums2):
            return 0
        
        if(k==0):
            return -1
        
        
        diff = [a-b for a,b in zip(nums1, nums2)]
        
        total = sum(diff)
        if(total != 0): return -1
        
        ans = 0
        for i in diff:
            if(i%k != 0):
                # print(i)
                return  -1
            if(i>0): ans += i//k
                
        return ans
",minOperations.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\minOperations.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,module,module,,136,cf4c98d4-24ab-4206-986e-197eeb618104
"class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        
        if(nums1 == nums2):
            return 0
        
        if(k==0):
            return -1
        
        
        diff = [a-b for a,b in zip(nums1, nums2)]
        
        total = sum(diff)
        if(total != 0): return -1
        
        ans = 0
        for i in diff:
            if(i%k != 0):
                # print(i)
                return  -1
            if(i>0): ans += i//k
                
        return ans",minOperations.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\minOperations.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 18)",N,class_definition,Solution,,135,e32ee647-62bd-423a-99f6-22bd40116910
"def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        
        if(nums1 == nums2):
            return 0
        
        if(k==0):
            return -1
        
        
        diff = [a-b for a,b in zip(nums1, nums2)]
        
        total = sum(diff)
        if(total != 0): return -1
        
        ans = 0
        for i in diff:
            if(i%k != 0):
                # print(i)
                return  -1
            if(i>0): ans += i//k
                
        return ans",minOperations.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\minOperations.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(22, 18)",N,function_definition,minOperations,,131,1f9433c6-2406-4bde-bd27-624b005af341
"class Solution:
    def compress(self, chars: List[str]) -> int:

        def getLen(num):
            ans = []
            if num == 1: return ans
            while(num):
                ans.append(str(num%10))
                num = num//10
            return ans[::-1]
        
        def replace(arr, swap, index):
            for i, val in enumerate(swap):
                if(index+i < len(arr)): arr[index+i] = val
                else: arr.append(val)

        index = 0
        start = 0
        end = 0
        while(start<len(chars)):
            while(end<len(chars) and chars[end] == chars[start]): end+=1
            
            chars[index] = chars[start]
            index+=1

            arr = getLen(end-start)
            replace(chars, arr, index)
            
            index+=len(arr)
            start = end

        return index
",compress.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\compress.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(32, 0)",N,module,module,,190,f7b07c8b-1b8d-46b7-b824-4f7f663ca575
"class Solution:
    def compress(self, chars: List[str]) -> int:

        def getLen(num):
            ans = []
            if num == 1: return ans
            while(num):
                ans.append(str(num%10))
                num = num//10
            return ans[::-1]
        
        def replace(arr, swap, index):
            for i, val in enumerate(swap):
                if(index+i < len(arr)): arr[index+i] = val
                else: arr.append(val)

        index = 0
        start = 0
        end = 0
        while(start<len(chars)):
            while(end<len(chars) and chars[end] == chars[start]): end+=1
            
            chars[index] = chars[start]
            index+=1

            arr = getLen(end-start)
            replace(chars, arr, index)
            
            index+=len(arr)
            start = end

        return index",compress.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\compress.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 20)",N,class_definition,Solution,,189,3ef62db5-e46f-42a8-94e5-e9bc75ec0ffd
"def compress(self, chars: List[str]) -> int:

        def getLen(num):
            ans = []
            if num == 1: return ans
            while(num):
                ans.append(str(num%10))
                num = num//10
            return ans[::-1]
        
        def replace(arr, swap, index):
            for i, val in enumerate(swap):
                if(index+i < len(arr)): arr[index+i] = val
                else: arr.append(val)

        index = 0
        start = 0
        end = 0
        while(start<len(chars)):
            while(end<len(chars) and chars[end] == chars[start]): end+=1
            
            chars[index] = chars[start]
            index+=1

            arr = getLen(end-start)
            replace(chars, arr, index)
            
            index+=len(arr)
            start = end

        return index",compress.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\compress.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(31, 20)",N,function_definition,compress,,185,971ee239-0425-41b2-b006-e9a17670a3fb
"def getLen(num):
            ans = []
            if num == 1: return ans
            while(num):
                ans.append(str(num%10))
                num = num//10
            return ans[::-1]",compress.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\compress.py,module/class_definition-Solution/function_definition-compress/,compress,Previous sibling does not exist,"def replace(arr, swap, index):
            for i, val in enumerate(swap):
                if(index+i < len(arr)): arr[index+i] = val
                else: arr.append(val)","(3, 8)","(9, 28)",N,function_definition,getLen,,44,39ffc45f-280a-4c1e-9584-e322f9259efe
"def replace(arr, swap, index):
            for i, val in enumerate(swap):
                if(index+i < len(arr)): arr[index+i] = val
                else: arr.append(val)",compress.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\compress.py,module/class_definition-Solution/function_definition-compress/,compress,"def getLen(num):
            ans = []
            if num == 1: return ans
            while(num):
                ans.append(str(num%10))
                num = num//10
            return ans[::-1]",index = 0,"(11, 8)","(14, 37)",N,function_definition,replace,,40,d780be04-f507-4573-862c-5ae9b636459f
"class Solution:

    def getNumOfCombinations(self, mn, mx, index1, index2, start, end):
        if(index1>=len(mn) or index2>=len(mx)): return 0
        mn_idx, mx_idx = min(mn[index1], mx[index2]), max(mn[index1], mx[index2])

        left = mn_idx - start + 1
        right = end - mx_idx
        if(mn_idx == mn[index1]): ans = self.getNumOfCombinations(mn, mx, index1+1, index2, mn[index1]+1, end)
        else: ans = self.getNumOfCombinations(mn, mx, index1, index2+1, mx[index2]+1, end)

        return (left*right) + ans

    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:

        def getSubAns(nums, start, end):
            mn = []
            mx = []
            for i in range(start, end): 
                if(nums[i] == minK): mn.append(i)
                if(nums[i] == maxK): mx.append(i)

            if((len(mn)==0 or len(mx)==0)): return 0
            
            # if we have n minK and m maxK in [start, end)
            # how to get all possible combinations
            return self.getNumOfCombinations(mn, mx, 0, 0, start, end)

        start = 0
        end = 0
        ans = 0 

        while(end<len(nums)):
            while(end<len(nums) and minK<=nums[end]<=maxK): end += 1
            ans += getSubAns(nums, start, end)
            end += 1
            start = end
        
        return ans

            


            
",countSubarraysWithFixedBounds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\countSubarraysWithFixedBounds.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(44, 0)",N,module,module,,393,0bcd3099-862a-44c9-9907-297d318eff65
"class Solution:

    def getNumOfCombinations(self, mn, mx, index1, index2, start, end):
        if(index1>=len(mn) or index2>=len(mx)): return 0
        mn_idx, mx_idx = min(mn[index1], mx[index2]), max(mn[index1], mx[index2])

        left = mn_idx - start + 1
        right = end - mx_idx
        if(mn_idx == mn[index1]): ans = self.getNumOfCombinations(mn, mx, index1+1, index2, mn[index1]+1, end)
        else: ans = self.getNumOfCombinations(mn, mx, index1, index2+1, mx[index2]+1, end)

        return (left*right) + ans

    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:

        def getSubAns(nums, start, end):
            mn = []
            mx = []
            for i in range(start, end): 
                if(nums[i] == minK): mn.append(i)
                if(nums[i] == maxK): mx.append(i)

            if((len(mn)==0 or len(mx)==0)): return 0
            
            # if we have n minK and m maxK in [start, end)
            # how to get all possible combinations
            return self.getNumOfCombinations(mn, mx, 0, 0, start, end)

        start = 0
        end = 0
        ans = 0 

        while(end<len(nums)):
            while(end<len(nums) and minK<=nums[end]<=maxK): end += 1
            ans += getSubAns(nums, start, end)
            end += 1
            start = end
        
        return ans",countSubarraysWithFixedBounds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\countSubarraysWithFixedBounds.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(38, 18)",N,class_definition,Solution,,389,260bb8f3-58c0-4b24-94ba-cf3c8cd231b4
"def getNumOfCombinations(self, mn, mx, index1, index2, start, end):
        if(index1>=len(mn) or index2>=len(mx)): return 0
        mn_idx, mx_idx = min(mn[index1], mx[index2]), max(mn[index1], mx[index2])

        left = mn_idx - start + 1
        right = end - mx_idx
        if(mn_idx == mn[index1]): ans = self.getNumOfCombinations(mn, mx, index1+1, index2, mn[index1]+1, end)
        else: ans = self.getNumOfCombinations(mn, mx, index1, index2+1, mx[index2]+1, end)

        return (left*right) + ans",countSubarraysWithFixedBounds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\countSubarraysWithFixedBounds.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:

        def getSubAns(nums, start, end):
            mn = []
            mx = []
            for i in range(start, end): 
                if(nums[i] == minK): mn.append(i)
                if(nums[i] == maxK): mx.append(i)

            if((len(mn)==0 or len(mx)==0)): return 0
            
            # if we have n minK and m maxK in [start, end)
            # how to get all possible combinations
            return self.getNumOfCombinations(mn, mx, 0, 0, start, end)

        start = 0
        end = 0
        ans = 0 

        while(end<len(nums)):
            while(end<len(nums) and minK<=nums[end]<=maxK): end += 1
            ans += getSubAns(nums, start, end)
            end += 1
            start = end
        
        return ans","(2, 4)","(11, 33)",N,function_definition,getNumOfCombinations,,166,177618db-5e16-4545-b658-378a2e07a551
"def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:

        def getSubAns(nums, start, end):
            mn = []
            mx = []
            for i in range(start, end): 
                if(nums[i] == minK): mn.append(i)
                if(nums[i] == maxK): mx.append(i)

            if((len(mn)==0 or len(mx)==0)): return 0
            
            # if we have n minK and m maxK in [start, end)
            # how to get all possible combinations
            return self.getNumOfCombinations(mn, mx, 0, 0, start, end)

        start = 0
        end = 0
        ans = 0 

        while(end<len(nums)):
            while(end<len(nums) and minK<=nums[end]<=maxK): end += 1
            ans += getSubAns(nums, start, end)
            end += 1
            start = end
        
        return ans",countSubarraysWithFixedBounds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\countSubarraysWithFixedBounds.py,module/class_definition-Solution/,Solution,"def getNumOfCombinations(self, mn, mx, index1, index2, start, end):
        if(index1>=len(mn) or index2>=len(mx)): return 0
        mn_idx, mx_idx = min(mn[index1], mx[index2]), max(mn[index1], mx[index2])

        left = mn_idx - start + 1
        right = end - mx_idx
        if(mn_idx == mn[index1]): ans = self.getNumOfCombinations(mn, mx, index1+1, index2, mn[index1]+1, end)
        else: ans = self.getNumOfCombinations(mn, mx, index1, index2+1, mx[index2]+1, end)

        return (left*right) + ans",Next sibling does not exist,"(13, 4)","(38, 18)",N,function_definition,countSubarrays,,217,b20545aa-ab62-4c00-b9e9-bccf2998368b
"def getSubAns(nums, start, end):
            mn = []
            mx = []
            for i in range(start, end): 
                if(nums[i] == minK): mn.append(i)
                if(nums[i] == maxK): mx.append(i)

            if((len(mn)==0 or len(mx)==0)): return 0
            
            # if we have n minK and m maxK in [start, end)
            # how to get all possible combinations
            return self.getNumOfCombinations(mn, mx, 0, 0, start, end)",countSubarraysWithFixedBounds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\countSubarraysWithFixedBounds.py,module/class_definition-Solution/function_definition-countSubarrays/,countSubarrays,Previous sibling does not exist,start = 0,"(15, 8)","(26, 70)",N,function_definition,getSubAns,,121,3abeef23-6467-472f-a45e-ccffe5863527
"class Solution:
    def jump(self, nums: List[int]) -> int:

        if(len(nums)==1): return 0

        count = 0
        start = 0
        end = 1

        while True:
            # print(nums[start:end], count)
            maxReach = start    
            while(start<end and start<len(nums)):
                maxReach = max(maxReach, start+nums[start])
                start += 1
            
            # print(maxReach)
            count += 1
            if(maxReach >= len(nums)-1): return count
            else: start, end = end, maxReach + 1
             


",jumpTwo.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\jumpTwo.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,module,module,,135,0292dfe7-0667-4fa4-886b-fed59b636472
"class Solution:
    def jump(self, nums: List[int]) -> int:

        if(len(nums)==1): return 0

        count = 0
        start = 0
        end = 1

        while True:
            # print(nums[start:end], count)
            maxReach = start    
            while(start<end and start<len(nums)):
                maxReach = max(maxReach, start+nums[start])
                start += 1
            
            # print(maxReach)
            count += 1
            if(maxReach >= len(nums)-1): return count
            else: start, end = end, maxReach + 1",jumpTwo.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\jumpTwo.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(19, 48)",N,class_definition,Solution,,132,c2cbe1f9-5e48-4afc-856b-b6fcafcde4de
"def jump(self, nums: List[int]) -> int:

        if(len(nums)==1): return 0

        count = 0
        start = 0
        end = 1

        while True:
            # print(nums[start:end], count)
            maxReach = start    
            while(start<end and start<len(nums)):
                maxReach = max(maxReach, start+nums[start])
                start += 1
            
            # print(maxReach)
            count += 1
            if(maxReach >= len(nums)-1): return count
            else: start, end = end, maxReach + 1",jumpTwo.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\arrays\two-pointers\jumpTwo.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(19, 48)",N,function_definition,jump,,128,ce6a93c6-668d-4a74-8344-d24f0ca4ceda
"class Solution:

    def __init__(self):
        self.arr = None
        self.ans = set()

    def helper(self, cur, index):        
        if(index == len(self.arr) and len(cur)>1): 
            self.ans.add(tuple(i for i in cur))
            return
        
        if(index >= len(self.arr)): return
        
        if(len(cur)==0 or (cur[-1]<=self.arr[index])): 
            cur.append(self.arr[index])
            self.helper(cur, index+1)
            cur.pop()
        
        self.helper(cur, index+1)
        


    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        self.arr = nums
        self.helper([], 0)
        return self.ans
",findSubsequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\findSubsequences.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(26, 0)",N,module,module,,159,ed43090c-a17f-41cb-b594-cfaa895d7895
"class Solution:

    def __init__(self):
        self.arr = None
        self.ans = set()

    def helper(self, cur, index):        
        if(index == len(self.arr) and len(cur)>1): 
            self.ans.add(tuple(i for i in cur))
            return
        
        if(index >= len(self.arr)): return
        
        if(len(cur)==0 or (cur[-1]<=self.arr[index])): 
            cur.append(self.arr[index])
            self.helper(cur, index+1)
            cur.pop()
        
        self.helper(cur, index+1)
        


    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        self.arr = nums
        self.helper([], 0)
        return self.ans",findSubsequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\findSubsequences.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 23)",N,class_definition,Solution,,158,78ad0258-dd3c-4c84-8cb0-ed6870fcea77
"def __init__(self):
        self.arr = None
        self.ans = set()",findSubsequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\findSubsequences.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def helper(self, cur, index):        
        if(index == len(self.arr) and len(cur)>1): 
            self.ans.add(tuple(i for i in cur))
            return
        
        if(index >= len(self.arr)): return
        
        if(len(cur)==0 or (cur[-1]<=self.arr[index])): 
            cur.append(self.arr[index])
            self.helper(cur, index+1)
            cur.pop()
        
        self.helper(cur, index+1)","(2, 4)","(4, 24)",N,function_definition,__init__,,19,cc462706-8c69-4a02-818e-6aaa10b654ea
"def helper(self, cur, index):        
        if(index == len(self.arr) and len(cur)>1): 
            self.ans.add(tuple(i for i in cur))
            return
        
        if(index >= len(self.arr)): return
        
        if(len(cur)==0 or (cur[-1]<=self.arr[index])): 
            cur.append(self.arr[index])
            self.helper(cur, index+1)
            cur.pop()
        
        self.helper(cur, index+1)",findSubsequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\findSubsequences.py,module/class_definition-Solution/,Solution,"def __init__(self):
        self.arr = None
        self.ans = set()","def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        self.arr = nums
        self.helper([], 0)
        return self.ans","(6, 4)","(18, 33)",N,function_definition,helper,,97,ed368b90-93ad-4417-8142-c9baf9a33557
"def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        self.arr = nums
        self.helper([], 0)
        return self.ans",findSubsequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\findSubsequences.py,module/class_definition-Solution/,Solution,"def helper(self, cur, index):        
        if(index == len(self.arr) and len(cur)>1): 
            self.ans.add(tuple(i for i in cur))
            return
        
        if(index >= len(self.arr)): return
        
        if(len(cur)==0 or (cur[-1]<=self.arr[index])): 
            cur.append(self.arr[index])
            self.helper(cur, index+1)
            cur.pop()
        
        self.helper(cur, index+1)",Next sibling does not exist,"(22, 4)","(25, 23)",N,function_definition,findSubsequences,,34,ade88c73-727c-405e-bf9d-2c1558e33183
"class Solution {
    
    private ArrayList<String> ans = new ArrayList<>();
    private String[] mapping = new String[] {""0"", ""1"", ""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""};

    
    public List<String> letterCombinations(String digits) {
        if(digits.length()>0) helper(digits, 0, """");
        return ans;
    }
    
    
    public void helper(String digits, int index, String cur){
        
        if(index==digits.length()){
            ans.add(cur);
            return;
        }
        
        for(char ch: mapping[digits.charAt(index) - '0'].toCharArray()){
            helper(digits, index+1, cur+ch);
        }
    }
    
    
    
}
",LetterCombinations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\LetterCombinations.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(27, 0)",N,program,program,,160,c8dd424d-89ca-4c85-ab80-214fbe94c574
"class Solution {
    
    private ArrayList<String> ans = new ArrayList<>();
    private String[] mapping = new String[] {""0"", ""1"", ""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""};

    
    public List<String> letterCombinations(String digits) {
        if(digits.length()>0) helper(digits, 0, """");
        return ans;
    }
    
    
    public void helper(String digits, int index, String cur){
        
        if(index==digits.length()){
            ans.add(cur);
            return;
        }
        
        for(char ch: mapping[digits.charAt(index) - '0'].toCharArray()){
            helper(digits, index+1, cur+ch);
        }
    }
    
    
    
}",LetterCombinations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\LetterCombinations.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(26, 1)",N,class_declaration,Solution,,160,b55a5969-11cb-41fb-8113-46c988cc240e
"public List<String> letterCombinations(String digits) {
        if(digits.length()>0) helper(digits, 0, """");
        return ans;
    }",LetterCombinations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\LetterCombinations.java,program/class_declaration-Solution/,Solution,"private String[] mapping = new String[] {""0"", ""1"", ""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""};","public void helper(String digits, int index, String cur){
        
        if(index==digits.length()){
            ans.add(cur);
            return;
        }
        
        for(char ch: mapping[digits.charAt(index) - '0'].toCharArray()){
            helper(digits, index+1, cur+ch);
        }
    }","(6, 4)","(9, 5)",N,method_declaration,letterCombinations,,31,19309628-50fb-48d6-b507-dfdcb2821a19
"public void helper(String digits, int index, String cur){
        
        if(index==digits.length()){
            ans.add(cur);
            return;
        }
        
        for(char ch: mapping[digits.charAt(index) - '0'].toCharArray()){
            helper(digits, index+1, cur+ch);
        }
    }",LetterCombinations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\LetterCombinations.java,program/class_declaration-Solution/,Solution,"public List<String> letterCombinations(String digits) {
        if(digits.length()>0) helper(digits, 0, """");
        return ans;
    }",Next sibling does not exist,"(12, 4)","(22, 5)",N,method_declaration,helper,,65,c52b0b21-559b-4a5f-9b1d-27286a20fa89
"class Solution {
    public List<List<Integer>> permute(int[] nums) {
        boolean[] added = new boolean[nums.length];
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        permute(nums, added, ans, new ArrayList<Integer>());
        return ans;
    }
    
    public void permute(int[] nums, boolean[] added, List<List<Integer>> ans, ArrayList<Integer> cur){
        
        if(cur.size() == nums.length) {
            ans.add(new ArrayList(cur));
            return;
        }
        
        for(int index=0; index<nums.length; index++){
            
            if(added[index]) continue;
            
            added[index] = true;
            cur.add(nums[index]);
            permute(nums, added, ans, cur);
            added[index] = false;
            cur.remove(cur.size()-1);
        }
    }
    
    
    
}
",Permutations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\Permutations.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 0)",N,program,program,,176,07bc6136-831c-44b7-afd5-6c48723b7dec
"class Solution {
    public List<List<Integer>> permute(int[] nums) {
        boolean[] added = new boolean[nums.length];
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        permute(nums, added, ans, new ArrayList<Integer>());
        return ans;
    }
    
    public void permute(int[] nums, boolean[] added, List<List<Integer>> ans, ArrayList<Integer> cur){
        
        if(cur.size() == nums.length) {
            ans.add(new ArrayList(cur));
            return;
        }
        
        for(int index=0; index<nums.length; index++){
            
            if(added[index]) continue;
            
            added[index] = true;
            cur.add(nums[index]);
            permute(nums, added, ans, cur);
            added[index] = false;
            cur.remove(cur.size()-1);
        }
    }
    
    
    
}",Permutations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\Permutations.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 1)",N,class_declaration,Solution,,176,88400d4a-5c05-46c4-b1f4-63f364830592
"public List<List<Integer>> permute(int[] nums) {
        boolean[] added = new boolean[nums.length];
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        permute(nums, added, ans, new ArrayList<Integer>());
        return ans;
    }",Permutations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\Permutations.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public void permute(int[] nums, boolean[] added, List<List<Integer>> ans, ArrayList<Integer> cur){
        
        if(cur.size() == nums.length) {
            ans.add(new ArrayList(cur));
            return;
        }
        
        for(int index=0; index<nums.length; index++){
            
            if(added[index]) continue;
            
            added[index] = true;
            cur.add(nums[index]);
            permute(nums, added, ans, cur);
            added[index] = false;
            cur.remove(cur.size()-1);
        }
    }","(1, 4)","(6, 5)",N,method_declaration,permute,,54,c5f4a4ae-da40-4b1d-9249-e64aa9aabe23
"public void permute(int[] nums, boolean[] added, List<List<Integer>> ans, ArrayList<Integer> cur){
        
        if(cur.size() == nums.length) {
            ans.add(new ArrayList(cur));
            return;
        }
        
        for(int index=0; index<nums.length; index++){
            
            if(added[index]) continue;
            
            added[index] = true;
            cur.add(nums[index]);
            permute(nums, added, ans, cur);
            added[index] = false;
            cur.remove(cur.size()-1);
        }
    }",Permutations.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\Permutations.java,program/class_declaration-Solution/,Solution,"public List<List<Integer>> permute(int[] nums) {
        boolean[] added = new boolean[nums.length];
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        permute(nums, added, ans, new ArrayList<Integer>());
        return ans;
    }",Next sibling does not exist,"(8, 4)","(25, 5)",N,method_declaration,permute,,114,7325259e-50ed-41b3-8f87-62ff3e8caef1
"class Solution:
    def totalNQueens(self, n: int) -> int:


        def good(row_index, col_index, cur):
            for val in cur:
                if(val & 1<<col_index): return False
            
            for index in range(1, row_index+1):
                val = 0
                if(col_index-index >=0 ): val = val | (1<<(col_index-index))
                if(0 <= col_index+index < n): val = val | (1<<(col_index+index))

                if(cur[row_index-index] & val): return False
            
            return True




        def helper(row_index, cur):
            if(row_index == n): return 1
            ans = 0
            for col_index in range(n):
                if(good(row_index, col_index, cur)):
                    cur[row_index] = 1<<col_index
                    ans += helper(row_index+1, cur)
                    cur[row_index] = 0
            
            return ans

        cur = [0 for i in range(n)]
        return helper(0, cur)
",totalNQueens.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\totalNQueens.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(33, 0)",N,module,module,,227,fd6f4497-062e-4545-833b-b5f2feabc238
"class Solution:
    def totalNQueens(self, n: int) -> int:


        def good(row_index, col_index, cur):
            for val in cur:
                if(val & 1<<col_index): return False
            
            for index in range(1, row_index+1):
                val = 0
                if(col_index-index >=0 ): val = val | (1<<(col_index-index))
                if(0 <= col_index+index < n): val = val | (1<<(col_index+index))

                if(cur[row_index-index] & val): return False
            
            return True




        def helper(row_index, cur):
            if(row_index == n): return 1
            ans = 0
            for col_index in range(n):
                if(good(row_index, col_index, cur)):
                    cur[row_index] = 1<<col_index
                    ans += helper(row_index+1, cur)
                    cur[row_index] = 0
            
            return ans

        cur = [0 for i in range(n)]
        return helper(0, cur)",totalNQueens.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\totalNQueens.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(32, 29)",N,class_definition,Solution,,227,def23f72-35c8-4670-97ab-511ab7986902
"def totalNQueens(self, n: int) -> int:


        def good(row_index, col_index, cur):
            for val in cur:
                if(val & 1<<col_index): return False
            
            for index in range(1, row_index+1):
                val = 0
                if(col_index-index >=0 ): val = val | (1<<(col_index-index))
                if(0 <= col_index+index < n): val = val | (1<<(col_index+index))

                if(cur[row_index-index] & val): return False
            
            return True




        def helper(row_index, cur):
            if(row_index == n): return 1
            ans = 0
            for col_index in range(n):
                if(good(row_index, col_index, cur)):
                    cur[row_index] = 1<<col_index
                    ans += helper(row_index+1, cur)
                    cur[row_index] = 0
            
            return ans

        cur = [0 for i in range(n)]
        return helper(0, cur)",totalNQueens.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\totalNQueens.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(32, 29)",N,function_definition,totalNQueens,,223,92bea095-ddf7-4964-85bb-90b3e3e60751
"def good(row_index, col_index, cur):
            for val in cur:
                if(val & 1<<col_index): return False
            
            for index in range(1, row_index+1):
                val = 0
                if(col_index-index >=0 ): val = val | (1<<(col_index-index))
                if(0 <= col_index+index < n): val = val | (1<<(col_index+index))

                if(cur[row_index-index] & val): return False
            
            return True",totalNQueens.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\totalNQueens.py,module/class_definition-Solution/function_definition-totalNQueens/,totalNQueens,Previous sibling does not exist,"def helper(row_index, cur):
            if(row_index == n): return 1
            ans = 0
            for col_index in range(n):
                if(good(row_index, col_index, cur)):
                    cur[row_index] = 1<<col_index
                    ans += helper(row_index+1, cur)
                    cur[row_index] = 0
            
            return ans","(4, 8)","(15, 23)",N,function_definition,good,,107,4c365e43-4f41-4baa-9b4a-0a46a7220b7d
"def helper(row_index, cur):
            if(row_index == n): return 1
            ans = 0
            for col_index in range(n):
                if(good(row_index, col_index, cur)):
                    cur[row_index] = 1<<col_index
                    ans += helper(row_index+1, cur)
                    cur[row_index] = 0
            
            return ans",totalNQueens.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\totalNQueens.py,module/class_definition-Solution/function_definition-totalNQueens/,totalNQueens,"def good(row_index, col_index, cur):
            for val in cur:
                if(val & 1<<col_index): return False
            
            for index in range(1, row_index+1):
                val = 0
                if(col_index-index >=0 ): val = val | (1<<(col_index-index))
                if(0 <= col_index+index < n): val = val | (1<<(col_index+index))

                if(cur[row_index-index] & val): return False
            
            return True",cur = [0 for i in range(n)],"(20, 8)","(29, 22)",N,function_definition,helper,,79,27612cfe-ffdc-4316-87a3-70210e1c6c45
"package com.akarsh.designpatterns;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class WordSearch2 {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findWords(
                new char[][]{
                        {'o','a','a','n'},
                        {'e','t','a','e'},
                        {'i','h','k','r'},
                        {'i','f','l','v'}
                },
                new String[]{""oath"",""pea"",""eat"",""rain""}
        ));
    }
}


class Solution {
    public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        List<String> ans = new ArrayList<>();


        for (String word: words) {
            TrieNode node = root;
            for (Character ch: word.toCharArray()){
                if(!node.hasChild(ch)) {
                    node.setChild(ch, new TrieNode());
                }
                node = node.getChild(ch);
            }
            node.setWord(word);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i=0;i<board.length;i++){
            for (int j=0; j<board[0].length; j++){
                helper(i ,j, board, root, ans, visited);
            }
        }

        return ans;
    }

    public void helper(int i, int j, char[][] board, TrieNode node, List<String> ans, boolean[][] visited){

        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) return;
        if(!node.hasChild(board[i][j])) return;

        Character ch = board[i][j];
        node = node.getChild(ch);

        if(node.getWord() != null ) {
            ans.add(node.getWord());
        }

        visited[i][j] = true;

        helper(i-1, j, board, node, ans, visited);
        helper(i, j+1, board, node, ans, visited);
        helper(i+1, j, board, node, ans, visited);
        helper(i, j-1, board, node, ans, visited);

        visited[i][j] = false;
    }

}

class TrieNode{
    private String word;
    private final TrieNode[] children;

    public TrieNode(){
        word = null;
        children = new TrieNode[26];
    }

    public void setWord(String word) {
        this.word = word;
    }

    public String getWord() {
        return word;
    }

    public boolean hasChild(Character ch){
        return children[ch - 'a'] != null;
    }

    public TrieNode getChild(Character ch) {
        return children[ch-'a'];
    }

    public void setChild(Character ch, TrieNode child) {
        this.children[ch-'a'] = child;
    }

    @Override
    public String toString() {
        return ""TrieNode{"" +
                ""Word="" + word +
                "", children="" + Arrays.toString(children) +
                '}';
    }
}
",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,,NA,Previous sibling does not exist,"package com.akarsh.designpatterns;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;","(0, 0)","(111, 0)",N,program,program,,655,72896d75-ed1f-4764-b2d6-0c5b8ec9352d
"package com.akarsh.designpatterns;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/,program,Previous sibling does not exist,"public class WordSearch2 {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findWords(
                new char[][]{
                        {'o','a','a','n'},
                        {'e','t','a','e'},
                        {'i','h','k','r'},
                        {'i','f','l','v'}
                },
                new String[]{""oath"",""pea"",""eat"",""rain""}
        ));
    }
}","(0, 0)","(4, 22)",N,"package_declaration,import_declaration,import_declaration,import_declaration",package_declaration,,23,1095e329-f575-48d1-98a1-722306fd23be
"public class WordSearch2 {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findWords(
                new char[][]{
                        {'o','a','a','n'},
                        {'e','t','a','e'},
                        {'i','h','k','r'},
                        {'i','f','l','v'}
                },
                new String[]{""oath"",""pea"",""eat"",""rain""}
        ));
    }
}",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/,program,"package com.akarsh.designpatterns;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;","class Solution {
    public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        List<String> ans = new ArrayList<>();


        for (String word: words) {
            TrieNode node = root;
            for (Character ch: word.toCharArray()){
                if(!node.hasChild(ch)) {
                    node.setChild(ch, new TrieNode());
                }
                node = node.getChild(ch);
            }
            node.setWord(word);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i=0;i<board.length;i++){
            for (int j=0; j<board[0].length; j++){
                helper(i ,j, board, root, ans, visited);
            }
        }

        return ans;
    }

    public void helper(int i, int j, char[][] board, TrieNode node, List<String> ans, boolean[][] visited){

        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) return;
        if(!node.hasChild(board[i][j])) return;

        Character ch = board[i][j];
        node = node.getChild(ch);

        if(node.getWord() != null ) {
            ans.add(node.getWord());
        }

        visited[i][j] = true;

        helper(i-1, j, board, node, ans, visited);
        helper(i, j+1, board, node, ans, visited);
        helper(i+1, j, board, node, ans, visited);
        helper(i, j-1, board, node, ans, visited);

        visited[i][j] = false;
    }

}","(6, 0)","(19, 1)",N,class_declaration,WordSearch2,,97,bfddd7cc-306f-4595-9c8e-1226c1663ef3
"public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findWords(
                new char[][]{
                        {'o','a','a','n'},
                        {'e','t','a','e'},
                        {'i','h','k','r'},
                        {'i','f','l','v'}
                },
                new String[]{""oath"",""pea"",""eat"",""rain""}
        ));
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-WordSearch2/,WordSearch2,Previous sibling does not exist,Next sibling does not exist,"(7, 4)","(18, 5)",N,method_declaration,main,,89,d36fc09a-1c00-46f3-b110-c0f56bf7a0b0
"class Solution {
    public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        List<String> ans = new ArrayList<>();


        for (String word: words) {
            TrieNode node = root;
            for (Character ch: word.toCharArray()){
                if(!node.hasChild(ch)) {
                    node.setChild(ch, new TrieNode());
                }
                node = node.getChild(ch);
            }
            node.setWord(word);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i=0;i<board.length;i++){
            for (int j=0; j<board[0].length; j++){
                helper(i ,j, board, root, ans, visited);
            }
        }

        return ans;
    }

    public void helper(int i, int j, char[][] board, TrieNode node, List<String> ans, boolean[][] visited){

        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) return;
        if(!node.hasChild(board[i][j])) return;

        Character ch = board[i][j];
        node = node.getChild(ch);

        if(node.getWord() != null ) {
            ans.add(node.getWord());
        }

        visited[i][j] = true;

        helper(i-1, j, board, node, ans, visited);
        helper(i, j+1, board, node, ans, visited);
        helper(i+1, j, board, node, ans, visited);
        helper(i, j-1, board, node, ans, visited);

        visited[i][j] = false;
    }

}",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/,program,"public class WordSearch2 {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findWords(
                new char[][]{
                        {'o','a','a','n'},
                        {'e','t','a','e'},
                        {'i','h','k','r'},
                        {'i','f','l','v'}
                },
                new String[]{""oath"",""pea"",""eat"",""rain""}
        ));
    }
}","class TrieNode{
    private String word;
    private final TrieNode[] children;

    public TrieNode(){
        word = null;
        children = new TrieNode[26];
    }

    public void setWord(String word) {
        this.word = word;
    }

    public String getWord() {
        return word;
    }

    public boolean hasChild(Character ch){
        return children[ch - 'a'] != null;
    }

    public TrieNode getChild(Character ch) {
        return children[ch-'a'];
    }

    public void setChild(Character ch, TrieNode child) {
        this.children[ch-'a'] = child;
    }

    @Override
    public String toString() {
        return ""TrieNode{"" +
                ""Word="" + word +
                "", children="" + Arrays.toString(children) +
                '}';
    }
}","(22, 0)","(72, 1)",N,class_declaration,Solution,,363,510a8ec1-e69e-4142-a895-b46d76e8161b
"public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        List<String> ans = new ArrayList<>();


        for (String word: words) {
            TrieNode node = root;
            for (Character ch: word.toCharArray()){
                if(!node.hasChild(ch)) {
                    node.setChild(ch, new TrieNode());
                }
                node = node.getChild(ch);
            }
            node.setWord(word);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i=0;i<board.length;i++){
            for (int j=0; j<board[0].length; j++){
                helper(i ,j, board, root, ans, visited);
            }
        }

        return ans;
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public void helper(int i, int j, char[][] board, TrieNode node, List<String> ans, boolean[][] visited){

        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) return;
        if(!node.hasChild(board[i][j])) return;

        Character ch = board[i][j];
        node = node.getChild(ch);

        if(node.getWord() != null ) {
            ans.add(node.getWord());
        }

        visited[i][j] = true;

        helper(i-1, j, board, node, ans, visited);
        helper(i, j+1, board, node, ans, visited);
        helper(i+1, j, board, node, ans, visited);
        helper(i, j-1, board, node, ans, visited);

        visited[i][j] = false;
    }","(23, 4)","(48, 5)",N,method_declaration,findWords,,169,52bd8c05-242a-4178-918d-2374ca33b09b
"public void helper(int i, int j, char[][] board, TrieNode node, List<String> ans, boolean[][] visited){

        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) return;
        if(!node.hasChild(board[i][j])) return;

        Character ch = board[i][j];
        node = node.getChild(ch);

        if(node.getWord() != null ) {
            ans.add(node.getWord());
        }

        visited[i][j] = true;

        helper(i-1, j, board, node, ans, visited);
        helper(i, j+1, board, node, ans, visited);
        helper(i+1, j, board, node, ans, visited);
        helper(i, j-1, board, node, ans, visited);

        visited[i][j] = false;
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-Solution/,Solution,"public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        List<String> ans = new ArrayList<>();


        for (String word: words) {
            TrieNode node = root;
            for (Character ch: word.toCharArray()){
                if(!node.hasChild(ch)) {
                    node.setChild(ch, new TrieNode());
                }
                node = node.getChild(ch);
            }
            node.setWord(word);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i=0;i<board.length;i++){
            for (int j=0; j<board[0].length; j++){
                helper(i ,j, board, root, ans, visited);
            }
        }

        return ans;
    }",Next sibling does not exist,"(50, 4)","(70, 5)",N,method_declaration,helper,,188,0cf1b1ef-b506-4e16-a01e-732916dd9d2a
"class TrieNode{
    private String word;
    private final TrieNode[] children;

    public TrieNode(){
        word = null;
        children = new TrieNode[26];
    }

    public void setWord(String word) {
        this.word = word;
    }

    public String getWord() {
        return word;
    }

    public boolean hasChild(Character ch){
        return children[ch - 'a'] != null;
    }

    public TrieNode getChild(Character ch) {
        return children[ch-'a'];
    }

    public void setChild(Character ch, TrieNode child) {
        this.children[ch-'a'] = child;
    }

    @Override
    public String toString() {
        return ""TrieNode{"" +
                ""Word="" + word +
                "", children="" + Arrays.toString(children) +
                '}';
    }
}",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/,program,"class Solution {
    public List<String> findWords(char[][] board, String[] words) {
        TrieNode root = new TrieNode();
        List<String> ans = new ArrayList<>();


        for (String word: words) {
            TrieNode node = root;
            for (Character ch: word.toCharArray()){
                if(!node.hasChild(ch)) {
                    node.setChild(ch, new TrieNode());
                }
                node = node.getChild(ch);
            }
            node.setWord(word);
        }

        boolean[][] visited = new boolean[board.length][board[0].length];

        for (int i=0;i<board.length;i++){
            for (int j=0; j<board[0].length; j++){
                helper(i ,j, board, root, ans, visited);
            }
        }

        return ans;
    }

    public void helper(int i, int j, char[][] board, TrieNode node, List<String> ans, boolean[][] visited){

        if(i<0 || j<0 || i>=board.length || j>=board[0].length || visited[i][j]) return;
        if(!node.hasChild(board[i][j])) return;

        Character ch = board[i][j];
        node = node.getChild(ch);

        if(node.getWord() != null ) {
            ans.add(node.getWord());
        }

        visited[i][j] = true;

        helper(i-1, j, board, node, ans, visited);
        helper(i, j+1, board, node, ans, visited);
        helper(i+1, j, board, node, ans, visited);
        helper(i, j-1, board, node, ans, visited);

        visited[i][j] = false;
    }

}",Next sibling does not exist,"(74, 0)","(110, 1)",N,class_declaration,TrieNode,,172,d407804f-17d5-4f64-b955-4a028570803e
"public TrieNode(){
        word = null;
        children = new TrieNode[26];
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,private final TrieNode[] children;,"public void setWord(String word) {
        this.word = word;
    }","(78, 4)","(81, 5)",N,constructor_declaration,TrieNode,,20,3966d196-35bc-4dde-a78f-70dad43a8483
"public void setWord(String word) {
        this.word = word;
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,"public TrieNode(){
        word = null;
        children = new TrieNode[26];
    }","public String getWord() {
        return word;
    }","(83, 4)","(85, 5)",N,method_declaration,setWord,,16,f77776b3-74b8-40ac-a76e-1ab58ad24c3c
"public String getWord() {
        return word;
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,"public void setWord(String word) {
        this.word = word;
    }","public boolean hasChild(Character ch){
        return children[ch - 'a'] != null;
    }","(87, 4)","(89, 5)",N,method_declaration,getWord,,12,feee69a4-5b56-4775-9f92-104af6368a77
"public boolean hasChild(Character ch){
        return children[ch - 'a'] != null;
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,"public String getWord() {
        return word;
    }","public TrieNode getChild(Character ch) {
        return children[ch-'a'];
    }","(91, 4)","(93, 5)",N,method_declaration,hasChild,,20,f2c38739-c7be-4ed6-a9be-5e3f67b14527
"public TrieNode getChild(Character ch) {
        return children[ch-'a'];
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,"public boolean hasChild(Character ch){
        return children[ch - 'a'] != null;
    }","public void setChild(Character ch, TrieNode child) {
        this.children[ch-'a'] = child;
    }","(95, 4)","(97, 5)",N,method_declaration,getChild,,17,0e30e6a1-93da-4c98-bab3-3b95046701d4
"public void setChild(Character ch, TrieNode child) {
        this.children[ch-'a'] = child;
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,"public TrieNode getChild(Character ch) {
        return children[ch-'a'];
    }","@Override
    public String toString() {
        return ""TrieNode{"" +
                ""Word="" + word +
                "", children="" + Arrays.toString(children) +
                '}';
    }","(99, 4)","(101, 5)",N,method_declaration,setChild,,24,75f7aa7a-d11e-4744-81ca-7242424be451
"@Override
    public String toString() {
        return ""TrieNode{"" +
                ""Word="" + word +
                "", children="" + Arrays.toString(children) +
                '}';
    }",WordSearch2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\backtracking\WordSearch2.java,program/class_declaration-TrieNode/,TrieNode,"public void setChild(Character ch, TrieNode child) {
        this.children[ch-'a'] = child;
    }",Next sibling does not exist,"(103, 4)","(109, 5)",N,method_declaration,toString,,37,8a2118f4-82af-41a4-b26c-3f0ba5e1b256
"class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        
        def isValid(target):
            carry = 0
            
            for index in range(len(nums)-1,-1,-1):
                cur = nums[index]
                cur += carry
                carry = 0
                if(cur>target):
                    carry = cur - target
                    
            return carry == 0
        
        left = 0
        right = 10**9
        
        while left<right:
            mid = (left+right)//2
            
            # print(mid, isValid(mid))
            
            if(isValid(mid)):
                right = mid
            else:
                left = mid+1
                
        # print(left,right)
        return right
        
",MinimizeMaximumOfArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\MinimizeMaximumOfArray.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 0)",N,module,module,,151,b3d50be8-92b3-4d1f-9e15-224b9a799182
"class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        
        def isValid(target):
            carry = 0
            
            for index in range(len(nums)-1,-1,-1):
                cur = nums[index]
                cur += carry
                carry = 0
                if(cur>target):
                    carry = cur - target
                    
            return carry == 0
        
        left = 0
        right = 10**9
        
        while left<right:
            mid = (left+right)//2
            
            # print(mid, isValid(mid))
            
            if(isValid(mid)):
                right = mid
            else:
                left = mid+1
                
        # print(left,right)
        return right",MinimizeMaximumOfArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\MinimizeMaximumOfArray.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 20)",N,class_definition,Solution,,150,fdcd206d-3199-4b6e-9944-5fec8f8c0392
"def minimizeArrayValue(self, nums: List[int]) -> int:
        
        def isValid(target):
            carry = 0
            
            for index in range(len(nums)-1,-1,-1):
                cur = nums[index]
                cur += carry
                carry = 0
                if(cur>target):
                    carry = cur - target
                    
            return carry == 0
        
        left = 0
        right = 10**9
        
        while left<right:
            mid = (left+right)//2
            
            # print(mid, isValid(mid))
            
            if(isValid(mid)):
                right = mid
            else:
                left = mid+1
                
        # print(left,right)
        return right",MinimizeMaximumOfArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\MinimizeMaximumOfArray.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(29, 20)",N,function_definition,minimizeArrayValue,,146,1a168b75-c105-4e50-8774-ec01928b209d
"def isValid(target):
            carry = 0
            
            for index in range(len(nums)-1,-1,-1):
                cur = nums[index]
                cur += carry
                carry = 0
                if(cur>target):
                    carry = cur - target
                    
            return carry == 0",MinimizeMaximumOfArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\MinimizeMaximumOfArray.py,module/class_definition-Solution/function_definition-minimizeArrayValue/,minimizeArrayValue,Previous sibling does not exist,left = 0,"(3, 8)","(13, 29)",N,function_definition,isValid,,60,8076c8c2-540b-4057-91d8-f0209cb0fff9
"class Solution:
    def minimumSeconds(self, nums: List[int]) -> int:
        
        N = len(nums)
        map = defaultdict(list)
        for index, num in enumerate(nums): map[num].append(index)
        
        def cov(indexs):
            if(len(indexs) <= 1): return 10 ** 10
            
            ans = 0
            for index in range(1, len(indexs)):
                ans = max(ans, indexs[index] - indexs[index-1])
            ans = max(ans, indexs[0] -  indexs[-1] + N)
            return ans
            
        
        
        val, minCov = -1, 10**10 + 1
        for num in map:
            re = cov(map[num])
            if(re < minCov):
                val = num
                minCov = re
        
        
        print(val)
        
        def can(s):
            nonlocal val
            counter = defaultdict(int)
            start = N - s
            end = start + 2*s
            # print(s, start, end)
            for index in range(start, end+1):  counter[nums[index%N]] += 1
                
            for index in range(N):
                # print(index, counter)
                if(counter[val] == 0): return False
                counter[nums[start%N]] -= 1
                start += 1
                end += 1
                counter[nums[end%N]] += 1
            
            return True
            
            
        low = 0
        high = len(nums)//2 + 1
        while(low<high):
            # print(low, high)
            mid = (low + high)//2
            if(can(mid)): high = mid
            else: low = mid + 1
        return low
",minimumSeconds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\minimumSeconds.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(55, 0)",N,module,module,,380,d27a6b1f-fc14-4ab7-bbe6-59f1deb5e156
"class Solution:
    def minimumSeconds(self, nums: List[int]) -> int:
        
        N = len(nums)
        map = defaultdict(list)
        for index, num in enumerate(nums): map[num].append(index)
        
        def cov(indexs):
            if(len(indexs) <= 1): return 10 ** 10
            
            ans = 0
            for index in range(1, len(indexs)):
                ans = max(ans, indexs[index] - indexs[index-1])
            ans = max(ans, indexs[0] -  indexs[-1] + N)
            return ans
            
        
        
        val, minCov = -1, 10**10 + 1
        for num in map:
            re = cov(map[num])
            if(re < minCov):
                val = num
                minCov = re
        
        
        print(val)
        
        def can(s):
            nonlocal val
            counter = defaultdict(int)
            start = N - s
            end = start + 2*s
            # print(s, start, end)
            for index in range(start, end+1):  counter[nums[index%N]] += 1
                
            for index in range(N):
                # print(index, counter)
                if(counter[val] == 0): return False
                counter[nums[start%N]] -= 1
                start += 1
                end += 1
                counter[nums[end%N]] += 1
            
            return True
            
            
        low = 0
        high = len(nums)//2 + 1
        while(low<high):
            # print(low, high)
            mid = (low + high)//2
            if(can(mid)): high = mid
            else: low = mid + 1
        return low",minimumSeconds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\minimumSeconds.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(54, 18)",N,class_definition,Solution,,379,dacf0630-5245-4e69-8f49-d05445903252
"def minimumSeconds(self, nums: List[int]) -> int:
        
        N = len(nums)
        map = defaultdict(list)
        for index, num in enumerate(nums): map[num].append(index)
        
        def cov(indexs):
            if(len(indexs) <= 1): return 10 ** 10
            
            ans = 0
            for index in range(1, len(indexs)):
                ans = max(ans, indexs[index] - indexs[index-1])
            ans = max(ans, indexs[0] -  indexs[-1] + N)
            return ans
            
        
        
        val, minCov = -1, 10**10 + 1
        for num in map:
            re = cov(map[num])
            if(re < minCov):
                val = num
                minCov = re
        
        
        print(val)
        
        def can(s):
            nonlocal val
            counter = defaultdict(int)
            start = N - s
            end = start + 2*s
            # print(s, start, end)
            for index in range(start, end+1):  counter[nums[index%N]] += 1
                
            for index in range(N):
                # print(index, counter)
                if(counter[val] == 0): return False
                counter[nums[start%N]] -= 1
                start += 1
                end += 1
                counter[nums[end%N]] += 1
            
            return True
            
            
        low = 0
        high = len(nums)//2 + 1
        while(low<high):
            # print(low, high)
            mid = (low + high)//2
            if(can(mid)): high = mid
            else: low = mid + 1
        return low",minimumSeconds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\minimumSeconds.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(54, 18)",N,function_definition,minimumSeconds,,375,12cf0dc7-c641-4baa-b434-364cf7b4cdf0
"def cov(indexs):
            if(len(indexs) <= 1): return 10 ** 10
            
            ans = 0
            for index in range(1, len(indexs)):
                ans = max(ans, indexs[index] - indexs[index-1])
            ans = max(ans, indexs[0] -  indexs[-1] + N)
            return ans",minimumSeconds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\minimumSeconds.py,module/class_definition-Solution/function_definition-minimumSeconds/,minimumSeconds,"for index, num in enumerate(nums): map[num].append(index)","val, minCov = -1, 10**10 + 1","(7, 8)","(14, 22)",N,function_definition,cov,,81,cb7bee31-ea6e-490e-8da9-6d6b9b6d9044
"def can(s):
            nonlocal val
            counter = defaultdict(int)
            start = N - s
            end = start + 2*s
            # print(s, start, end)
            for index in range(start, end+1):  counter[nums[index%N]] += 1
                
            for index in range(N):
                # print(index, counter)
                if(counter[val] == 0): return False
                counter[nums[start%N]] -= 1
                start += 1
                end += 1
                counter[nums[end%N]] += 1
            
            return True",minimumSeconds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\minimumSeconds.py,module/class_definition-Solution/function_definition-minimumSeconds/,minimumSeconds,print(val),low = 0,"(28, 8)","(44, 23)",N,function_definition,can,,128,fb3c16e6-8300-49b9-91be-7855965380b8
"class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:

        nums.sort()
        N = len(nums)
        start = 0
        end = N-1
        mod = 10**9 + 7
        dp = {}

        def binarySearch(start, end):
            s = start

            while(start<=end):
                mid = start + (end - start +1)//2
                if(nums[s] + nums[mid] <= target):
                    if(start == end): return start 
                    start = mid
                else: end = mid-1
            
            return -1

        def getpow(num):
            if(num in dp): return dp[num]
            dp[num] = 2**num
            return dp[num]

        count = 0
        while(start<N):
            end = binarySearch(start, end)
            if(end == -1): break
            count += getpow(end - start)
            start += 1

        return count%mod
",numSubseq.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\numSubseq.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(35, 0)",N,module,module,,214,b51ed989-1e64-4d42-bfc8-bff79043392d
"class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:

        nums.sort()
        N = len(nums)
        start = 0
        end = N-1
        mod = 10**9 + 7
        dp = {}

        def binarySearch(start, end):
            s = start

            while(start<=end):
                mid = start + (end - start +1)//2
                if(nums[s] + nums[mid] <= target):
                    if(start == end): return start 
                    start = mid
                else: end = mid-1
            
            return -1

        def getpow(num):
            if(num in dp): return dp[num]
            dp[num] = 2**num
            return dp[num]

        count = 0
        while(start<N):
            end = binarySearch(start, end)
            if(end == -1): break
            count += getpow(end - start)
            start += 1

        return count%mod",numSubseq.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\numSubseq.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(34, 24)",N,class_definition,Solution,,213,0ff3a202-875e-4086-889b-44b525580100
"def numSubseq(self, nums: List[int], target: int) -> int:

        nums.sort()
        N = len(nums)
        start = 0
        end = N-1
        mod = 10**9 + 7
        dp = {}

        def binarySearch(start, end):
            s = start

            while(start<=end):
                mid = start + (end - start +1)//2
                if(nums[s] + nums[mid] <= target):
                    if(start == end): return start 
                    start = mid
                else: end = mid-1
            
            return -1

        def getpow(num):
            if(num in dp): return dp[num]
            dp[num] = 2**num
            return dp[num]

        count = 0
        while(start<N):
            end = binarySearch(start, end)
            if(end == -1): break
            count += getpow(end - start)
            start += 1

        return count%mod",numSubseq.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\numSubseq.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(34, 24)",N,function_definition,numSubseq,,209,8fa77460-6185-440f-9adb-08162732cac0
"def binarySearch(start, end):
            s = start

            while(start<=end):
                mid = start + (end - start +1)//2
                if(nums[s] + nums[mid] <= target):
                    if(start == end): return start 
                    start = mid
                else: end = mid-1
            
            return -1",numSubseq.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\numSubseq.py,module/class_definition-Solution/function_definition-numSubseq/,numSubseq,dp = {},"def getpow(num):
            if(num in dp): return dp[num]
            dp[num] = 2**num
            return dp[num]","(10, 8)","(20, 21)",N,function_definition,binarySearch,,71,67cd8c86-b29c-4274-bae0-593a2d69a40e
"def getpow(num):
            if(num in dp): return dp[num]
            dp[num] = 2**num
            return dp[num]",numSubseq.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\numSubseq.py,module/class_definition-Solution/function_definition-numSubseq/,numSubseq,"def binarySearch(start, end):
            s = start

            while(start<=end):
                mid = start + (end - start +1)//2
                if(nums[s] + nums[mid] <= target):
                    if(start == end): return start 
                    start = mid
                else: end = mid-1
            
            return -1",count = 0,"(22, 8)","(25, 26)",N,function_definition,getpow,,30,0757cc52-95e4-4f07-b0bf-02c27dc6ef2b
"class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        if(nums[-1] == target): return True
        while(nums and nums[-1] == nums[0]): nums.pop()
        if(not nums): return False

        N = len(nums)
        '''
            [x x x x x+1 x+2 .. x+k x-3 x-2 x-1 x x x x]
        '''

        def good(index):
            if(nums[index] >=  nums[0]):
                if(nums[0] <= target <= nums[index]): return True
                return False
            else:
                if(target > nums[-1] or target < nums[index]): return True
                return False
            
            return False

        low = 0
        high = N-1

        while(low < high):
            mid = low + (high - low)//2
            if(nums[mid] == target): return True
            # print(low, high, mid)

            # good(mid) => true means target in [0...mid]
            if(good(mid)): high = mid
            else: low = mid+1
        
        return (0 <= low < N and nums[low] == target) 
",searchInRotatedArray2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\searchInRotatedArray2.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(34, 0)",N,module,module,,260,6b33b0a4-dbdf-4da6-b2b7-d961b7dd9686
"class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        if(nums[-1] == target): return True
        while(nums and nums[-1] == nums[0]): nums.pop()
        if(not nums): return False

        N = len(nums)
        '''
            [x x x x x+1 x+2 .. x+k x-3 x-2 x-1 x x x x]
        '''

        def good(index):
            if(nums[index] >=  nums[0]):
                if(nums[0] <= target <= nums[index]): return True
                return False
            else:
                if(target > nums[-1] or target < nums[index]): return True
                return False
            
            return False

        low = 0
        high = N-1

        while(low < high):
            mid = low + (high - low)//2
            if(nums[mid] == target): return True
            # print(low, high, mid)

            # good(mid) => true means target in [0...mid]
            if(good(mid)): high = mid
            else: low = mid+1
        
        return (0 <= low < N and nums[low] == target)",searchInRotatedArray2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\searchInRotatedArray2.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(33, 53)",N,class_definition,Solution,,259,ea5051cc-3488-405d-bd05-f9033c9e70f5
"def search(self, nums: List[int], target: int) -> bool:
        if(nums[-1] == target): return True
        while(nums and nums[-1] == nums[0]): nums.pop()
        if(not nums): return False

        N = len(nums)
        '''
            [x x x x x+1 x+2 .. x+k x-3 x-2 x-1 x x x x]
        '''

        def good(index):
            if(nums[index] >=  nums[0]):
                if(nums[0] <= target <= nums[index]): return True
                return False
            else:
                if(target > nums[-1] or target < nums[index]): return True
                return False
            
            return False

        low = 0
        high = N-1

        while(low < high):
            mid = low + (high - low)//2
            if(nums[mid] == target): return True
            # print(low, high, mid)

            # good(mid) => true means target in [0...mid]
            if(good(mid)): high = mid
            else: low = mid+1
        
        return (0 <= low < N and nums[low] == target)",searchInRotatedArray2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\searchInRotatedArray2.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(33, 53)",N,function_definition,search,,255,f826166e-cf03-45c1-91fb-15263cb45f2d
"def good(index):
            if(nums[index] >=  nums[0]):
                if(nums[0] <= target <= nums[index]): return True
                return False
            else:
                if(target > nums[-1] or target < nums[index]): return True
                return False
            
            return False",searchInRotatedArray2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\searchInRotatedArray2.py,module/class_definition-Solution/function_definition-search/,search,"'''
            [x x x x x+1 x+2 .. x+k x-3 x-2 x-1 x x x x]
        '''",low = 0,"(11, 8)","(19, 24)",N,function_definition,good,,61,c813458f-a9d7-47ed-9594-db219e1c6cec
"class TimeMap {

    HashMap<String, ArrayList<Node>> map;
    
    public TimeMap() {
        map = new HashMap<>();
    }
    
    public void set(String key, String value, int timestamp) {
        Node newNode = new Node(timestamp, value);
        if(this.map.containsKey(key)){
            map.get(key).add(newNode);
        } else {
            ArrayList<Node> arr = new ArrayList<>();
            arr.add(newNode);
            map.put(key, arr);
        }
    }
    
    public String get(String key, int timestamp) {
        if(!map.containsKey(key)) return """";
        
        ArrayList<Node> list = map.get(key);
        int low = 0;
        int high = list.size()-1;
        
        while(low<high){
            int mid = (low + high + 1)/2;
            if(timestamp == list.get(mid).timestamp) return list.get(mid).value;
            else if(timestamp < list.get(mid).timestamp) high = mid -1;
            else low = mid;
        }
        
        return (0<=low && low<list.size() && list.get(low).timestamp<=timestamp) ? list.get(low).value : """";
        
    }
}



class Node{
    int timestamp;
    String value;
    
    Node(int timestamp, String key){
        this.timestamp = timestamp;
        this.value = key;
    }
}

/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap obj = new TimeMap();
 * obj.set(key,value,timestamp);
 * String param_2 = obj.get(key,timestamp);
 */
",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(56, 0)",N,program,program,,323,0f7a97a3-3e16-4353-8827-47c10c0f0753
"class TimeMap {

    HashMap<String, ArrayList<Node>> map;
    
    public TimeMap() {
        map = new HashMap<>();
    }
    
    public void set(String key, String value, int timestamp) {
        Node newNode = new Node(timestamp, value);
        if(this.map.containsKey(key)){
            map.get(key).add(newNode);
        } else {
            ArrayList<Node> arr = new ArrayList<>();
            arr.add(newNode);
            map.put(key, arr);
        }
    }
    
    public String get(String key, int timestamp) {
        if(!map.containsKey(key)) return """";
        
        ArrayList<Node> list = map.get(key);
        int low = 0;
        int high = list.size()-1;
        
        while(low<high){
            int mid = (low + high + 1)/2;
            if(timestamp == list.get(mid).timestamp) return list.get(mid).value;
            else if(timestamp < list.get(mid).timestamp) high = mid -1;
            else low = mid;
        }
        
        return (0<=low && low<list.size() && list.get(low).timestamp<=timestamp) ? list.get(low).value : """";
        
    }
}",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/,program,Previous sibling does not exist,"class Node{
    int timestamp;
    String value;
    
    Node(int timestamp, String key){
        this.timestamp = timestamp;
        this.value = key;
    }
}","(0, 0)","(36, 1)",N,class_declaration,TimeMap,,244,e586bd60-ae25-4d46-ab9e-18e1b7cdbdce
"public TimeMap() {
        map = new HashMap<>();
    }",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/class_declaration-TimeMap/,TimeMap,"HashMap<String, ArrayList<Node>> map;","public void set(String key, String value, int timestamp) {
        Node newNode = new Node(timestamp, value);
        if(this.map.containsKey(key)){
            map.get(key).add(newNode);
        } else {
            ArrayList<Node> arr = new ArrayList<>();
            arr.add(newNode);
            map.put(key, arr);
        }
    }","(4, 4)","(6, 5)",N,constructor_declaration,TimeMap,,13,c9a3cdf1-46d8-4840-8c31-bb9ce4ffaee7
"public void set(String key, String value, int timestamp) {
        Node newNode = new Node(timestamp, value);
        if(this.map.containsKey(key)){
            map.get(key).add(newNode);
        } else {
            ArrayList<Node> arr = new ArrayList<>();
            arr.add(newNode);
            map.put(key, arr);
        }
    }",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/class_declaration-TimeMap/,TimeMap,"public TimeMap() {
        map = new HashMap<>();
    }","public String get(String key, int timestamp) {
        if(!map.containsKey(key)) return """";
        
        ArrayList<Node> list = map.get(key);
        int low = 0;
        int high = list.size()-1;
        
        while(low<high){
            int mid = (low + high + 1)/2;
            if(timestamp == list.get(mid).timestamp) return list.get(mid).value;
            else if(timestamp < list.get(mid).timestamp) high = mid -1;
            else low = mid;
        }
        
        return (0<=low && low<list.size() && list.get(low).timestamp<=timestamp) ? list.get(low).value : """";
        
    }","(8, 4)","(17, 5)",N,method_declaration,set,,69,e6458096-7843-44dc-b094-1280379856f4
"public String get(String key, int timestamp) {
        if(!map.containsKey(key)) return """";
        
        ArrayList<Node> list = map.get(key);
        int low = 0;
        int high = list.size()-1;
        
        while(low<high){
            int mid = (low + high + 1)/2;
            if(timestamp == list.get(mid).timestamp) return list.get(mid).value;
            else if(timestamp < list.get(mid).timestamp) high = mid -1;
            else low = mid;
        }
        
        return (0<=low && low<list.size() && list.get(low).timestamp<=timestamp) ? list.get(low).value : """";
        
    }",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/class_declaration-TimeMap/,TimeMap,"public void set(String key, String value, int timestamp) {
        Node newNode = new Node(timestamp, value);
        if(this.map.containsKey(key)){
            map.get(key).add(newNode);
        } else {
            ArrayList<Node> arr = new ArrayList<>();
            arr.add(newNode);
            map.put(key, arr);
        }
    }",Next sibling does not exist,"(19, 4)","(35, 5)",N,method_declaration,get,,142,6c35b87c-b42f-47e7-bd50-d408b78b3758
"class Node{
    int timestamp;
    String value;
    
    Node(int timestamp, String key){
        this.timestamp = timestamp;
        this.value = key;
    }
}",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/,program,"class TimeMap {

    HashMap<String, ArrayList<Node>> map;
    
    public TimeMap() {
        map = new HashMap<>();
    }
    
    public void set(String key, String value, int timestamp) {
        Node newNode = new Node(timestamp, value);
        if(this.map.containsKey(key)){
            map.get(key).add(newNode);
        } else {
            ArrayList<Node> arr = new ArrayList<>();
            arr.add(newNode);
            map.put(key, arr);
        }
    }
    
    public String get(String key, int timestamp) {
        if(!map.containsKey(key)) return """";
        
        ArrayList<Node> list = map.get(key);
        int low = 0;
        int high = list.size()-1;
        
        while(low<high){
            int mid = (low + high + 1)/2;
            if(timestamp == list.get(mid).timestamp) return list.get(mid).value;
            else if(timestamp < list.get(mid).timestamp) high = mid -1;
            else low = mid;
        }
        
        return (0<=low && low<list.size() && list.get(low).timestamp<=timestamp) ? list.get(low).value : """";
        
    }
}","/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap obj = new TimeMap();
 * obj.set(key,value,timestamp);
 * String param_2 = obj.get(key,timestamp);
 */","(40, 0)","(48, 1)",N,class_declaration,Node,,35,0f81b9dc-f208-49c7-acb2-4fc396db14e6
"Node(int timestamp, String key){
        this.timestamp = timestamp;
        this.value = key;
    }",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/class_declaration-Node/,Node,String value;,Next sibling does not exist,"(44, 4)","(47, 5)",N,constructor_declaration,Node,,21,4f7ad6b0-3d74-415a-99bb-d6d012dd56ff
"/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap obj = new TimeMap();
 * obj.set(key,value,timestamp);
 * String param_2 = obj.get(key,timestamp);
 */",TimeBasedMap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\binary_search\TimeBasedMap.java,program/,program,"class Node{
    int timestamp;
    String value;
    
    Node(int timestamp, String key){
        this.timestamp = timestamp;
        this.value = key;
    }
}",Next sibling does not exist,"(50, 0)","(55, 3)",N,block_comment,block_comment,,44,a2642ffc-46da-4327-b9b6-3ab9b984f432
"class Solution:
    def addBinary(self, a: str, b: str) -> str:
        
        def binToInt(s):
            num = 0
            for i in s:
                num = num << 1
                if( i == '1'): num = num | 1
            
            return num
        
        def intToBin(num):
            if(num == 0): return ""0""
            ans = """"
            while(num):
                ans += str(num%2)
                num = num//2
            return ans[::-1]


        a = binToInt(a)
        b = binToInt(b)
        # print(a, b)
        return intToBin(a+b)

",addBinary.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\addBinary.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 0)",N,module,module,,142,093f6320-d641-4c0d-be83-57c87ac9570f
"class Solution:
    def addBinary(self, a: str, b: str) -> str:
        
        def binToInt(s):
            num = 0
            for i in s:
                num = num << 1
                if( i == '1'): num = num | 1
            
            return num
        
        def intToBin(num):
            if(num == 0): return ""0""
            ans = """"
            while(num):
                ans += str(num%2)
                num = num//2
            return ans[::-1]


        a = binToInt(a)
        b = binToInt(b)
        # print(a, b)
        return intToBin(a+b)",addBinary.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\addBinary.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 28)",N,class_definition,Solution,,142,3e3232e4-00f7-4c31-bb44-3e330c7168c1
"def addBinary(self, a: str, b: str) -> str:
        
        def binToInt(s):
            num = 0
            for i in s:
                num = num << 1
                if( i == '1'): num = num | 1
            
            return num
        
        def intToBin(num):
            if(num == 0): return ""0""
            ans = """"
            while(num):
                ans += str(num%2)
                num = num//2
            return ans[::-1]


        a = binToInt(a)
        b = binToInt(b)
        # print(a, b)
        return intToBin(a+b)",addBinary.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\addBinary.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(23, 28)",N,function_definition,addBinary,,138,42a0b054-5ac2-4112-86cd-459a8ce512cc
"def binToInt(s):
            num = 0
            for i in s:
                num = num << 1
                if( i == '1'): num = num | 1
            
            return num",addBinary.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\addBinary.py,module/class_definition-Solution/function_definition-addBinary/,addBinary,Previous sibling does not exist,"def intToBin(num):
            if(num == 0): return ""0""
            ans = """"
            while(num):
                ans += str(num%2)
                num = num//2
            return ans[::-1]","(3, 8)","(9, 22)",N,function_definition,binToInt,,43,518b0eef-0f9a-4b58-ab8f-dd377e965d54
"def intToBin(num):
            if(num == 0): return ""0""
            ans = """"
            while(num):
                ans += str(num%2)
                num = num//2
            return ans[::-1]",addBinary.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\addBinary.py,module/class_definition-Solution/function_definition-addBinary/,addBinary,"def binToInt(s):
            num = 0
            for i in s:
                num = num << 1
                if( i == '1'): num = num | 1
            
            return num",a = binToInt(a),"(11, 8)","(17, 28)",N,function_definition,intToBin,,46,449a1c1f-50a6-4317-975a-66f4522d60a1
"class Solution:
    def beautifulSubarrays(self, nums: List[int]) -> int:
        
        running_xor = 0
        visited = defaultdict(int)
        visited[running_xor] = 1
        ans = 0
        
        for index, num in enumerate(nums):
            running_xor ^= num
            if(running_xor in visited): ans += visited[running_xor]
            visited[running_xor] += 1
        
        return ans
        
",beautifulSubarrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\beautifulSubarrays.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(15, 0)",N,module,module,,92,675d42a1-2fd6-452a-b935-e72dcbb4de69
"class Solution:
    def beautifulSubarrays(self, nums: List[int]) -> int:
        
        running_xor = 0
        visited = defaultdict(int)
        visited[running_xor] = 1
        ans = 0
        
        for index, num in enumerate(nums):
            running_xor ^= num
            if(running_xor in visited): ans += visited[running_xor]
            visited[running_xor] += 1
        
        return ans",beautifulSubarrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\beautifulSubarrays.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(13, 18)",N,class_definition,Solution,,91,3f4b55c7-5fd9-4b07-bef2-f7efa22a8d12
"def beautifulSubarrays(self, nums: List[int]) -> int:
        
        running_xor = 0
        visited = defaultdict(int)
        visited[running_xor] = 1
        ans = 0
        
        for index, num in enumerate(nums):
            running_xor ^= num
            if(running_xor in visited): ans += visited[running_xor]
            visited[running_xor] += 1
        
        return ans",beautifulSubarrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\beautifulSubarrays.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(13, 18)",N,function_definition,beautifulSubarrays,,87,2f524018-8d73-4ad9-9d88-bcd1b45216b2
"class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:

        dp = [0 for i in range(high+1)]
        dp[one] += 1
        dp[zero] += 1

        mod = 10**9 + 7

        for index in range(high+1):
            if(index-one>=0): dp[index] = (dp[index]%mod + dp[index-one]%mod)%mod
            if(index-zero>=0): dp[index] = (dp[index]%mod + dp[index-zero]%mod)%mod
        
        ans = 0
        for val in dp[low:high+1]: ans = (ans%mod + val%mod)%mod
        
        return ans

",countGoodStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\countGoodStrings.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 0)",N,module,module,,165,09fb0c8c-b190-47af-b33e-404560efe163
"class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:

        dp = [0 for i in range(high+1)]
        dp[one] += 1
        dp[zero] += 1

        mod = 10**9 + 7

        for index in range(high+1):
            if(index-one>=0): dp[index] = (dp[index]%mod + dp[index-one]%mod)%mod
            if(index-zero>=0): dp[index] = (dp[index]%mod + dp[index-zero]%mod)%mod
        
        ans = 0
        for val in dp[low:high+1]: ans = (ans%mod + val%mod)%mod
        
        return ans",countGoodStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\countGoodStrings.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 18)",N,class_definition,Solution,,164,211103e3-0d8a-487e-a445-92802d29e01a
"def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:

        dp = [0 for i in range(high+1)]
        dp[one] += 1
        dp[zero] += 1

        mod = 10**9 + 7

        for index in range(high+1):
            if(index-one>=0): dp[index] = (dp[index]%mod + dp[index-one]%mod)%mod
            if(index-zero>=0): dp[index] = (dp[index]%mod + dp[index-zero]%mod)%mod
        
        ans = 0
        for val in dp[low:high+1]: ans = (ans%mod + val%mod)%mod
        
        return ans",countGoodStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\countGoodStrings.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(16, 18)",N,function_definition,countGoodStrings,,160,d92d72f7-20f8-48bf-a6cb-d742a745164a
"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        for(int i=2;i<=(n-2);i++){
            // System.out.println(getBaseString(n,i));
            if(!isPalindrome(getBaseString(n,i))) return false;
        }
        
        return true;
    }
    
    public boolean isPalindrome(String s){
        int i=0;
        int j=s.length()-1;
        while(i<j){
            if(s.charAt(i)!=s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }
    
    public String getBaseString(int n, int base){
        StringBuffer ans = new StringBuffer();
        while(n>0){
            ans.append((n%base)+"""");
            n = n/base;
        }
        
        return ans.reverse().toString();
    }
}
",IsStrictlyPalindromic.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 0)",N,program,program,,174,a38ab538-96d7-43a9-bd39-9d16219e586c
"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        for(int i=2;i<=(n-2);i++){
            // System.out.println(getBaseString(n,i));
            if(!isPalindrome(getBaseString(n,i))) return false;
        }
        
        return true;
    }
    
    public boolean isPalindrome(String s){
        int i=0;
        int j=s.length()-1;
        while(i<j){
            if(s.charAt(i)!=s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }
    
    public String getBaseString(int n, int base){
        StringBuffer ans = new StringBuffer();
        while(n>0){
            ans.append((n%base)+"""");
            n = n/base;
        }
        
        return ans.reverse().toString();
    }
}",IsStrictlyPalindromic.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 1)",N,class_declaration,Solution,,174,52d707f0-03fb-4ed2-aa1d-972d470b1623
"public boolean isStrictlyPalindromic(int n) {
        for(int i=2;i<=(n-2);i++){
            // System.out.println(getBaseString(n,i));
            if(!isPalindrome(getBaseString(n,i))) return false;
        }
        
        return true;
    }",IsStrictlyPalindromic.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public boolean isPalindrome(String s){
        int i=0;
        int j=s.length()-1;
        while(i<j){
            if(s.charAt(i)!=s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }","(1, 4)","(8, 5)",N,method_declaration,isStrictlyPalindromic,,61,cedaf2f7-8911-4b71-b0c7-00c71b03faac
"public boolean isPalindrome(String s){
        int i=0;
        int j=s.length()-1;
        while(i<j){
            if(s.charAt(i)!=s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }",IsStrictlyPalindromic.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic.java,program/class_declaration-Solution/,Solution,"public boolean isStrictlyPalindromic(int n) {
        for(int i=2;i<=(n-2);i++){
            // System.out.println(getBaseString(n,i));
            if(!isPalindrome(getBaseString(n,i))) return false;
        }
        
        return true;
    }","public String getBaseString(int n, int base){
        StringBuffer ans = new StringBuffer();
        while(n>0){
            ans.append((n%base)+"""");
            n = n/base;
        }
        
        return ans.reverse().toString();
    }","(10, 4)","(19, 5)",N,method_declaration,isPalindrome,,53,d4b27dec-6884-4540-a867-0c31b6e19e6e
"public String getBaseString(int n, int base){
        StringBuffer ans = new StringBuffer();
        while(n>0){
            ans.append((n%base)+"""");
            n = n/base;
        }
        
        return ans.reverse().toString();
    }",IsStrictlyPalindromic.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic.java,program/class_declaration-Solution/,Solution,"public boolean isPalindrome(String s){
        int i=0;
        int j=s.length()-1;
        while(i<j){
            if(s.charAt(i)!=s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }",Next sibling does not exist,"(21, 4)","(29, 5)",N,method_declaration,getBaseString,,51,62c0c79f-7b7f-4985-b52e-a0b6cded0829
"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        return false;
    }
}
",IsStrictlyPalindromic2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic2.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(5, 0)",N,program,program,,24,f679d13b-729c-49a2-931d-e16a6a0c1315
"class Solution {
    public boolean isStrictlyPalindromic(int n) {
        return false;
    }
}",IsStrictlyPalindromic2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic2.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(4, 1)",N,class_declaration,Solution,,24,32825500-c9b0-4500-a8cf-4fa203eaf9c0
"public boolean isStrictlyPalindromic(int n) {
        return false;
    }",IsStrictlyPalindromic2.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\IsStrictlyPalindromic2.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(3, 5)",N,method_declaration,isStrictlyPalindromic,,19,dc5548eb-6f2c-4838-8bc0-292af7002109
"class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        ans = 0
        count = [0 for i in range(66)]
        
        for num in nums:            
            index = 0
            while(num):
                if(num%2 == 1): count[index] += 1
                index+=1
                num >>= 1
            
        
        def op(nums, k):
            
            bor = 0
            for num in nums: bor = bor | num
            best = [-1, -1]
            
            for idx, num in enumerate(nums):
                temp = num
                cur = bor

                index = 0
                while(temp):
                    if(temp%2 == 1 and count[index]==1):
                        cur = cur ^ (1<<index)
                    index += 1
                    temp >>= 1

                cur = cur | (num<<k)
                if(best[0]<cur): best = [cur, idx]
            
            return best
            # idx = best[-1]
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
                
            # nums[idx] *= 2
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
        val, index = op(nums, k)
        return val
        # ans = 0
        # for i in nums: ans |= i
        # return ans
                
# if you observer you will see the shift (<<1) is always done on the same index to get the maximum OR
",maximumOr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\maximumOr.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(60, 0)",N,module,module,,398,2dd673de-67fd-4099-a113-3c6f37513083
"class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        ans = 0
        count = [0 for i in range(66)]
        
        for num in nums:            
            index = 0
            while(num):
                if(num%2 == 1): count[index] += 1
                index+=1
                num >>= 1
            
        
        def op(nums, k):
            
            bor = 0
            for num in nums: bor = bor | num
            best = [-1, -1]
            
            for idx, num in enumerate(nums):
                temp = num
                cur = bor

                index = 0
                while(temp):
                    if(temp%2 == 1 and count[index]==1):
                        cur = cur ^ (1<<index)
                    index += 1
                    temp >>= 1

                cur = cur | (num<<k)
                if(best[0]<cur): best = [cur, idx]
            
            return best
            # idx = best[-1]
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
                
            # nums[idx] *= 2
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
        val, index = op(nums, k)
        return val
        # ans = 0
        # for i in nums: ans |= i
        # return ans",maximumOr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\maximumOr.py,module/,module,Previous sibling does not exist,# if you observer you will see the shift (<<1) is always done on the same index to get the maximum OR,"(0, 0)","(57, 20)",N,class_definition,Solution,,371,d4193eef-c10d-4f8a-8d54-28c55155e69c
"def maximumOr(self, nums: List[int], k: int) -> int:
        ans = 0
        count = [0 for i in range(66)]
        
        for num in nums:            
            index = 0
            while(num):
                if(num%2 == 1): count[index] += 1
                index+=1
                num >>= 1
            
        
        def op(nums, k):
            
            bor = 0
            for num in nums: bor = bor | num
            best = [-1, -1]
            
            for idx, num in enumerate(nums):
                temp = num
                cur = bor

                index = 0
                while(temp):
                    if(temp%2 == 1 and count[index]==1):
                        cur = cur ^ (1<<index)
                    index += 1
                    temp >>= 1

                cur = cur | (num<<k)
                if(best[0]<cur): best = [cur, idx]
            
            return best
            # idx = best[-1]
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
                
            # nums[idx] *= 2
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
        val, index = op(nums, k)
        return val
        # ans = 0
        # for i in nums: ans |= i
        # return ans",maximumOr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\maximumOr.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(57, 20)",N,function_definition,maximumOr,,367,82019e4a-6b90-4f39-94af-6c3c3d7be967
"def op(nums, k):
            
            bor = 0
            for num in nums: bor = bor | num
            best = [-1, -1]
            
            for idx, num in enumerate(nums):
                temp = num
                cur = bor

                index = 0
                while(temp):
                    if(temp%2 == 1 and count[index]==1):
                        cur = cur ^ (1<<index)
                    index += 1
                    temp >>= 1

                cur = cur | (num<<k)
                if(best[0]<cur): best = [cur, idx]
            
            return best
            # idx = best[-1]
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
                
            # nums[idx] *= 2
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1",maximumOr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\maximumOr.py,module/class_definition-Solution/function_definition-maximumOr/,maximumOr,"for num in nums:            
            index = 0
            while(num):
                if(num%2 == 1): count[index] += 1
                index+=1
                num >>= 1","val, index = op(nums, k)","(13, 8)","(51, 27)",N,function_definition,op,,248,0c3b3d94-eb11-42e5-80bf-3e981f04d1c1
# if you observer you will see the shift (<<1) is always done on the same index to get the maximum OR,maximumOr.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\maximumOr.py,module/,module,"class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        ans = 0
        count = [0 for i in range(66)]
        
        for num in nums:            
            index = 0
            while(num):
                if(num%2 == 1): count[index] += 1
                index+=1
                num >>= 1
            
        
        def op(nums, k):
            
            bor = 0
            for num in nums: bor = bor | num
            best = [-1, -1]
            
            for idx, num in enumerate(nums):
                temp = num
                cur = bor

                index = 0
                while(temp):
                    if(temp%2 == 1 and count[index]==1):
                        cur = cur ^ (1<<index)
                    index += 1
                    temp >>= 1

                cur = cur | (num<<k)
                if(best[0]<cur): best = [cur, idx]
            
            return best
            # idx = best[-1]
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
                
            # nums[idx] *= 2
            
            # num = nums[idx]
            # index = 0
            # while(num):
            #     if(num%2==1): count[index]-=1
            #     index+=1
            #     num >>= 1
                
        val, index = op(nums, k)
        return val
        # ans = 0
        # for i in nums: ans |= i
        # return ans",Next sibling does not exist,"(59, 0)","(59, 101)",N,comment,comment,,25,e8691088-05f0-4adb-8e70-73f8867796a5
"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        
        def getNumOfOnBits(num):
            ans = 0
            while(num):
                ans += 1
                num = num & (num-1)
            return ans
        
        ans = 0
        zero_one = ((a | b) ^ c) & c
        ans += getNumOfOnBits(zero_one)
        
        one_zero_a = ((a | b) ^ c) & a
        ans += getNumOfOnBits(one_zero_a)

        one_zero_b = ((a | b) ^ c) & b
        ans += getNumOfOnBits(one_zero_b)

        return ans
",minFlips.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\minFlips.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 0)",N,module,module,,159,e74dfde0-a8e2-4818-a8d9-482a0d5a241b
"class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        
        def getNumOfOnBits(num):
            ans = 0
            while(num):
                ans += 1
                num = num & (num-1)
            return ans
        
        ans = 0
        zero_one = ((a | b) ^ c) & c
        ans += getNumOfOnBits(zero_one)
        
        one_zero_a = ((a | b) ^ c) & a
        ans += getNumOfOnBits(one_zero_a)

        one_zero_b = ((a | b) ^ c) & b
        ans += getNumOfOnBits(one_zero_b)

        return ans",minFlips.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\minFlips.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(20, 18)",N,class_definition,Solution,,158,2b6a8090-2da3-4e88-bb5e-20bc9e8ce673
"def minFlips(self, a: int, b: int, c: int) -> int:
        
        def getNumOfOnBits(num):
            ans = 0
            while(num):
                ans += 1
                num = num & (num-1)
            return ans
        
        ans = 0
        zero_one = ((a | b) ^ c) & c
        ans += getNumOfOnBits(zero_one)
        
        one_zero_a = ((a | b) ^ c) & a
        ans += getNumOfOnBits(one_zero_a)

        one_zero_b = ((a | b) ^ c) & b
        ans += getNumOfOnBits(one_zero_b)

        return ans",minFlips.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\minFlips.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(20, 18)",N,function_definition,minFlips,,154,970f701a-53ad-4381-99fb-8a608854930a
"def getNumOfOnBits(num):
            ans = 0
            while(num):
                ans += 1
                num = num & (num-1)
            return ans",minFlips.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\minFlips.py,module/class_definition-Solution/function_definition-minFlips/,minFlips,Previous sibling does not exist,ans = 0,"(3, 8)","(8, 22)",N,function_definition,getNumOfOnBits,,37,2ab3b029-1e09-45c8-884b-9827c0432338
"class Solution {
    public int minimizeXor(int num1, int num2) {
        int n2 = getnumBits(num2);
        int n1 = getnumBits(num1);
        
        // System.out.println(n1 + "" "" + n2);
        
        if(n2 == n1) return num1;
        int ans = 0;
        
        while(n2>0 && n1>0){
            int len = (int) (Math.log(num1) / Math.log(2) + 1);
            num1 = num1 ^ (1<<len-1);
            ans = ans | (1<<len-1);
            n1--;
            n2--;
        }
        
        // System.out.println(ans);
        
            for(int i=0;i<=31 && n2>0;i++){
                int val = 1<<i;
                // System.out.println(i + "" "" +  val);
                if((val&ans)==0){
                    ans = ans ^ val;
                    n2--;
                }
            }
        
        return ans;
    }
    
    public int getnumBits(int num2){
        int n = 0;
        while(num2>0){
            num2 = num2 & (num2-1);
            n++;
        }
        return n;
    }
}
",MinimizeXor.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\MinimizeXor.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(41, 0)",N,program,program,,275,93bc23a6-3bba-4003-8c51-4e1260a1205d
"class Solution {
    public int minimizeXor(int num1, int num2) {
        int n2 = getnumBits(num2);
        int n1 = getnumBits(num1);
        
        // System.out.println(n1 + "" "" + n2);
        
        if(n2 == n1) return num1;
        int ans = 0;
        
        while(n2>0 && n1>0){
            int len = (int) (Math.log(num1) / Math.log(2) + 1);
            num1 = num1 ^ (1<<len-1);
            ans = ans | (1<<len-1);
            n1--;
            n2--;
        }
        
        // System.out.println(ans);
        
            for(int i=0;i<=31 && n2>0;i++){
                int val = 1<<i;
                // System.out.println(i + "" "" +  val);
                if((val&ans)==0){
                    ans = ans ^ val;
                    n2--;
                }
            }
        
        return ans;
    }
    
    public int getnumBits(int num2){
        int n = 0;
        while(num2>0){
            num2 = num2 & (num2-1);
            n++;
        }
        return n;
    }
}",MinimizeXor.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\MinimizeXor.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(40, 1)",N,class_declaration,Solution,,275,32b84f05-f1bd-4685-a10d-a39763c19cba
"public int minimizeXor(int num1, int num2) {
        int n2 = getnumBits(num2);
        int n1 = getnumBits(num1);
        
        // System.out.println(n1 + "" "" + n2);
        
        if(n2 == n1) return num1;
        int ans = 0;
        
        while(n2>0 && n1>0){
            int len = (int) (Math.log(num1) / Math.log(2) + 1);
            num1 = num1 ^ (1<<len-1);
            ans = ans | (1<<len-1);
            n1--;
            n2--;
        }
        
        // System.out.println(ans);
        
            for(int i=0;i<=31 && n2>0;i++){
                int val = 1<<i;
                // System.out.println(i + "" "" +  val);
                if((val&ans)==0){
                    ans = ans ^ val;
                    n2--;
                }
            }
        
        return ans;
    }",MinimizeXor.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\MinimizeXor.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public int getnumBits(int num2){
        int n = 0;
        while(num2>0){
            num2 = num2 & (num2-1);
            n++;
        }
        return n;
    }","(1, 4)","(30, 5)",N,method_declaration,minimizeXor,,221,9266b006-7086-450a-b67e-4436dbf899eb
"public int getnumBits(int num2){
        int n = 0;
        while(num2>0){
            num2 = num2 & (num2-1);
            n++;
        }
        return n;
    }",MinimizeXor.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\MinimizeXor.java,program/class_declaration-Solution/,Solution,"public int minimizeXor(int num1, int num2) {
        int n2 = getnumBits(num2);
        int n1 = getnumBits(num1);
        
        // System.out.println(n1 + "" "" + n2);
        
        if(n2 == n1) return num1;
        int ans = 0;
        
        while(n2>0 && n1>0){
            int len = (int) (Math.log(num1) / Math.log(2) + 1);
            num1 = num1 ^ (1<<len-1);
            ans = ans | (1<<len-1);
            n1--;
            n2--;
        }
        
        // System.out.println(ans);
        
            for(int i=0;i<=31 && n2>0;i++){
                int val = 1<<i;
                // System.out.println(i + "" "" +  val);
                if((val&ans)==0){
                    ans = ans ^ val;
                    n2--;
                }
            }
        
        return ans;
    }",Next sibling does not exist,"(32, 4)","(39, 5)",N,method_declaration,getnumBits,,47,ad4cdd95-06c6-49bc-b9ea-6726238e224f
"class Solution {
    public int[] smallestSubarrays(int[] nums) {
        
        int[] backward = new int[nums.length];
        int index = nums.length - 1;
        backward[index] = nums[index];
        index--;
        
        while(index>=0){
            backward[index] = backward[index+1] | nums[index];
            index--;
        }
                
        index = 0;
        int index2 = 0;
        int or = 0;
        
        int[] bitCount = new int[32];
        int[] ans = new int[nums.length];
        
        
        while(index2<nums.length && or!=backward[index]) {
            for(int i=0;i<=30;i++){
                if(((1<<i) & nums[index2]) != 0) bitCount[i]++;
            }
            or = or | nums[index2];
            index2++;
        }
        
        if(index2<index){
            index2 = index;
        }
        
        
        
        
        ans[index] = index2 - index;
        if(ans[index]==0) ans[index] = 1;
        index++;
        
        while(index<nums.length){
            
            if(index2<index){
                index2 = index;
            }
            
            int prev = index-1;
            
            for(int i=0;i<=30;i++){
                if(((1<<i) & nums[prev]) != 0) {
                    if(bitCount[i]==1){
                        or = or^(1<<i);
                    }
                    bitCount[i]--;
                }
            }            
            
            while(index2<nums.length && or!=backward[index]) {
                for(int i=0;i<=30;i++){
                    if(((1<<i) & nums[index2]) != 0) bitCount[i]++;
                }
                or = or | nums[index2];
                index2++;
            }
            
            
            ans[index] = index2 - index;
            if(ans[index]==0) ans[index] = 1;
            index++;
        }
                
        return ans;
    }
}
",SmallestSubarrays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\SmallestSubarrays.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(74, 0)",N,program,program,,418,9dbf6a15-79d1-4b0e-8321-2b6e8d6cbb66
"class Solution {
    public int[] smallestSubarrays(int[] nums) {
        
        int[] backward = new int[nums.length];
        int index = nums.length - 1;
        backward[index] = nums[index];
        index--;
        
        while(index>=0){
            backward[index] = backward[index+1] | nums[index];
            index--;
        }
                
        index = 0;
        int index2 = 0;
        int or = 0;
        
        int[] bitCount = new int[32];
        int[] ans = new int[nums.length];
        
        
        while(index2<nums.length && or!=backward[index]) {
            for(int i=0;i<=30;i++){
                if(((1<<i) & nums[index2]) != 0) bitCount[i]++;
            }
            or = or | nums[index2];
            index2++;
        }
        
        if(index2<index){
            index2 = index;
        }
        
        
        
        
        ans[index] = index2 - index;
        if(ans[index]==0) ans[index] = 1;
        index++;
        
        while(index<nums.length){
            
            if(index2<index){
                index2 = index;
            }
            
            int prev = index-1;
            
            for(int i=0;i<=30;i++){
                if(((1<<i) & nums[prev]) != 0) {
                    if(bitCount[i]==1){
                        or = or^(1<<i);
                    }
                    bitCount[i]--;
                }
            }            
            
            while(index2<nums.length && or!=backward[index]) {
                for(int i=0;i<=30;i++){
                    if(((1<<i) & nums[index2]) != 0) bitCount[i]++;
                }
                or = or | nums[index2];
                index2++;
            }
            
            
            ans[index] = index2 - index;
            if(ans[index]==0) ans[index] = 1;
            index++;
        }
                
        return ans;
    }
}",SmallestSubarrays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\SmallestSubarrays.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(73, 1)",N,class_declaration,Solution,,418,60f025ba-c9ec-48ab-9af0-a8134acc833a
"public int[] smallestSubarrays(int[] nums) {
        
        int[] backward = new int[nums.length];
        int index = nums.length - 1;
        backward[index] = nums[index];
        index--;
        
        while(index>=0){
            backward[index] = backward[index+1] | nums[index];
            index--;
        }
                
        index = 0;
        int index2 = 0;
        int or = 0;
        
        int[] bitCount = new int[32];
        int[] ans = new int[nums.length];
        
        
        while(index2<nums.length && or!=backward[index]) {
            for(int i=0;i<=30;i++){
                if(((1<<i) & nums[index2]) != 0) bitCount[i]++;
            }
            or = or | nums[index2];
            index2++;
        }
        
        if(index2<index){
            index2 = index;
        }
        
        
        
        
        ans[index] = index2 - index;
        if(ans[index]==0) ans[index] = 1;
        index++;
        
        while(index<nums.length){
            
            if(index2<index){
                index2 = index;
            }
            
            int prev = index-1;
            
            for(int i=0;i<=30;i++){
                if(((1<<i) & nums[prev]) != 0) {
                    if(bitCount[i]==1){
                        or = or^(1<<i);
                    }
                    bitCount[i]--;
                }
            }            
            
            while(index2<nums.length && or!=backward[index]) {
                for(int i=0;i<=30;i++){
                    if(((1<<i) & nums[index2]) != 0) bitCount[i]++;
                }
                or = or | nums[index2];
                index2++;
            }
            
            
            ans[index] = index2 - index;
            if(ans[index]==0) ans[index] = 1;
            index++;
        }
                
        return ans;
    }",SmallestSubarrays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\SmallestSubarrays.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(72, 5)",N,method_declaration,smallestSubarrays,,413,edd4f4ef-90cd-422d-a025-7e6ff7ddc51e
"class Solution {
    public int xorAllNums(int[] nums1, int[] nums2) {
        if(nums1.length%2==0 && nums2.length%2==0){
            return 0;
        } 
        
        if(nums1.length%2==1 && nums2.length%2==1){
            int ans = 0;
            for(int x: nums1) ans = ans ^ x;
            for(int x: nums2) ans = ans ^ x;
            return ans;
        }
        
        if(nums1.length%2==0 && nums2.length%2==1){
            int ans = 0;
            for(int x: nums1) ans = ans ^ x;
            return ans;
        }
        
        if(nums1.length%2==1 && nums2.length%2==0){
            int ans = 0;
            for(int x: nums2) ans = ans ^ x;
            return ans;
        }
        
        return 0;
    }
}
",XorAllNums.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\XorAllNums.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 0)",N,program,program,,207,4ff0c25b-c37d-41db-8e35-6d19d7b5c334
"class Solution {
    public int xorAllNums(int[] nums1, int[] nums2) {
        if(nums1.length%2==0 && nums2.length%2==0){
            return 0;
        } 
        
        if(nums1.length%2==1 && nums2.length%2==1){
            int ans = 0;
            for(int x: nums1) ans = ans ^ x;
            for(int x: nums2) ans = ans ^ x;
            return ans;
        }
        
        if(nums1.length%2==0 && nums2.length%2==1){
            int ans = 0;
            for(int x: nums1) ans = ans ^ x;
            return ans;
        }
        
        if(nums1.length%2==1 && nums2.length%2==0){
            int ans = 0;
            for(int x: nums2) ans = ans ^ x;
            return ans;
        }
        
        return 0;
    }
}",XorAllNums.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\XorAllNums.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(27, 1)",N,class_declaration,Solution,,207,4d5b2878-0bd1-4f5b-a5e4-ca68188d25f3
"public int xorAllNums(int[] nums1, int[] nums2) {
        if(nums1.length%2==0 && nums2.length%2==0){
            return 0;
        } 
        
        if(nums1.length%2==1 && nums2.length%2==1){
            int ans = 0;
            for(int x: nums1) ans = ans ^ x;
            for(int x: nums2) ans = ans ^ x;
            return ans;
        }
        
        if(nums1.length%2==0 && nums2.length%2==1){
            int ans = 0;
            for(int x: nums1) ans = ans ^ x;
            return ans;
        }
        
        if(nums1.length%2==1 && nums2.length%2==0){
            int ans = 0;
            for(int x: nums2) ans = ans ^ x;
            return ans;
        }
        
        return 0;
    }",XorAllNums.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\bitwise\XorAllNums.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(26, 5)",N,method_declaration,xorAllNums,,202,5bec4161-fb50-4c2a-b756-f17c76924f05
"class Solution:
    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:

        arr = [[score, age] for score,age in zip(scores, ages)]
        arr.sort() # O(nlogn)
        dp = [None for i in range(len(scores))]
        dp[0] = arr[0][0]

        # O(n^2)
        for index in range(len(scores)):
            curmax = arr[index][0]
            cur_age = arr[index][1]
            for j in range(index-1, -1,-1):
                if(cur_age >= arr[j][-1]): 
                    curmax = max(curmax, arr[index][0] + 
            dp[index] = curmax
        return max(dp)
",bestTeamScoreWithNoConflicts.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\bestTeamScoreWithNoConflicts.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 0)",Y,module,module,,161,90d71ee1-264d-4884-9a18-cadde14b0f22
"class Solution:
    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:

        arr = [[score, age] for score,age in zip(scores, ages)]
        arr.sort() # O(nlogn)
        dp = [None for i in range(len(scores))]
        dp[0] = arr[0][0]

        # O(n^2)
        for index in range(len(scores)):
            curmax = arr[index][0]
            cur_age = arr[index][1]
            for j in range(index-1, -1,-1):
                if(cur_age >= arr[j][-1]): 
                    curmax = max(curmax, arr[index][0] + 
            dp[index] = curmax
        return max(dp)",bestTeamScoreWithNoConflicts.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\bestTeamScoreWithNoConflicts.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 22)",Y,class_definition,Solution,,161,c7eeae3c-587d-4530-949e-095393d867c2
"def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:

        arr = [[score, age] for score,age in zip(scores, ages)]
        arr.sort() # O(nlogn)
        dp = [None for i in range(len(scores))]
        dp[0] = arr[0][0]

        # O(n^2)
        for index in range(len(scores)):
            curmax = arr[index][0]
            cur_age = arr[index][1]
            for j in range(index-1, -1,-1):
                if(cur_age >= arr[j][-1]): 
                    curmax = max(curmax, arr[index][0] + 
            dp[index] = curmax
        return max(dp)",bestTeamScoreWithNoConflicts.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\bestTeamScoreWithNoConflicts.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(16, 22)",Y,function_definition,bestTeamScore,,157,6cbb226e-e8cc-4cd8-915e-f685798d7385
"class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:

        N = len(grid)
        M = len(grid[0])
        dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        visited = [[False]*M for _ in range(N)]
        mod = 10**9 + 7

        @cache
        def dfs(row_index, col_index):
            ans = 1
            cur = grid[row_index][col_index]
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if(newx < 0  or newx >= N or newy < 0 or newy >= M): continue
                if(grid[newx][newy] <= cur): continue  
                ans = (ans%mod + dfs(newx, newy)%mod)%mod
            return ans
        
        ans = 0
        for row_index in range(N):
            for col_index in range(M):
                ans = (ans%mod + dfs(row_index, col_index)%mod)%mod
        
        return ans
",countIncreasingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\countIncreasingPaths.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(26, 0)",N,module,module,,246,98f4e1f0-20b2-42bd-b705-81f81ca1549b
"class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:

        N = len(grid)
        M = len(grid[0])
        dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        visited = [[False]*M for _ in range(N)]
        mod = 10**9 + 7

        @cache
        def dfs(row_index, col_index):
            ans = 1
            cur = grid[row_index][col_index]
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if(newx < 0  or newx >= N or newy < 0 or newy >= M): continue
                if(grid[newx][newy] <= cur): continue  
                ans = (ans%mod + dfs(newx, newy)%mod)%mod
            return ans
        
        ans = 0
        for row_index in range(N):
            for col_index in range(M):
                ans = (ans%mod + dfs(row_index, col_index)%mod)%mod
        
        return ans",countIncreasingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\countIncreasingPaths.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 18)",N,class_definition,Solution,,245,b9d3a4fd-6535-43ef-ab99-9263f2817d33
"def countPaths(self, grid: List[List[int]]) -> int:

        N = len(grid)
        M = len(grid[0])
        dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        visited = [[False]*M for _ in range(N)]
        mod = 10**9 + 7

        @cache
        def dfs(row_index, col_index):
            ans = 1
            cur = grid[row_index][col_index]
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if(newx < 0  or newx >= N or newy < 0 or newy >= M): continue
                if(grid[newx][newy] <= cur): continue  
                ans = (ans%mod + dfs(newx, newy)%mod)%mod
            return ans
        
        ans = 0
        for row_index in range(N):
            for col_index in range(M):
                ans = (ans%mod + dfs(row_index, col_index)%mod)%mod
        
        return ans",countIncreasingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\countIncreasingPaths.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(25, 18)",N,function_definition,countPaths,,241,9c1225b9-a0a3-4288-b82b-4a7eaf589762
"@cache
        def dfs(row_index, col_index):
            ans = 1
            cur = grid[row_index][col_index]
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if(newx < 0  or newx >= N or newy < 0 or newy >= M): continue
                if(grid[newx][newy] <= cur): continue  
                ans = (ans%mod + dfs(newx, newy)%mod)%mod
            return ans",countIncreasingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\countIncreasingPaths.py,module/class_definition-Solution/function_definition-countPaths/,countPaths,mod = 10**9 + 7,ans = 0,"(9, 8)","(18, 22)",N,function_definition,"def dfs(row_index, col_index):
            ans = 1
            cur = grid[row_index][col_index]
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if(newx < 0  or newx >= N or newy < 0 or newy >= M): continue
                if(grid[newx][newy] <= cur): continue  
                ans = (ans%mod + dfs(newx, newy)%mod)%mod
            return ans",,116,4d19b686-531f-4d8b-862f-3232803ace65
"class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        dp = [1 for i in range(len(prices))]
        
        index = 1
        
        while(index<len(prices)):
            if(prices[index] + 1 == prices[index-1]):
                dp[index] = dp[index-1] + 1
            index = index+1
        
        return sum(dp)
",DescentStock.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\DescentStock.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(12, 0)",N,module,module,,88,bd220b17-5aec-46fd-b4b9-6f48ceb9d21a
"class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        dp = [1 for i in range(len(prices))]
        
        index = 1
        
        while(index<len(prices)):
            if(prices[index] + 1 == prices[index-1]):
                dp[index] = dp[index-1] + 1
            index = index+1
        
        return sum(dp)",DescentStock.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\DescentStock.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(11, 22)",N,class_definition,Solution,,88,aa3f8e4e-499a-430a-bfed-f7b97987751d
"def getDescentPeriods(self, prices: List[int]) -> int:
        dp = [1 for i in range(len(prices))]
        
        index = 1
        
        while(index<len(prices)):
            if(prices[index] + 1 == prices[index-1]):
                dp[index] = dp[index-1] + 1
            index = index+1
        
        return sum(dp)",DescentStock.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\DescentStock.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(11, 22)",N,function_definition,getDescentPeriods,,84,fad1e5d0-9e66-43fa-b9c8-35bb07e33741
"class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        
        sLen = len(s)
        pLen = len(p)
        
        @cache
        def dfs(sIndex, pIndex):
            # print(sIndex, pIndex)
            if(sIndex == sLen and pIndex == pLen): return True
            if(not (pIndex < pLen and p[pIndex] == ""*"") and ((sIndex == sLen) ^ (pIndex == pLen))): return False
            
            
            if(p[pIndex] == ""?""): return dfs(sIndex+1, pIndex+1)
            if(p[pIndex] == ""*""): 
                for index in range(sIndex, sLen+1):
                    if(dfs(index, pIndex+1)): return True
                return False
            
            if(s[sIndex]!= p[pIndex]): return False
            return dfs(sIndex+1, pIndex+1)
        
        return dfs(0, 0)
",isMatch.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\isMatch.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,module,module,,211,018896da-da8d-4012-9211-7eb858a137be
"class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        
        sLen = len(s)
        pLen = len(p)
        
        @cache
        def dfs(sIndex, pIndex):
            # print(sIndex, pIndex)
            if(sIndex == sLen and pIndex == pLen): return True
            if(not (pIndex < pLen and p[pIndex] == ""*"") and ((sIndex == sLen) ^ (pIndex == pLen))): return False
            
            
            if(p[pIndex] == ""?""): return dfs(sIndex+1, pIndex+1)
            if(p[pIndex] == ""*""): 
                for index in range(sIndex, sLen+1):
                    if(dfs(index, pIndex+1)): return True
                return False
            
            if(s[sIndex]!= p[pIndex]): return False
            return dfs(sIndex+1, pIndex+1)
        
        return dfs(0, 0)",isMatch.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\isMatch.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 24)",N,class_definition,Solution,,211,63d6efbc-8093-4cd4-bcdd-67b1086c4edd
"def isMatch(self, s: str, p: str) -> bool:
        
        sLen = len(s)
        pLen = len(p)
        
        @cache
        def dfs(sIndex, pIndex):
            # print(sIndex, pIndex)
            if(sIndex == sLen and pIndex == pLen): return True
            if(not (pIndex < pLen and p[pIndex] == ""*"") and ((sIndex == sLen) ^ (pIndex == pLen))): return False
            
            
            if(p[pIndex] == ""?""): return dfs(sIndex+1, pIndex+1)
            if(p[pIndex] == ""*""): 
                for index in range(sIndex, sLen+1):
                    if(dfs(index, pIndex+1)): return True
                return False
            
            if(s[sIndex]!= p[pIndex]): return False
            return dfs(sIndex+1, pIndex+1)
        
        return dfs(0, 0)",isMatch.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\isMatch.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(22, 24)",N,function_definition,isMatch,,207,e6613ab0-175d-4b7d-a1d6-379f19d08f3f
"@cache
        def dfs(sIndex, pIndex):
            # print(sIndex, pIndex)
            if(sIndex == sLen and pIndex == pLen): return True
            if(not (pIndex < pLen and p[pIndex] == ""*"") and ((sIndex == sLen) ^ (pIndex == pLen))): return False
            
            
            if(p[pIndex] == ""?""): return dfs(sIndex+1, pIndex+1)
            if(p[pIndex] == ""*""): 
                for index in range(sIndex, sLen+1):
                    if(dfs(index, pIndex+1)): return True
                return False
            
            if(s[sIndex]!= p[pIndex]): return False
            return dfs(sIndex+1, pIndex+1)",isMatch.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\isMatch.py,module/class_definition-Solution/function_definition-isMatch/,isMatch,pLen = len(p),"return dfs(0, 0)","(6, 8)","(20, 42)",N,function_definition,"def dfs(sIndex, pIndex):
            # print(sIndex, pIndex)
            if(sIndex == sLen and pIndex == pLen): return True
            if(not (pIndex < pLen and p[pIndex] == ""*"") and ((sIndex == sLen) ^ (pIndex == pLen))): return False
            
            
            if(p[pIndex] == ""?""): return dfs(sIndex+1, pIndex+1)
            if(p[pIndex] == ""*""): 
                for index in range(sIndex, sLen+1):
                    if(dfs(index, pIndex+1)): return True
                return False
            
            if(s[sIndex]!= p[pIndex]): return False
            return dfs(sIndex+1, pIndex+1)",,164,cd84fa7d-3760-4275-9f31-752fa072ece8
"class Solution:
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        
        N = len(obstacles)
        dp = [1 for i in range(N)]
        best = []

        for index, height in enumerate(obstacles):
            low = 0
            high = len(best)-1

            while(low<=high):
                mid = low + (high - low)//2
                if(best[mid] <= height): low = mid+1
                else: high = mid-1
            
            if(low < len(best)): best[low] = height
            else: best.append(height)
            dp[index] = low+1
        
        return dp
",longestObstacleCourseAtEachPosition.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\longestObstacleCourseAtEachPosition.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 0)",N,module,module,,145,11ced16b-3368-4a6e-8047-a9ba79aadc04
"class Solution:
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        
        N = len(obstacles)
        dp = [1 for i in range(N)]
        best = []

        for index, height in enumerate(obstacles):
            low = 0
            high = len(best)-1

            while(low<=high):
                mid = low + (high - low)//2
                if(best[mid] <= height): low = mid+1
                else: high = mid-1
            
            if(low < len(best)): best[low] = height
            else: best.append(height)
            dp[index] = low+1
        
        return dp",longestObstacleCourseAtEachPosition.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\longestObstacleCourseAtEachPosition.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(20, 17)",N,class_definition,Solution,,144,ac6f4e80-681f-4a7a-9385-391395814ef6
"def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        
        N = len(obstacles)
        dp = [1 for i in range(N)]
        best = []

        for index, height in enumerate(obstacles):
            low = 0
            high = len(best)-1

            while(low<=high):
                mid = low + (high - low)//2
                if(best[mid] <= height): low = mid+1
                else: high = mid-1
            
            if(low < len(best)): best[low] = height
            else: best.append(height)
            dp[index] = low+1
        
        return dp",longestObstacleCourseAtEachPosition.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\longestObstacleCourseAtEachPosition.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(20, 17)",N,function_definition,longestObstacleCourseAtEachPosition,,140,d1f0ceaf-0353-49cb-a204-3c1865084993
"class Solution:
    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
      
        arr2.sort()
        N = len(arr1)
        M = len(arr2)
        INF = 10**20

        @cache
        def helper(index1, prev):
            if(index1 == N): return 0
            
            best = INF
            if(arr1[index1] > prev): best = min(best, helper(index1 + 1, arr1[index1]))
            idx = bisect.bisect_right(arr2,prev)
            if(idx < M): best = min(best, 1 + helper(index1 + 1, arr2[idx]))
            return best

        res = helper(0, -1)    
        if(res == INF): return -1
        return res
",makeArrayIncreasing.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\makeArrayIncreasing.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 0)",N,module,module,,176,3f2fb7ff-678a-4284-8ac9-237462cc5c1b
"class Solution:
    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
      
        arr2.sort()
        N = len(arr1)
        M = len(arr2)
        INF = 10**20

        @cache
        def helper(index1, prev):
            if(index1 == N): return 0
            
            best = INF
            if(arr1[index1] > prev): best = min(best, helper(index1 + 1, arr1[index1]))
            idx = bisect.bisect_right(arr2,prev)
            if(idx < M): best = min(best, 1 + helper(index1 + 1, arr2[idx]))
            return best

        res = helper(0, -1)    
        if(res == INF): return -1
        return res",makeArrayIncreasing.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\makeArrayIncreasing.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(20, 18)",N,class_definition,Solution,,175,e47871f8-1078-4373-9f08-4c801defdeff
"def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
      
        arr2.sort()
        N = len(arr1)
        M = len(arr2)
        INF = 10**20

        @cache
        def helper(index1, prev):
            if(index1 == N): return 0
            
            best = INF
            if(arr1[index1] > prev): best = min(best, helper(index1 + 1, arr1[index1]))
            idx = bisect.bisect_right(arr2,prev)
            if(idx < M): best = min(best, 1 + helper(index1 + 1, arr2[idx]))
            return best

        res = helper(0, -1)    
        if(res == INF): return -1
        return res",makeArrayIncreasing.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\makeArrayIncreasing.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(20, 18)",N,function_definition,makeArrayIncreasing,,171,996d18aa-cd89-497a-be55-4ce3908b085a
"@cache
        def helper(index1, prev):
            if(index1 == N): return 0
            
            best = INF
            if(arr1[index1] > prev): best = min(best, helper(index1 + 1, arr1[index1]))
            idx = bisect.bisect_right(arr2,prev)
            if(idx < M): best = min(best, 1 + helper(index1 + 1, arr2[idx]))
            return best",makeArrayIncreasing.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\makeArrayIncreasing.py,module/class_definition-Solution/function_definition-makeArrayIncreasing/,makeArrayIncreasing,INF = 10**20,"res = helper(0, -1)","(8, 8)","(16, 23)",N,function_definition,"def helper(index1, prev):
            if(index1 == N): return 0
            
            best = INF
            if(arr1[index1] > prev): best = min(best, helper(index1 + 1, arr1[index1]))
            idx = bisect.bisect_right(arr2,prev)
            if(idx < M): best = min(best, 1 + helper(index1 + 1, arr2[idx]))
            return best",,96,aab5bd0b-04c0-4c89-85a5-cac3814bf279
"class Solution {
    public int maximumScore(int[] nums, int[] multipliers) {
     
        int[] cur = new int[nums.length];
        int[] prev = new int[nums.length];

        for(int row = multipliers.length-1; row>=0; row--){
            for(int i=row; i<nums.length; i++){
                int mIndex = row - (i) + nums.length -1;
//                System.out.println(row + "" "" + i + "" "" + nums.length + "" "" + mIndex);

                if(0>mIndex || mIndex>=multipliers.length) continue;

                int left = (0<=(i-1) && (i-1)<nums.length) ? cur[i-1] : 0;
                int down = (0<=(i) && (i)<nums.length) ? prev[i] : 0;

//                int left = (0<=row && row<nums.length && 0<=(i-1) && (i-1)<nums.length) ? dp[row][i-1] : 0;
//                int down = (0<=row+1 && row+1<nums.length && 0<=(i) && (i)<nums.length) ? dp[row+1][i] : 0;


//                dp[row][i] = Math.max(
//                        nums[row] * multipliers[mIndex] + down,
//                        nums[i] * multipliers[mIndex] + left
//                );

                cur[i] = Math.max(
                        nums[row] * multipliers[mIndex] + down,
                        nums[i] * multipliers[mIndex] + left
                );
//                System.out.println(cur[i]);
            }
            prev = cur;
        }


//        for(int diff=diffBtwIndex; diff<nums.length; diff++ ){
//            for(int i=0; i+diff<nums.length; i++){
//
//
//                int mIndex = i - (i + diff) + nums.length -1;
//                System.out.println( i + "" "" + (i+diff) + "" "" + diff + "" "" + nums.length + "" "" + mIndex);
//                System.out.println(dp[i][i+diff]);
//
//                int left = (0<=i && i<nums.length && 0<=(i+diff-1) && (i+diff-1)<nums.length) ? dp[i][i+diff-1] : 0;
//                int down = (0<=i+1 && i+1<nums.length && 0<=(i+diff) && (i+diff)<nums.length) ? dp[i+1][i+diff] : 0;
//
//
//                dp[i][i+diff] = Math.max(
//                        nums[i]*multipliers[mIndex] + down,
//                        nums[i+diff]*multipliers[mIndex] + left
//                );
//            }
//        }

//        for(int[] x:dp) System.out.println(Arrays.toString(x));

//        System.out.println(Arrays.toString(cur) + "" "" + Arrays.toString(prev));

        return prev[nums.length-1];
    }
}
",MaximumScore.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MaximumScore.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(61, 0)",N,program,program,,661,53b8b11e-d6ac-4093-9838-febd63bc48eb
"class Solution {
    public int maximumScore(int[] nums, int[] multipliers) {
     
        int[] cur = new int[nums.length];
        int[] prev = new int[nums.length];

        for(int row = multipliers.length-1; row>=0; row--){
            for(int i=row; i<nums.length; i++){
                int mIndex = row - (i) + nums.length -1;
//                System.out.println(row + "" "" + i + "" "" + nums.length + "" "" + mIndex);

                if(0>mIndex || mIndex>=multipliers.length) continue;

                int left = (0<=(i-1) && (i-1)<nums.length) ? cur[i-1] : 0;
                int down = (0<=(i) && (i)<nums.length) ? prev[i] : 0;

//                int left = (0<=row && row<nums.length && 0<=(i-1) && (i-1)<nums.length) ? dp[row][i-1] : 0;
//                int down = (0<=row+1 && row+1<nums.length && 0<=(i) && (i)<nums.length) ? dp[row+1][i] : 0;


//                dp[row][i] = Math.max(
//                        nums[row] * multipliers[mIndex] + down,
//                        nums[i] * multipliers[mIndex] + left
//                );

                cur[i] = Math.max(
                        nums[row] * multipliers[mIndex] + down,
                        nums[i] * multipliers[mIndex] + left
                );
//                System.out.println(cur[i]);
            }
            prev = cur;
        }


//        for(int diff=diffBtwIndex; diff<nums.length; diff++ ){
//            for(int i=0; i+diff<nums.length; i++){
//
//
//                int mIndex = i - (i + diff) + nums.length -1;
//                System.out.println( i + "" "" + (i+diff) + "" "" + diff + "" "" + nums.length + "" "" + mIndex);
//                System.out.println(dp[i][i+diff]);
//
//                int left = (0<=i && i<nums.length && 0<=(i+diff-1) && (i+diff-1)<nums.length) ? dp[i][i+diff-1] : 0;
//                int down = (0<=i+1 && i+1<nums.length && 0<=(i+diff) && (i+diff)<nums.length) ? dp[i+1][i+diff] : 0;
//
//
//                dp[i][i+diff] = Math.max(
//                        nums[i]*multipliers[mIndex] + down,
//                        nums[i+diff]*multipliers[mIndex] + left
//                );
//            }
//        }

//        for(int[] x:dp) System.out.println(Arrays.toString(x));

//        System.out.println(Arrays.toString(cur) + "" "" + Arrays.toString(prev));

        return prev[nums.length-1];
    }
}",MaximumScore.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MaximumScore.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(60, 1)",N,class_declaration,Solution,,661,f5835e1f-f13d-4a44-9611-148724f7ea7d
"public int maximumScore(int[] nums, int[] multipliers) {
     
        int[] cur = new int[nums.length];
        int[] prev = new int[nums.length];

        for(int row = multipliers.length-1; row>=0; row--){
            for(int i=row; i<nums.length; i++){
                int mIndex = row - (i) + nums.length -1;
//                System.out.println(row + "" "" + i + "" "" + nums.length + "" "" + mIndex);

                if(0>mIndex || mIndex>=multipliers.length) continue;

                int left = (0<=(i-1) && (i-1)<nums.length) ? cur[i-1] : 0;
                int down = (0<=(i) && (i)<nums.length) ? prev[i] : 0;

//                int left = (0<=row && row<nums.length && 0<=(i-1) && (i-1)<nums.length) ? dp[row][i-1] : 0;
//                int down = (0<=row+1 && row+1<nums.length && 0<=(i) && (i)<nums.length) ? dp[row+1][i] : 0;


//                dp[row][i] = Math.max(
//                        nums[row] * multipliers[mIndex] + down,
//                        nums[i] * multipliers[mIndex] + left
//                );

                cur[i] = Math.max(
                        nums[row] * multipliers[mIndex] + down,
                        nums[i] * multipliers[mIndex] + left
                );
//                System.out.println(cur[i]);
            }
            prev = cur;
        }


//        for(int diff=diffBtwIndex; diff<nums.length; diff++ ){
//            for(int i=0; i+diff<nums.length; i++){
//
//
//                int mIndex = i - (i + diff) + nums.length -1;
//                System.out.println( i + "" "" + (i+diff) + "" "" + diff + "" "" + nums.length + "" "" + mIndex);
//                System.out.println(dp[i][i+diff]);
//
//                int left = (0<=i && i<nums.length && 0<=(i+diff-1) && (i+diff-1)<nums.length) ? dp[i][i+diff-1] : 0;
//                int down = (0<=i+1 && i+1<nums.length && 0<=(i+diff) && (i+diff)<nums.length) ? dp[i+1][i+diff] : 0;
//
//
//                dp[i][i+diff] = Math.max(
//                        nums[i]*multipliers[mIndex] + down,
//                        nums[i+diff]*multipliers[mIndex] + left
//                );
//            }
//        }

//        for(int[] x:dp) System.out.println(Arrays.toString(x));

//        System.out.println(Arrays.toString(cur) + "" "" + Arrays.toString(prev));

        return prev[nums.length-1];
    }",MaximumScore.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MaximumScore.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"int[] cur = new int[nums.length];
int[] prev = new int[nums.length];
for(int row = multipliers.length-1; row>=0; row--){
            for(int i=row; i<nums.length; i++){
                int mIndex = row - (i) + nums.length -1;
//                System.out.println(row + "" "" + i + "" "" + nums.length + "" "" + mIndex);

                if(0>mIndex || mIndex>=multipliers.length) continue;

                int left = (0<=(i-1) && (i-1)<nums.length) ? cur[i-1] : 0;
                int down = (0<=(i) && (i)<nums.length) ? prev[i] : 0;

//                int left = (0<=row && row<nums.length && 0<=(i-1) && (i-1)<nums.length) ? dp[row][i-1] : 0;
//                int down = (0<=row+1 && row+1<nums.length && 0<=(i) && (i)<nums.length) ? dp[row+1][i] : 0;


//                dp[row][i] = Math.max(
//                        nums[row] * multipliers[mIndex] + down,
//                        nums[i] * multipliers[mIndex] + left
//                );

                cur[i] = Math.max(
                        nums[row] * multipliers[mIndex] + down,
                        nums[i] * multipliers[mIndex] + left
                );
//                System.out.println(cur[i]);
            }
            prev = cur;
        }
//        for(int diff=diffBtwIndex; diff<nums.length; diff++ ){
//            for(int i=0; i+diff<nums.length; i++){
//
//
//                int mIndex = i - (i + diff) + nums.length -1;
//                System.out.println( i + "" "" + (i+diff) + "" "" + diff + "" "" + nums.length + "" "" + mIndex);
//                System.out.println(dp[i][i+diff]);
//
//                int left = (0<=i && i<nums.length && 0<=(i+diff-1) && (i+diff-1)<nums.length) ? dp[i][i+diff-1] : 0;","(1, 4)","(59, 5)",N,method_declaration,maximumScore,,656,4ca452e3-2dd3-4c4d-83a5-886c0747d4be
"int[] cur = new int[nums.length];
int[] prev = new int[nums.length];
for(int row = multipliers.length-1; row>=0; row--){
            for(int i=row; i<nums.length; i++){
                int mIndex = row - (i) + nums.length -1;
//                System.out.println(row + "" "" + i + "" "" + nums.length + "" "" + mIndex);

                if(0>mIndex || mIndex>=multipliers.length) continue;

                int left = (0<=(i-1) && (i-1)<nums.length) ? cur[i-1] : 0;
                int down = (0<=(i) && (i)<nums.length) ? prev[i] : 0;

//                int left = (0<=row && row<nums.length && 0<=(i-1) && (i-1)<nums.length) ? dp[row][i-1] : 0;
//                int down = (0<=row+1 && row+1<nums.length && 0<=(i) && (i)<nums.length) ? dp[row+1][i] : 0;


//                dp[row][i] = Math.max(
//                        nums[row] * multipliers[mIndex] + down,
//                        nums[i] * multipliers[mIndex] + left
//                );

                cur[i] = Math.max(
                        nums[row] * multipliers[mIndex] + down,
                        nums[i] * multipliers[mIndex] + left
                );
//                System.out.println(cur[i]);
            }
            prev = cur;
        }
//        for(int diff=diffBtwIndex; diff<nums.length; diff++ ){
//            for(int i=0; i+diff<nums.length; i++){
//
//
//                int mIndex = i - (i + diff) + nums.length -1;
//                System.out.println( i + "" "" + (i+diff) + "" "" + diff + "" "" + nums.length + "" "" + mIndex);
//                System.out.println(dp[i][i+diff]);
//
//                int left = (0<=i && i<nums.length && 0<=(i+diff-1) && (i+diff-1)<nums.length) ? dp[i][i+diff-1] : 0;",MaximumScore.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MaximumScore.java,program/class_declaration-Solution/method_declaration-maximumScore/,maximumScore,Previous sibling does not exist,"//                int down = (0<=i+1 && i+1<nums.length && 0<=(i+diff) && (i+diff)<nums.length) ? dp[i+1][i+diff] : 0;
//
//
//                dp[i][i+diff] = Math.max(
//                        nums[i]*multipliers[mIndex] + down,
//                        nums[i+diff]*multipliers[mIndex] + left
//                );
//            }
//        }
//        for(int[] x:dp) System.out.println(Arrays.toString(x));
//        System.out.println(Arrays.toString(cur) + "" "" + Arrays.toString(prev));
return prev[nums.length-1];
}","(3, 8)","(43, 118)",N,"local_variable_declaration,local_variable_declaration,for_statement,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment",local_variable_declaration,,493,05cb7f76-eb56-4826-aca6-5022a644c8ac
"//                int down = (0<=i+1 && i+1<nums.length && 0<=(i+diff) && (i+diff)<nums.length) ? dp[i+1][i+diff] : 0;
//
//
//                dp[i][i+diff] = Math.max(
//                        nums[i]*multipliers[mIndex] + down,
//                        nums[i+diff]*multipliers[mIndex] + left
//                );
//            }
//        }
//        for(int[] x:dp) System.out.println(Arrays.toString(x));
//        System.out.println(Arrays.toString(cur) + "" "" + Arrays.toString(prev));
return prev[nums.length-1];
}",MaximumScore.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MaximumScore.java,program/class_declaration-Solution/method_declaration-maximumScore/,maximumScore,//                int left = (0<=i && i<nums.length && 0<=(i+diff-1) && (i+diff-1)<nums.length) ? dp[i][i+diff-1] : 0;,Next sibling does not exist,"(44, 0)","(59, 5)",N,"line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,line_comment,return_statement,}",line_comment,,142,5e845de4-32dd-4148-903f-b2fe881f5c67
"class Solution:
    def maxScore(self, nums: List[int]) -> int:

        N = len(nums)
        s = set([index for index in range(N)])

        def gcd(a, b):
            if(a<b): return gcd(b, a)
            return a if(b==0) else gcd(b, a%b)

        @cache
        def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans
        
        visited = 0        
        ans = helper(visited, 1)
        return ans

# [1,2]
# [3,4,6,8]
# [1,2,3,4,5,6]
# [111111, 222222, 333333, 444444, 555555 ,66666]
# [773274,313112,131789,222437,918065,49745,321270,74163,900218,80160,325440,961730]
# [7,3,1,2,9,4,3,7,9,8,3,9]
",maxScore_gcd.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxScore_gcd.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(35, 0)",N,module,module,,342,342222ea-2a22-4615-886c-58fa221e9ed7
"class Solution:
    def maxScore(self, nums: List[int]) -> int:

        N = len(nums)
        s = set([index for index in range(N)])

        def gcd(a, b):
            if(a<b): return gcd(b, a)
            return a if(b==0) else gcd(b, a%b)

        @cache
        def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans
        
        visited = 0        
        ans = helper(visited, 1)
        return ans",maxScore_gcd.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxScore_gcd.py,module/,module,Previous sibling does not exist,"# [1,2]","(0, 0)","(27, 18)",N,class_definition,Solution,,223,0944575a-99c7-47c9-bd89-dd5eef1e556c
"def maxScore(self, nums: List[int]) -> int:

        N = len(nums)
        s = set([index for index in range(N)])

        def gcd(a, b):
            if(a<b): return gcd(b, a)
            return a if(b==0) else gcd(b, a%b)

        @cache
        def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans
        
        visited = 0        
        ans = helper(visited, 1)
        return ans",maxScore_gcd.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxScore_gcd.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(27, 18)",N,function_definition,maxScore,,219,7e45946d-72b6-4f17-b206-8d187a08dd9f
"def gcd(a, b):
            if(a<b): return gcd(b, a)
            return a if(b==0) else gcd(b, a%b)",maxScore_gcd.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxScore_gcd.py,module/class_definition-Solution/function_definition-maxScore/,maxScore,s = set([index for index in range(N)]),"@cache
        def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans","(6, 8)","(8, 46)",N,function_definition,gcd,,33,db09f6a2-6dbc-4d69-82c6-194135dca7b4
"@cache
        def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans",maxScore_gcd.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxScore_gcd.py,module/class_definition-Solution/function_definition-maxScore/,maxScore,"def gcd(a, b):
            if(a<b): return gcd(b, a)
            return a if(b==0) else gcd(b, a%b)","# [1,2]
# [3,4,6,8]
# [1,2,3,4,5,6]
# [111111, 222222, 333333, 444444, 555555 ,66666]
# [773274,313112,131789,222437,918065,49745,321270,74163,900218,80160,325440,961730]
# [7,3,1,2,9,4,3,7,9,8,3,9]","(10, 8)","(23, 22)",N,function_definition,"def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans",,133,1042b8f2-a8ed-4fbd-87ec-0e46a5d829cb
"# [1,2]
# [3,4,6,8]
# [1,2,3,4,5,6]
# [111111, 222222, 333333, 444444, 555555 ,66666]
# [773274,313112,131789,222437,918065,49745,321270,74163,900218,80160,325440,961730]
# [7,3,1,2,9,4,3,7,9,8,3,9]",maxScore_gcd.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxScore_gcd.py,module/,module,"class Solution:
    def maxScore(self, nums: List[int]) -> int:

        N = len(nums)
        s = set([index for index in range(N)])

        def gcd(a, b):
            if(a<b): return gcd(b, a)
            return a if(b==0) else gcd(b, a%b)

        @cache
        def helper(visited, i):
            ans = 0

            for index1 in range(len(nums)):
                for index2 in range(index1+1, len(nums)):
                    if( ((visited>>index1)%2 == 1) or ((visited>>index2)%2==1) ): continue
                    
                    visited |= 1<<index1
                    visited |= 1<<index2
                    ans = max(ans, i*gcd(nums[index1], nums[index2]) + helper(visited, i+1))
                    visited ^= 1<<index1
                    visited ^= 1<<index2
            return ans
        
        visited = 0        
        ans = helper(visited, 1)
        return ans",Next sibling does not exist,"(29, 0)","(34, 27)",N,"comment,comment,comment,comment,comment,comment",comment,,118,1f4a6553-b331-41ff-a694-49284b0b6cd9
"class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        
        @cache
        def helper(index1, index2):
            if(index1 >= len(nums1) or index2>=len(nums2)): return 0

            if(nums1[index1] == nums2[index2]): return 1+helper(index1+1, index2+1)
            
            ans = -1 * 10**10
            ans = max(ans, helper(index1+1, index2))
            ans = max(ans, helper(index1, index2+1))
            return ans

        return helper(0, 0)

    
    

# class Solution:
#     def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:

#         map1 = defaultdict(list)
#         for index, val in enumerate(nums1): map1[val].append(index)
        
#         indexMapper = defaultdict(list)
#         for index, val in enumerate(nums2): 
#             if(val not in map1): continue
#             for i in map1[val]: indexMapper[i].append(index)

#         @cache
#         def helper(index1, index2):
#             if(index1 >= len(nums1) or index2>=len(nums2)): return 0
#             ans = -1 * 10**10
#             ans = max(ans, helper(index1+1, index2))
#             for index in indexMapper[index1]:
#                 if(index<index2): continue
#                 ans = max(ans, 1+helper(index1+1, index+1))
            
#             return ans

#         return helper(0, 0)
",maxUncrossedLines.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxUncrossedLines.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(42, 0)",N,module,module,,371,28db5f78-675d-4086-a3f3-185b394ec245
"class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        
        @cache
        def helper(index1, index2):
            if(index1 >= len(nums1) or index2>=len(nums2)): return 0

            if(nums1[index1] == nums2[index2]): return 1+helper(index1+1, index2+1)
            
            ans = -1 * 10**10
            ans = max(ans, helper(index1+1, index2))
            ans = max(ans, helper(index1, index2+1))
            return ans

        return helper(0, 0)",maxUncrossedLines.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxUncrossedLines.py,module/,module,Previous sibling does not exist,# class Solution:,"(0, 0)","(14, 27)",N,class_definition,Solution,,145,0eb79ea2-0b6c-4a20-8f17-8defff85d2d6
"def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        
        @cache
        def helper(index1, index2):
            if(index1 >= len(nums1) or index2>=len(nums2)): return 0

            if(nums1[index1] == nums2[index2]): return 1+helper(index1+1, index2+1)
            
            ans = -1 * 10**10
            ans = max(ans, helper(index1+1, index2))
            ans = max(ans, helper(index1, index2+1))
            return ans

        return helper(0, 0)",maxUncrossedLines.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxUncrossedLines.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(14, 27)",N,function_definition,maxUncrossedLines,,141,9e76c0bc-636d-4c89-8243-2e07154d31c6
"@cache
        def helper(index1, index2):
            if(index1 >= len(nums1) or index2>=len(nums2)): return 0

            if(nums1[index1] == nums2[index2]): return 1+helper(index1+1, index2+1)
            
            ans = -1 * 10**10
            ans = max(ans, helper(index1+1, index2))
            ans = max(ans, helper(index1, index2+1))
            return ans",maxUncrossedLines.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxUncrossedLines.py,module/class_definition-Solution/function_definition-maxUncrossedLines/,maxUncrossedLines,Previous sibling does not exist,"# class Solution:
#     def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
#         map1 = defaultdict(list)
#         for index, val in enumerate(nums1): map1[val].append(index)
#         indexMapper = defaultdict(list)
#         for index, val in enumerate(nums2): 
#             if(val not in map1): continue
#             for i in map1[val]: indexMapper[i].append(index)
#         @cache
#         def helper(index1, index2):
#             if(index1 >= len(nums1) or index2>=len(nums2)): return 0
#             ans = -1 * 10**10
#             ans = max(ans, helper(index1+1, index2))
#             for index in indexMapper[index1]:
#                 if(index<index2): continue
#                 ans = max(ans, 1+helper(index1+1, index+1))
#             return ans
#         return helper(0, 0)","(3, 8)","(12, 22)",N,function_definition,"def helper(index1, index2):
            if(index1 >= len(nums1) or index2>=len(nums2)): return 0

            if(nums1[index1] == nums2[index2]): return 1+helper(index1+1, index2+1)
            
            ans = -1 * 10**10
            ans = max(ans, helper(index1+1, index2))
            ans = max(ans, helper(index1, index2+1))
            return ans",,106,e076489f-0cac-432e-b0d3-ce5013f79019
"# class Solution:
#     def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
#         map1 = defaultdict(list)
#         for index, val in enumerate(nums1): map1[val].append(index)
#         indexMapper = defaultdict(list)
#         for index, val in enumerate(nums2): 
#             if(val not in map1): continue
#             for i in map1[val]: indexMapper[i].append(index)
#         @cache
#         def helper(index1, index2):
#             if(index1 >= len(nums1) or index2>=len(nums2)): return 0
#             ans = -1 * 10**10
#             ans = max(ans, helper(index1+1, index2))
#             for index in indexMapper[index1]:
#                 if(index<index2): continue
#                 ans = max(ans, 1+helper(index1+1, index+1))
#             return ans
#         return helper(0, 0)",maxUncrossedLines.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\maxUncrossedLines.py,module/,module,"class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        
        @cache
        def helper(index1, index2):
            if(index1 >= len(nums1) or index2>=len(nums2)): return 0

            if(nums1[index1] == nums2[index2]): return 1+helper(index1+1, index2+1)
            
            ans = -1 * 10**10
            ans = max(ans, helper(index1+1, index2))
            ans = max(ans, helper(index1, index2+1))
            return ans

        return helper(0, 0)",Next sibling does not exist,"(19, 0)","(41, 29)",N,"comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment",comment,,216,c5f3f4eb-6c7c-4f7e-958d-c7f3127425c4
"class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:

        N = len(days)
        days.sort()

        @cache
        def helper(index):
            if(index >= N): return 0
            curday = days[index]

            ans = 10**10
            ans = min(ans, helper(index+1)+costs[0])
            
            while(index<N and days[index]-curday<7): index+=1 
            ans = min(ans, helper(index) + costs[1])
            
            while(index<N and days[index]-curday<30): index+=1 
            ans = min(ans, helper(index) + costs[2])
            return ans

        return helper(0)
",mincostTickets.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\mincostTickets.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 0)",N,module,module,,157,9c103c9f-6845-4ee8-94aa-5f5b29ca6b57
"class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:

        N = len(days)
        days.sort()

        @cache
        def helper(index):
            if(index >= N): return 0
            curday = days[index]

            ans = 10**10
            ans = min(ans, helper(index+1)+costs[0])
            
            while(index<N and days[index]-curday<7): index+=1 
            ans = min(ans, helper(index) + costs[1])
            
            while(index<N and days[index]-curday<30): index+=1 
            ans = min(ans, helper(index) + costs[2])
            return ans

        return helper(0)",mincostTickets.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\mincostTickets.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 24)",N,class_definition,Solution,,157,96abc642-686f-4dc7-a3c8-8e6c2d6c0f5b
"def mincostTickets(self, days: List[int], costs: List[int]) -> int:

        N = len(days)
        days.sort()

        @cache
        def helper(index):
            if(index >= N): return 0
            curday = days[index]

            ans = 10**10
            ans = min(ans, helper(index+1)+costs[0])
            
            while(index<N and days[index]-curday<7): index+=1 
            ans = min(ans, helper(index) + costs[1])
            
            while(index<N and days[index]-curday<30): index+=1 
            ans = min(ans, helper(index) + costs[2])
            return ans

        return helper(0)",mincostTickets.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\mincostTickets.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(21, 24)",N,function_definition,mincostTickets,,153,528b1d8d-afff-4242-ab8a-bf6cd60e5ad2
"@cache
        def helper(index):
            if(index >= N): return 0
            curday = days[index]

            ans = 10**10
            ans = min(ans, helper(index+1)+costs[0])
            
            while(index<N and days[index]-curday<7): index+=1 
            ans = min(ans, helper(index) + costs[1])
            
            while(index<N and days[index]-curday<30): index+=1 
            ans = min(ans, helper(index) + costs[2])
            return ans",mincostTickets.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\mincostTickets.py,module/class_definition-Solution/function_definition-mincostTickets/,mincostTickets,days.sort(),return helper(0),"(6, 8)","(19, 22)",N,function_definition,"def helper(index):
            if(index >= N): return 0
            curday = days[index]

            ans = 10**10
            ans = min(ans, helper(index+1)+costs[0])
            
            while(index<N and days[index]-curday<7): index+=1 
            ans = min(ans, helper(index) + costs[1])
            
            while(index<N and days[index]-curday<30): index+=1 
            ans = min(ans, helper(index) + costs[2])
            return ans",,116,adb25121-f856-4b9c-8a47-7c574b87323a
"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:

        N = len(cuts)
        cuts.sort()


        @cache
        def helper(start_index, end_index, cstart, cend):
            if(start_index == end_index): return 0
            if(cstart == cend): return end_index - start_index
            if(cstart>cend): return 0

            ans = 10**10
            cur_cost = end_index - start_index
            for index in range(cstart, cend+1):
                ans = min(ans, cur_cost + helper(start_index, cuts[index], cstart, index-1) + helper(cuts[index], end_index, index+1, cend))
            return ans

        return helper(0, n, 0, N-1)
",minCostToCutStick.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minCostToCutStick.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(20, 0)",N,module,module,,178,d64f6d1e-1ad5-45a4-8e3d-67b0bc301c65
"class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:

        N = len(cuts)
        cuts.sort()


        @cache
        def helper(start_index, end_index, cstart, cend):
            if(start_index == end_index): return 0
            if(cstart == cend): return end_index - start_index
            if(cstart>cend): return 0

            ans = 10**10
            cur_cost = end_index - start_index
            for index in range(cstart, cend+1):
                ans = min(ans, cur_cost + helper(start_index, cuts[index], cstart, index-1) + helper(cuts[index], end_index, index+1, cend))
            return ans

        return helper(0, n, 0, N-1)",minCostToCutStick.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minCostToCutStick.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(19, 35)",N,class_definition,Solution,,178,d116712a-0510-4e2f-9304-a1e90168dad3
"def minCost(self, n: int, cuts: List[int]) -> int:

        N = len(cuts)
        cuts.sort()


        @cache
        def helper(start_index, end_index, cstart, cend):
            if(start_index == end_index): return 0
            if(cstart == cend): return end_index - start_index
            if(cstart>cend): return 0

            ans = 10**10
            cur_cost = end_index - start_index
            for index in range(cstart, cend+1):
                ans = min(ans, cur_cost + helper(start_index, cuts[index], cstart, index-1) + helper(cuts[index], end_index, index+1, cend))
            return ans

        return helper(0, n, 0, N-1)",minCostToCutStick.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minCostToCutStick.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(19, 35)",N,function_definition,minCost,,174,e1bd577f-42a1-4675-b88a-2a68f18a9ed8
"@cache
        def helper(start_index, end_index, cstart, cend):
            if(start_index == end_index): return 0
            if(cstart == cend): return end_index - start_index
            if(cstart>cend): return 0

            ans = 10**10
            cur_cost = end_index - start_index
            for index in range(cstart, cend+1):
                ans = min(ans, cur_cost + helper(start_index, cuts[index], cstart, index-1) + helper(cuts[index], end_index, index+1, cend))
            return ans",minCostToCutStick.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minCostToCutStick.py,module/class_definition-Solution/function_definition-minCost/,minCost,cuts.sort(),"return helper(0, n, 0, N-1)","(7, 8)","(17, 22)",N,function_definition,"def helper(start_index, end_index, cstart, cend):
            if(start_index == end_index): return 0
            if(cstart == cend): return end_index - start_index
            if(cstart>cend): return 0

            ans = 10**10
            cur_cost = end_index - start_index
            for index in range(cstart, cend+1):
                ans = min(ans, cur_cost + helper(start_index, cuts[index], cstart, index-1) + helper(cuts[index], end_index, index+1, cend))
            return ans",,129,74eeaadc-98f8-4e04-80f5-34ff2231a623
"class Solution:
    def __init__(self):
        self.s1 = None
        self.s2 = None
        self.cache = {}


    def helper(self, index1, index2):
        key = (index1, index2)
        if(key  in self.cache): return self.cache[key]

        if(index1 == len(self.s1)): return len(self.s2) -index2
        if(len(self.s2) == index2): return len(self.s1) - index1
        if(self.s1[index1] == self.s2[index2]): ans = self.helper(index1+1, index2+1)
        else: ans = min(self.helper(index1, index2+1) +1, self.helper(index1+1, index2) +1, self.helper(index1+1, index2+1) +1)

        self.cache[key] = ans
        return ans

    def minDistance(self, s1: str, s2: str) -> int:
        self.s1 = s1
        self.s2 = s2
        return self.helper(0, 0)
",minDistance.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minDistance.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,module,module,,237,f25911db-ce0d-48d1-96be-e89570524b86
"class Solution:
    def __init__(self):
        self.s1 = None
        self.s2 = None
        self.cache = {}


    def helper(self, index1, index2):
        key = (index1, index2)
        if(key  in self.cache): return self.cache[key]

        if(index1 == len(self.s1)): return len(self.s2) -index2
        if(len(self.s2) == index2): return len(self.s1) - index1
        if(self.s1[index1] == self.s2[index2]): ans = self.helper(index1+1, index2+1)
        else: ans = min(self.helper(index1, index2+1) +1, self.helper(index1+1, index2) +1, self.helper(index1+1, index2+1) +1)

        self.cache[key] = ans
        return ans

    def minDistance(self, s1: str, s2: str) -> int:
        self.s1 = s1
        self.s2 = s2
        return self.helper(0, 0)",minDistance.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minDistance.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 32)",N,class_definition,Solution,,237,3a2becba-9738-4956-a388-9118ac8567e7
"def __init__(self):
        self.s1 = None
        self.s2 = None
        self.cache = {}",minDistance.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minDistance.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def helper(self, index1, index2):
        key = (index1, index2)
        if(key  in self.cache): return self.cache[key]

        if(index1 == len(self.s1)): return len(self.s2) -index2
        if(len(self.s2) == index2): return len(self.s1) - index1
        if(self.s1[index1] == self.s2[index2]): ans = self.helper(index1+1, index2+1)
        else: ans = min(self.helper(index1, index2+1) +1, self.helper(index1+1, index2) +1, self.helper(index1+1, index2+1) +1)

        self.cache[key] = ans
        return ans","(1, 4)","(4, 23)",N,function_definition,__init__,,25,edd42dee-2f0d-40f3-ba09-c10de5e9136a
"def helper(self, index1, index2):
        key = (index1, index2)
        if(key  in self.cache): return self.cache[key]

        if(index1 == len(self.s1)): return len(self.s2) -index2
        if(len(self.s2) == index2): return len(self.s1) - index1
        if(self.s1[index1] == self.s2[index2]): ans = self.helper(index1+1, index2+1)
        else: ans = min(self.helper(index1, index2+1) +1, self.helper(index1+1, index2) +1, self.helper(index1+1, index2+1) +1)

        self.cache[key] = ans
        return ans",minDistance.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minDistance.py,module/class_definition-Solution/,Solution,"def __init__(self):
        self.s1 = None
        self.s2 = None
        self.cache = {}","def minDistance(self, s1: str, s2: str) -> int:
        self.s1 = s1
        self.s2 = s2
        return self.helper(0, 0)","(7, 4)","(17, 18)",N,function_definition,helper,,161,db6b50b5-9bc9-41c1-8505-2158be43fa60
"def minDistance(self, s1: str, s2: str) -> int:
        self.s1 = s1
        self.s2 = s2
        return self.helper(0, 0)",minDistance.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minDistance.py,module/class_definition-Solution/,Solution,"def helper(self, index1, index2):
        key = (index1, index2)
        if(key  in self.cache): return self.cache[key]

        if(index1 == len(self.s1)): return len(self.s2) -index2
        if(len(self.s2) == index2): return len(self.s1) - index1
        if(self.s1[index1] == self.s2[index2]): ans = self.helper(index1+1, index2+1)
        else: ans = min(self.helper(index1, index2+1) +1, self.helper(index1+1, index2) +1, self.helper(index1+1, index2+1) +1)

        self.cache[key] = ans
        return ans",Next sibling does not exist,"(19, 4)","(22, 32)",N,function_definition,minDistance,,44,faf34f71-5e39-4153-8969-fee535b754f5
"class Solution:
    def minimizeMax(self, nums: List[int], p: int) -> int:
        if(p == 0): return 0

        N = len(nums)
        nums.sort()
        inf = 10**10 +1

        prevprev = [inf for i in range(p + 1)]
        prev = [inf for i in range(p + 1)]
        dp = [inf for i in range(p + 1)]
        
        for index in range(N-2, -1, -1):
            for p_index in range(1, p+1):
                if(N - index < 2*p_index): continue
                if( p_index == 0): continue
                if(p_index == 1):
                    dp[p_index] = min(prev[p_index], nums[index+1] - nums[index])
                    continue

                dp[p_index] = min(
                    max(nums[index+1] - nums[index], prevprev[p_index-1]),
                    prev[p_index]
                )

            prevprev = prev
            prev = dp
            dp = [inf for i in range(p + 1)]
            
        return prev[-1]

# best solution for the problem is using binary search ckeck the problem (2616. leetcode)
# with a mix of greedy.
",minimizeMax.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minimizeMax.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(33, 0)",N,module,module,,273,a85a055e-7632-495a-8efd-557805c5d97c
"class Solution:
    def minimizeMax(self, nums: List[int], p: int) -> int:
        if(p == 0): return 0

        N = len(nums)
        nums.sort()
        inf = 10**10 +1

        prevprev = [inf for i in range(p + 1)]
        prev = [inf for i in range(p + 1)]
        dp = [inf for i in range(p + 1)]
        
        for index in range(N-2, -1, -1):
            for p_index in range(1, p+1):
                if(N - index < 2*p_index): continue
                if( p_index == 0): continue
                if(p_index == 1):
                    dp[p_index] = min(prev[p_index], nums[index+1] - nums[index])
                    continue

                dp[p_index] = min(
                    max(nums[index+1] - nums[index], prevprev[p_index-1]),
                    prev[p_index]
                )

            prevprev = prev
            prev = dp
            dp = [inf for i in range(p + 1)]
            
        return prev[-1]",minimizeMax.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minimizeMax.py,module/,module,Previous sibling does not exist,# best solution for the problem is using binary search ckeck the problem (2616. leetcode),"(0, 0)","(29, 23)",N,class_definition,Solution,,244,0d07f5c4-d4cc-4f24-a153-fc2d3c07fe12
"def minimizeMax(self, nums: List[int], p: int) -> int:
        if(p == 0): return 0

        N = len(nums)
        nums.sort()
        inf = 10**10 +1

        prevprev = [inf for i in range(p + 1)]
        prev = [inf for i in range(p + 1)]
        dp = [inf for i in range(p + 1)]
        
        for index in range(N-2, -1, -1):
            for p_index in range(1, p+1):
                if(N - index < 2*p_index): continue
                if( p_index == 0): continue
                if(p_index == 1):
                    dp[p_index] = min(prev[p_index], nums[index+1] - nums[index])
                    continue

                dp[p_index] = min(
                    max(nums[index+1] - nums[index], prevprev[p_index-1]),
                    prev[p_index]
                )

            prevprev = prev
            prev = dp
            dp = [inf for i in range(p + 1)]
            
        return prev[-1]",minimizeMax.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minimizeMax.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"# best solution for the problem is using binary search ckeck the problem (2616. leetcode)
# with a mix of greedy.","(1, 4)","(29, 23)",N,function_definition,minimizeMax,,240,1196deb9-599c-4d12-96d4-3244e749ed89
"# best solution for the problem is using binary search ckeck the problem (2616. leetcode)
# with a mix of greedy.",minimizeMax.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minimizeMax.py,module/,module,"class Solution:
    def minimizeMax(self, nums: List[int], p: int) -> int:
        if(p == 0): return 0

        N = len(nums)
        nums.sort()
        inf = 10**10 +1

        prevprev = [inf for i in range(p + 1)]
        prev = [inf for i in range(p + 1)]
        dp = [inf for i in range(p + 1)]
        
        for index in range(N-2, -1, -1):
            for p_index in range(1, p+1):
                if(N - index < 2*p_index): continue
                if( p_index == 0): continue
                if(p_index == 1):
                    dp[p_index] = min(prev[p_index], nums[index+1] - nums[index])
                    continue

                dp[p_index] = min(
                    max(nums[index+1] - nums[index], prevprev[p_index-1]),
                    prev[p_index]
                )

            prevprev = prev
            prev = dp
            dp = [inf for i in range(p + 1)]
            
        return prev[-1]",Next sibling does not exist,"(31, 0)","(32, 23)",N,"comment,comment",comment,,29,6c394945-9a82-445c-bd1d-7b3a5caa1f39
"class Solution:
    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
                
        maxArr = [[-1]*len(jobDifficulty)  for i in range(len(jobDifficulty))]
        
        for i in range(len(jobDifficulty)):
            maxArr[i][i] = jobDifficulty[i]
        
        for l in range(1, len(jobDifficulty)):
            for start in range(0, len(jobDifficulty)):
                if(l+start < len(maxArr)):
                    maxArr[start][start+l] = max(maxArr[start][start+l-1], maxArr[start+1][start+l])
                        
        cache = {}
        
        def getMin(index, d):
            
            if(d == 1): return maxArr[index][-1]
            if(d>len(jobDifficulty)): return -1
            
            key = (index, d)
            
            if(key in cache): return cache[key]
        
            prefixMax = -1
            best = 10**20
        
            for i in range(0, len(jobDifficulty[index:])-d+1):
                best = min(best, maxArr[index][index+i] + getMin(index + i + 1, d-1))
            
            cache[key] = best
            return best
        
        return getMin(0, d)
",MinimumDifficultyJobSchedule.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MinimumDifficultyJobSchedule.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(34, 0)",N,module,module,,271,8c120bdd-e34d-44af-945a-60f7ce348176
"class Solution:
    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
                
        maxArr = [[-1]*len(jobDifficulty)  for i in range(len(jobDifficulty))]
        
        for i in range(len(jobDifficulty)):
            maxArr[i][i] = jobDifficulty[i]
        
        for l in range(1, len(jobDifficulty)):
            for start in range(0, len(jobDifficulty)):
                if(l+start < len(maxArr)):
                    maxArr[start][start+l] = max(maxArr[start][start+l-1], maxArr[start+1][start+l])
                        
        cache = {}
        
        def getMin(index, d):
            
            if(d == 1): return maxArr[index][-1]
            if(d>len(jobDifficulty)): return -1
            
            key = (index, d)
            
            if(key in cache): return cache[key]
        
            prefixMax = -1
            best = 10**20
        
            for i in range(0, len(jobDifficulty[index:])-d+1):
                best = min(best, maxArr[index][index+i] + getMin(index + i + 1, d-1))
            
            cache[key] = best
            return best
        
        return getMin(0, d)",MinimumDifficultyJobSchedule.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MinimumDifficultyJobSchedule.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(33, 27)",N,class_definition,Solution,,271,4d8fc23a-1ca1-4668-81fd-a397b1792969
"def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
                
        maxArr = [[-1]*len(jobDifficulty)  for i in range(len(jobDifficulty))]
        
        for i in range(len(jobDifficulty)):
            maxArr[i][i] = jobDifficulty[i]
        
        for l in range(1, len(jobDifficulty)):
            for start in range(0, len(jobDifficulty)):
                if(l+start < len(maxArr)):
                    maxArr[start][start+l] = max(maxArr[start][start+l-1], maxArr[start+1][start+l])
                        
        cache = {}
        
        def getMin(index, d):
            
            if(d == 1): return maxArr[index][-1]
            if(d>len(jobDifficulty)): return -1
            
            key = (index, d)
            
            if(key in cache): return cache[key]
        
            prefixMax = -1
            best = 10**20
        
            for i in range(0, len(jobDifficulty[index:])-d+1):
                best = min(best, maxArr[index][index+i] + getMin(index + i + 1, d-1))
            
            cache[key] = best
            return best
        
        return getMin(0, d)",MinimumDifficultyJobSchedule.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MinimumDifficultyJobSchedule.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(33, 27)",N,function_definition,minDifficulty,,267,62396ee7-eb81-445c-b6d7-533426d1278a
"def getMin(index, d):
            
            if(d == 1): return maxArr[index][-1]
            if(d>len(jobDifficulty)): return -1
            
            key = (index, d)
            
            if(key in cache): return cache[key]
        
            prefixMax = -1
            best = 10**20
        
            for i in range(0, len(jobDifficulty[index:])-d+1):
                best = min(best, maxArr[index][index+i] + getMin(index + i + 1, d-1))
            
            cache[key] = best
            return best",MinimumDifficultyJobSchedule.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\MinimumDifficultyJobSchedule.py,module/class_definition-Solution/function_definition-minDifficulty/,minDifficulty,cache = {},"return getMin(0, d)","(15, 8)","(31, 23)",N,function_definition,getMin,,125,af7e7089-6598-4b8f-b06d-af0ed2d1ce21
"class Solution:
    def minPathSum(self, dp: List[List[int]]) -> int:

        N = len(dp)
        M = len(dp[0])

        for i in range(1, N): dp[i][0] += dp[i-1][0]
        for i in range(1, M): dp[0][i] += dp[0][i-1]

        for i in range(1, N):
            for j in range(1, M):
                dp[i][j] += min(dp[i-1][j], dp[i][j-1])

        return dp[-1][-1]
",minPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minPathSum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 0)",N,module,module,,131,9b58919c-012c-4464-8794-a54e39308513
"class Solution:
    def minPathSum(self, dp: List[List[int]]) -> int:

        N = len(dp)
        M = len(dp[0])

        for i in range(1, N): dp[i][0] += dp[i-1][0]
        for i in range(1, M): dp[0][i] += dp[0][i-1]

        for i in range(1, N):
            for j in range(1, M):
                dp[i][j] += min(dp[i-1][j], dp[i][j-1])

        return dp[-1][-1]",minPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minPathSum.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(13, 25)",N,class_definition,Solution,,131,a5edeb6a-e572-4684-945d-ba0dd6d39f48
"def minPathSum(self, dp: List[List[int]]) -> int:

        N = len(dp)
        M = len(dp[0])

        for i in range(1, N): dp[i][0] += dp[i-1][0]
        for i in range(1, M): dp[0][i] += dp[0][i-1]

        for i in range(1, N):
            for j in range(1, M):
                dp[i][j] += min(dp[i-1][j], dp[i][j-1])

        return dp[-1][-1]",minPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\minPathSum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(13, 25)",N,function_definition,minPathSum,,127,b9add97e-6118-47dd-9c08-3a3820a1ab61
"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        dp = [[] for i in range(10**4+2)]
        for i in range(k, 10**4+2):
            if(k<=n): dp[i] = [1, 0]
            else: dp[i] = [0, 1]
        
        start_index = k
        end_index = k-1+maxPts
        x_sum = sum(i[0] for i in dp[start_index:end_index+1])
        y_sum = sum(i[-1] for i in dp[start_index:end_index+1])
        print(x_sum, y_sum)

        for i in range(k-1, -1, -1):
            ans = [x_sum * 1/maxPts, y_sum * 1/maxPts]
            dp[i] = ans

            x_sum = x_sum + dp[start_index-1][0] - dp[end_index][0]
            y_sum = y_sum + dp[start_index-1][1] - dp[end_index][1]
            start_index-=1
            end_index-=1
        
        print(dp)
        return x_sum


        # cache = {}
        # def helper(num):
        #     if(num >= k):
        #         if(num>n): return [0, 1]
        #         return [1, 0]

        #     ans = [0, 0]
        #     for i in range(1, maxPts+1):
        #         x, y = helper(num + i)
        #         ans[0] += x * (1/maxPts)
        #         ans[-1] += y * (1/maxPts)

        #     cache[num] = ans
        #     return ans 
        
        # arr = helper(0)
        # return arr[0]

ans = Solution().new21Game(10000, 6666, 565)
print(ans)",New21Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\New21Game.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(45, 10)",N,module,module,,419,c8ed6b1a-b9ce-4eb8-99b9-0f468cdc6b02
"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        dp = [[] for i in range(10**4+2)]
        for i in range(k, 10**4+2):
            if(k<=n): dp[i] = [1, 0]
            else: dp[i] = [0, 1]
        
        start_index = k
        end_index = k-1+maxPts
        x_sum = sum(i[0] for i in dp[start_index:end_index+1])
        y_sum = sum(i[-1] for i in dp[start_index:end_index+1])
        print(x_sum, y_sum)

        for i in range(k-1, -1, -1):
            ans = [x_sum * 1/maxPts, y_sum * 1/maxPts]
            dp[i] = ans

            x_sum = x_sum + dp[start_index-1][0] - dp[end_index][0]
            y_sum = y_sum + dp[start_index-1][1] - dp[end_index][1]
            start_index-=1
            end_index-=1
        
        print(dp)
        return x_sum


        # cache = {}
        # def helper(num):
        #     if(num >= k):
        #         if(num>n): return [0, 1]
        #         return [1, 0]

        #     ans = [0, 0]
        #     for i in range(1, maxPts+1):
        #         x, y = helper(num + i)
        #         ans[0] += x * (1/maxPts)
        #         ans[-1] += y * (1/maxPts)

        #     cache[num] = ans
        #     return ans 
        
        # arr = helper(0)
        # return arr[0]",New21Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\New21Game.py,module/,module,Previous sibling does not exist,"ans = Solution().new21Game(10000, 6666, 565)","(0, 0)","(42, 23)",N,class_definition,Solution,,398,acdf77f9-9f0b-4143-8791-089ae0bca079
"def new21Game(self, n: int, k: int, maxPts: int) -> float:
        dp = [[] for i in range(10**4+2)]
        for i in range(k, 10**4+2):
            if(k<=n): dp[i] = [1, 0]
            else: dp[i] = [0, 1]
        
        start_index = k
        end_index = k-1+maxPts
        x_sum = sum(i[0] for i in dp[start_index:end_index+1])
        y_sum = sum(i[-1] for i in dp[start_index:end_index+1])
        print(x_sum, y_sum)

        for i in range(k-1, -1, -1):
            ans = [x_sum * 1/maxPts, y_sum * 1/maxPts]
            dp[i] = ans

            x_sum = x_sum + dp[start_index-1][0] - dp[end_index][0]
            y_sum = y_sum + dp[start_index-1][1] - dp[end_index][1]
            start_index-=1
            end_index-=1
        
        print(dp)
        return x_sum


        # cache = {}
        # def helper(num):
        #     if(num >= k):
        #         if(num>n): return [0, 1]
        #         return [1, 0]

        #     ans = [0, 0]
        #     for i in range(1, maxPts+1):
        #         x, y = helper(num + i)
        #         ans[0] += x * (1/maxPts)
        #         ans[-1] += y * (1/maxPts)

        #     cache[num] = ans
        #     return ans 
        
        # arr = helper(0)
        # return arr[0]",New21Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\New21Game.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"ans = Solution().new21Game(10000, 6666, 565)
print(ans)","(1, 4)","(42, 23)",N,function_definition,new21Game,,394,acaed469-ea5f-4869-934e-0fa6a4935497
"ans = Solution().new21Game(10000, 6666, 565)
print(ans)",New21Game.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\New21Game.py,module/,module,"class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        dp = [[] for i in range(10**4+2)]
        for i in range(k, 10**4+2):
            if(k<=n): dp[i] = [1, 0]
            else: dp[i] = [0, 1]
        
        start_index = k
        end_index = k-1+maxPts
        x_sum = sum(i[0] for i in dp[start_index:end_index+1])
        y_sum = sum(i[-1] for i in dp[start_index:end_index+1])
        print(x_sum, y_sum)

        for i in range(k-1, -1, -1):
            ans = [x_sum * 1/maxPts, y_sum * 1/maxPts]
            dp[i] = ans

            x_sum = x_sum + dp[start_index-1][0] - dp[end_index][0]
            y_sum = y_sum + dp[start_index-1][1] - dp[end_index][1]
            start_index-=1
            end_index-=1
        
        print(dp)
        return x_sum


        # cache = {}
        # def helper(num):
        #     if(num >= k):
        #         if(num>n): return [0, 1]
        #         return [1, 0]

        #     ans = [0, 0]
        #     for i in range(1, maxPts+1):
        #         x, y = helper(num + i)
        #         ans[0] += x * (1/maxPts)
        #         ans[-1] += y * (1/maxPts)

        #     cache[num] = ans
        #     return ans 
        
        # arr = helper(0)
        # return arr[0]",Next sibling does not exist,"(44, 0)","(45, 10)",N,"expression_statement,expression_statement",expression_statement,,21,69720faa-ee38-42fe-b24a-3478dad1b1e8
"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        
        mod = 10**9 + 7

        @cache
        def helper(index):
            if(index == len(s)): return 1
            if(s[index] == '0'): return 0

            count = 0
            cur = 0
            for ind in range(index, len(s)):
                cur *= 10 
                cur += int(s[ind])
                if(cur > k): break

                count = (count%mod +  helper(ind+1)%mod)%mod
            return count

        return helper(0)
",numberOfArrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\numberOfArrays.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 0)",N,module,module,,136,403c22a3-dedb-41da-848e-a85edb3881d1
"class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        
        mod = 10**9 + 7

        @cache
        def helper(index):
            if(index == len(s)): return 1
            if(s[index] == '0'): return 0

            count = 0
            cur = 0
            for ind in range(index, len(s)):
                cur *= 10 
                cur += int(s[ind])
                if(cur > k): break

                count = (count%mod +  helper(ind+1)%mod)%mod
            return count

        return helper(0)",numberOfArrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\numberOfArrays.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(20, 24)",N,class_definition,Solution,,136,2dce320c-529e-4913-bc7b-c43d34f153f5
"def numberOfArrays(self, s: str, k: int) -> int:
        
        mod = 10**9 + 7

        @cache
        def helper(index):
            if(index == len(s)): return 1
            if(s[index] == '0'): return 0

            count = 0
            cur = 0
            for ind in range(index, len(s)):
                cur *= 10 
                cur += int(s[ind])
                if(cur > k): break

                count = (count%mod +  helper(ind+1)%mod)%mod
            return count

        return helper(0)",numberOfArrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\numberOfArrays.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(20, 24)",N,function_definition,numberOfArrays,,132,af3da155-bf90-4ddc-8433-50852635f91e
"@cache
        def helper(index):
            if(index == len(s)): return 1
            if(s[index] == '0'): return 0

            count = 0
            cur = 0
            for ind in range(index, len(s)):
                cur *= 10 
                cur += int(s[ind])
                if(cur > k): break

                count = (count%mod +  helper(ind+1)%mod)%mod
            return count",numberOfArrays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\numberOfArrays.py,module/class_definition-Solution/function_definition-numberOfArrays/,numberOfArrays,mod = 10**9 + 7,return helper(0),"(5, 8)","(18, 24)",N,function_definition,"def helper(index):
            if(index == len(s)): return 1
            if(s[index] == '0'): return 0

            count = 0
            cur = 0
            for ind in range(index, len(s)):
                cur *= 10 
                cur += int(s[ind])
                if(cur > k): break

                count = (count%mod +  helper(ind+1)%mod)%mod
            return count",,96,8e6b5916-0846-4ac1-919f-9d253f061c3e
"class Solution {
    public int numberOfWays(int startPos, int endPos, int k) {
        if(endPos<startPos) return numberOfWays(endPos, startPos, k);

        if(startPos+k < endPos) return 0;
        
        int xysum = k;
        int xysub = endPos - startPos;
        
        if((xysum + xysub)%2 == 1) return 0;
        
        int x = (xysum + xysub)/2;
        int y = xysum - x;
        
        return ncr(k, x);
    }
    
    public int ncr(int n, int r){
        int[][] ans = new int[n+1][n+1];
        ans[0][0] = 1;

        for(int i = 1; i <= n; i++) {
            ans[i][0] = 1;
            for(int j = 1; j <= i; j++) {
                ans[i][j] = (ans[i - 1][j - 1] + ans[i - 1][j]) % (1000000007);
            }
        }
        return ans[n][r];
    }
    
}
",NumberOfWays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumberOfWays.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 0)",N,program,program,,258,6dd646ff-c05c-495e-a5bc-be26ac2e889f
"class Solution {
    public int numberOfWays(int startPos, int endPos, int k) {
        if(endPos<startPos) return numberOfWays(endPos, startPos, k);

        if(startPos+k < endPos) return 0;
        
        int xysum = k;
        int xysub = endPos - startPos;
        
        if((xysum + xysub)%2 == 1) return 0;
        
        int x = (xysum + xysub)/2;
        int y = xysum - x;
        
        return ncr(k, x);
    }
    
    public int ncr(int n, int r){
        int[][] ans = new int[n+1][n+1];
        ans[0][0] = 1;

        for(int i = 1; i <= n; i++) {
            ans[i][0] = 1;
            for(int j = 1; j <= i; j++) {
                ans[i][j] = (ans[i - 1][j - 1] + ans[i - 1][j]) % (1000000007);
            }
        }
        return ans[n][r];
    }
    
}",NumberOfWays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumberOfWays.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 1)",N,class_declaration,Solution,,258,05bdbfa6-a9f8-4753-af03-23f5bdf1f46f
"public int numberOfWays(int startPos, int endPos, int k) {
        if(endPos<startPos) return numberOfWays(endPos, startPos, k);

        if(startPos+k < endPos) return 0;
        
        int xysum = k;
        int xysub = endPos - startPos;
        
        if((xysum + xysub)%2 == 1) return 0;
        
        int x = (xysum + xysub)/2;
        int y = xysum - x;
        
        return ncr(k, x);
    }",NumberOfWays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumberOfWays.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public int ncr(int n, int r){
        int[][] ans = new int[n+1][n+1];
        ans[0][0] = 1;

        for(int i = 1; i <= n; i++) {
            ans[i][0] = 1;
            for(int j = 1; j <= i; j++) {
                ans[i][j] = (ans[i - 1][j - 1] + ans[i - 1][j]) % (1000000007);
            }
        }
        return ans[n][r];
    }","(1, 4)","(15, 5)",N,method_declaration,numberOfWays,,126,71ec5f15-8a2e-42e6-89b4-fda5badb8dde
"public int ncr(int n, int r){
        int[][] ans = new int[n+1][n+1];
        ans[0][0] = 1;

        for(int i = 1; i <= n; i++) {
            ans[i][0] = 1;
            for(int j = 1; j <= i; j++) {
                ans[i][j] = (ans[i - 1][j - 1] + ans[i - 1][j]) % (1000000007);
            }
        }
        return ans[n][r];
    }",NumberOfWays.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumberOfWays.java,program/class_declaration-Solution/,Solution,"public int numberOfWays(int startPos, int endPos, int k) {
        if(endPos<startPos) return numberOfWays(endPos, startPos, k);

        if(startPos+k < endPos) return 0;
        
        int xysum = k;
        int xysub = endPos - startPos;
        
        if((xysum + xysub)%2 == 1) return 0;
        
        int x = (xysum + xysub)/2;
        int y = xysum - x;
        
        return ncr(k, x);
    }",Next sibling does not exist,"(17, 4)","(28, 5)",N,method_declaration,ncr,,124,598e892a-73a4-4943-98c5-18b09ea986c1
"class Solution {
    public int numDecodings(String s) {

        final int n = s.length();
        int[] ans = new int[n];
        
        ans[n-1] = s.charAt(n-1) != '0' ? 1 : 0;
        
        if(n>=2){
            ans[n-2] = isValid(s.substring(n-2)) * 1 +  isValid(s.substring(n-2,n-1)) * ans[s.length()-1];
        }
        
        for(int index = n-3; index>=0; index--){
            ans[index] = isValid(s.substring(index,index+2)) * ans[index+2] +  isValid(s.substring(index,index+1)) * ans[index+1];
        }
        
        // System.out.println(Arrays.toString(ans));
        
        return ans[0];
    }
    
    
    public int isValid(String s){
        // System.out.println(s);
        if(s.charAt(0)=='0') return 0;
        int val = Integer.parseInt(s);
        return (val>=1 && val<=26) ? 1 :0;
    }
}
",NumDecodings.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumDecodings.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 0)",N,program,program,,228,a8b50959-256d-4033-93bb-e495be7dd622
"class Solution {
    public int numDecodings(String s) {

        final int n = s.length();
        int[] ans = new int[n];
        
        ans[n-1] = s.charAt(n-1) != '0' ? 1 : 0;
        
        if(n>=2){
            ans[n-2] = isValid(s.substring(n-2)) * 1 +  isValid(s.substring(n-2,n-1)) * ans[s.length()-1];
        }
        
        for(int index = n-3; index>=0; index--){
            ans[index] = isValid(s.substring(index,index+2)) * ans[index+2] +  isValid(s.substring(index,index+1)) * ans[index+1];
        }
        
        // System.out.println(Arrays.toString(ans));
        
        return ans[0];
    }
    
    
    public int isValid(String s){
        // System.out.println(s);
        if(s.charAt(0)=='0') return 0;
        int val = Integer.parseInt(s);
        return (val>=1 && val<=26) ? 1 :0;
    }
}",NumDecodings.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumDecodings.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 1)",N,class_declaration,Solution,,228,a67d4bd5-dadf-47b0-abf7-137af9ffde62
"public int numDecodings(String s) {

        final int n = s.length();
        int[] ans = new int[n];
        
        ans[n-1] = s.charAt(n-1) != '0' ? 1 : 0;
        
        if(n>=2){
            ans[n-2] = isValid(s.substring(n-2)) * 1 +  isValid(s.substring(n-2,n-1)) * ans[s.length()-1];
        }
        
        for(int index = n-3; index>=0; index--){
            ans[index] = isValid(s.substring(index,index+2)) * ans[index+2] +  isValid(s.substring(index,index+1)) * ans[index+1];
        }
        
        // System.out.println(Arrays.toString(ans));
        
        return ans[0];
    }",NumDecodings.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumDecodings.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public int isValid(String s){
        // System.out.println(s);
        if(s.charAt(0)=='0') return 0;
        int val = Integer.parseInt(s);
        return (val>=1 && val<=26) ? 1 :0;
    }","(1, 4)","(19, 5)",N,method_declaration,numDecodings,,168,0fe67e6e-3bae-42cb-af86-b656c9d2aacf
"public int isValid(String s){
        // System.out.println(s);
        if(s.charAt(0)=='0') return 0;
        int val = Integer.parseInt(s);
        return (val>=1 && val<=26) ? 1 :0;
    }",NumDecodings.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumDecodings.java,program/class_declaration-Solution/,Solution,"public int numDecodings(String s) {

        final int n = s.length();
        int[] ans = new int[n];
        
        ans[n-1] = s.charAt(n-1) != '0' ? 1 : 0;
        
        if(n>=2){
            ans[n-2] = isValid(s.substring(n-2)) * 1 +  isValid(s.substring(n-2,n-1)) * ans[s.length()-1];
        }
        
        for(int index = n-3; index>=0; index--){
            ans[index] = isValid(s.substring(index,index+2)) * ans[index+2] +  isValid(s.substring(index,index+1)) * ans[index+1];
        }
        
        // System.out.println(Arrays.toString(ans));
        
        return ans[0];
    }",Next sibling does not exist,"(22, 4)","(27, 5)",N,method_declaration,isValid,,53,f9ebdafe-61bf-4223-964e-f5e4923d6068
"class Solution {
    public int numRollsToTarget(int n, int k, int target) {
        int[][] dp = new int[n+1][target+1];
        
        for(int i=1; i<=k && i<=target; i++){
            dp[1][i] = 1;
        }
        
        for(int i=2; i<=n; i++){
            for(int j=0; j<=target; j++){
                dp[i][j] = (int) getVal(dp,i,j,k);
            }
        }
        
        return dp[n][target]; 
    }
    
    
    public long getVal(int[][] dp, int row, int col, int k){
        int mod = 1000000007;
        int val = 0;
        for(int index = col-1; index>=0 && k>0; index--){
            val = (val + dp[row-1][index])%mod;
            k-=1;
        }
        return val;
    }
    
}
",NumRollsToTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumRollsToTarget.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 0)",N,program,program,,212,12ab6965-4f0f-4632-a6c8-6e65a9adc8c4
"class Solution {
    public int numRollsToTarget(int n, int k, int target) {
        int[][] dp = new int[n+1][target+1];
        
        for(int i=1; i<=k && i<=target; i++){
            dp[1][i] = 1;
        }
        
        for(int i=2; i<=n; i++){
            for(int j=0; j<=target; j++){
                dp[i][j] = (int) getVal(dp,i,j,k);
            }
        }
        
        return dp[n][target]; 
    }
    
    
    public long getVal(int[][] dp, int row, int col, int k){
        int mod = 1000000007;
        int val = 0;
        for(int index = col-1; index>=0 && k>0; index--){
            val = (val + dp[row-1][index])%mod;
            k-=1;
        }
        return val;
    }
    
}",NumRollsToTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumRollsToTarget.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 1)",N,class_declaration,Solution,,212,65425d58-1cea-4a15-aa0d-15f3ed2baf59
"public int numRollsToTarget(int n, int k, int target) {
        int[][] dp = new int[n+1][target+1];
        
        for(int i=1; i<=k && i<=target; i++){
            dp[1][i] = 1;
        }
        
        for(int i=2; i<=n; i++){
            for(int j=0; j<=target; j++){
                dp[i][j] = (int) getVal(dp,i,j,k);
            }
        }
        
        return dp[n][target]; 
    }",NumRollsToTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumRollsToTarget.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public long getVal(int[][] dp, int row, int col, int k){
        int mod = 1000000007;
        int val = 0;
        for(int index = col-1; index>=0 && k>0; index--){
            val = (val + dp[row-1][index])%mod;
            k-=1;
        }
        return val;
    }","(1, 4)","(15, 5)",N,method_declaration,numRollsToTarget,,122,dadc8164-805b-46af-8718-6824d6b2f549
"public long getVal(int[][] dp, int row, int col, int k){
        int mod = 1000000007;
        int val = 0;
        for(int index = col-1; index>=0 && k>0; index--){
            val = (val + dp[row-1][index])%mod;
            k-=1;
        }
        return val;
    }",NumRollsToTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\NumRollsToTarget.java,program/class_declaration-Solution/,Solution,"public int numRollsToTarget(int n, int k, int target) {
        int[][] dp = new int[n+1][target+1];
        
        for(int i=1; i<=k && i<=target; i++){
            dp[1][i] = 1;
        }
        
        for(int i=2; i<=n; i++){
            for(int j=0; j<=target; j++){
                dp[i][j] = (int) getVal(dp,i,j,k);
            }
        }
        
        return dp[n][target]; 
    }",Next sibling does not exist,"(18, 4)","(26, 5)",N,method_declaration,getVal,,82,740e6282-0d91-42e1-ba96-f690ecad7688
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:

        @cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans
        
        return (sum(piles) + helper(0, 1))//2
",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\stoneGameII.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 0)",N,module,module,,147,77ae3e28-0984-4c74-94bf-d68c95ff751d
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:

        @cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans
        
        return (sum(piles) + helper(0, 1))//2",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\stoneGameII.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 45)",N,class_definition,Solution,,146,4b0726a4-11cd-4cdb-bbc8-a577ea387d1a
"def stoneGameII(self, piles: List[int]) -> int:

        @cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans
        
        return (sum(piles) + helper(0, 1))//2",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\stoneGameII.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(17, 45)",N,function_definition,stoneGameII,,142,bf942749-6733-4052-bed0-32e8bd70305c
"@cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\stoneGameII.py,module/class_definition-Solution/function_definition-stoneGameII/,stoneGameII,Previous sibling does not exist,"return (sum(piles) + helper(0, 1))//2","(3, 8)","(15, 22)",N,function_definition,"def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans",,109,98e828af-9022-40c4-8d70-dbc04ac509a9
"class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        
        def f(x):
            if(x==0): return 0
            if(x==1): return 1
            if(x<=9): return 2
            if(x<=99): return 3
            return 4
        
        cache = {}
        
        def getMin(index, prevChar, run, k):
            
            key = (index, prevChar, run, k)
            
            if key in cache:
                return cache[key]
            
            if(index>=len(s)): return f(run)
            
            best = 10**20
            
            if(s[index] == prevChar):
                #keep
                best = min(best, getMin(index+1, prevChar, run+1, k))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            else:
                #keep
                best = min(best, getMin(index+1, s[index], 1, k) + f(run))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            cache[key] = best
            return best
        
        return getMin(0, '', 0, k)
",StringCompressionII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\StringCompressionII.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(43, 0)",N,module,module,,295,8d6731c5-5ea6-4350-9ef8-abdbf7976c80
"class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        
        def f(x):
            if(x==0): return 0
            if(x==1): return 1
            if(x<=9): return 2
            if(x<=99): return 3
            return 4
        
        cache = {}
        
        def getMin(index, prevChar, run, k):
            
            key = (index, prevChar, run, k)
            
            if key in cache:
                return cache[key]
            
            if(index>=len(s)): return f(run)
            
            best = 10**20
            
            if(s[index] == prevChar):
                #keep
                best = min(best, getMin(index+1, prevChar, run+1, k))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            else:
                #keep
                best = min(best, getMin(index+1, s[index], 1, k) + f(run))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            cache[key] = best
            return best
        
        return getMin(0, '', 0, k)",StringCompressionII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\StringCompressionII.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(42, 34)",N,class_definition,Solution,,295,a2c57db1-ce50-40f5-8d0c-889f16a511d3
"def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        
        def f(x):
            if(x==0): return 0
            if(x==1): return 1
            if(x<=9): return 2
            if(x<=99): return 3
            return 4
        
        cache = {}
        
        def getMin(index, prevChar, run, k):
            
            key = (index, prevChar, run, k)
            
            if key in cache:
                return cache[key]
            
            if(index>=len(s)): return f(run)
            
            best = 10**20
            
            if(s[index] == prevChar):
                #keep
                best = min(best, getMin(index+1, prevChar, run+1, k))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            else:
                #keep
                best = min(best, getMin(index+1, s[index], 1, k) + f(run))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            cache[key] = best
            return best
        
        return getMin(0, '', 0, k)",StringCompressionII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\StringCompressionII.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(42, 34)",N,function_definition,getLengthOfOptimalCompression,,291,76343234-b99a-4fb3-8154-ee542695a4fc
"def f(x):
            if(x==0): return 0
            if(x==1): return 1
            if(x<=9): return 2
            if(x<=99): return 3
            return 4",StringCompressionII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\StringCompressionII.py,module/class_definition-Solution/function_definition-getLengthOfOptimalCompression/,getLengthOfOptimalCompression,Previous sibling does not exist,cache = {},"(3, 8)","(8, 20)",N,function_definition,f,,48,971f5520-bf06-4f0d-b954-f573505a715b
"def getMin(index, prevChar, run, k):
            
            key = (index, prevChar, run, k)
            
            if key in cache:
                return cache[key]
            
            if(index>=len(s)): return f(run)
            
            best = 10**20
            
            if(s[index] == prevChar):
                #keep
                best = min(best, getMin(index+1, prevChar, run+1, k))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            else:
                #keep
                best = min(best, getMin(index+1, s[index], 1, k) + f(run))
                
                #remove
                if(k>0):
                    best = min(best, getMin(index+1, prevChar, run, k-1))
            
            cache[key] = best
            return best",StringCompressionII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\StringCompressionII.py,module/class_definition-Solution/function_definition-getLengthOfOptimalCompression/,getLengthOfOptimalCompression,cache = {},"return getMin(0, '', 0, k)","(12, 8)","(40, 23)",N,function_definition,getMin,,200,00dd0cfc-6a10-4b45-95a5-32a013a857df
"class Solution:
        
    pizza = []
    M = 0
    N = 0
    prefixSum = []
    cache = {}
    mod = 10**9 + 7
    
    def ways(self, pizza: List[str], k: int) -> int:
        
        self.pizza = pizza
        self.M = len(pizza) - 1
        self.N = len(pizza[0]) - 1
        self.cache = {}
        
        prefixSum = [[0]*len(pizza[0]) for i in range(len(pizza))]
        
        
        prefixSum[0][0] = 1 if(pizza[0][0]=='A') else 0
        
        for i in range(1, len(pizza[0])): 
            prefixSum[0][i] += prefixSum[0][i-1]
            prefixSum[0][i] += 1 if(pizza[0][i]=='A') else 0
        
        for i in range(1, len(pizza)): 
            prefixSum[i][0] += prefixSum[i-1][0]
            prefixSum[i][0] += 1 if(pizza[i][0]=='A') else 0
        
        
        for i in range(1, len(pizza)):
            for j in range(1, len(pizza[0])):
                prefixSum[i][j] += 1 if(pizza[i][j]=='A') else 0
                prefixSum[i][j] += prefixSum[i-1][j]
                prefixSum[i][j] += prefixSum[i][j-1]
                prefixSum[i][j] -= prefixSum[i-1][j-1]
                
        if(prefixSum[-1][-1]<k): return 0
        
        self.prefixSum = prefixSum
        return self.helper(0,0,k)
    
    
    def helper(self, rowIndex, colIndex, k):
        
        key = (rowIndex, colIndex, k)
        if(key in self.cache): return self.cache[key]
        
        ans = 0
        
        if(k == 1): return self.valid(rowIndex, self.M, colIndex, self.N)
        
        for index in range(rowIndex+1, self.M+1):
            ans += self.valid(rowIndex, index-1, colIndex, self.N) * self.helper(index, colIndex, k-1)
            ans = ans%self.mod
        
        for index in range(colIndex+1, self.N+1):
            ans += self.valid(rowIndex, self.M, colIndex, index-1) * self.helper(rowIndex, index, k-1)
            ans = ans%self.mod

        self.cache[key] = ans
        return ans
    
    def valid(self, rowStart, rowEnd, colStart, colEnd):        
        ans = self.prefixSum[rowEnd][colEnd]
        
        if(rowStart-1 >= 0):
            ans -= self.prefixSum[rowStart-1][colEnd]
            
        if(colStart-1 >= 0):
            ans -= self.prefixSum[rowEnd][colStart-1]
        
        if(rowStart-1 >= 0 and colStart-1 >= 0):
            ans += self.prefixSum[rowStart-1][colStart-1]
        
        return 1 if(ans>0) else 0

        
        
        



            
        
        
",WaysToCutPizza.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\WaysToCutPizza.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(86, 0)",N,module,module,,703,30dbd94c-4315-41a3-9f84-46638b62c0fd
"class Solution:
        
    pizza = []
    M = 0
    N = 0
    prefixSum = []
    cache = {}
    mod = 10**9 + 7
    
    def ways(self, pizza: List[str], k: int) -> int:
        
        self.pizza = pizza
        self.M = len(pizza) - 1
        self.N = len(pizza[0]) - 1
        self.cache = {}
        
        prefixSum = [[0]*len(pizza[0]) for i in range(len(pizza))]
        
        
        prefixSum[0][0] = 1 if(pizza[0][0]=='A') else 0
        
        for i in range(1, len(pizza[0])): 
            prefixSum[0][i] += prefixSum[0][i-1]
            prefixSum[0][i] += 1 if(pizza[0][i]=='A') else 0
        
        for i in range(1, len(pizza)): 
            prefixSum[i][0] += prefixSum[i-1][0]
            prefixSum[i][0] += 1 if(pizza[i][0]=='A') else 0
        
        
        for i in range(1, len(pizza)):
            for j in range(1, len(pizza[0])):
                prefixSum[i][j] += 1 if(pizza[i][j]=='A') else 0
                prefixSum[i][j] += prefixSum[i-1][j]
                prefixSum[i][j] += prefixSum[i][j-1]
                prefixSum[i][j] -= prefixSum[i-1][j-1]
                
        if(prefixSum[-1][-1]<k): return 0
        
        self.prefixSum = prefixSum
        return self.helper(0,0,k)
    
    
    def helper(self, rowIndex, colIndex, k):
        
        key = (rowIndex, colIndex, k)
        if(key in self.cache): return self.cache[key]
        
        ans = 0
        
        if(k == 1): return self.valid(rowIndex, self.M, colIndex, self.N)
        
        for index in range(rowIndex+1, self.M+1):
            ans += self.valid(rowIndex, index-1, colIndex, self.N) * self.helper(index, colIndex, k-1)
            ans = ans%self.mod
        
        for index in range(colIndex+1, self.N+1):
            ans += self.valid(rowIndex, self.M, colIndex, index-1) * self.helper(rowIndex, index, k-1)
            ans = ans%self.mod

        self.cache[key] = ans
        return ans
    
    def valid(self, rowStart, rowEnd, colStart, colEnd):        
        ans = self.prefixSum[rowEnd][colEnd]
        
        if(rowStart-1 >= 0):
            ans -= self.prefixSum[rowStart-1][colEnd]
            
        if(colStart-1 >= 0):
            ans -= self.prefixSum[rowEnd][colStart-1]
        
        if(rowStart-1 >= 0 and colStart-1 >= 0):
            ans += self.prefixSum[rowStart-1][colStart-1]
        
        return 1 if(ans>0) else 0",WaysToCutPizza.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\WaysToCutPizza.py,module/,module,Previous sibling does not exist,"pizza = []
M = 0
N = 0
prefixSum = []
cache = {}
mod = 10**9 + 7","(0, 0)","(75, 33)",N,class_definition,Solution,,697,27e8dcc8-1f0d-4758-8b94-1214946900dc
"pizza = []
M = 0
N = 0
prefixSum = []
cache = {}
mod = 10**9 + 7",WaysToCutPizza.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\WaysToCutPizza.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def ways(self, pizza: List[str], k: int) -> int:
        
        self.pizza = pizza
        self.M = len(pizza) - 1
        self.N = len(pizza[0]) - 1
        self.cache = {}
        
        prefixSum = [[0]*len(pizza[0]) for i in range(len(pizza))]
        
        
        prefixSum[0][0] = 1 if(pizza[0][0]=='A') else 0
        
        for i in range(1, len(pizza[0])): 
            prefixSum[0][i] += prefixSum[0][i-1]
            prefixSum[0][i] += 1 if(pizza[0][i]=='A') else 0
        
        for i in range(1, len(pizza)): 
            prefixSum[i][0] += prefixSum[i-1][0]
            prefixSum[i][0] += 1 if(pizza[i][0]=='A') else 0
        
        
        for i in range(1, len(pizza)):
            for j in range(1, len(pizza[0])):
                prefixSum[i][j] += 1 if(pizza[i][j]=='A') else 0
                prefixSum[i][j] += prefixSum[i-1][j]
                prefixSum[i][j] += prefixSum[i][j-1]
                prefixSum[i][j] -= prefixSum[i-1][j-1]
                
        if(prefixSum[-1][-1]<k): return 0
        
        self.prefixSum = prefixSum
        return self.helper(0,0,k)","(2, 4)","(7, 19)",N,"expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement",expression_statement,,27,76a1d370-9bb4-4ec6-8392-054a49a9bd05
"def ways(self, pizza: List[str], k: int) -> int:
        
        self.pizza = pizza
        self.M = len(pizza) - 1
        self.N = len(pizza[0]) - 1
        self.cache = {}
        
        prefixSum = [[0]*len(pizza[0]) for i in range(len(pizza))]
        
        
        prefixSum[0][0] = 1 if(pizza[0][0]=='A') else 0
        
        for i in range(1, len(pizza[0])): 
            prefixSum[0][i] += prefixSum[0][i-1]
            prefixSum[0][i] += 1 if(pizza[0][i]=='A') else 0
        
        for i in range(1, len(pizza)): 
            prefixSum[i][0] += prefixSum[i-1][0]
            prefixSum[i][0] += 1 if(pizza[i][0]=='A') else 0
        
        
        for i in range(1, len(pizza)):
            for j in range(1, len(pizza[0])):
                prefixSum[i][j] += 1 if(pizza[i][j]=='A') else 0
                prefixSum[i][j] += prefixSum[i-1][j]
                prefixSum[i][j] += prefixSum[i][j-1]
                prefixSum[i][j] -= prefixSum[i-1][j-1]
                
        if(prefixSum[-1][-1]<k): return 0
        
        self.prefixSum = prefixSum
        return self.helper(0,0,k)",WaysToCutPizza.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\WaysToCutPizza.py,module/class_definition-Solution/,Solution,"pizza = []
M = 0
N = 0
prefixSum = []
cache = {}
mod = 10**9 + 7","def helper(self, rowIndex, colIndex, k):
        
        key = (rowIndex, colIndex, k)
        if(key in self.cache): return self.cache[key]
        
        ans = 0
        
        if(k == 1): return self.valid(rowIndex, self.M, colIndex, self.N)
        
        for index in range(rowIndex+1, self.M+1):
            ans += self.valid(rowIndex, index-1, colIndex, self.N) * self.helper(index, colIndex, k-1)
            ans = ans%self.mod
        
        for index in range(colIndex+1, self.N+1):
            ans += self.valid(rowIndex, self.M, colIndex, index-1) * self.helper(rowIndex, index, k-1)
            ans = ans%self.mod

        self.cache[key] = ans
        return ans","(9, 4)","(40, 33)",N,function_definition,ways,,347,2f56c623-ecb7-4f0f-b585-951cfe3b710b
"def helper(self, rowIndex, colIndex, k):
        
        key = (rowIndex, colIndex, k)
        if(key in self.cache): return self.cache[key]
        
        ans = 0
        
        if(k == 1): return self.valid(rowIndex, self.M, colIndex, self.N)
        
        for index in range(rowIndex+1, self.M+1):
            ans += self.valid(rowIndex, index-1, colIndex, self.N) * self.helper(index, colIndex, k-1)
            ans = ans%self.mod
        
        for index in range(colIndex+1, self.N+1):
            ans += self.valid(rowIndex, self.M, colIndex, index-1) * self.helper(rowIndex, index, k-1)
            ans = ans%self.mod

        self.cache[key] = ans
        return ans",WaysToCutPizza.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\WaysToCutPizza.py,module/class_definition-Solution/,Solution,"def ways(self, pizza: List[str], k: int) -> int:
        
        self.pizza = pizza
        self.M = len(pizza) - 1
        self.N = len(pizza[0]) - 1
        self.cache = {}
        
        prefixSum = [[0]*len(pizza[0]) for i in range(len(pizza))]
        
        
        prefixSum[0][0] = 1 if(pizza[0][0]=='A') else 0
        
        for i in range(1, len(pizza[0])): 
            prefixSum[0][i] += prefixSum[0][i-1]
            prefixSum[0][i] += 1 if(pizza[0][i]=='A') else 0
        
        for i in range(1, len(pizza)): 
            prefixSum[i][0] += prefixSum[i-1][0]
            prefixSum[i][0] += 1 if(pizza[i][0]=='A') else 0
        
        
        for i in range(1, len(pizza)):
            for j in range(1, len(pizza[0])):
                prefixSum[i][j] += 1 if(pizza[i][j]=='A') else 0
                prefixSum[i][j] += prefixSum[i-1][j]
                prefixSum[i][j] += prefixSum[i][j-1]
                prefixSum[i][j] -= prefixSum[i-1][j-1]
                
        if(prefixSum[-1][-1]<k): return 0
        
        self.prefixSum = prefixSum
        return self.helper(0,0,k)","def valid(self, rowStart, rowEnd, colStart, colEnd):        
        ans = self.prefixSum[rowEnd][colEnd]
        
        if(rowStart-1 >= 0):
            ans -= self.prefixSum[rowStart-1][colEnd]
            
        if(colStart-1 >= 0):
            ans -= self.prefixSum[rowEnd][colStart-1]
        
        if(rowStart-1 >= 0 and colStart-1 >= 0):
            ans += self.prefixSum[rowStart-1][colStart-1]
        
        return 1 if(ans>0) else 0","(43, 4)","(61, 18)",N,function_definition,helper,,178,8b17ba7c-deed-4629-8fa8-c0f6f48aacd1
"def valid(self, rowStart, rowEnd, colStart, colEnd):        
        ans = self.prefixSum[rowEnd][colEnd]
        
        if(rowStart-1 >= 0):
            ans -= self.prefixSum[rowStart-1][colEnd]
            
        if(colStart-1 >= 0):
            ans -= self.prefixSum[rowEnd][colStart-1]
        
        if(rowStart-1 >= 0 and colStart-1 >= 0):
            ans += self.prefixSum[rowStart-1][colStart-1]
        
        return 1 if(ans>0) else 0",WaysToCutPizza.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\WaysToCutPizza.py,module/class_definition-Solution/,Solution,"def helper(self, rowIndex, colIndex, k):
        
        key = (rowIndex, colIndex, k)
        if(key in self.cache): return self.cache[key]
        
        ans = 0
        
        if(k == 1): return self.valid(rowIndex, self.M, colIndex, self.N)
        
        for index in range(rowIndex+1, self.M+1):
            ans += self.valid(rowIndex, index-1, colIndex, self.N) * self.helper(index, colIndex, k-1)
            ans = ans%self.mod
        
        for index in range(colIndex+1, self.N+1):
            ans += self.valid(rowIndex, self.M, colIndex, index-1) * self.helper(rowIndex, index, k-1)
            ans = ans%self.mod

        self.cache[key] = ans
        return ans",Next sibling does not exist,"(63, 4)","(75, 33)",N,function_definition,valid,,127,939e38ed-c4c8-4c45-a9b0-48e35d22768e
"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.isWord = False
    
    def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True
    
    def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return True if node.isWord else False
            
            ch = s[index]
            if(ch not in node.childern): return False
            node = node.childern[ch]
            if((node.isWord and helper(index+1, root)) or helper(index+1, node)): return True

        return helper(0, root)
",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(35, 0)",N,module,module,,243,b4b86547-5cff-483e-8d9c-00d665fb36ac
"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.isWord = False
    
    def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True
    
    def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/,module,Previous sibling does not exist,"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return True if node.isWord else False
            
            ch = s[index]
            if(ch not in node.childern): return False
            node = node.childern[ch]
            if((node.isWord and helper(index+1, root)) or helper(index+1, node)): return True

        return helper(0, root)","(0, 0)","(17, 16)",N,class_definition,TrieNode,,115,581a808e-1adb-49d8-b638-463818bc9f0c
"def __init__(self):
        self.childern = {}
        self.isWord = False",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/class_definition-TrieNode/,TrieNode,Previous sibling does not exist,"def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True","(1, 4)","(3, 27)",N,function_definition,__init__,,18,f705b43f-5226-43ff-b500-7990e8aea084
"def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/class_definition-TrieNode/,TrieNode,"def __init__(self):
        self.childern = {}
        self.isWord = False","def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s","(5, 4)","(12, 26)",N,function_definition,add,,49,a5baac36-1020-4fcd-b10d-2ea188493b3e
"def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/class_definition-TrieNode/,TrieNode,"def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True",Next sibling does not exist,"(14, 4)","(17, 16)",N,function_definition,__str__,,39,d572dae9-93c1-41f0-98ce-65cf603afb7a
"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return True if node.isWord else False
            
            ch = s[index]
            if(ch not in node.childern): return False
            node = node.childern[ch]
            if((node.isWord and helper(index+1, root)) or helper(index+1, node)): return True

        return helper(0, root)",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/,module,"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.isWord = False
    
    def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True
    
    def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s",Next sibling does not exist,"(19, 0)","(34, 30)",N,class_definition,Solution,,127,14459628-8ede-4535-9a91-e7e760aea81f
"def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return True if node.isWord else False
            
            ch = s[index]
            if(ch not in node.childern): return False
            node = node.childern[ch]
            if((node.isWord and helper(index+1, root)) or helper(index+1, node)): return True

        return helper(0, root)",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(20, 4)","(34, 30)",N,function_definition,wordBreak,,123,eca5791c-0885-4939-8dfc-5f0454c5ecfc
"@cache
        def helper(index, node):
            if(index == len(s)): 
                return True if node.isWord else False
            
            ch = s[index]
            if(ch not in node.childern): return False
            node = node.childern[ch]
            if((node.isWord and helper(index+1, root)) or helper(index+1, node)): return True",wordBreak.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak.py,module/class_definition-Solution/function_definition-wordBreak/,wordBreak,for word in wordDict: root.add(word),"return helper(0, root)","(24, 8)","(32, 93)",N,function_definition,"def helper(index, node):
            if(index == len(s)): 
                return True if node.isWord else False
            
            ch = s[index]
            if(ch not in node.childern): return False
            node = node.childern[ch]
            if((node.isWord and helper(index+1, root)) or helper(index+1, node)): return True",,78,301797a4-0050-45ed-86b3-c4fc981b806b
"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.isWord = False
    
    def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True
    
    def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s


class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return [""""] if node.isWord else []
            
            ch = s[index]
            if(ch not in node.childern): return []
            node = node.childern[ch]

            ans = []
            if(node.isWord): for sub_str in helper(index+1, root): ans.append(ch + "" "" + sub_str)
            for sub_str in helper(index+1, node): ans.append(ch + sub_str)
            return ans

        return helper(0, root)
",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(41, 0)",Y,module,module,,273,6bfda65e-bb41-477c-aef4-a579e9737af7
"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.isWord = False
    
    def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True
    
    def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/,module,Previous sibling does not exist,"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return [""""] if node.isWord else []
            
            ch = s[index]
            if(ch not in node.childern): return []
            node = node.childern[ch]

            ans = []
            if(node.isWord): for sub_str in helper(index+1, root): ans.append(ch + "" "" + sub_str)
            for sub_str in helper(index+1, node): ans.append(ch + sub_str)
            return ans

        return helper(0, root)","(0, 0)","(17, 16)",N,class_definition,TrieNode,,115,70f93441-440b-4ef6-8ce9-b8bf4cb33305
"def __init__(self):
        self.childern = {}
        self.isWord = False",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/class_definition-TrieNode/,TrieNode,Previous sibling does not exist,"def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True","(1, 4)","(3, 27)",N,function_definition,__init__,,18,bee77443-7a00-4550-b783-6ac7c599bd2a
"def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/class_definition-TrieNode/,TrieNode,"def __init__(self):
        self.childern = {}
        self.isWord = False","def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s","(5, 4)","(12, 26)",N,function_definition,add,,49,d069a1af-8d31-40b0-be9a-5534f01ee23a
"def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/class_definition-TrieNode/,TrieNode,"def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True",Next sibling does not exist,"(14, 4)","(17, 16)",N,function_definition,__str__,,39,aeb98353-2d19-4b34-932e-d60c14499a04
"class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return [""""] if node.isWord else []
            
            ch = s[index]
            if(ch not in node.childern): return []
            node = node.childern[ch]

            ans = []
            if(node.isWord): for sub_str in helper(index+1, root): ans.append(ch + "" "" + sub_str)
            for sub_str in helper(index+1, node): ans.append(ch + sub_str)
            return ans

        return helper(0, root)",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/,module,"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.isWord = False
    
    def add(self, word):
        node = self

        for ch in word:
            if(ch not in node.childern): node.childern[ch] = TrieNode()
            node = node.childern[ch]

        node.isWord = True
    
    def __str__(self):
        s =  """"
        for key in self.childern: s += f"" {key} : [{str(self.childern[key])}] ""
        return s",Next sibling does not exist,"(20, 0)","(40, 30)",Y,class_definition,Solution,,157,86510a3b-5d7a-4615-8445-88ca53e27850
"def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        root = TrieNode()
        for word in wordDict: root.add(word)

        @cache
        def helper(index, node):
            if(index == len(s)): 
                return [""""] if node.isWord else []
            
            ch = s[index]
            if(ch not in node.childern): return []
            node = node.childern[ch]

            ans = []
            if(node.isWord): for sub_str in helper(index+1, root): ans.append(ch + "" "" + sub_str)
            for sub_str in helper(index+1, node): ans.append(ch + sub_str)
            return ans

        return helper(0, root)",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(21, 4)","(40, 30)",Y,function_definition,wordBreak,,153,7f0bfe33-cbc4-4b59-841e-54181f83180d
"@cache
        def helper(index, node):
            if(index == len(s)): 
                return [""""] if node.isWord else []
            
            ch = s[index]
            if(ch not in node.childern): return []
            node = node.childern[ch]

            ans = []
            if(node.isWord): for sub_str in helper(index+1, root): ans.append(ch + "" "" + sub_str)
            for sub_str in helper(index+1, node): ans.append(ch + sub_str)
            return ans",wordBreak2.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\dp\wordBreak2.py,module/class_definition-Solution/function_definition-wordBreak/,wordBreak,for word in wordDict: root.add(word),"return helper(0, root)","(26, 8)","(38, 22)",Y,function_definition,"def helper(index, node):
            if(index == len(s)): 
                return [""""] if node.isWord else []
            
            ch = s[index]
            if(ch not in node.childern): return []
            node = node.childern[ch]

            ans = []
            if(node.isWord): for sub_str in helper(index+1, root): ans.append(ch + "" "" + sub_str)
            for sub_str in helper(index+1, node): ans.append(ch + sub_str)
            return ans",,107,d28976e8-3a27-49a3-8a1d-531cbb35e362
"class FenwickTree:

    def __init__(self, arr) -> None:
        self.arr = arr
        self.fenwickTree = [0] + [i for i in arr]
        self.buildTree()
    

    def buildTree(self):
        for i in range(1, len(self.fenwickTree)):
            parentIndex = i + FenwickTree.lsb(i)
            if(parentIndex<len(self.fenwickTree)): 
                self.fenwickTree[parentIndex] += self.fenwickTree[i]


    def query(self, index):
        index+=1
        ans = 0 
        while(index>0):
            ans += self.fenwickTree[index]
            index -= FenwickTree.lsb(index)
        return ans


    def rangeQuery(self, start, end=None):
        return self.query(end) - self.query(start)

    def update(self, index, new_val):
        prev = self.arr[index]
        index += 1
        while(index<len(self.fenwickTree)):
            self.fenwickTree[index] -= prev
            self.fenwickTree[index] += new_val
            index = index + FenwickTree.lsb(index)

    @staticmethod
    def lsb(num):
        return num ^ (num & (num-1))
    
FenwickTree = FenwickTree([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])
print(FenwickTree.fenwickTree)

print(FenwickTree.query(8))
print(FenwickTree.query(13))
print(FenwickTree.query(15))

FenwickTree.update(8, 19)
print(FenwickTree.fenwickTree)


# print(FenwickTree.lsb(108))
# print(FenwickTree.lsb(104))
# print(FenwickTree.lsb(96))
# print(FenwickTree.lsb(64))
# print(FenwickTree.lsb(0))
",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(55, 0)",N,module,module,,425,3f0f8af6-c774-4f4f-beee-e591b0f91a6a
"class FenwickTree:

    def __init__(self, arr) -> None:
        self.arr = arr
        self.fenwickTree = [0] + [i for i in arr]
        self.buildTree()
    

    def buildTree(self):
        for i in range(1, len(self.fenwickTree)):
            parentIndex = i + FenwickTree.lsb(i)
            if(parentIndex<len(self.fenwickTree)): 
                self.fenwickTree[parentIndex] += self.fenwickTree[i]


    def query(self, index):
        index+=1
        ans = 0 
        while(index>0):
            ans += self.fenwickTree[index]
            index -= FenwickTree.lsb(index)
        return ans


    def rangeQuery(self, start, end=None):
        return self.query(end) - self.query(start)

    def update(self, index, new_val):
        prev = self.arr[index]
        index += 1
        while(index<len(self.fenwickTree)):
            self.fenwickTree[index] -= prev
            self.fenwickTree[index] += new_val
            index = index + FenwickTree.lsb(index)

    @staticmethod
    def lsb(num):
        return num ^ (num & (num-1))",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/,module,Previous sibling does not exist,"FenwickTree = FenwickTree([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])","(0, 0)","(37, 36)",N,class_definition,FenwickTree,,270,4c86b160-1552-44da-8199-c8cf38cd48f2
"def __init__(self, arr) -> None:
        self.arr = arr
        self.fenwickTree = [0] + [i for i in arr]
        self.buildTree()",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/class_definition-FenwickTree/,FenwickTree,Previous sibling does not exist,"def buildTree(self):
        for i in range(1, len(self.fenwickTree)):
            parentIndex = i + FenwickTree.lsb(i)
            if(parentIndex<len(self.fenwickTree)): 
                self.fenwickTree[parentIndex] += self.fenwickTree[i]","(2, 4)","(5, 24)",N,function_definition,__init__,,40,93f47b41-32a2-450d-ad09-553ba3795ba9
"def buildTree(self):
        for i in range(1, len(self.fenwickTree)):
            parentIndex = i + FenwickTree.lsb(i)
            if(parentIndex<len(self.fenwickTree)): 
                self.fenwickTree[parentIndex] += self.fenwickTree[i]",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/class_definition-FenwickTree/,FenwickTree,"def __init__(self, arr) -> None:
        self.arr = arr
        self.fenwickTree = [0] + [i for i in arr]
        self.buildTree()","def query(self, index):
        index+=1
        ans = 0 
        while(index>0):
            ans += self.fenwickTree[index]
            index -= FenwickTree.lsb(index)
        return ans","(8, 4)","(12, 68)",N,function_definition,buildTree,,62,6f8c78e9-e49c-496c-b554-8fa0e9bbb91e
"def query(self, index):
        index+=1
        ans = 0 
        while(index>0):
            ans += self.fenwickTree[index]
            index -= FenwickTree.lsb(index)
        return ans",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/class_definition-FenwickTree/,FenwickTree,"def buildTree(self):
        for i in range(1, len(self.fenwickTree)):
            parentIndex = i + FenwickTree.lsb(i)
            if(parentIndex<len(self.fenwickTree)): 
                self.fenwickTree[parentIndex] += self.fenwickTree[i]","def rangeQuery(self, start, end=None):
        return self.query(end) - self.query(start)","(15, 4)","(21, 18)",N,function_definition,query,,46,9edb912c-d50d-4693-a681-3e1a5fe55fe0
"def rangeQuery(self, start, end=None):
        return self.query(end) - self.query(start)",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/class_definition-FenwickTree/,FenwickTree,"def query(self, index):
        index+=1
        ans = 0 
        while(index>0):
            ans += self.fenwickTree[index]
            index -= FenwickTree.lsb(index)
        return ans","def update(self, index, new_val):
        prev = self.arr[index]
        index += 1
        while(index<len(self.fenwickTree)):
            self.fenwickTree[index] -= prev
            self.fenwickTree[index] += new_val
            index = index + FenwickTree.lsb(index)","(24, 4)","(25, 50)",N,function_definition,rangeQuery,,21,f1be81b0-ae48-4c84-a0df-d21161cfac02
"def update(self, index, new_val):
        prev = self.arr[index]
        index += 1
        while(index<len(self.fenwickTree)):
            self.fenwickTree[index] -= prev
            self.fenwickTree[index] += new_val
            index = index + FenwickTree.lsb(index)",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/class_definition-FenwickTree/,FenwickTree,"def rangeQuery(self, start, end=None):
        return self.query(end) - self.query(start)","@staticmethod
    def lsb(num):
        return num ^ (num & (num-1))","(27, 4)","(33, 50)",N,function_definition,update,,67,7a79392f-0a37-40b6-b171-a0c0e27c888e
"@staticmethod
    def lsb(num):
        return num ^ (num & (num-1))",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/class_definition-FenwickTree/,FenwickTree,"def update(self, index, new_val):
        prev = self.arr[index]
        index += 1
        while(index<len(self.fenwickTree)):
            self.fenwickTree[index] -= prev
            self.fenwickTree[index] += new_val
            index = index + FenwickTree.lsb(index)","FenwickTree = FenwickTree([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])
print(FenwickTree.fenwickTree)
print(FenwickTree.query(8))
print(FenwickTree.query(13))
print(FenwickTree.query(15))
FenwickTree.update(8, 19)
print(FenwickTree.fenwickTree)
# print(FenwickTree.lsb(108))
# print(FenwickTree.lsb(104))
# print(FenwickTree.lsb(96))
# print(FenwickTree.lsb(64))
# print(FenwickTree.lsb(0))","(35, 4)","(37, 36)",N,function_definition,"def lsb(num):
        return num ^ (num & (num-1))",,21,35c299ea-97e1-48d6-86a9-bd26e65d8226
"FenwickTree = FenwickTree([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])
print(FenwickTree.fenwickTree)
print(FenwickTree.query(8))
print(FenwickTree.query(13))
print(FenwickTree.query(15))
FenwickTree.update(8, 19)
print(FenwickTree.fenwickTree)
# print(FenwickTree.lsb(108))
# print(FenwickTree.lsb(104))
# print(FenwickTree.lsb(96))
# print(FenwickTree.lsb(64))
# print(FenwickTree.lsb(0))",FenwickTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\FenwickTree\FenwickTree.py,module/,module,"class FenwickTree:

    def __init__(self, arr) -> None:
        self.arr = arr
        self.fenwickTree = [0] + [i for i in arr]
        self.buildTree()
    

    def buildTree(self):
        for i in range(1, len(self.fenwickTree)):
            parentIndex = i + FenwickTree.lsb(i)
            if(parentIndex<len(self.fenwickTree)): 
                self.fenwickTree[parentIndex] += self.fenwickTree[i]


    def query(self, index):
        index+=1
        ans = 0 
        while(index>0):
            ans += self.fenwickTree[index]
            index -= FenwickTree.lsb(index)
        return ans


    def rangeQuery(self, start, end=None):
        return self.query(end) - self.query(start)

    def update(self, index, new_val):
        prev = self.arr[index]
        index += 1
        while(index<len(self.fenwickTree)):
            self.fenwickTree[index] -= prev
            self.fenwickTree[index] += new_val
            index = index + FenwickTree.lsb(index)

    @staticmethod
    def lsb(num):
        return num ^ (num & (num-1))",Next sibling does not exist,"(39, 0)","(54, 27)",N,"expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,comment,comment,comment,comment,comment",expression_statement,,154,718327fa-8549-424c-bb48-7096c8c26e10
"class Solution {
    List<List<Integer>> list = new ArrayList<List<Integer>>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {    
        dfs(graph, 0, new ArrayList());
        return list;
    }
    
    public void dfs(int[][] graph, int cur, ArrayList<Integer> path){
        path.add(cur);
        if(cur==graph.length-1){
            list.add((ArrayList<Integer>) path.clone());
        }
        for(int i=0;i<graph[cur].length;i++){
            dfs(graph, graph[cur][i], path);
        }
        path.remove(path.size()-1);
    }
    
}
",AllPathsSourceTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AllPathsSourceTarget.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(19, 0)",N,program,program,,129,b5efd55d-0234-4dfd-b5bc-057cbb9319f8
"class Solution {
    List<List<Integer>> list = new ArrayList<List<Integer>>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {    
        dfs(graph, 0, new ArrayList());
        return list;
    }
    
    public void dfs(int[][] graph, int cur, ArrayList<Integer> path){
        path.add(cur);
        if(cur==graph.length-1){
            list.add((ArrayList<Integer>) path.clone());
        }
        for(int i=0;i<graph[cur].length;i++){
            dfs(graph, graph[cur][i], path);
        }
        path.remove(path.size()-1);
    }
    
}",AllPathsSourceTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AllPathsSourceTarget.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 1)",N,class_declaration,Solution,,129,f0e6785a-c009-4138-80b8-67baf6713755
"public List<List<Integer>> allPathsSourceTarget(int[][] graph) {    
        dfs(graph, 0, new ArrayList());
        return list;
    }",AllPathsSourceTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AllPathsSourceTarget.java,program/class_declaration-Solution/,Solution,List<List<Integer>> list = new ArrayList<List<Integer>>();,"public void dfs(int[][] graph, int cur, ArrayList<Integer> path){
        path.add(cur);
        if(cur==graph.length-1){
            list.add((ArrayList<Integer>) path.clone());
        }
        for(int i=0;i<graph[cur].length;i++){
            dfs(graph, graph[cur][i], path);
        }
        path.remove(path.size()-1);
    }","(2, 4)","(5, 5)",N,method_declaration,allPathsSourceTarget,,31,5501c7aa-f9f3-449f-ab57-eb8120cc3e87
"public void dfs(int[][] graph, int cur, ArrayList<Integer> path){
        path.add(cur);
        if(cur==graph.length-1){
            list.add((ArrayList<Integer>) path.clone());
        }
        for(int i=0;i<graph[cur].length;i++){
            dfs(graph, graph[cur][i], path);
        }
        path.remove(path.size()-1);
    }",AllPathsSourceTarget.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AllPathsSourceTarget.java,program/class_declaration-Solution/,Solution,"public List<List<Integer>> allPathsSourceTarget(int[][] graph) {    
        dfs(graph, 0, new ArrayList());
        return list;
    }",Next sibling does not exist,"(7, 4)","(16, 5)",N,method_declaration,dfs,,78,07b320bb-894d-4072-b236-ea7bdd68cbce
"class Point{
    
    public  int x;
    public int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}

class Solution {
    public int maxDistance(int[][] grid) {
        
        Queue<Point> queue = new LinkedList<>();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1) { 
                    queue.add(new Point(i,j));
                    visited[i][j] = true;
                }
            }
        }
        
        int ans = 0;
        int l = queue.size();
        
        if(l== ( grid.length)*(grid[0].length)) return -1;
        
        while(!queue.isEmpty()){
            
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int[] k = dir[i];
                int newRow = cur.x + k[0];
                int newCol = cur.y + k[1];
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol< grid[0].length &&   !visited[newRow][newCol]){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
            }
            
            if(l==0) {
                ans++;
                l = queue.size();
            }
            
        }
        return ans-1;
    }
}
",AsFarFromLandAsPossible.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AsFarFromLandAsPossible.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(58, 0)",N,program,program,,354,97276b0f-2076-41f7-80ea-55525514640b
"class Point{
    
    public  int x;
    public int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}",AsFarFromLandAsPossible.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AsFarFromLandAsPossible.java,program/,program,Previous sibling does not exist,"class Solution {
    public int maxDistance(int[][] grid) {
        
        Queue<Point> queue = new LinkedList<>();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1) { 
                    queue.add(new Point(i,j));
                    visited[i][j] = true;
                }
            }
        }
        
        int ans = 0;
        int l = queue.size();
        
        if(l== ( grid.length)*(grid[0].length)) return -1;
        
        while(!queue.isEmpty()){
            
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int[] k = dir[i];
                int newRow = cur.x + k[0];
                int newCol = cur.y + k[1];
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol< grid[0].length &&   !visited[newRow][newCol]){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
            }
            
            if(l==0) {
                ans++;
                l = queue.size();
            }
            
        }
        return ans-1;
    }
}","(0, 0)","(9, 1)",N,class_declaration,Point,,39,7c46753f-0d11-414f-bef9-611f74decb8a
"Point(int x, int y){
        this.x = x;
        this.y = y;
    }",AsFarFromLandAsPossible.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AsFarFromLandAsPossible.java,program/class_declaration-Point/,Point,public int y;,Next sibling does not exist,"(5, 4)","(8, 5)",N,constructor_declaration,Point,,21,dc47c169-cad5-4cad-9522-83c5a93cfcd7
"class Solution {
    public int maxDistance(int[][] grid) {
        
        Queue<Point> queue = new LinkedList<>();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1) { 
                    queue.add(new Point(i,j));
                    visited[i][j] = true;
                }
            }
        }
        
        int ans = 0;
        int l = queue.size();
        
        if(l== ( grid.length)*(grid[0].length)) return -1;
        
        while(!queue.isEmpty()){
            
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int[] k = dir[i];
                int newRow = cur.x + k[0];
                int newCol = cur.y + k[1];
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol< grid[0].length &&   !visited[newRow][newCol]){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
            }
            
            if(l==0) {
                ans++;
                l = queue.size();
            }
            
        }
        return ans-1;
    }
}",AsFarFromLandAsPossible.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AsFarFromLandAsPossible.java,program/,program,"class Point{
    
    public  int x;
    public int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}",Next sibling does not exist,"(11, 0)","(57, 1)",N,class_declaration,Solution,,315,72c2aa41-4b67-4e5d-b3ff-eb6fd0d6c9e6
"public int maxDistance(int[][] grid) {
        
        Queue<Point> queue = new LinkedList<>();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1) { 
                    queue.add(new Point(i,j));
                    visited[i][j] = true;
                }
            }
        }
        
        int ans = 0;
        int l = queue.size();
        
        if(l== ( grid.length)*(grid[0].length)) return -1;
        
        while(!queue.isEmpty()){
            
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int[] k = dir[i];
                int newRow = cur.x + k[0];
                int newCol = cur.y + k[1];
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol< grid[0].length &&   !visited[newRow][newCol]){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
            }
            
            if(l==0) {
                ans++;
                l = queue.size();
            }
            
        }
        return ans-1;
    }",AsFarFromLandAsPossible.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\AsFarFromLandAsPossible.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(12, 4)","(56, 5)",N,method_declaration,maxDistance,,310,3fb7a11f-e370-480c-a238-f1538f2db88e
"""""""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
""""""

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if(not node): return

        mapper = {}
        def dfs(node):
            if(node.val in mapper): return mapper[node.val]

            new_node = Node(node.val, [])
            mapper[new_node.val] = new_node
            for neigh in node.neighbors: new_node.neighbors.append(dfs(neigh))
            return mapper[new_node.val] 
        
        dfs(node)
        return mapper[node.val]
",cloneGraph.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\cloneGraph.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,module,module,,144,997c7950-6915-4b37-886c-e1af0ff1d1c1
"""""""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
""""""",cloneGraph.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\cloneGraph.py,module/,module,Previous sibling does not exist,"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if(not node): return

        mapper = {}
        def dfs(node):
            if(node.val in mapper): return mapper[node.val]

            new_node = Node(node.val, [])
            mapper[new_node.val] = new_node
            for neigh in node.neighbors: new_node.neighbors.append(dfs(neigh))
            return mapper[new_node.val] 
        
        dfs(node)
        return mapper[node.val]","(0, 0)","(6, 3)",N,expression_statement,expression_statement,,45,1e90b86e-d97b-49c8-9939-c9c2b4755980
"class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if(not node): return

        mapper = {}
        def dfs(node):
            if(node.val in mapper): return mapper[node.val]

            new_node = Node(node.val, [])
            mapper[new_node.val] = new_node
            for neigh in node.neighbors: new_node.neighbors.append(dfs(neigh))
            return mapper[new_node.val] 
        
        dfs(node)
        return mapper[node.val]",cloneGraph.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\cloneGraph.py,module/,module,"""""""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
""""""",Next sibling does not exist,"(8, 0)","(22, 31)",N,class_definition,Solution,,99,bba2ab38-8998-4164-a6dd-c8fe12850347
"def cloneGraph(self, node: 'Node') -> 'Node':
        if(not node): return

        mapper = {}
        def dfs(node):
            if(node.val in mapper): return mapper[node.val]

            new_node = Node(node.val, [])
            mapper[new_node.val] = new_node
            for neigh in node.neighbors: new_node.neighbors.append(dfs(neigh))
            return mapper[new_node.val] 
        
        dfs(node)
        return mapper[node.val]",cloneGraph.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\cloneGraph.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(9, 4)","(22, 31)",N,function_definition,cloneGraph,,95,23b70fe7-a366-4080-9325-8b22418b9191
"def dfs(node):
            if(node.val in mapper): return mapper[node.val]

            new_node = Node(node.val, [])
            mapper[new_node.val] = new_node
            for neigh in node.neighbors: new_node.neighbors.append(dfs(neigh))
            return mapper[new_node.val]",cloneGraph.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\cloneGraph.py,module/class_definition-Solution/function_definition-cloneGraph/,cloneGraph,mapper = {},dfs(node),"(13, 8)","(19, 39)",N,function_definition,dfs,,58,a2c0e5e4-659a-4c88-9758-22b0956a8159
"class Solution {
    
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int ans = 0;
        boolean[][] visited = new boolean[grid1.length][grid1[0].length];
        
        for(int i=0;i<grid2.length;i++){
            for(int j=0;j<grid2[0].length;j++){
                if(grid2[i][j]==1 && !visited[i][j] && dfs(grid1, grid2, i, j, visited)) {
                    ans += 1;
                }
            }
        }
        
        return ans;
    }
    
    public boolean dfs(int[][] grid1, int[][] grid2, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid1.length && sc<grid1[0].length && grid2[sr][sc]==1 && !visited[sr][sc]){
            visited[sr][sc] = true;
            
            boolean isSubIsland = true;
            if(grid1[sr][sc]==0) isSubIsland = false;
            
            isSubIsland =  dfs(grid1, grid2, sr-1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc+1, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr+1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc-1, visited) && isSubIsland;
            
            return isSubIsland;
        } else {
            return true;
        }
    }
    
}
",CountSubIslands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\CountSubIslands.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(36, 0)",N,program,program,,367,41c3f29a-50af-4470-81d9-5819340c39c5
"class Solution {
    
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int ans = 0;
        boolean[][] visited = new boolean[grid1.length][grid1[0].length];
        
        for(int i=0;i<grid2.length;i++){
            for(int j=0;j<grid2[0].length;j++){
                if(grid2[i][j]==1 && !visited[i][j] && dfs(grid1, grid2, i, j, visited)) {
                    ans += 1;
                }
            }
        }
        
        return ans;
    }
    
    public boolean dfs(int[][] grid1, int[][] grid2, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid1.length && sc<grid1[0].length && grid2[sr][sc]==1 && !visited[sr][sc]){
            visited[sr][sc] = true;
            
            boolean isSubIsland = true;
            if(grid1[sr][sc]==0) isSubIsland = false;
            
            isSubIsland =  dfs(grid1, grid2, sr-1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc+1, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr+1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc-1, visited) && isSubIsland;
            
            return isSubIsland;
        } else {
            return true;
        }
    }
    
}",CountSubIslands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\CountSubIslands.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(35, 1)",N,class_declaration,Solution,,367,af80807f-3545-4637-a65a-a11f8b5b1681
"public int countSubIslands(int[][] grid1, int[][] grid2) {
        int ans = 0;
        boolean[][] visited = new boolean[grid1.length][grid1[0].length];
        
        for(int i=0;i<grid2.length;i++){
            for(int j=0;j<grid2[0].length;j++){
                if(grid2[i][j]==1 && !visited[i][j] && dfs(grid1, grid2, i, j, visited)) {
                    ans += 1;
                }
            }
        }
        
        return ans;
    }",CountSubIslands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\CountSubIslands.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public boolean dfs(int[][] grid1, int[][] grid2, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid1.length && sc<grid1[0].length && grid2[sr][sc]==1 && !visited[sr][sc]){
            visited[sr][sc] = true;
            
            boolean isSubIsland = true;
            if(grid1[sr][sc]==0) isSubIsland = false;
            
            isSubIsland =  dfs(grid1, grid2, sr-1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc+1, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr+1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc-1, visited) && isSubIsland;
            
            return isSubIsland;
        } else {
            return true;
        }
    }","(2, 4)","(15, 5)",N,method_declaration,countSubIslands,,123,596c6cda-0f02-4d92-ad10-cea8998240f3
"public boolean dfs(int[][] grid1, int[][] grid2, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid1.length && sc<grid1[0].length && grid2[sr][sc]==1 && !visited[sr][sc]){
            visited[sr][sc] = true;
            
            boolean isSubIsland = true;
            if(grid1[sr][sc]==0) isSubIsland = false;
            
            isSubIsland =  dfs(grid1, grid2, sr-1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc+1, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr+1, sc, visited) && isSubIsland;
            isSubIsland =  dfs(grid1, grid2, sr, sc-1, visited) && isSubIsland;
            
            return isSubIsland;
        } else {
            return true;
        }
    }",CountSubIslands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\CountSubIslands.java,program/class_declaration-Solution/,Solution,"public int countSubIslands(int[][] grid1, int[][] grid2) {
        int ans = 0;
        boolean[][] visited = new boolean[grid1.length][grid1[0].length];
        
        for(int i=0;i<grid2.length;i++){
            for(int j=0;j<grid2[0].length;j++){
                if(grid2[i][j]==1 && !visited[i][j] && dfs(grid1, grid2, i, j, visited)) {
                    ans += 1;
                }
            }
        }
        
        return ans;
    }",Next sibling does not exist,"(17, 4)","(33, 5)",N,method_declaration,dfs,,235,8521ff43-01f4-484d-a91b-012ab6128d4f
"class Solution:
    
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:

        N = len(graph)
        visited = [False for _ in range(N)]
        isSafe = [None for _ in range(N)]
        stack = set()

        def dfs(node):
            if(node >= N): return False
            
            if(len(graph[node]) == 0):
                visited[node] = True
                isSafe[node] = True
                return True
            
            if(visited[node]):
                if(node in stack): return False 
                return isSafe[node]

            stack.add(node)
            visited[node] = True
            ans = True
            
            for neigh in graph[node]: 
                ans = ans and dfs(neigh)
            
            isSafe[node] = ans
            stack.remove(node)
            return ans
        
        for index in range(N):
            if(not visited[index]): dfs(index)
        
        # print(isSafe)
        return [i for i in range(N) if(isSafe[i])]


",eventualSafeNodes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\eventualSafeNodes.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(39, 0)",N,module,module,,210,134e978f-bd5e-44ab-b311-46fdd77fb068
"class Solution:
    
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:

        N = len(graph)
        visited = [False for _ in range(N)]
        isSafe = [None for _ in range(N)]
        stack = set()

        def dfs(node):
            if(node >= N): return False
            
            if(len(graph[node]) == 0):
                visited[node] = True
                isSafe[node] = True
                return True
            
            if(visited[node]):
                if(node in stack): return False 
                return isSafe[node]

            stack.add(node)
            visited[node] = True
            ans = True
            
            for neigh in graph[node]: 
                ans = ans and dfs(neigh)
            
            isSafe[node] = ans
            stack.remove(node)
            return ans
        
        for index in range(N):
            if(not visited[index]): dfs(index)
        
        # print(isSafe)
        return [i for i in range(N) if(isSafe[i])]",eventualSafeNodes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\eventualSafeNodes.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(36, 50)",N,class_definition,Solution,,209,cac09a6d-624e-4459-b2d5-07a59c638fbe
"def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:

        N = len(graph)
        visited = [False for _ in range(N)]
        isSafe = [None for _ in range(N)]
        stack = set()

        def dfs(node):
            if(node >= N): return False
            
            if(len(graph[node]) == 0):
                visited[node] = True
                isSafe[node] = True
                return True
            
            if(visited[node]):
                if(node in stack): return False 
                return isSafe[node]

            stack.add(node)
            visited[node] = True
            ans = True
            
            for neigh in graph[node]: 
                ans = ans and dfs(neigh)
            
            isSafe[node] = ans
            stack.remove(node)
            return ans
        
        for index in range(N):
            if(not visited[index]): dfs(index)
        
        # print(isSafe)
        return [i for i in range(N) if(isSafe[i])]",eventualSafeNodes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\eventualSafeNodes.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(2, 4)","(36, 50)",N,function_definition,eventualSafeNodes,,204,bef7cde0-d0f3-4f9d-b381-40eba08a2576
"def dfs(node):
            if(node >= N): return False
            
            if(len(graph[node]) == 0):
                visited[node] = True
                isSafe[node] = True
                return True
            
            if(visited[node]):
                if(node in stack): return False 
                return isSafe[node]

            stack.add(node)
            visited[node] = True
            ans = True
            
            for neigh in graph[node]: 
                ans = ans and dfs(neigh)
            
            isSafe[node] = ans
            stack.remove(node)
            return ans",eventualSafeNodes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\eventualSafeNodes.py,module/class_definition-Solution/function_definition-eventualSafeNodes/,eventualSafeNodes,stack = set(),"for index in range(N):
            if(not visited[index]): dfs(index)","(9, 8)","(30, 22)",N,function_definition,dfs,,114,b3554df1-c090-4f17-8940-7c9432678ba2
"class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:

        if(len(trust)==0):
            return 1 if n==1 else -1


        out_graph = {}
        in_graph = {}

        for a, b in trust:
            if a not in out_graph: out_graph[a] = set()
            if(b not in in_graph): in_graph[b] = set()

            out_graph[a].add(b)
            in_graph[b].add(a)
        
        for i in range(1, n+1):
            if(i not in out_graph and (i in in_graph and len(in_graph[i])==n-1)):
                return i
        
        return -1
",findJudge.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findJudge.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 0)",N,module,module,,151,38e207b4-c559-4994-ae59-57088455699b
"class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:

        if(len(trust)==0):
            return 1 if n==1 else -1


        out_graph = {}
        in_graph = {}

        for a, b in trust:
            if a not in out_graph: out_graph[a] = set()
            if(b not in in_graph): in_graph[b] = set()

            out_graph[a].add(b)
            in_graph[b].add(a)
        
        for i in range(1, n+1):
            if(i not in out_graph and (i in in_graph and len(in_graph[i])==n-1)):
                return i
        
        return -1",findJudge.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findJudge.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 17)",N,class_definition,Solution,,150,40bf8d06-4778-410b-a545-c6b09f63a954
"def findJudge(self, n: int, trust: List[List[int]]) -> int:

        if(len(trust)==0):
            return 1 if n==1 else -1


        out_graph = {}
        in_graph = {}

        for a, b in trust:
            if a not in out_graph: out_graph[a] = set()
            if(b not in in_graph): in_graph[b] = set()

            out_graph[a].add(b)
            in_graph[b].add(a)
        
        for i in range(1, n+1):
            if(i not in out_graph and (i in in_graph and len(in_graph[i])==n-1)):
                return i
        
        return -1",findJudge.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findJudge.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(21, 17)",N,function_definition,findJudge,,146,a06cfc42-9239-44e5-ac60-29c50cab9d0a
"class Solution:
    def findMaxFish(self, grid: List[List[int]]) -> int:
        
        N = len(grid)
        M = len(grid[0])
        visited = [[False]*M for i in range(N)]
        
        def dfs(row, col):
            if(row<0 or row>=N or col<0 or col>=M or visited[row][col] or grid[row][col] == 0): return 0
            
            visited[row][col] = True
            ans = grid[row][col]
            for dx, dy in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
                newx, newy = row+dx, col+dy
                ans += dfs(newx, newy)
            
            return ans
        
        ans = 0
        for index1 in range(N):
            for index2 in range(M):
                if(not visited[index1][index2] and grid[index1][index2]!=0):
                    sub_ans = dfs(index1, index2)
                    ans = max(ans, sub_ans)
        
        return ans
        
        
",findMaxFish.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findMaxFish.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 0)",N,module,module,,236,f8733195-4ce0-442d-95f0-cae2048b51fd
"class Solution:
    def findMaxFish(self, grid: List[List[int]]) -> int:
        
        N = len(grid)
        M = len(grid[0])
        visited = [[False]*M for i in range(N)]
        
        def dfs(row, col):
            if(row<0 or row>=N or col<0 or col>=M or visited[row][col] or grid[row][col] == 0): return 0
            
            visited[row][col] = True
            ans = grid[row][col]
            for dx, dy in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
                newx, newy = row+dx, col+dy
                ans += dfs(newx, newy)
            
            return ans
        
        ans = 0
        for index1 in range(N):
            for index2 in range(M):
                if(not visited[index1][index2] and grid[index1][index2]!=0):
                    sub_ans = dfs(index1, index2)
                    ans = max(ans, sub_ans)
        
        return ans",findMaxFish.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findMaxFish.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 18)",N,class_definition,Solution,,235,d64f745a-d891-4ff0-bcea-c7f5dec5cf0a
"def findMaxFish(self, grid: List[List[int]]) -> int:
        
        N = len(grid)
        M = len(grid[0])
        visited = [[False]*M for i in range(N)]
        
        def dfs(row, col):
            if(row<0 or row>=N or col<0 or col>=M or visited[row][col] or grid[row][col] == 0): return 0
            
            visited[row][col] = True
            ans = grid[row][col]
            for dx, dy in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
                newx, newy = row+dx, col+dy
                ans += dfs(newx, newy)
            
            return ans
        
        ans = 0
        for index1 in range(N):
            for index2 in range(M):
                if(not visited[index1][index2] and grid[index1][index2]!=0):
                    sub_ans = dfs(index1, index2)
                    ans = max(ans, sub_ans)
        
        return ans",findMaxFish.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findMaxFish.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(25, 18)",N,function_definition,findMaxFish,,231,c1bef88d-8c5d-400f-a314-e8531cb6678a
"def dfs(row, col):
            if(row<0 or row>=N or col<0 or col>=M or visited[row][col] or grid[row][col] == 0): return 0
            
            visited[row][col] = True
            ans = grid[row][col]
            for dx, dy in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
                newx, newy = row+dx, col+dy
                ans += dfs(newx, newy)
            
            return ans",findMaxFish.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\findMaxFish.py,module/class_definition-Solution/function_definition-findMaxFish/,findMaxFish,visited = [[False]*M for i in range(N)],ans = 0,"(7, 8)","(16, 22)",N,function_definition,dfs,,119,72f5e485-eb66-415f-925c-76dbc8268243
"class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        boolean[] visited = new boolean[rooms.size()];
        
        dfs(rooms, 0, visited);
        
        for(boolean x: visited){
            if(!x) return x;
        }
        
        return true;
    }
    
    
    public void dfs(List<List<Integer>> rooms, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int key: rooms.get(cur)){
            dfs(rooms, key, visited);
        }
    }
}
",KeysAndRooms.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\KeysAndRooms.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 0)",N,program,program,,120,873a8463-babc-4979-8732-3d5d214cb215
"class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        boolean[] visited = new boolean[rooms.size()];
        
        dfs(rooms, 0, visited);
        
        for(boolean x: visited){
            if(!x) return x;
        }
        
        return true;
    }
    
    
    public void dfs(List<List<Integer>> rooms, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int key: rooms.get(cur)){
            dfs(rooms, key, visited);
        }
    }
}",KeysAndRooms.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\KeysAndRooms.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 1)",N,class_declaration,Solution,,120,4a8d228a-1ede-48eb-a98e-4884f4f840ff
"public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        boolean[] visited = new boolean[rooms.size()];
        
        dfs(rooms, 0, visited);
        
        for(boolean x: visited){
            if(!x) return x;
        }
        
        return true;
    }",KeysAndRooms.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\KeysAndRooms.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public void dfs(List<List<Integer>> rooms, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int key: rooms.get(cur)){
            dfs(rooms, key, visited);
        }
    }","(1, 4)","(11, 5)",N,method_declaration,canVisitAllRooms,,60,b20a43d1-905d-42cd-8b01-3c88e24da75f
"public void dfs(List<List<Integer>> rooms, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int key: rooms.get(cur)){
            dfs(rooms, key, visited);
        }
    }",KeysAndRooms.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\KeysAndRooms.java,program/class_declaration-Solution/,Solution,"public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        boolean[] visited = new boolean[rooms.size()];
        
        dfs(rooms, 0, visited);
        
        for(boolean x: visited){
            if(!x) return x;
        }
        
        return true;
    }",Next sibling does not exist,"(14, 4)","(20, 5)",N,method_declaration,dfs,,53,3678cc9e-1491-45c4-a83b-f7302d397ef0
"class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        words = {}
        for index, word in enumerate(wordList): words[word] = index
        if(endWord not in words): return 0

        src = -1
        dest = words[endWord]

        if(beginWord not in words): 
            wordList.append(beginWord)
            src = len(wordList)-1
        else:
            src = wordList.index(beginWord)
        
        N = len(wordList)
        graph = {}
        for index in range(N): graph[index] = set()
        

        # O(N * L * 26) ~ O(N * 260) ~ O((1.3)*10**6)
        for wordIndex in range(N):
            word = wordList[wordIndex]
            for index in range(len(word)):
                for ch in 'abcdefghijklmnopqrstuvwyz':
                    new = word[:index] + ch + word[index+1:]
                    if(new not in words): continue 
                    node = words[new]
                    graph[wordIndex].add(node)
                    graph[node].add(wordIndex)

        # Make it bidirectional bfs
        def bfs(root, dest):
            queue = [root]
            visited = set()
            visited.add(root)
            l = 1
            depth = 1

            while(queue):
                cur = queue.pop(0)
                l -= 1
                if(cur == dest): return depth 

                for neigh in graph[cur]:
                    if(neigh in visited): continue
                    if(neigh == dest): return depth+1
                    visited.add(neigh)
                    queue.append(neigh)
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1
        
        def biDirectionalBfs(root, dest):
            queue = [(root, 0), (dest, 1)]
            visited = [{}, {}]
            l = 2
            depth = 1

            while(queue):
                cur, parent = queue.pop(0)
                l -= 1
                if(cur in visited[1^parent]): return depth + visited[1^parent][cur] 

                for neigh in graph[cur]:
                    if(neigh in visited[parent]): continue
                    visited[parent][neigh] = depth
                    queue.append((neigh, parent))
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1

        depth = bfs(src, dest)
        if(depth == -1): return 0
        return depth
",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(82, 0)",N,module,module,,551,5086d10e-ef47-440e-999b-87e9f9eafc55
"class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        words = {}
        for index, word in enumerate(wordList): words[word] = index
        if(endWord not in words): return 0

        src = -1
        dest = words[endWord]

        if(beginWord not in words): 
            wordList.append(beginWord)
            src = len(wordList)-1
        else:
            src = wordList.index(beginWord)
        
        N = len(wordList)
        graph = {}
        for index in range(N): graph[index] = set()
        

        # O(N * L * 26) ~ O(N * 260) ~ O((1.3)*10**6)
        for wordIndex in range(N):
            word = wordList[wordIndex]
            for index in range(len(word)):
                for ch in 'abcdefghijklmnopqrstuvwyz':
                    new = word[:index] + ch + word[index+1:]
                    if(new not in words): continue 
                    node = words[new]
                    graph[wordIndex].add(node)
                    graph[node].add(wordIndex)

        # Make it bidirectional bfs
        def bfs(root, dest):
            queue = [root]
            visited = set()
            visited.add(root)
            l = 1
            depth = 1

            while(queue):
                cur = queue.pop(0)
                l -= 1
                if(cur == dest): return depth 

                for neigh in graph[cur]:
                    if(neigh in visited): continue
                    if(neigh == dest): return depth+1
                    visited.add(neigh)
                    queue.append(neigh)
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1
        
        def biDirectionalBfs(root, dest):
            queue = [(root, 0), (dest, 1)]
            visited = [{}, {}]
            l = 2
            depth = 1

            while(queue):
                cur, parent = queue.pop(0)
                l -= 1
                if(cur in visited[1^parent]): return depth + visited[1^parent][cur] 

                for neigh in graph[cur]:
                    if(neigh in visited[parent]): continue
                    visited[parent][neigh] = depth
                    queue.append((neigh, parent))
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1

        depth = bfs(src, dest)
        if(depth == -1): return 0
        return depth",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(81, 20)",N,class_definition,Solution,,550,fa5c7016-0f5f-4fe4-af92-6c84a5675551
"def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        words = {}
        for index, word in enumerate(wordList): words[word] = index
        if(endWord not in words): return 0

        src = -1
        dest = words[endWord]

        if(beginWord not in words): 
            wordList.append(beginWord)
            src = len(wordList)-1
        else:
            src = wordList.index(beginWord)
        
        N = len(wordList)
        graph = {}
        for index in range(N): graph[index] = set()
        

        # O(N * L * 26) ~ O(N * 260) ~ O((1.3)*10**6)
        for wordIndex in range(N):
            word = wordList[wordIndex]
            for index in range(len(word)):
                for ch in 'abcdefghijklmnopqrstuvwyz':
                    new = word[:index] + ch + word[index+1:]
                    if(new not in words): continue 
                    node = words[new]
                    graph[wordIndex].add(node)
                    graph[node].add(wordIndex)

        # Make it bidirectional bfs
        def bfs(root, dest):
            queue = [root]
            visited = set()
            visited.add(root)
            l = 1
            depth = 1

            while(queue):
                cur = queue.pop(0)
                l -= 1
                if(cur == dest): return depth 

                for neigh in graph[cur]:
                    if(neigh in visited): continue
                    if(neigh == dest): return depth+1
                    visited.add(neigh)
                    queue.append(neigh)
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1
        
        def biDirectionalBfs(root, dest):
            queue = [(root, 0), (dest, 1)]
            visited = [{}, {}]
            l = 2
            depth = 1

            while(queue):
                cur, parent = queue.pop(0)
                l -= 1
                if(cur in visited[1^parent]): return depth + visited[1^parent][cur] 

                for neigh in graph[cur]:
                    if(neigh in visited[parent]): continue
                    visited[parent][neigh] = depth
                    queue.append((neigh, parent))
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1

        depth = bfs(src, dest)
        if(depth == -1): return 0
        return depth",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"words = {}
for index, word in enumerate(wordList): words[word] = index
if(endWord not in words): return 0
src = -1
dest = words[endWord]
if(beginWord not in words): 
            wordList.append(beginWord)
            src = len(wordList)-1
        else:
            src = wordList.index(beginWord)
N = len(wordList)
graph = {}
for index in range(N): graph[index] = set()
# O(N * L * 26) ~ O(N * 260) ~ O((1.3)*10**6)
for wordIndex in range(N):
            word = wordList[wordIndex]
            for index in range(len(word)):
                for ch in 'abcdefghijklmnopqrstuvwyz':
                    new = word[:index] + ch + word[index+1:]
                    if(new not in words): continue 
                    node = words[new]
                    graph[wordIndex].add(node)
                    graph[node].add(wordIndex)
# Make it bidirectional bfs","(1, 4)","(81, 20)",N,function_definition,ladderLength,,546,9df02c15-fdbc-458d-8386-a14e94f25691
"words = {}
for index, word in enumerate(wordList): words[word] = index
if(endWord not in words): return 0
src = -1
dest = words[endWord]
if(beginWord not in words): 
            wordList.append(beginWord)
            src = len(wordList)-1
        else:
            src = wordList.index(beginWord)
N = len(wordList)
graph = {}
for index in range(N): graph[index] = set()
# O(N * L * 26) ~ O(N * 260) ~ O((1.3)*10**6)
for wordIndex in range(N):
            word = wordList[wordIndex]
            for index in range(len(word)):
                for ch in 'abcdefghijklmnopqrstuvwyz':
                    new = word[:index] + ch + word[index+1:]
                    if(new not in words): continue 
                    node = words[new]
                    graph[wordIndex].add(node)
                    graph[node].add(wordIndex)
# Make it bidirectional bfs",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,module/class_definition-Solution/function_definition-ladderLength/,ladderLength,Previous sibling does not exist,"def bfs(root, dest):
            queue = [root]
            visited = set()
            visited.add(root)
            l = 1
            depth = 1

            while(queue):
                cur = queue.pop(0)
                l -= 1
                if(cur == dest): return depth 

                for neigh in graph[cur]:
                    if(neigh in visited): continue
                    if(neigh == dest): return depth+1
                    visited.add(neigh)
                    queue.append(neigh)
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1","(3, 8)","(32, 35)",N,"expression_statement,for_statement,if_statement,expression_statement,expression_statement,if_statement,expression_statement,expression_statement,for_statement,comment,for_statement,comment",expression_statement,,206,f469573c-ee12-4653-a6ee-80c760649111
"def bfs(root, dest):
            queue = [root]
            visited = set()
            visited.add(root)
            l = 1
            depth = 1

            while(queue):
                cur = queue.pop(0)
                l -= 1
                if(cur == dest): return depth 

                for neigh in graph[cur]:
                    if(neigh in visited): continue
                    if(neigh == dest): return depth+1
                    visited.add(neigh)
                    queue.append(neigh)
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,module/class_definition-Solution/function_definition-ladderLength/,ladderLength,"words = {}
for index, word in enumerate(wordList): words[word] = index
if(endWord not in words): return 0
src = -1
dest = words[endWord]
if(beginWord not in words): 
            wordList.append(beginWord)
            src = len(wordList)-1
        else:
            src = wordList.index(beginWord)
N = len(wordList)
graph = {}
for index in range(N): graph[index] = set()
# O(N * L * 26) ~ O(N * 260) ~ O((1.3)*10**6)
for wordIndex in range(N):
            word = wordList[wordIndex]
            for index in range(len(word)):
                for ch in 'abcdefghijklmnopqrstuvwyz':
                    new = word[:index] + ch + word[index+1:]
                    if(new not in words): continue 
                    node = words[new]
                    graph[wordIndex].add(node)
                    graph[node].add(wordIndex)
# Make it bidirectional bfs","def biDirectionalBfs(root, dest):
            queue = [(root, 0), (dest, 1)]
            visited = [{}, {}]
            l = 2
            depth = 1

            while(queue):
                cur, parent = queue.pop(0)
                l -= 1
                if(cur in visited[1^parent]): return depth + visited[1^parent][cur] 

                for neigh in graph[cur]:
                    if(neigh in visited[parent]): continue
                    visited[parent][neigh] = depth
                    queue.append((neigh, parent))
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1","(33, 8)","(55, 21)",N,function_definition,bfs,,125,4cba2636-f1eb-4f02-9c90-ec84e57258bb
"def biDirectionalBfs(root, dest):
            queue = [(root, 0), (dest, 1)]
            visited = [{}, {}]
            l = 2
            depth = 1

            while(queue):
                cur, parent = queue.pop(0)
                l -= 1
                if(cur in visited[1^parent]): return depth + visited[1^parent][cur] 

                for neigh in graph[cur]:
                    if(neigh in visited[parent]): continue
                    visited[parent][neigh] = depth
                    queue.append((neigh, parent))
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,module/class_definition-Solution/function_definition-ladderLength/,ladderLength,"def bfs(root, dest):
            queue = [root]
            visited = set()
            visited.add(root)
            l = 1
            depth = 1

            while(queue):
                cur = queue.pop(0)
                l -= 1
                if(cur == dest): return depth 

                for neigh in graph[cur]:
                    if(neigh in visited): continue
                    if(neigh == dest): return depth+1
                    visited.add(neigh)
                    queue.append(neigh)
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1","depth = bfs(src, dest)
if(depth == -1): return 0
return depth","(57, 8)","(77, 21)",N,function_definition,biDirectionalBfs,,146,9c13237d-7911-45a7-b1d5-0cfa7ab86653
"depth = bfs(src, dest)
if(depth == -1): return 0
return depth",ladderLength.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ladderLength.py,module/class_definition-Solution/function_definition-ladderLength/,ladderLength,"def biDirectionalBfs(root, dest):
            queue = [(root, 0), (dest, 1)]
            visited = [{}, {}]
            l = 2
            depth = 1

            while(queue):
                cur, parent = queue.pop(0)
                l -= 1
                if(cur in visited[1^parent]): return depth + visited[1^parent][cur] 

                for neigh in graph[cur]:
                    if(neigh in visited[parent]): continue
                    visited[parent][neigh] = depth
                    queue.append((neigh, parent))
                
                if(l == 0):
                    l = len(queue)
                    depth += 1
            
            return -1",Next sibling does not exist,"(79, 8)","(81, 20)",N,"expression_statement,if_statement,return_statement",expression_statement,,18,68c75725-d102-401b-9ddc-f3ea07ff1827
"import collections


class Solution:

    def __init__(self):
        self.stack = set()
        self.ans = 0
        self.cycleDetected = False
        self.graph = None
        self.colors = None
        self.cache = None


    def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]
    

    def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1

    def largestPathValue(self, colors, edges):

        N = len(colors)

        self.ans = 0
        self.cache = collections.defaultdict(list)
        self.stack = set()
        self.cycleDetected = False
        self.graph = collections.defaultdict(list)
        self.colors = colors
        self.visited = set()

        for source, destination in edges: self.graph[source].append(destination)
        def maximumFrequency(arr): return max(arr)

        for node in range(N):
            if(node not in self.visited):
                self.dfs(node)
                if(self.cycleDetected): return -1
        
        # print(self.cache)
        return self.ans

sol = Solution()
# ans =  sol.largestPathValue(""abaca"", [[0,1],[0,2],[2,3],[3,4]])
ans =  sol.largestPathValue(""a"", [[0,0]])
print(ans)",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(69, 10)",N,module,module,,445,f43d2fd8-249e-42ba-a96f-4bd1a93a43c6
import collections,largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/,module,Previous sibling does not exist,"class Solution:

    def __init__(self):
        self.stack = set()
        self.ans = 0
        self.cycleDetected = False
        self.graph = None
        self.colors = None
        self.cache = None


    def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]
    

    def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1

    def largestPathValue(self, colors, edges):

        N = len(colors)

        self.ans = 0
        self.cache = collections.defaultdict(list)
        self.stack = set()
        self.cycleDetected = False
        self.graph = collections.defaultdict(list)
        self.colors = colors
        self.visited = set()

        for source, destination in edges: self.graph[source].append(destination)
        def maximumFrequency(arr): return max(arr)

        for node in range(N):
            if(node not in self.visited):
                self.dfs(node)
                if(self.cycleDetected): return -1
        
        # print(self.cache)
        return self.ans","(0, 0)","(0, 18)",N,import_statement,import_statement,,2,02eaebc7-1c6f-4588-a704-9c4b5711c0a4
"class Solution:

    def __init__(self):
        self.stack = set()
        self.ans = 0
        self.cycleDetected = False
        self.graph = None
        self.colors = None
        self.cache = None


    def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]
    

    def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1

    def largestPathValue(self, colors, edges):

        N = len(colors)

        self.ans = 0
        self.cache = collections.defaultdict(list)
        self.stack = set()
        self.cycleDetected = False
        self.graph = collections.defaultdict(list)
        self.colors = colors
        self.visited = set()

        for source, destination in edges: self.graph[source].append(destination)
        def maximumFrequency(arr): return max(arr)

        for node in range(N):
            if(node not in self.visited):
                self.dfs(node)
                if(self.cycleDetected): return -1
        
        # print(self.cache)
        return self.ans",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/,module,import collections,sol = Solution(),"(3, 0)","(64, 23)",N,class_definition,Solution,,388,15001489-6871-401a-944d-c089e74d51eb
"def __init__(self):
        self.stack = set()
        self.ans = 0
        self.cycleDetected = False
        self.graph = None
        self.colors = None
        self.cache = None",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]","(5, 4)","(11, 25)",N,function_definition,__init__,,45,c83e343d-d815-4888-a5bc-2db9b1e161a4
"def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/class_definition-Solution/,Solution,"def __init__(self):
        self.stack = set()
        self.ans = 0
        self.cycleDetected = False
        self.graph = None
        self.colors = None
        self.cache = None","def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1","(14, 4)","(35, 31)",N,function_definition,dfs,,156,61b2d81e-988e-468a-9aff-5d8a6a29ae58
"def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/class_definition-Solution/,Solution,"def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]","def largestPathValue(self, colors, edges):

        N = len(colors)

        self.ans = 0
        self.cache = collections.defaultdict(list)
        self.stack = set()
        self.cycleDetected = False
        self.graph = collections.defaultdict(list)
        self.colors = colors
        self.visited = set()

        for source, destination in edges: self.graph[source].append(destination)
        def maximumFrequency(arr): return max(arr)

        for node in range(N):
            if(node not in self.visited):
                self.dfs(node)
                if(self.cycleDetected): return -1
        
        # print(self.cache)
        return self.ans","(38, 4)","(41, 19)",N,function_definition,maxArr,,39,935ce893-2d64-4436-84b2-1ac2a2688752
"def largestPathValue(self, colors, edges):

        N = len(colors)

        self.ans = 0
        self.cache = collections.defaultdict(list)
        self.stack = set()
        self.cycleDetected = False
        self.graph = collections.defaultdict(list)
        self.colors = colors
        self.visited = set()

        for source, destination in edges: self.graph[source].append(destination)
        def maximumFrequency(arr): return max(arr)

        for node in range(N):
            if(node not in self.visited):
                self.dfs(node)
                if(self.cycleDetected): return -1
        
        # print(self.cache)
        return self.ans",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/class_definition-Solution/,Solution,"def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1",Next sibling does not exist,"(43, 4)","(64, 23)",N,function_definition,largestPathValue,,138,1fd237b7-9f76-45ab-888c-02f05f756246
def maximumFrequency(arr): return max(arr),largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/class_definition-Solution/function_definition-largestPathValue/,largestPathValue,"for source, destination in edges: self.graph[source].append(destination)","sol = Solution()
# ans =  sol.largestPathValue(""abaca"", [[0,1],[0,2],[2,3],[3,4]])
ans =  sol.largestPathValue(""a"", [[0,0]])
print(ans)","(56, 8)","(56, 50)",N,function_definition,maximumFrequency,,9,54c2e46c-3b68-4e9a-9491-dd33f07584d6
"sol = Solution()
# ans =  sol.largestPathValue(""abaca"", [[0,1],[0,2],[2,3],[3,4]])
ans =  sol.largestPathValue(""a"", [[0,0]])
print(ans)",largestPathValue.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\largestPathValue.py,module/,module,"class Solution:

    def __init__(self):
        self.stack = set()
        self.ans = 0
        self.cycleDetected = False
        self.graph = None
        self.colors = None
        self.cache = None


    def dfs(self, node):

        if(node in self.stack):
            self.cycleDetected = True 
            return [0 for i in range(26)]

        if(node in self.visited): return self.cache[node]
        
        self.visited.add(node)
        self.stack.add(node)
        nodeVal = ord(self.colors[node]) - 97

        path = [0 for i in range(26)]
        for neigh in self.graph[node]: 
            response = self.dfs(neigh)
            path = self.maxArr(path, response)

        path[nodeVal] += 1
        self.cache[node] = path
        self.ans = max(self.ans, path[nodeVal])                
        self.stack.remove(node)
        return self.cache[node]
    

    def maxArr(self, arr1, arr2):
        for i in range(26):
            arr1[i] = max(arr2[i], arr1[1])
        return arr1

    def largestPathValue(self, colors, edges):

        N = len(colors)

        self.ans = 0
        self.cache = collections.defaultdict(list)
        self.stack = set()
        self.cycleDetected = False
        self.graph = collections.defaultdict(list)
        self.colors = colors
        self.visited = set()

        for source, destination in edges: self.graph[source].append(destination)
        def maximumFrequency(arr): return max(arr)

        for node in range(N):
            if(node not in self.visited):
                self.dfs(node)
                if(self.cycleDetected): return -1
        
        # print(self.cache)
        return self.ans",Next sibling does not exist,"(66, 0)","(69, 10)",N,"expression_statement,comment,expression_statement,expression_statement",expression_statement,,53,4a570c6a-470e-44e3-bd87-818b627babae
"from UnionFind.EquationsPossible import UnionFind


class Solution:
    def latestDayToCross(self, row, col, cells):

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            for index in range(row*col-1, mid-1, -1): uf.add((index // col) + 1, (index % col) + 1)
            # prev = mid

            if(connected()): low = mid
            else: high = mid-1        
        return low


class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(cell):
            row_index, col_index = cell
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            # print(tops, bottoms)
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            print(low, high, mid)

            for index in range(row*col-1, mid-1, -1):
                # print(index, ((index // col) + 1, (index % col) + 1))
                # uf.merge((index // col) + 1, (index % col) + 1)
                # uf.merge(cells[index][0], cells[index][1])
                print(index, cells[index])
                add_node(cells[index])                
                
            print(uf.idx, connected())
            if(connected()): low = mid
            else: high = mid-1        
        
        print(low, high)
        return low",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(99, 18)",N,module,module,,833,e20bc703-d0e9-4737-a9e5-3a7ce3d48bfe
from UnionFind.EquationsPossible import UnionFind,latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/,module,Previous sibling does not exist,"class Solution:
    def latestDayToCross(self, row, col, cells):

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            for index in range(row*col-1, mid-1, -1): uf.add((index // col) + 1, (index % col) + 1)
            # prev = mid

            if(connected()): low = mid
            else: high = mid-1        
        return low","(0, 0)","(0, 49)",N,import_from_statement,import_from_statement,,10,8d48d164-44b6-457a-aa87-e4840d38fa21
"class Solution:
    def latestDayToCross(self, row, col, cells):

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            for index in range(row*col-1, mid-1, -1): uf.add((index // col) + 1, (index % col) + 1)
            # prev = mid

            if(connected()): low = mid
            else: high = mid-1        
        return low",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/,module,from UnionFind.EquationsPossible import UnionFind,"class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(cell):
            row_index, col_index = cell
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            # print(tops, bottoms)
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            print(low, high, mid)

            for index in range(row*col-1, mid-1, -1):
                # print(index, ((index // col) + 1, (index % col) + 1))
                # uf.merge((index // col) + 1, (index % col) + 1)
                # uf.merge(cells[index][0], cells[index][1])
                print(index, cells[index])
                add_node(cells[index])                
                
            print(uf.idx, connected())
            if(connected()): low = mid
            else: high = mid-1        
        
        print(low, high)
        return low","(3, 0)","(44, 18)",N,class_definition,Solution,,364,2d8f115d-bf54-475e-aeed-b2a8a3b573c4
"def latestDayToCross(self, row, col, cells):

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            for index in range(row*col-1, mid-1, -1): uf.add((index // col) + 1, (index % col) + 1)
            # prev = mid

            if(connected()): low = mid
            else: high = mid-1        
        return low",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(4, 4)","(44, 18)",N,function_definition,latestDayToCross,,360,65c3567b-bf15-4f24-adb9-17d6a12b9bd5
"def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/class_definition-Solution/function_definition-latestDayToCross/,latestDayToCross,"dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]","def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False","(13, 8)","(21, 86)",N,function_definition,add_node,,124,7a0e80f1-0ea2-4473-b71e-62f22f013203
"def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/class_definition-Solution/function_definition-latestDayToCross/,latestDayToCross,"def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)",low = 0,"(23, 8)","(31, 24)",N,function_definition,connected,,59,5c7f40c8-34c9-4409-a52e-74ee931de12b
"class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(cell):
            row_index, col_index = cell
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            # print(tops, bottoms)
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            print(low, high, mid)

            for index in range(row*col-1, mid-1, -1):
                # print(index, ((index // col) + 1, (index % col) + 1))
                # uf.merge((index // col) + 1, (index % col) + 1)
                # uf.merge(cells[index][0], cells[index][1])
                print(index, cells[index])
                add_node(cells[index])                
                
            print(uf.idx, connected())
            if(connected()): low = mid
            else: high = mid-1        
        
        print(low, high)
        return low",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/,module,"class Solution:
    def latestDayToCross(self, row, col, cells):

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(row_index, col_index):
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            for index in range(row*col-1, mid-1, -1): uf.add((index // col) + 1, (index % col) + 1)
            # prev = mid

            if(connected()): low = mid
            else: high = mid-1        
        return low",Next sibling does not exist,"(47, 0)","(99, 18)",N,class_definition,Solution,,457,6f743a46-3c62-40e0-bf87-50b7cdd6366f
"def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:

        lands = set()   
        tops = set()
        bottoms = set()

        uf = UnionFind(row*col)
        dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]

        def add_node(cell):
            row_index, col_index = cell
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)

        def connected():
            # print(tops, bottoms)
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False
        
        low = 0
        high = row*col -1
        # prev = row*col

        while(low < high):
            mid = low + (high - low + 1)//2
            print(low, high, mid)

            for index in range(row*col-1, mid-1, -1):
                # print(index, ((index // col) + 1, (index % col) + 1))
                # uf.merge((index // col) + 1, (index % col) + 1)
                # uf.merge(cells[index][0], cells[index][1])
                print(index, cells[index])
                add_node(cells[index])                
                
            print(uf.idx, connected())
            if(connected()): low = mid
            else: high = mid-1        
        
        print(low, high)
        return low",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(48, 4)","(99, 18)",N,function_definition,latestDayToCross,,453,96364426-d2bd-4292-b4ad-a78c9b02cba8
"def add_node(cell):
            row_index, col_index = cell
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/class_definition-Solution/function_definition-latestDayToCross/,latestDayToCross,"dir = [[-1 ,0], [0, 1], [1, 0], [0, -1]]","def connected():
            # print(tops, bottoms)
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False","(57, 8)","(66, 86)",N,function_definition,add_node,,129,7be96192-ed34-4aa0-90b6-6fa4a06ed04b
"def connected():
            # print(tops, bottoms)
            for top_cell in tops:
                _, top = top_cell
                for bottom_cell in bottoms:
                    _, bottom = bottom_cell
                    if(uf.connected(top-1, col*(row-1) + bottom-1)): 
                        return True
            
            return False",latestDayToCross.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\latestDayToCross.py,module/class_definition-Solution/function_definition-latestDayToCross/,latestDayToCross,"def add_node(cell):
            row_index, col_index = cell
            lands.add((row_index, col_index))
            if(row_index == 1): tops.add((row_index, col_index))
            if(row_index == row): bottoms.add((row_index, col_index))
            
            for dx, dy in dir:
                newx, newy = row_index + dx, col_index + dy
                if((newx, newy) not in lands): continue
                uf.merge((row_index-1) * col + col_index -1, (newx-1) * col + newy -1)",low = 0,"(68, 8)","(77, 24)",N,function_definition,connected,,67,6d65c669-1e57-4776-b898-d18f0ea81f52
"class Solution {
    public int longestIncreasingPath(int[][] matrix) {
        
        int[][] ans = new int[matrix.length][matrix[0].length];
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                ans[i][j] = -1;
            }
        }
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                dfs(matrix, ans, i, j);
            }
        }
        
        
        // for(int[] x: ans) System.out.println(Arrays.toString(x));
        
        int max = 0;
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                max = Math.max(max, ans[i][j]);
            }
        }
        
        return max+1;
    }
    
    // 
    
    
    public int dfs(int[][] matrix, int[][] ans, int sr, int sc){
        // System.out.println(""start "" + sr + "" "" + sc);
        
        if(ans[sr][sc]!=-1) return ans[sr][sc];
        
        int[][] dir = new int[][] {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        
        for(int[] x: dir){
            int r = sr + x[0];
            int c = sc + x[1];
            if(r<0 || c<0 || r>=matrix.length || c>=matrix[0].length || matrix[r][c] <= matrix[sr][sc]) continue;
            ans[sr][sc] = Math.max(ans[sr][sc], dfs(matrix, ans, r, c));
        }
        
        // System.out.println(sr + "" "" + sc + "" "" + left + "" "" + right +"" "" + down + "" "" + left);
        ans[sr][sc] += 1;
        
        // System.out.println(""end "" + sr + "" "" + sc);
        return ans[sr][sc];
    }
    
    
    
    
}
",LongestIncreasingPathInAMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\LongestIncreasingPathInAMatrix.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(62, 0)",N,program,program,,468,f38b042a-3348-47cf-8877-43e0944d1343
"class Solution {
    public int longestIncreasingPath(int[][] matrix) {
        
        int[][] ans = new int[matrix.length][matrix[0].length];
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                ans[i][j] = -1;
            }
        }
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                dfs(matrix, ans, i, j);
            }
        }
        
        
        // for(int[] x: ans) System.out.println(Arrays.toString(x));
        
        int max = 0;
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                max = Math.max(max, ans[i][j]);
            }
        }
        
        return max+1;
    }
    
    // 
    
    
    public int dfs(int[][] matrix, int[][] ans, int sr, int sc){
        // System.out.println(""start "" + sr + "" "" + sc);
        
        if(ans[sr][sc]!=-1) return ans[sr][sc];
        
        int[][] dir = new int[][] {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        
        for(int[] x: dir){
            int r = sr + x[0];
            int c = sc + x[1];
            if(r<0 || c<0 || r>=matrix.length || c>=matrix[0].length || matrix[r][c] <= matrix[sr][sc]) continue;
            ans[sr][sc] = Math.max(ans[sr][sc], dfs(matrix, ans, r, c));
        }
        
        // System.out.println(sr + "" "" + sc + "" "" + left + "" "" + right +"" "" + down + "" "" + left);
        ans[sr][sc] += 1;
        
        // System.out.println(""end "" + sr + "" "" + sc);
        return ans[sr][sc];
    }
    
    
    
    
}",LongestIncreasingPathInAMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\LongestIncreasingPathInAMatrix.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(61, 1)",N,class_declaration,Solution,,468,82a07010-f875-4276-87c5-75fe2c832a82
"public int longestIncreasingPath(int[][] matrix) {
        
        int[][] ans = new int[matrix.length][matrix[0].length];
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                ans[i][j] = -1;
            }
        }
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                dfs(matrix, ans, i, j);
            }
        }
        
        
        // for(int[] x: ans) System.out.println(Arrays.toString(x));
        
        int max = 0;
        
        for(int i = 0; i < matrix.length; i++){
            for( int j = 0; j < matrix[0].length; j++){
                max = Math.max(max, ans[i][j]);
            }
        }
        
        return max+1;
    }",LongestIncreasingPathInAMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\LongestIncreasingPathInAMatrix.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,// ,"(1, 4)","(29, 5)",N,method_declaration,longestIncreasingPath,,211,7187a4c8-baf9-493c-a74c-41b97bd1f2d4
"public int dfs(int[][] matrix, int[][] ans, int sr, int sc){
        // System.out.println(""start "" + sr + "" "" + sc);
        
        if(ans[sr][sc]!=-1) return ans[sr][sc];
        
        int[][] dir = new int[][] {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        
        for(int[] x: dir){
            int r = sr + x[0];
            int c = sc + x[1];
            if(r<0 || c<0 || r>=matrix.length || c>=matrix[0].length || matrix[r][c] <= matrix[sr][sc]) continue;
            ans[sr][sc] = Math.max(ans[sr][sc], dfs(matrix, ans, r, c));
        }
        
        // System.out.println(sr + "" "" + sc + "" "" + left + "" "" + right +"" "" + down + "" "" + left);
        ans[sr][sc] += 1;
        
        // System.out.println(""end "" + sr + "" "" + sc);
        return ans[sr][sc];
    }",LongestIncreasingPathInAMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\LongestIncreasingPathInAMatrix.java,program/class_declaration-Solution/,Solution,// ,Next sibling does not exist,"(34, 4)","(56, 5)",N,method_declaration,dfs,,245,35b28229-5055-4c47-9a2d-475bb67572da
"class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        
        N = len(bombs)
        def inRange(index1, index2):
            x1, y1, r1 = bombs[index1]
            x2, y2, r2 = bombs[index2]
            dis = ((x1-x2)**2 + (y1-y2)**2)**(1/2)
            return dis <= r1
        
        graph = defaultdict(list)
        for index1 in range(N):
            for index2 in range(N):
                if(index1 != index2 and inRange(index1, index2)): 
                    graph[index1].append(index2)
        
        
        stack = set()
        def dfs(index):
            if(index in stack): return
            stack.add(index)
            for child in graph[index]: dfs(child)


        ans = 0
        for index1 in range(N):
            stack = set()
            dfs(index1)
            ans = max(ans, len(stack))
        
        return ans
",maximumDetonation.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maximumDetonation.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 0)",N,module,module,,216,6399b537-2200-4ec8-a029-ba5043a632da
"class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        
        N = len(bombs)
        def inRange(index1, index2):
            x1, y1, r1 = bombs[index1]
            x2, y2, r2 = bombs[index2]
            dis = ((x1-x2)**2 + (y1-y2)**2)**(1/2)
            return dis <= r1
        
        graph = defaultdict(list)
        for index1 in range(N):
            for index2 in range(N):
                if(index1 != index2 and inRange(index1, index2)): 
                    graph[index1].append(index2)
        
        
        stack = set()
        def dfs(index):
            if(index in stack): return
            stack.add(index)
            for child in graph[index]: dfs(child)


        ans = 0
        for index1 in range(N):
            stack = set()
            dfs(index1)
            ans = max(ans, len(stack))
        
        return ans",maximumDetonation.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maximumDetonation.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 18)",N,class_definition,Solution,,215,0c499e88-ef43-4ca3-98a7-354b371011d4
"def maximumDetonation(self, bombs: List[List[int]]) -> int:
        
        N = len(bombs)
        def inRange(index1, index2):
            x1, y1, r1 = bombs[index1]
            x2, y2, r2 = bombs[index2]
            dis = ((x1-x2)**2 + (y1-y2)**2)**(1/2)
            return dis <= r1
        
        graph = defaultdict(list)
        for index1 in range(N):
            for index2 in range(N):
                if(index1 != index2 and inRange(index1, index2)): 
                    graph[index1].append(index2)
        
        
        stack = set()
        def dfs(index):
            if(index in stack): return
            stack.add(index)
            for child in graph[index]: dfs(child)


        ans = 0
        for index1 in range(N):
            stack = set()
            dfs(index1)
            ans = max(ans, len(stack))
        
        return ans",maximumDetonation.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maximumDetonation.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(30, 18)",N,function_definition,maximumDetonation,,211,b7507084-8e92-456b-b882-af6690822f3f
"def inRange(index1, index2):
            x1, y1, r1 = bombs[index1]
            x2, y2, r2 = bombs[index2]
            dis = ((x1-x2)**2 + (y1-y2)**2)**(1/2)
            return dis <= r1",maximumDetonation.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maximumDetonation.py,module/class_definition-Solution/function_definition-maximumDetonation/,maximumDetonation,N = len(bombs),graph = defaultdict(list),"(4, 8)","(8, 28)",N,function_definition,inRange,,67,26475a0e-64c4-480d-9f38-c7e26ac706e6
"def dfs(index):
            if(index in stack): return
            stack.add(index)
            for child in graph[index]: dfs(child)",maximumDetonation.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maximumDetonation.py,module/class_definition-Solution/function_definition-maximumDetonation/,maximumDetonation,stack = set(),ans = 0,"(18, 8)","(21, 49)",N,function_definition,dfs,,27,e2544ecb-529d-4d9f-af70-41004997f57b
"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        
        @cache
        def helper(row_index, col_index):
            if(not (0<=row_index and row_index<len(grid) and 0<=col_index and col_index<len(grid[0]))): return 0
            
            ans = 0
            dire = [[-1, 1], [0, 1], [1,1]]
            for dx, dy in dire:
                nx, ny = row_index+dx, col_index+dy
                if(0<=nx and nx<len(grid) and 0<=ny and ny<len(grid[0]) and grid[row_index][col_index]<grid[nx][ny]):
                    sub = 1+helper(nx, ny)
                    ans = max(ans, sub)
            return ans
        
        ans = 0
        for index in range(len(grid)):
            ans = max(ans, helper(index, 0))
        
        return ans
              
",maxMoves_grid.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxMoves_grid.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 0)",N,module,module,,207,88c52ce4-0bb1-41a9-a47f-7d58e7deefa7
"class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        
        @cache
        def helper(row_index, col_index):
            if(not (0<=row_index and row_index<len(grid) and 0<=col_index and col_index<len(grid[0]))): return 0
            
            ans = 0
            dire = [[-1, 1], [0, 1], [1,1]]
            for dx, dy in dire:
                nx, ny = row_index+dx, col_index+dy
                if(0<=nx and nx<len(grid) and 0<=ny and ny<len(grid[0]) and grid[row_index][col_index]<grid[nx][ny]):
                    sub = 1+helper(nx, ny)
                    ans = max(ans, sub)
            return ans
        
        ans = 0
        for index in range(len(grid)):
            ans = max(ans, helper(index, 0))
        
        return ans",maxMoves_grid.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxMoves_grid.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(20, 18)",N,class_definition,Solution,,205,a47d6f1f-ccde-4a8f-807f-3e316627d5de
"def maxMoves(self, grid: List[List[int]]) -> int:
        
        @cache
        def helper(row_index, col_index):
            if(not (0<=row_index and row_index<len(grid) and 0<=col_index and col_index<len(grid[0]))): return 0
            
            ans = 0
            dire = [[-1, 1], [0, 1], [1,1]]
            for dx, dy in dire:
                nx, ny = row_index+dx, col_index+dy
                if(0<=nx and nx<len(grid) and 0<=ny and ny<len(grid[0]) and grid[row_index][col_index]<grid[nx][ny]):
                    sub = 1+helper(nx, ny)
                    ans = max(ans, sub)
            return ans
        
        ans = 0
        for index in range(len(grid)):
            ans = max(ans, helper(index, 0))
        
        return ans",maxMoves_grid.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxMoves_grid.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(20, 18)",N,function_definition,maxMoves,,201,44a81a1c-8dad-4941-b892-202effaf5656
"@cache
        def helper(row_index, col_index):
            if(not (0<=row_index and row_index<len(grid) and 0<=col_index and col_index<len(grid[0]))): return 0
            
            ans = 0
            dire = [[-1, 1], [0, 1], [1,1]]
            for dx, dy in dire:
                nx, ny = row_index+dx, col_index+dy
                if(0<=nx and nx<len(grid) and 0<=ny and ny<len(grid[0]) and grid[row_index][col_index]<grid[nx][ny]):
                    sub = 1+helper(nx, ny)
                    ans = max(ans, sub)
            return ans",maxMoves_grid.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxMoves_grid.py,module/class_definition-Solution/function_definition-maxMoves/,maxMoves,Previous sibling does not exist,ans = 0,"(3, 8)","(14, 22)",N,function_definition,"def helper(row_index, col_index):
            if(not (0<=row_index and row_index<len(grid) and 0<=col_index and col_index<len(grid[0]))): return 0
            
            ans = 0
            dire = [[-1, 1], [0, 1], [1,1]]
            for dx, dy in dire:
                nx, ny = row_index+dx, col_index+dy
                if(0<=nx and nx<len(grid) and 0<=ny and ny<len(grid[0]) and grid[row_index][col_index]<grid[nx][ny]):
                    sub = 1+helper(nx, ny)
                    ans = max(ans, sub)
            return ans",,154,19f6e3d8-83e9-442b-aae1-d77edc20a8c0
"class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:

        graph = defaultdict(list)
        for [src, dest], prob in zip(edges, succProb):
            graph[src].append([dest, prob])
            graph[dest].append([src, prob])

        heap = []
        heapify(heap)
        heappush(heap, (1, start))
        visited = [False for _ in range(n)]

        while(heap):
            prob, node =  heappop(heap)
            if(visited[node]): continue
            visited[node] = True
            
            if(node == end): return 1/prob
            for child, p in graph[node]:
                if(visited[child]): continue 
                heappush(heap, (prob * 1/p, child))
        
        return 0
",maxProbability.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxProbability.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(24, 0)",N,module,module,,189,3c13bec1-c295-4597-af10-bd1b4cd6783a
"class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:

        graph = defaultdict(list)
        for [src, dest], prob in zip(edges, succProb):
            graph[src].append([dest, prob])
            graph[dest].append([src, prob])

        heap = []
        heapify(heap)
        heappush(heap, (1, start))
        visited = [False for _ in range(n)]

        while(heap):
            prob, node =  heappop(heap)
            if(visited[node]): continue
            visited[node] = True
            
            if(node == end): return 1/prob
            for child, p in graph[node]:
                if(visited[child]): continue 
                heappush(heap, (prob * 1/p, child))
        
        return 0",maxProbability.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxProbability.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 16)",N,class_definition,Solution,,188,6923690d-ab6d-4166-abda-3ffe73e3095f
"def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:

        graph = defaultdict(list)
        for [src, dest], prob in zip(edges, succProb):
            graph[src].append([dest, prob])
            graph[dest].append([src, prob])

        heap = []
        heapify(heap)
        heappush(heap, (1, start))
        visited = [False for _ in range(n)]

        while(heap):
            prob, node =  heappop(heap)
            if(visited[node]): continue
            visited[node] = True
            
            if(node == end): return 1/prob
            for child, p in graph[node]:
                if(visited[child]): continue 
                heappush(heap, (prob * 1/p, child))
        
        return 0",maxProbability.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxProbability.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(23, 16)",N,function_definition,maxProbability,,184,75159ca8-31c8-4364-8657-c6ed62d32f85
"from heapq import heappush,heappop,heapify

class Solution:
    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
        
        N = len(vals)
        graph = [[] for i in range(N)]
        
        for edge in edges:
            heappush(graph[edge[0]], -1 * vals[edge[1]])
            heappush(graph[edge[1]], -1 * vals[edge[0]])
        
        
        ans = -10 ** 10
        for i in range(N):
            temp = k
            curSum = vals[i]
            heap = graph[i]
            ans = max(ans, curSum)
            
            
            while(temp>0 and len(heap)>0):
                curSum += -1 * heappop(heap)
                ans = max(ans, curSum)
                temp-=1
        
        return ans
",maxStarSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxStarSum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(27, 0)",N,module,module,,186,eeca2fd2-a33a-419b-a6bb-8b481c71da2c
"from heapq import heappush,heappop,heapify",maxStarSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxStarSum.py,module/,module,Previous sibling does not exist,"class Solution:
    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
        
        N = len(vals)
        graph = [[] for i in range(N)]
        
        for edge in edges:
            heappush(graph[edge[0]], -1 * vals[edge[1]])
            heappush(graph[edge[1]], -1 * vals[edge[0]])
        
        
        ans = -10 ** 10
        for i in range(N):
            temp = k
            curSum = vals[i]
            heap = graph[i]
            ans = max(ans, curSum)
            
            
            while(temp>0 and len(heap)>0):
                curSum += -1 * heappop(heap)
                ans = max(ans, curSum)
                temp-=1
        
        return ans","(0, 0)","(0, 42)",N,import_from_statement,import_from_statement,,13,cede737d-f4aa-4095-ab67-adfc24d43b4a
"class Solution:
    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
        
        N = len(vals)
        graph = [[] for i in range(N)]
        
        for edge in edges:
            heappush(graph[edge[0]], -1 * vals[edge[1]])
            heappush(graph[edge[1]], -1 * vals[edge[0]])
        
        
        ans = -10 ** 10
        for i in range(N):
            temp = k
            curSum = vals[i]
            heap = graph[i]
            ans = max(ans, curSum)
            
            
            while(temp>0 and len(heap)>0):
                curSum += -1 * heappop(heap)
                ans = max(ans, curSum)
                temp-=1
        
        return ans",maxStarSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxStarSum.py,module/,module,"from heapq import heappush,heappop,heapify",Next sibling does not exist,"(2, 0)","(26, 18)",N,class_definition,Solution,,171,fda81545-54c2-449b-85bf-0aa23a2354cd
"def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
        
        N = len(vals)
        graph = [[] for i in range(N)]
        
        for edge in edges:
            heappush(graph[edge[0]], -1 * vals[edge[1]])
            heappush(graph[edge[1]], -1 * vals[edge[0]])
        
        
        ans = -10 ** 10
        for i in range(N):
            temp = k
            curSum = vals[i]
            heap = graph[i]
            ans = max(ans, curSum)
            
            
            while(temp>0 and len(heap)>0):
                curSum += -1 * heappop(heap)
                ans = max(ans, curSum)
                temp-=1
        
        return ans",maxStarSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\maxStarSum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(3, 4)","(26, 18)",N,function_definition,maxStarSum,,167,5532fdd3-19c4-4872-b83b-0a4631ee5a71
"class Solution:
    def minJumps(self, arr: List[int]) -> int:

        graph = collections.defaultdict(list)
        for index, val in enumerate(arr):
            graph[val].append(index)

        queue = [0]
        size = len(queue)
        depth = 0
        visited = [False for i in range(len(arr))]

        while(queue):
            cur = queue.pop(0)
            size -= 1

            if(cur == len(arr)-1): return depth

            if(cur+1<len(arr) and not visited[cur+1]): 
                queue.append(cur+1)
                visited[cur+1] = True

            if(cur-1>=0 and not visited[cur-1]): 
                queue.append(cur-1)
                visited[cur+1] = True

            for idx in graph[arr[cur]]: 
                if(not visited[idx]):
                    queue.append(idx)
                    visited[idx] = True
            
            graph[arr[cur]] = []



            if(size == 0):
                size = len(queue)
                depth += 1
",minJumps_IV.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\minJumps_IV.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(38, 0)",N,module,module,,221,01007375-be07-470b-b621-7a2812cc36d4
"class Solution:
    def minJumps(self, arr: List[int]) -> int:

        graph = collections.defaultdict(list)
        for index, val in enumerate(arr):
            graph[val].append(index)

        queue = [0]
        size = len(queue)
        depth = 0
        visited = [False for i in range(len(arr))]

        while(queue):
            cur = queue.pop(0)
            size -= 1

            if(cur == len(arr)-1): return depth

            if(cur+1<len(arr) and not visited[cur+1]): 
                queue.append(cur+1)
                visited[cur+1] = True

            if(cur-1>=0 and not visited[cur-1]): 
                queue.append(cur-1)
                visited[cur+1] = True

            for idx in graph[arr[cur]]: 
                if(not visited[idx]):
                    queue.append(idx)
                    visited[idx] = True
            
            graph[arr[cur]] = []



            if(size == 0):
                size = len(queue)
                depth += 1",minJumps_IV.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\minJumps_IV.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(37, 26)",N,class_definition,Solution,,220,58f4867e-7eb4-4c24-90e6-bd26f71275c6
"def minJumps(self, arr: List[int]) -> int:

        graph = collections.defaultdict(list)
        for index, val in enumerate(arr):
            graph[val].append(index)

        queue = [0]
        size = len(queue)
        depth = 0
        visited = [False for i in range(len(arr))]

        while(queue):
            cur = queue.pop(0)
            size -= 1

            if(cur == len(arr)-1): return depth

            if(cur+1<len(arr) and not visited[cur+1]): 
                queue.append(cur+1)
                visited[cur+1] = True

            if(cur-1>=0 and not visited[cur-1]): 
                queue.append(cur-1)
                visited[cur+1] = True

            for idx in graph[arr[cur]]: 
                if(not visited[idx]):
                    queue.append(idx)
                    visited[idx] = True
            
            graph[arr[cur]] = []



            if(size == 0):
                size = len(queue)
                depth += 1",minJumps_IV.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\minJumps_IV.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(37, 26)",N,function_definition,minJumps,,216,5fc84f18-66d9-4942-9600-2159bacbd57f
"class Point{
    int x;
    int y;
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}



class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        
        boolean[][] visited = new boolean[maze.length][maze[0].length];
        Queue<Point> queue = new LinkedList<>();
       
        visited[entrance[0]][entrance[1]] = true;
        queue.add(new Point(entrance[0],entrance[1]));
        
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            if(ans==0){}
            else if(cur.x==0 || cur.y ==0 || cur.x == maze.length-1 || cur.y== maze[0].length-1) return ans;
            
            for(int index = 0;index<4;index++){
                int newx = cur.x + dir[index][0];
                int newy = cur.y + dir[index][1];
                
                if(newx>=0 && newy>=0 && newx<maze.length && newy<maze[0].length && !visited[newx][newy] && maze[newx][newy]=='.'){
                        visited[newx][newy] = true;
                        queue.add(new Point(newx, newy));
                }
                
            }
            
            
            if(l==0){
                l = queue.size();
                ans++;
            }
        }
        
        
        return -1;
    }
}
",NearestExitFromEntranceInMaze.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NearestExitFromEntranceInMaze.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(56, 0)",N,program,program,,354,1cdba57b-7c9a-4f91-8faf-e2d332c0204d
"class Point{
    int x;
    int y;
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}",NearestExitFromEntranceInMaze.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NearestExitFromEntranceInMaze.java,program/,program,Previous sibling does not exist,"class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        
        boolean[][] visited = new boolean[maze.length][maze[0].length];
        Queue<Point> queue = new LinkedList<>();
       
        visited[entrance[0]][entrance[1]] = true;
        queue.add(new Point(entrance[0],entrance[1]));
        
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            if(ans==0){}
            else if(cur.x==0 || cur.y ==0 || cur.x == maze.length-1 || cur.y== maze[0].length-1) return ans;
            
            for(int index = 0;index<4;index++){
                int newx = cur.x + dir[index][0];
                int newy = cur.y + dir[index][1];
                
                if(newx>=0 && newy>=0 && newx<maze.length && newy<maze[0].length && !visited[newx][newy] && maze[newx][newy]=='.'){
                        visited[newx][newy] = true;
                        queue.add(new Point(newx, newy));
                }
                
            }
            
            
            if(l==0){
                l = queue.size();
                ans++;
            }
        }
        
        
        return -1;
    }
}","(0, 0)","(7, 1)",N,class_declaration,Point,,34,71fdcf02-bb37-4ea0-a71a-0015cbfb98da
"Point(int x, int y){
        this.x = x;
        this.y = y;
    }",NearestExitFromEntranceInMaze.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NearestExitFromEntranceInMaze.java,program/class_declaration-Point/,Point,int y;,Next sibling does not exist,"(3, 4)","(6, 5)",N,constructor_declaration,Point,,21,d72735c5-db6d-41ff-ba6d-437301c98bfb
"class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        
        boolean[][] visited = new boolean[maze.length][maze[0].length];
        Queue<Point> queue = new LinkedList<>();
       
        visited[entrance[0]][entrance[1]] = true;
        queue.add(new Point(entrance[0],entrance[1]));
        
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            if(ans==0){}
            else if(cur.x==0 || cur.y ==0 || cur.x == maze.length-1 || cur.y== maze[0].length-1) return ans;
            
            for(int index = 0;index<4;index++){
                int newx = cur.x + dir[index][0];
                int newy = cur.y + dir[index][1];
                
                if(newx>=0 && newy>=0 && newx<maze.length && newy<maze[0].length && !visited[newx][newy] && maze[newx][newy]=='.'){
                        visited[newx][newy] = true;
                        queue.add(new Point(newx, newy));
                }
                
            }
            
            
            if(l==0){
                l = queue.size();
                ans++;
            }
        }
        
        
        return -1;
    }
}",NearestExitFromEntranceInMaze.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NearestExitFromEntranceInMaze.java,program/,program,"class Point{
    int x;
    int y;
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
}",Next sibling does not exist,"(11, 0)","(55, 1)",N,class_declaration,Solution,,320,14a00191-001f-439b-a903-b320e93dfc86
"public int nearestExit(char[][] maze, int[] entrance) {
        
        boolean[][] visited = new boolean[maze.length][maze[0].length];
        Queue<Point> queue = new LinkedList<>();
       
        visited[entrance[0]][entrance[1]] = true;
        queue.add(new Point(entrance[0],entrance[1]));
        
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            if(ans==0){}
            else if(cur.x==0 || cur.y ==0 || cur.x == maze.length-1 || cur.y== maze[0].length-1) return ans;
            
            for(int index = 0;index<4;index++){
                int newx = cur.x + dir[index][0];
                int newy = cur.y + dir[index][1];
                
                if(newx>=0 && newy>=0 && newx<maze.length && newy<maze[0].length && !visited[newx][newy] && maze[newx][newy]=='.'){
                        visited[newx][newy] = true;
                        queue.add(new Point(newx, newy));
                }
                
            }
            
            
            if(l==0){
                l = queue.size();
                ans++;
            }
        }
        
        
        return -1;
    }",NearestExitFromEntranceInMaze.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NearestExitFromEntranceInMaze.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(12, 4)","(54, 5)",N,method_declaration,nearestExit,,315,cb7ba3fe-61c5-4f1a-941b-0f743e9f13c6
"class Solution {
    
    public int closedIsland(int[][] grid) {
        
        int ans = 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==0 && !visited[i][j] && helper(grid,i,j,visited)==false) 
                {
                    // System.out.println(i + "" "" + j);
                    ans++;
                }
            }
        }
        
        return ans;
    }
    
    public boolean helper(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length){
            if(grid[sr][sc]==1 || visited[sr][sc]) return false;
            visited[sr][sc] = true;
            boolean ans = helper(grid,sr-1,sc,visited);
            ans = helper(grid,sr,sc+1,visited) || ans;
            ans = helper(grid,sr+1,sc,visited) || ans;
            ans = helper(grid,sr,sc-1,visited) || ans;
            return ans;
        } else {
            return true;
        }
    }
    
    
}
",Number of Closed Islands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\Number of Closed Islands.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(36, 0)",N,program,program,,279,fd3969a6-c75a-4d2b-84f7-8584ddbd0e8f
"class Solution {
    
    public int closedIsland(int[][] grid) {
        
        int ans = 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==0 && !visited[i][j] && helper(grid,i,j,visited)==false) 
                {
                    // System.out.println(i + "" "" + j);
                    ans++;
                }
            }
        }
        
        return ans;
    }
    
    public boolean helper(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length){
            if(grid[sr][sc]==1 || visited[sr][sc]) return false;
            visited[sr][sc] = true;
            boolean ans = helper(grid,sr-1,sc,visited);
            ans = helper(grid,sr,sc+1,visited) || ans;
            ans = helper(grid,sr+1,sc,visited) || ans;
            ans = helper(grid,sr,sc-1,visited) || ans;
            return ans;
        } else {
            return true;
        }
    }
    
    
}",Number of Closed Islands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\Number of Closed Islands.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(35, 1)",N,class_declaration,Solution,,279,98466170-d3ce-498b-84e9-c7691425772b
"public int closedIsland(int[][] grid) {
        
        int ans = 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==0 && !visited[i][j] && helper(grid,i,j,visited)==false) 
                {
                    // System.out.println(i + "" "" + j);
                    ans++;
                }
            }
        }
        
        return ans;
    }",Number of Closed Islands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\Number of Closed Islands.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public boolean helper(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length){
            if(grid[sr][sc]==1 || visited[sr][sc]) return false;
            visited[sr][sc] = true;
            boolean ans = helper(grid,sr-1,sc,visited);
            ans = helper(grid,sr,sc+1,visited) || ans;
            ans = helper(grid,sr+1,sc,visited) || ans;
            ans = helper(grid,sr,sc-1,visited) || ans;
            return ans;
        } else {
            return true;
        }
    }","(2, 4)","(18, 5)",N,method_declaration,closedIsland,,119,e70d1d43-6f00-4608-bdb4-865bd1d9a12e
"public boolean helper(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length){
            if(grid[sr][sc]==1 || visited[sr][sc]) return false;
            visited[sr][sc] = true;
            boolean ans = helper(grid,sr-1,sc,visited);
            ans = helper(grid,sr,sc+1,visited) || ans;
            ans = helper(grid,sr+1,sc,visited) || ans;
            ans = helper(grid,sr,sc-1,visited) || ans;
            return ans;
        } else {
            return true;
        }
    }",Number of Closed Islands.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\Number of Closed Islands.java,program/class_declaration-Solution/,Solution,"public int closedIsland(int[][] grid) {
        
        int ans = 0;
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==0 && !visited[i][j] && helper(grid,i,j,visited)==false) 
                {
                    // System.out.println(i + "" "" + j);
                    ans++;
                }
            }
        }
        
        return ans;
    }",Next sibling does not exist,"(20, 4)","(32, 5)",N,method_declaration,helper,,151,28a85807-6497-4d47-b0bd-eee5a3346d03
"class Solution {
    public int findCircleNum(int[][] isConnected) {
        boolean[] visited = new boolean[isConnected.length];
        int ans = 0;
        for(int i=0; i<isConnected.length;i++){
            if(!visited[i]){
                ans++;
                dfs(isConnected, i, visited);
            }
        }
        
        return ans;
    }
    
    
    
    public void dfs(int[][] isConnected, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int i=0;i<isConnected.length;i++){
            if(isConnected[cur][i]==1){
                dfs(isConnected, i, visited);
               }
        }
    }
}
",NumberOfProvinces.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumberOfProvinces.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(26, 0)",N,program,program,,146,5b413a0a-3b5d-4717-b0a2-090194e86793
"class Solution {
    public int findCircleNum(int[][] isConnected) {
        boolean[] visited = new boolean[isConnected.length];
        int ans = 0;
        for(int i=0; i<isConnected.length;i++){
            if(!visited[i]){
                ans++;
                dfs(isConnected, i, visited);
            }
        }
        
        return ans;
    }
    
    
    
    public void dfs(int[][] isConnected, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int i=0;i<isConnected.length;i++){
            if(isConnected[cur][i]==1){
                dfs(isConnected, i, visited);
               }
        }
    }
}",NumberOfProvinces.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumberOfProvinces.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 1)",N,class_declaration,Solution,,146,1354803b-17c5-4fe1-a94d-6a94a32f0de5
"public int findCircleNum(int[][] isConnected) {
        boolean[] visited = new boolean[isConnected.length];
        int ans = 0;
        for(int i=0; i<isConnected.length;i++){
            if(!visited[i]){
                ans++;
                dfs(isConnected, i, visited);
            }
        }
        
        return ans;
    }",NumberOfProvinces.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumberOfProvinces.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public void dfs(int[][] isConnected, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int i=0;i<isConnected.length;i++){
            if(isConnected[cur][i]==1){
                dfs(isConnected, i, visited);
               }
        }
    }","(1, 4)","(12, 5)",N,method_declaration,findCircleNum,,72,ca66da94-013b-4c75-92a9-94e75ab057df
"public void dfs(int[][] isConnected, int cur, boolean[] visited){
        if(visited[cur]) return;
        visited[cur] = true;
        for(int i=0;i<isConnected.length;i++){
            if(isConnected[cur][i]==1){
                dfs(isConnected, i, visited);
               }
        }
    }",NumberOfProvinces.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumberOfProvinces.java,program/class_declaration-Solution/,Solution,"public int findCircleNum(int[][] isConnected) {
        boolean[] visited = new boolean[isConnected.length];
        int ans = 0;
        for(int i=0; i<isConnected.length;i++){
            if(!visited[i]){
                ans++;
                dfs(isConnected, i, visited);
            }
        }
        
        return ans;
    }",Next sibling does not exist,"(16, 4)","(24, 5)",N,method_declaration,dfs,,67,fee817ea-b9f6-48a6-ad50-6ad10c9aafbf
"class Solution {
    
    boolean isInBoundary = false;
    
    public int numEnclaves(int[][] grid) {
        int ans = 0;
        
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    int cur = dfs(grid, i, j, visited);
                    
                    // System.out.println(i +"" "" + j + "" ""+ cur + isInBoundary);
                    
                    if(!isInBoundary) ans+=cur;
                    isInBoundary=false;
                }
            }
        }
        return ans;
    }
        
    public int dfs(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc >=0 && sr<grid.length && sc<grid[0].length && grid[sr][sc] == 1 && !visited[sr][sc]){
            if(sr==0 || sc ==0 || sr == grid.length-1 || sc==grid[0].length-1) isInBoundary = true;
            visited[sr][sc] = true;
            return 1 + dfs(grid,sr-1,sc,visited) + dfs(grid,sr,sc+1,visited) + dfs(grid,sr+1,sc,visited) + dfs(grid,sr,sc-1,visited);
        } else {
            return 0;
        }
    }
}
",NumEnclaves.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumEnclaves.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(34, 0)",N,program,program,,314,8cc3fd70-7224-459a-9e82-a16681514d28
"class Solution {
    
    boolean isInBoundary = false;
    
    public int numEnclaves(int[][] grid) {
        int ans = 0;
        
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    int cur = dfs(grid, i, j, visited);
                    
                    // System.out.println(i +"" "" + j + "" ""+ cur + isInBoundary);
                    
                    if(!isInBoundary) ans+=cur;
                    isInBoundary=false;
                }
            }
        }
        return ans;
    }
        
    public int dfs(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc >=0 && sr<grid.length && sc<grid[0].length && grid[sr][sc] == 1 && !visited[sr][sc]){
            if(sr==0 || sc ==0 || sr == grid.length-1 || sc==grid[0].length-1) isInBoundary = true;
            visited[sr][sc] = true;
            return 1 + dfs(grid,sr-1,sc,visited) + dfs(grid,sr,sc+1,visited) + dfs(grid,sr+1,sc,visited) + dfs(grid,sr,sc-1,visited);
        } else {
            return 0;
        }
    }
}",NumEnclaves.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumEnclaves.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(33, 1)",N,class_declaration,Solution,,314,00341a10-99ba-44a2-992c-44a8cefe2819
"public int numEnclaves(int[][] grid) {
        int ans = 0;
        
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    int cur = dfs(grid, i, j, visited);
                    
                    // System.out.println(i +"" "" + j + "" ""+ cur + isInBoundary);
                    
                    if(!isInBoundary) ans+=cur;
                    isInBoundary=false;
                }
            }
        }
        return ans;
    }",NumEnclaves.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumEnclaves.java,program/class_declaration-Solution/,Solution,boolean isInBoundary = false;,"public int dfs(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc >=0 && sr<grid.length && sc<grid[0].length && grid[sr][sc] == 1 && !visited[sr][sc]){
            if(sr==0 || sc ==0 || sr == grid.length-1 || sc==grid[0].length-1) isInBoundary = true;
            visited[sr][sc] = true;
            return 1 + dfs(grid,sr-1,sc,visited) + dfs(grid,sr,sc+1,visited) + dfs(grid,sr+1,sc,visited) + dfs(grid,sr,sc-1,visited);
        } else {
            return 0;
        }
    }","(4, 4)","(22, 5)",N,method_declaration,numEnclaves,,134,24a0f865-e611-48c3-ba83-664e525f53b8
"public int dfs(int[][] grid, int sr, int sc, boolean[][] visited){
        if(sr>=0 && sc >=0 && sr<grid.length && sc<grid[0].length && grid[sr][sc] == 1 && !visited[sr][sc]){
            if(sr==0 || sc ==0 || sr == grid.length-1 || sc==grid[0].length-1) isInBoundary = true;
            visited[sr][sc] = true;
            return 1 + dfs(grid,sr-1,sc,visited) + dfs(grid,sr,sc+1,visited) + dfs(grid,sr+1,sc,visited) + dfs(grid,sr,sc-1,visited);
        } else {
            return 0;
        }
    }",NumEnclaves.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\NumEnclaves.java,program/class_declaration-Solution/,Solution,"public int numEnclaves(int[][] grid) {
        int ans = 0;
        
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    int cur = dfs(grid, i, j, visited);
                    
                    // System.out.println(i +"" "" + j + "" ""+ cur + isInBoundary);
                    
                    if(!isInBoundary) ans+=cur;
                    isInBoundary=false;
                }
            }
        }
        return ans;
    }",Next sibling does not exist,"(24, 4)","(32, 5)",N,method_declaration,dfs,,164,46decde6-745d-4ae2-8f20-874e38041042
"class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:

        ans = 0
        N = len(grid)
        M = len(grid[0])

        def dfs(row, col):
            if(row<0 or col<0 or row>=N or col>=M): return True, 0 
            if(grid[row][col] == -1 or grid[row][col] == 0): return False, 0

            grid[row][col] = -1

            onEdge = False
            ans = 1

            for dx, dy in [[-1, 0], [0, 1], [1, 0], [0, -1]]:
                nx, ny = row + dx, col + dy
                a, b = dfs(nx, ny)
                onEdge = onEdge or a
                ans += b
            
            return onEdge, ans

        
        ans = 0
        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == 1):
                    onEdge, count = dfs(row_index, col_index)
                    if(not onEdge): ans += count

        return ans 
",numEnclaves.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\numEnclaves.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(33, 0)",N,module,module,,257,bf1135a6-11e3-4c18-8d9f-8d54655587ce
"class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:

        ans = 0
        N = len(grid)
        M = len(grid[0])

        def dfs(row, col):
            if(row<0 or col<0 or row>=N or col>=M): return True, 0 
            if(grid[row][col] == -1 or grid[row][col] == 0): return False, 0

            grid[row][col] = -1

            onEdge = False
            ans = 1

            for dx, dy in [[-1, 0], [0, 1], [1, 0], [0, -1]]:
                nx, ny = row + dx, col + dy
                a, b = dfs(nx, ny)
                onEdge = onEdge or a
                ans += b
            
            return onEdge, ans

        
        ans = 0
        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == 1):
                    onEdge, count = dfs(row_index, col_index)
                    if(not onEdge): ans += count

        return ans",numEnclaves.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\numEnclaves.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(32, 18)",N,class_definition,Solution,,256,eca03db8-55e7-443d-9f6f-3a42e6616eba
"def numEnclaves(self, grid: List[List[int]]) -> int:

        ans = 0
        N = len(grid)
        M = len(grid[0])

        def dfs(row, col):
            if(row<0 or col<0 or row>=N or col>=M): return True, 0 
            if(grid[row][col] == -1 or grid[row][col] == 0): return False, 0

            grid[row][col] = -1

            onEdge = False
            ans = 1

            for dx, dy in [[-1, 0], [0, 1], [1, 0], [0, -1]]:
                nx, ny = row + dx, col + dy
                a, b = dfs(nx, ny)
                onEdge = onEdge or a
                ans += b
            
            return onEdge, ans

        
        ans = 0
        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == 1):
                    onEdge, count = dfs(row_index, col_index)
                    if(not onEdge): ans += count

        return ans",numEnclaves.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\numEnclaves.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(32, 18)",N,function_definition,numEnclaves,,252,774958a5-c5dc-4410-952d-6390389f18b5
"def dfs(row, col):
            if(row<0 or col<0 or row>=N or col>=M): return True, 0 
            if(grid[row][col] == -1 or grid[row][col] == 0): return False, 0

            grid[row][col] = -1

            onEdge = False
            ans = 1

            for dx, dy in [[-1, 0], [0, 1], [1, 0], [0, -1]]:
                nx, ny = row + dx, col + dy
                a, b = dfs(nx, ny)
                onEdge = onEdge or a
                ans += b
            
            return onEdge, ans",numEnclaves.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\numEnclaves.py,module/class_definition-Solution/function_definition-numEnclaves/,numEnclaves,M = len(grid[0]),ans = 0,"(7, 8)","(22, 30)",N,function_definition,dfs,,152,cdaf88e2-471d-477d-af41-a7a9a87447c5
"class Solution {
    public int orangesRotting(int[][] grid) {
        
        Queue<CoOrdinate> queue = new LinkedList<>();
        int count = 0;
        
        for(int i=0;i<grid.length; i++){
            for(int j=0; j<grid[0].length; j++){
                if(grid[i][j] == 2) queue.add(new CoOrdinate(i,j));
                if(grid[i][j] == 1) count++;
            }
        }
        
        
        int size = queue.size();
        int level = 0;
        int[][] dir = new int[][]{
            {-1,0},
            {0,1},
            {1,0},
            {0,-1}
        };
        
        
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            // System.out.println(level);
            
            CoOrdinate cur = queue.poll();
            size--;
            
            for(int[] x: dir){
                int dx = cur.x + x[0];
                int dy = cur.y + x[1];
                
                if(dx<0 || dy<0 || dx>=grid.length || dy>=grid[0].length || grid[dx][dy]!=1 ) continue;
                
                queue.add(new CoOrdinate(dx, dy));
                grid[dx][dy] = 2;
                count--;
            }
            
            
            if(size==0 && queue.size()>0){
                size = queue.size();
                level++;
            }
        }
        
        return count == 0 ? level : -1;
        
    }
}


class CoOrdinate{
    int x;
    int y;
    
    CoOrdinate(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    
    public String toString(){
        return this.x + "" "" + this.y; 
    }
    
}
",OrangesRotting.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\OrangesRotting.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(71, 0)",N,program,program,,382,acb4c3d3-3414-4bdf-9d4d-27d4537753cf
"class Solution {
    public int orangesRotting(int[][] grid) {
        
        Queue<CoOrdinate> queue = new LinkedList<>();
        int count = 0;
        
        for(int i=0;i<grid.length; i++){
            for(int j=0; j<grid[0].length; j++){
                if(grid[i][j] == 2) queue.add(new CoOrdinate(i,j));
                if(grid[i][j] == 1) count++;
            }
        }
        
        
        int size = queue.size();
        int level = 0;
        int[][] dir = new int[][]{
            {-1,0},
            {0,1},
            {1,0},
            {0,-1}
        };
        
        
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            // System.out.println(level);
            
            CoOrdinate cur = queue.poll();
            size--;
            
            for(int[] x: dir){
                int dx = cur.x + x[0];
                int dy = cur.y + x[1];
                
                if(dx<0 || dy<0 || dx>=grid.length || dy>=grid[0].length || grid[dx][dy]!=1 ) continue;
                
                queue.add(new CoOrdinate(dx, dy));
                grid[dx][dy] = 2;
                count--;
            }
            
            
            if(size==0 && queue.size()>0){
                size = queue.size();
                level++;
            }
        }
        
        return count == 0 ? level : -1;
        
    }
}",OrangesRotting.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\OrangesRotting.java,program/,program,Previous sibling does not exist,"class CoOrdinate{
    int x;
    int y;
    
    CoOrdinate(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    
    public String toString(){
        return this.x + "" "" + this.y; 
    }
    
}","(0, 0)","(53, 1)",N,class_declaration,Solution,,322,af555427-9f86-46ea-a50c-e1e8676b1623
"public int orangesRotting(int[][] grid) {
        
        Queue<CoOrdinate> queue = new LinkedList<>();
        int count = 0;
        
        for(int i=0;i<grid.length; i++){
            for(int j=0; j<grid[0].length; j++){
                if(grid[i][j] == 2) queue.add(new CoOrdinate(i,j));
                if(grid[i][j] == 1) count++;
            }
        }
        
        
        int size = queue.size();
        int level = 0;
        int[][] dir = new int[][]{
            {-1,0},
            {0,1},
            {1,0},
            {0,-1}
        };
        
        
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            // System.out.println(level);
            
            CoOrdinate cur = queue.poll();
            size--;
            
            for(int[] x: dir){
                int dx = cur.x + x[0];
                int dy = cur.y + x[1];
                
                if(dx<0 || dy<0 || dx>=grid.length || dy>=grid[0].length || grid[dx][dy]!=1 ) continue;
                
                queue.add(new CoOrdinate(dx, dy));
                grid[dx][dy] = 2;
                count--;
            }
            
            
            if(size==0 && queue.size()>0){
                size = queue.size();
                level++;
            }
        }
        
        return count == 0 ? level : -1;
        
    }",OrangesRotting.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\OrangesRotting.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(52, 5)",N,method_declaration,orangesRotting,,317,bae4f8f8-b9f1-44a6-b02d-08d6b06ebdd7
"class CoOrdinate{
    int x;
    int y;
    
    CoOrdinate(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    
    public String toString(){
        return this.x + "" "" + this.y; 
    }
    
}",OrangesRotting.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\OrangesRotting.java,program/,program,"class Solution {
    public int orangesRotting(int[][] grid) {
        
        Queue<CoOrdinate> queue = new LinkedList<>();
        int count = 0;
        
        for(int i=0;i<grid.length; i++){
            for(int j=0; j<grid[0].length; j++){
                if(grid[i][j] == 2) queue.add(new CoOrdinate(i,j));
                if(grid[i][j] == 1) count++;
            }
        }
        
        
        int size = queue.size();
        int level = 0;
        int[][] dir = new int[][]{
            {-1,0},
            {0,1},
            {1,0},
            {0,-1}
        };
        
        
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            // System.out.println(level);
            
            CoOrdinate cur = queue.poll();
            size--;
            
            for(int[] x: dir){
                int dx = cur.x + x[0];
                int dy = cur.y + x[1];
                
                if(dx<0 || dy<0 || dx>=grid.length || dy>=grid[0].length || grid[dx][dy]!=1 ) continue;
                
                queue.add(new CoOrdinate(dx, dy));
                grid[dx][dy] = 2;
                count--;
            }
            
            
            if(size==0 && queue.size()>0){
                size = queue.size();
                level++;
            }
        }
        
        return count == 0 ? level : -1;
        
    }
}",Next sibling does not exist,"(56, 0)","(70, 1)",N,class_declaration,CoOrdinate,,60,eac424aa-0fd2-490b-8481-bb0957f956d1
"CoOrdinate(int x, int y){
        this.x = x;
        this.y = y;
    }",OrangesRotting.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\OrangesRotting.java,program/class_declaration-CoOrdinate/,CoOrdinate,int y;,"public String toString(){
        return this.x + "" "" + this.y; 
    }","(60, 4)","(63, 5)",N,constructor_declaration,CoOrdinate,,23,02804ecb-43e5-40a7-a8e9-4e2a5005d73d
"public String toString(){
        return this.x + "" "" + this.y; 
    }",OrangesRotting.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\OrangesRotting.java,program/class_declaration-CoOrdinate/,CoOrdinate,"CoOrdinate(int x, int y){
        this.x = x;
        this.y = y;
    }",Next sibling does not exist,"(66, 4)","(68, 5)",N,method_declaration,toString,,18,ddf26b74-8359-464b-b538-6788282b807c
"class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
        
        ArrayList<Edge>[] graph = new ArrayList[n];
        int[] ans = new int[n];
        Queue<Node> queue = new LinkedList<>();
        
        for(int i=0;i<n;i++) {
            ans[i] = -1;
            graph[i] = new ArrayList<>();
        }

        
        
        for(int i=0;i<redEdges.length;i++){
            graph[redEdges[i][0]].add(new Edge(redEdges[i][0], redEdges[i][1], 0));
        }
        
        for(int i=0;i<blueEdges.length;i++){
            graph[blueEdges[i][0]].add(new Edge(blueEdges[i][0], blueEdges[i][1], 1));
        }
        
        // System.out.println(Arrays.toString(graph));
        
        
        queue.add(new Node(0,-1));
        int l = queue.size();
        int level = 0;
        
        while(!queue.isEmpty()){
            
            Node cur = queue.poll();
            l--;
            if(ans[cur.vtx]==-1) ans[cur.vtx] = level;
            
            for(Edge edge : graph[cur.vtx]){
                if(edge.visited==true) continue;
                
                if(cur.pathColor == 1 && edge.color==0){ queue.add(new Node(edge.end, 0)); edge.visited = true;}
                if(cur.pathColor == 0 && edge.color==1){ queue.add(new Node(edge.end, 1)); edge.visited = true;}
                if(cur.pathColor==-1){ queue.add(new Node(edge.end, edge.color)); edge.visited = true;}
            }
            
            if(l==0){
                // System.out.println(Arrays.toString(graph));
                // System.out.println(queue);
                l = queue.size();
                level++;
            }
        }
        
        return ans;
    }
}

class Node{
    int vtx;
    int pathColor;
    
    Node(int vtx, int pathColor){
        this.vtx = vtx;
        this.pathColor = pathColor;
    }
    
    public String toString(){
        return this.vtx + "" "" + this.pathColor;
    }
    
}

class Edge{
    
    int start;
    int end;
    int color;
    boolean visited;
    
    Edge(int start, int end, int color){
        this.start = start;
        this.end = end;
        this.color = color;
        this.visited = false;
    }
    
    
    public String toString(){
        return this.start + "" "" + this.end + "" "" +this.color + "" ""+ this.visited;
    }
}
",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(89, 0)",N,program,program,,548,3fb598fc-b77a-4901-9364-930be6550c11
"class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
        
        ArrayList<Edge>[] graph = new ArrayList[n];
        int[] ans = new int[n];
        Queue<Node> queue = new LinkedList<>();
        
        for(int i=0;i<n;i++) {
            ans[i] = -1;
            graph[i] = new ArrayList<>();
        }

        
        
        for(int i=0;i<redEdges.length;i++){
            graph[redEdges[i][0]].add(new Edge(redEdges[i][0], redEdges[i][1], 0));
        }
        
        for(int i=0;i<blueEdges.length;i++){
            graph[blueEdges[i][0]].add(new Edge(blueEdges[i][0], blueEdges[i][1], 1));
        }
        
        // System.out.println(Arrays.toString(graph));
        
        
        queue.add(new Node(0,-1));
        int l = queue.size();
        int level = 0;
        
        while(!queue.isEmpty()){
            
            Node cur = queue.poll();
            l--;
            if(ans[cur.vtx]==-1) ans[cur.vtx] = level;
            
            for(Edge edge : graph[cur.vtx]){
                if(edge.visited==true) continue;
                
                if(cur.pathColor == 1 && edge.color==0){ queue.add(new Node(edge.end, 0)); edge.visited = true;}
                if(cur.pathColor == 0 && edge.color==1){ queue.add(new Node(edge.end, 1)); edge.visited = true;}
                if(cur.pathColor==-1){ queue.add(new Node(edge.end, edge.color)); edge.visited = true;}
            }
            
            if(l==0){
                // System.out.println(Arrays.toString(graph));
                // System.out.println(queue);
                l = queue.size();
                level++;
            }
        }
        
        return ans;
    }
}",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/,program,Previous sibling does not exist,"class Node{
    int vtx;
    int pathColor;
    
    Node(int vtx, int pathColor){
        this.vtx = vtx;
        this.pathColor = pathColor;
    }
    
    public String toString(){
        return this.vtx + "" "" + this.pathColor;
    }
    
}","(0, 0)","(53, 1)",N,class_declaration,Solution,,395,6258df20-8f14-4777-9c8b-7af34765bc85
"public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
        
        ArrayList<Edge>[] graph = new ArrayList[n];
        int[] ans = new int[n];
        Queue<Node> queue = new LinkedList<>();
        
        for(int i=0;i<n;i++) {
            ans[i] = -1;
            graph[i] = new ArrayList<>();
        }

        
        
        for(int i=0;i<redEdges.length;i++){
            graph[redEdges[i][0]].add(new Edge(redEdges[i][0], redEdges[i][1], 0));
        }
        
        for(int i=0;i<blueEdges.length;i++){
            graph[blueEdges[i][0]].add(new Edge(blueEdges[i][0], blueEdges[i][1], 1));
        }
        
        // System.out.println(Arrays.toString(graph));
        
        
        queue.add(new Node(0,-1));
        int l = queue.size();
        int level = 0;
        
        while(!queue.isEmpty()){
            
            Node cur = queue.poll();
            l--;
            if(ans[cur.vtx]==-1) ans[cur.vtx] = level;
            
            for(Edge edge : graph[cur.vtx]){
                if(edge.visited==true) continue;
                
                if(cur.pathColor == 1 && edge.color==0){ queue.add(new Node(edge.end, 0)); edge.visited = true;}
                if(cur.pathColor == 0 && edge.color==1){ queue.add(new Node(edge.end, 1)); edge.visited = true;}
                if(cur.pathColor==-1){ queue.add(new Node(edge.end, edge.color)); edge.visited = true;}
            }
            
            if(l==0){
                // System.out.println(Arrays.toString(graph));
                // System.out.println(queue);
                l = queue.size();
                level++;
            }
        }
        
        return ans;
    }",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(52, 5)",N,method_declaration,shortestAlternatingPaths,,390,f624dc1e-ba41-46c3-afaf-1fc127b32227
"class Node{
    int vtx;
    int pathColor;
    
    Node(int vtx, int pathColor){
        this.vtx = vtx;
        this.pathColor = pathColor;
    }
    
    public String toString(){
        return this.vtx + "" "" + this.pathColor;
    }
    
}",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/,program,"class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
        
        ArrayList<Edge>[] graph = new ArrayList[n];
        int[] ans = new int[n];
        Queue<Node> queue = new LinkedList<>();
        
        for(int i=0;i<n;i++) {
            ans[i] = -1;
            graph[i] = new ArrayList<>();
        }

        
        
        for(int i=0;i<redEdges.length;i++){
            graph[redEdges[i][0]].add(new Edge(redEdges[i][0], redEdges[i][1], 0));
        }
        
        for(int i=0;i<blueEdges.length;i++){
            graph[blueEdges[i][0]].add(new Edge(blueEdges[i][0], blueEdges[i][1], 1));
        }
        
        // System.out.println(Arrays.toString(graph));
        
        
        queue.add(new Node(0,-1));
        int l = queue.size();
        int level = 0;
        
        while(!queue.isEmpty()){
            
            Node cur = queue.poll();
            l--;
            if(ans[cur.vtx]==-1) ans[cur.vtx] = level;
            
            for(Edge edge : graph[cur.vtx]){
                if(edge.visited==true) continue;
                
                if(cur.pathColor == 1 && edge.color==0){ queue.add(new Node(edge.end, 0)); edge.visited = true;}
                if(cur.pathColor == 0 && edge.color==1){ queue.add(new Node(edge.end, 1)); edge.visited = true;}
                if(cur.pathColor==-1){ queue.add(new Node(edge.end, edge.color)); edge.visited = true;}
            }
            
            if(l==0){
                // System.out.println(Arrays.toString(graph));
                // System.out.println(queue);
                l = queue.size();
                level++;
            }
        }
        
        return ans;
    }
}","class Edge{
    
    int start;
    int end;
    int color;
    boolean visited;
    
    Edge(int start, int end, int color){
        this.start = start;
        this.end = end;
        this.color = color;
        this.visited = false;
    }
    
    
    public String toString(){
        return this.start + "" "" + this.end + "" "" +this.color + "" ""+ this.visited;
    }
}","(55, 0)","(68, 1)",N,class_declaration,Node,,62,86e3f188-8121-4ba1-b154-d5b2d2d57078
"Node(int vtx, int pathColor){
        this.vtx = vtx;
        this.pathColor = pathColor;
    }",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/class_declaration-Node/,Node,int pathColor;,"public String toString(){
        return this.vtx + "" "" + this.pathColor;
    }","(59, 4)","(62, 5)",N,constructor_declaration,Node,,25,2d88a917-e2ee-4712-9238-32f85e27de50
"public String toString(){
        return this.vtx + "" "" + this.pathColor;
    }",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/class_declaration-Node/,Node,"Node(int vtx, int pathColor){
        this.vtx = vtx;
        this.pathColor = pathColor;
    }",Next sibling does not exist,"(64, 4)","(66, 5)",N,method_declaration,toString,,19,3b946ef4-0e94-4654-ba19-dba99cb8f4f2
"class Edge{
    
    int start;
    int end;
    int color;
    boolean visited;
    
    Edge(int start, int end, int color){
        this.start = start;
        this.end = end;
        this.color = color;
        this.visited = false;
    }
    
    
    public String toString(){
        return this.start + "" "" + this.end + "" "" +this.color + "" ""+ this.visited;
    }
}",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/,program,"class Node{
    int vtx;
    int pathColor;
    
    Node(int vtx, int pathColor){
        this.vtx = vtx;
        this.pathColor = pathColor;
    }
    
    public String toString(){
        return this.vtx + "" "" + this.pathColor;
    }
    
}",Next sibling does not exist,"(70, 0)","(88, 1)",N,class_declaration,Edge,,91,126c29a9-d669-4c40-b7df-2dd2d21584ce
"Edge(int start, int end, int color){
        this.start = start;
        this.end = end;
        this.color = color;
        this.visited = false;
    }",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/class_declaration-Edge/,Edge,boolean visited;,"public String toString(){
        return this.start + "" "" + this.end + "" "" +this.color + "" ""+ this.visited;
    }","(77, 4)","(82, 5)",N,constructor_declaration,Edge,,37,60612f00-4efe-44df-a02f-c171a954f26f
"public String toString(){
        return this.start + "" "" + this.end + "" "" +this.color + "" ""+ this.visited;
    }",ShortestAlternatingPaths.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestAlternatingPaths.java,program/class_declaration-Edge/,Edge,"Edge(int start, int end, int color){
        this.start = start;
        this.end = end;
        this.color = color;
        this.visited = false;
    }",Next sibling does not exist,"(85, 4)","(87, 5)",N,method_declaration,toString,,29,14a0ca5d-5ba8-422a-aee8-a6a579289b35
"class Solution:
    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:

        rgraph = defaultdict(list)
        bgraph = defaultdict(list)

        for src,dest in redEdges: rgraph[src].append(dest)
        for src,dest in blueEdges: bgraph[src].append(dest)
        print(rgraph, bgraph)

        heap = []
        ans = [-1 for i in range(n)]
        rvisited = [False for i in range(n)]
        bvisited = [False for i in range(n)]    
        for node in rgraph[0]: heap.append([node, 1])
        for node in bgraph[0]: heap.append([node, 0])
        dis = 1
        l = len(heap)

        rvisited[0] = True
        bvisited[0] = True
        ans[0] = 0

        # print(heap)
        while(heap):
            node, prevColor = heap.pop(0)
            l -= 1

            if(prevColor == 1):
                visited, nvisited = rvisited, bvisited
                graph = bgraph
            else:
                visited, nvisited = bvisited, rvisited
                graph = rgraph
            
            # print(node, prevColor, dis, ans)
            visited[node] = True

            if(ans[node] == -1): ans[node] = dis
            for neigh in graph[node]:
                if(nvisited[neigh]): continue
                heap.append([neigh, 1 ^ prevColor])

            if(l == 0):
                l = len(heap)
                dis += 1

        return ans

",shortestAlternatingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestAlternatingPaths.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(49, 0)",N,module,module,,360,fb7c421a-6968-4c57-b018-fdf800bbdc23
"class Solution:
    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:

        rgraph = defaultdict(list)
        bgraph = defaultdict(list)

        for src,dest in redEdges: rgraph[src].append(dest)
        for src,dest in blueEdges: bgraph[src].append(dest)
        print(rgraph, bgraph)

        heap = []
        ans = [-1 for i in range(n)]
        rvisited = [False for i in range(n)]
        bvisited = [False for i in range(n)]    
        for node in rgraph[0]: heap.append([node, 1])
        for node in bgraph[0]: heap.append([node, 0])
        dis = 1
        l = len(heap)

        rvisited[0] = True
        bvisited[0] = True
        ans[0] = 0

        # print(heap)
        while(heap):
            node, prevColor = heap.pop(0)
            l -= 1

            if(prevColor == 1):
                visited, nvisited = rvisited, bvisited
                graph = bgraph
            else:
                visited, nvisited = bvisited, rvisited
                graph = rgraph
            
            # print(node, prevColor, dis, ans)
            visited[node] = True

            if(ans[node] == -1): ans[node] = dis
            for neigh in graph[node]:
                if(nvisited[neigh]): continue
                heap.append([neigh, 1 ^ prevColor])

            if(l == 0):
                l = len(heap)
                dis += 1

        return ans",shortestAlternatingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestAlternatingPaths.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(47, 18)",N,class_definition,Solution,,359,d75a23bb-29e9-4727-8374-11f6e5c3b731
"def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:

        rgraph = defaultdict(list)
        bgraph = defaultdict(list)

        for src,dest in redEdges: rgraph[src].append(dest)
        for src,dest in blueEdges: bgraph[src].append(dest)
        print(rgraph, bgraph)

        heap = []
        ans = [-1 for i in range(n)]
        rvisited = [False for i in range(n)]
        bvisited = [False for i in range(n)]    
        for node in rgraph[0]: heap.append([node, 1])
        for node in bgraph[0]: heap.append([node, 0])
        dis = 1
        l = len(heap)

        rvisited[0] = True
        bvisited[0] = True
        ans[0] = 0

        # print(heap)
        while(heap):
            node, prevColor = heap.pop(0)
            l -= 1

            if(prevColor == 1):
                visited, nvisited = rvisited, bvisited
                graph = bgraph
            else:
                visited, nvisited = bvisited, rvisited
                graph = rgraph
            
            # print(node, prevColor, dis, ans)
            visited[node] = True

            if(ans[node] == -1): ans[node] = dis
            for neigh in graph[node]:
                if(nvisited[neigh]): continue
                heap.append([neigh, 1 ^ prevColor])

            if(l == 0):
                l = len(heap)
                dis += 1

        return ans",shortestAlternatingPaths.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestAlternatingPaths.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(47, 18)",N,function_definition,shortestAlternatingPaths,,355,c477c840-8c3c-4b50-b7ba-0978b3257d6b
"class Point{
    int x;
    int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    public String toString(){
        return x + "" "" + y;
    }
}


class Solution {
    
    boolean[][] visited;
    Queue<Point> queue = new LinkedList<>();
        
    
    public int shortestBridge(int[][] grid) {
        
        this.visited = new boolean[grid.length][grid[0].length];
            
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == 1){
                    dfs(grid,i,j);
                    i = grid.length;
                    j = grid[0].length;
                }
            }
        }
        
        // System.out.println(queue);
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int sr = cur.x + dir[i][0];
                int sc = cur.y + dir[i][1];
                
                if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc]){
                    if(grid[sr][sc]==1) return ans;
                    else{
                        visited[sr][sc] = true;
                        queue.add(new Point(sr,sc));
                    }
                }
                
            }
            
            
            if(l==0){
                l=queue.size();
                ans++;
            }
        }
        
        return ans;
        
    }
    
    
    public void dfs(int[][] grid, int sr, int sc){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc] && grid[sr][sc]==1){
            
            queue.add(new Point(sr,sc));
            visited[sr][sc] = true;
            
            dfs(grid, sr-1, sc);
            dfs(grid, sr, sc+1);
            dfs(grid, sr+1, sc);
            dfs(grid, sr, sc-1);
            
        }
    }
    
    
}
",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(89, 0)",N,program,program,,490,3f697be8-1da1-4f45-aea7-a9b3549a3d85
"class Point{
    int x;
    int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    public String toString(){
        return x + "" "" + y;
    }
}",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,program/,program,Previous sibling does not exist,"class Solution {
    
    boolean[][] visited;
    Queue<Point> queue = new LinkedList<>();
        
    
    public int shortestBridge(int[][] grid) {
        
        this.visited = new boolean[grid.length][grid[0].length];
            
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == 1){
                    dfs(grid,i,j);
                    i = grid.length;
                    j = grid[0].length;
                }
            }
        }
        
        // System.out.println(queue);
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int sr = cur.x + dir[i][0];
                int sc = cur.y + dir[i][1];
                
                if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc]){
                    if(grid[sr][sc]==1) return ans;
                    else{
                        visited[sr][sc] = true;
                        queue.add(new Point(sr,sc));
                    }
                }
                
            }
            
            
            if(l==0){
                l=queue.size();
                ans++;
            }
        }
        
        return ans;
        
    }
    
    
    public void dfs(int[][] grid, int sr, int sc){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc] && grid[sr][sc]==1){
            
            queue.add(new Point(sr,sc));
            visited[sr][sc] = true;
            
            dfs(grid, sr-1, sc);
            dfs(grid, sr, sc+1);
            dfs(grid, sr+1, sc);
            dfs(grid, sr, sc-1);
            
        }
    }
    
    
}","(0, 0)","(12, 1)",N,class_declaration,Point,,52,a01e70f8-34b5-497b-8d0c-e0b40dfd877a
"Point(int x, int y){
        this.x = x;
        this.y = y;
    }",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,program/class_declaration-Point/,Point,int y;,"public String toString(){
        return x + "" "" + y;
    }","(4, 4)","(7, 5)",N,constructor_declaration,Point,,21,c347cc98-dd93-4bda-9dd2-f8b46c9bd71c
"public String toString(){
        return x + "" "" + y;
    }",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,program/class_declaration-Point/,Point,"Point(int x, int y){
        this.x = x;
        this.y = y;
    }",Next sibling does not exist,"(9, 4)","(11, 5)",N,method_declaration,toString,,15,3f96455f-dac8-4818-9e1a-c06729138963
"class Solution {
    
    boolean[][] visited;
    Queue<Point> queue = new LinkedList<>();
        
    
    public int shortestBridge(int[][] grid) {
        
        this.visited = new boolean[grid.length][grid[0].length];
            
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == 1){
                    dfs(grid,i,j);
                    i = grid.length;
                    j = grid[0].length;
                }
            }
        }
        
        // System.out.println(queue);
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int sr = cur.x + dir[i][0];
                int sc = cur.y + dir[i][1];
                
                if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc]){
                    if(grid[sr][sc]==1) return ans;
                    else{
                        visited[sr][sc] = true;
                        queue.add(new Point(sr,sc));
                    }
                }
                
            }
            
            
            if(l==0){
                l=queue.size();
                ans++;
            }
        }
        
        return ans;
        
    }
    
    
    public void dfs(int[][] grid, int sr, int sc){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc] && grid[sr][sc]==1){
            
            queue.add(new Point(sr,sc));
            visited[sr][sc] = true;
            
            dfs(grid, sr-1, sc);
            dfs(grid, sr, sc+1);
            dfs(grid, sr+1, sc);
            dfs(grid, sr, sc-1);
            
        }
    }
    
    
}",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,program/,program,"class Point{
    int x;
    int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    public String toString(){
        return x + "" "" + y;
    }
}",Next sibling does not exist,"(15, 0)","(88, 1)",N,class_declaration,Solution,,438,0fe378d1-0e73-423b-b955-8983a0083082
"public int shortestBridge(int[][] grid) {
        
        this.visited = new boolean[grid.length][grid[0].length];
            
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == 1){
                    dfs(grid,i,j);
                    i = grid.length;
                    j = grid[0].length;
                }
            }
        }
        
        // System.out.println(queue);
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int sr = cur.x + dir[i][0];
                int sc = cur.y + dir[i][1];
                
                if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc]){
                    if(grid[sr][sc]==1) return ans;
                    else{
                        visited[sr][sc] = true;
                        queue.add(new Point(sr,sc));
                    }
                }
                
            }
            
            
            if(l==0){
                l=queue.size();
                ans++;
            }
        }
        
        return ans;
        
    }",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,program/class_declaration-Solution/,Solution,Queue<Point> queue = new LinkedList<>();,"public void dfs(int[][] grid, int sr, int sc){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc] && grid[sr][sc]==1){
            
            queue.add(new Point(sr,sc));
            visited[sr][sc] = true;
            
            dfs(grid, sr-1, sc);
            dfs(grid, sr, sc+1);
            dfs(grid, sr+1, sc);
            dfs(grid, sr, sc-1);
            
        }
    }","(21, 4)","(70, 5)",N,method_declaration,shortestBridge,,296,76a98bb3-6ae3-488a-aa49-a2faeb44c159
"public void dfs(int[][] grid, int sr, int sc){
        if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc] && grid[sr][sc]==1){
            
            queue.add(new Point(sr,sc));
            visited[sr][sc] = true;
            
            dfs(grid, sr-1, sc);
            dfs(grid, sr, sc+1);
            dfs(grid, sr+1, sc);
            dfs(grid, sr, sc-1);
            
        }
    }",ShortestBridge.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestBridge.java,program/class_declaration-Solution/,Solution,"public int shortestBridge(int[][] grid) {
        
        this.visited = new boolean[grid.length][grid[0].length];
            
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j] == 1){
                    dfs(grid,i,j);
                    i = grid.length;
                    j = grid[0].length;
                }
            }
        }
        
        // System.out.println(queue);
        
        int ans = 0;
        int l = queue.size();
        int[][] dir = {
            {-1,0},{0,1},{1,0},{0,-1}
        };
        
        while(!queue.isEmpty()){
            Point cur = queue.poll();
            l--;
            
            for(int i=0;i<4;i++){
                int sr = cur.x + dir[i][0];
                int sc = cur.y + dir[i][1];
                
                if(sr>=0 && sc>=0 && sr<grid.length && sc<grid[0].length && !visited[sr][sc]){
                    if(grid[sr][sc]==1) return ans;
                    else{
                        visited[sr][sc] = true;
                        queue.add(new Point(sr,sc));
                    }
                }
                
            }
            
            
            if(l==0){
                l=queue.size();
                ans++;
            }
        }
        
        return ans;
        
    }",Next sibling does not exist,"(73, 4)","(85, 5)",N,method_declaration,dfs,,118,25530ff7-1b70-4d07-b62b-c26f6f90f370
"class Solution {

	public int[] shortestPath(int N,int M, int[][] edges) {
		//Code here
		int[] ans = new int[N];
		for(int i=0;i<N;i++) ans[i] = -1;
		
		ArrayList<ArrayList<Edge>> graph = new ArrayList<>();
		
		for(int i=0; i<N;i++) graph.add(new ArrayList<>());
		
		for(int[] edge:edges){
		    graph.get(edge[0]).add(new Edge(edge[0], edge[1], edge[2]));
		}
		
// 		System.out.println(graph);
		
		boolean[] visited = new boolean[N];
		PriorityQueue<Node> queue = new PriorityQueue<>();
		queue.add(new Node(0, 0));
		
		while(!queue.isEmpty()){
		    Node cur = queue.poll();
		    if(visited[cur.val]) continue;
		    
		    visited[cur.val] = true;
		    ans[cur.val] = cur.distance;
		    
		    for(Edge e: graph.get(cur.val)){
		        if(visited[e.dest]) continue;
		        queue.add(new Node(e.dest, cur.distance + e.distance));
		    }
		}
		
		return ans;
	}
}


class Edge {
    int source;
    int dest;
    int distance;
    
    
    public Edge(int source, int dest, int distance){
        this.source = source;
        this.dest = dest;
        this.distance = distance;
    }
    
    public String toString() {
        return this.source  + "" "" + this.dest + "" "" + this.distance;
    }
    
}


class Node implements Comparable<Node> {
    int val;
    int distance;
    
    public Node(int val, int distance) {
        this.val = val;
        this.distance = distance;
    }
    
    
    public int compareTo(Node o){
        return this.distance - o.distance;
    }
}
",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(72, 0)",N,program,program,,378,3f970907-2869-41ed-9aa6-e6d94a683dbf
"class Solution {

	public int[] shortestPath(int N,int M, int[][] edges) {
		//Code here
		int[] ans = new int[N];
		for(int i=0;i<N;i++) ans[i] = -1;
		
		ArrayList<ArrayList<Edge>> graph = new ArrayList<>();
		
		for(int i=0; i<N;i++) graph.add(new ArrayList<>());
		
		for(int[] edge:edges){
		    graph.get(edge[0]).add(new Edge(edge[0], edge[1], edge[2]));
		}
		
// 		System.out.println(graph);
		
		boolean[] visited = new boolean[N];
		PriorityQueue<Node> queue = new PriorityQueue<>();
		queue.add(new Node(0, 0));
		
		while(!queue.isEmpty()){
		    Node cur = queue.poll();
		    if(visited[cur.val]) continue;
		    
		    visited[cur.val] = true;
		    ans[cur.val] = cur.distance;
		    
		    for(Edge e: graph.get(cur.val)){
		        if(visited[e.dest]) continue;
		        queue.add(new Node(e.dest, cur.distance + e.distance));
		    }
		}
		
		return ans;
	}
}",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/,program,Previous sibling does not exist,"class Edge {
    int source;
    int dest;
    int distance;
    
    
    public Edge(int source, int dest, int distance){
        this.source = source;
        this.dest = dest;
        this.distance = distance;
    }
    
    public String toString() {
        return this.source  + "" "" + this.dest + "" "" + this.distance;
    }
    
}","(0, 0)","(36, 1)",N,class_declaration,Solution,,242,1cd6ebd6-2987-4c56-8d9f-fa884080e9d7
"public int[] shortestPath(int N,int M, int[][] edges) {
		//Code here
		int[] ans = new int[N];
		for(int i=0;i<N;i++) ans[i] = -1;
		
		ArrayList<ArrayList<Edge>> graph = new ArrayList<>();
		
		for(int i=0; i<N;i++) graph.add(new ArrayList<>());
		
		for(int[] edge:edges){
		    graph.get(edge[0]).add(new Edge(edge[0], edge[1], edge[2]));
		}
		
// 		System.out.println(graph);
		
		boolean[] visited = new boolean[N];
		PriorityQueue<Node> queue = new PriorityQueue<>();
		queue.add(new Node(0, 0));
		
		while(!queue.isEmpty()){
		    Node cur = queue.poll();
		    if(visited[cur.val]) continue;
		    
		    visited[cur.val] = true;
		    ans[cur.val] = cur.distance;
		    
		    for(Edge e: graph.get(cur.val)){
		        if(visited[e.dest]) continue;
		        queue.add(new Node(e.dest, cur.distance + e.distance));
		    }
		}
		
		return ans;
	}",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(2, 1)","(35, 2)",N,method_declaration,shortestPath,,238,ad8df85e-6534-466e-95ce-7609aac062e1
"class Edge {
    int source;
    int dest;
    int distance;
    
    
    public Edge(int source, int dest, int distance){
        this.source = source;
        this.dest = dest;
        this.distance = distance;
    }
    
    public String toString() {
        return this.source  + "" "" + this.dest + "" "" + this.distance;
    }
    
}",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/,program,"class Solution {

	public int[] shortestPath(int N,int M, int[][] edges) {
		//Code here
		int[] ans = new int[N];
		for(int i=0;i<N;i++) ans[i] = -1;
		
		ArrayList<ArrayList<Edge>> graph = new ArrayList<>();
		
		for(int i=0; i<N;i++) graph.add(new ArrayList<>());
		
		for(int[] edge:edges){
		    graph.get(edge[0]).add(new Edge(edge[0], edge[1], edge[2]));
		}
		
// 		System.out.println(graph);
		
		boolean[] visited = new boolean[N];
		PriorityQueue<Node> queue = new PriorityQueue<>();
		queue.add(new Node(0, 0));
		
		while(!queue.isEmpty()){
		    Node cur = queue.poll();
		    if(visited[cur.val]) continue;
		    
		    visited[cur.val] = true;
		    ans[cur.val] = cur.distance;
		    
		    for(Edge e: graph.get(cur.val)){
		        if(visited[e.dest]) continue;
		        queue.add(new Node(e.dest, cur.distance + e.distance));
		    }
		}
		
		return ans;
	}
}","class Node implements Comparable<Node> {
    int val;
    int distance;
    
    public Node(int val, int distance) {
        this.val = val;
        this.distance = distance;
    }
    
    
    public int compareTo(Node o){
        return this.distance - o.distance;
    }
}","(39, 0)","(55, 1)",N,class_declaration,Edge,,77,faa5d964-97b4-4bde-87e6-4b121c47e968
"public Edge(int source, int dest, int distance){
        this.source = source;
        this.dest = dest;
        this.distance = distance;
    }",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/class_declaration-Edge/,Edge,int distance;,"public String toString() {
        return this.source  + "" "" + this.dest + "" "" + this.distance;
    }","(45, 4)","(49, 5)",N,constructor_declaration,Edge,,31,f2bc2c30-b22d-4bcf-a111-751a3914f9ed
"public String toString() {
        return this.source  + "" "" + this.dest + "" "" + this.distance;
    }",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/class_declaration-Edge/,Edge,"public Edge(int source, int dest, int distance){
        this.source = source;
        this.dest = dest;
        this.distance = distance;
    }",Next sibling does not exist,"(51, 4)","(53, 5)",N,method_declaration,toString,,25,98237d4b-9fc4-4e10-9daf-8989dd17d438
"class Node implements Comparable<Node> {
    int val;
    int distance;
    
    public Node(int val, int distance) {
        this.val = val;
        this.distance = distance;
    }
    
    
    public int compareTo(Node o){
        return this.distance - o.distance;
    }
}",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/,program,"class Edge {
    int source;
    int dest;
    int distance;
    
    
    public Edge(int source, int dest, int distance){
        this.source = source;
        this.dest = dest;
        this.distance = distance;
    }
    
    public String toString() {
        return this.source  + "" "" + this.dest + "" "" + this.distance;
    }
    
}",Next sibling does not exist,"(58, 0)","(71, 1)",N,class_declaration,Node,,59,c28ad0a8-efba-483d-b20d-66d56f4903aa
"public Node(int val, int distance) {
        this.val = val;
        this.distance = distance;
    }",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/class_declaration-Node/,Node,int distance;,"public int compareTo(Node o){
        return this.distance - o.distance;
    }","(62, 4)","(65, 5)",N,constructor_declaration,Node,,23,f83a0973-0715-4d5a-a117-f64b956b0951
"public int compareTo(Node o){
        return this.distance - o.distance;
    }",ShortestPath.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPath.java,program/class_declaration-Node/,Node,"public Node(int val, int distance) {
        this.val = val;
        this.distance = distance;
    }",Next sibling does not exist,"(68, 4)","(70, 5)",N,method_declaration,compareTo,,16,340c9635-d1bb-4785-892d-48f58284de59
"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()
        best = [INF for _ in range(6)]

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return [INF for _ in range(6)]
            if(node in stack or grid[x][y] == '#'): return [INF for _ in range(6)]
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): 
                return [INF for _ in range(6)]
            
            if(97 <= ord(grid[x][y]) <= 122): 
                keys.add(grid[x][y])
            

            ans = [INF for _ in range(6)]
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in range(6): ans[index] = min(ans[index], d[index] + 1) 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start))
        print(dfs(start))
        return -1 if(ans >= INF) else ans


class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return {}
            if(node in stack or grid[x][y] == '#'): return {}
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): return {}
            if(97 <= ord(grid[x][y]) <= 122): keys.add(grid[x][y])
            

            ans = {}
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in d: 
                    if(index in ans):
                        ans[index] = min(ans[index], d[index] + 1)
                    else:
                        ans[index] = d[index] + 1 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start).values())
        print(dfs(start))
        return -1 if(ans >= INF) else ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(109, 41)",N,module,module,,964,88c5c59f-0f8a-44a0-9f46-9c2f679e114b
"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()
        best = [INF for _ in range(6)]

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return [INF for _ in range(6)]
            if(node in stack or grid[x][y] == '#'): return [INF for _ in range(6)]
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): 
                return [INF for _ in range(6)]
            
            if(97 <= ord(grid[x][y]) <= 122): 
                keys.add(grid[x][y])
            

            ans = [INF for _ in range(6)]
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in range(6): ans[index] = min(ans[index], d[index] + 1) 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start))
        print(dfs(start))
        return -1 if(ans >= INF) else ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,module/,module,Previous sibling does not exist,"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return {}
            if(node in stack or grid[x][y] == '#'): return {}
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): return {}
            if(97 <= ord(grid[x][y]) <= 122): keys.add(grid[x][y])
            

            ans = {}
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in d: 
                    if(index in ans):
                        ans[index] = min(ans[index], d[index] + 1)
                    else:
                        ans[index] = d[index] + 1 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start).values())
        print(dfs(start))
        return -1 if(ans >= INF) else ans","(0, 0)","(53, 41)",N,class_definition,Solution,,495,ae8f6afd-a5c7-41e8-a62d-5a7bbe9cb94b
"def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()
        best = [INF for _ in range(6)]

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return [INF for _ in range(6)]
            if(node in stack or grid[x][y] == '#'): return [INF for _ in range(6)]
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): 
                return [INF for _ in range(6)]
            
            if(97 <= ord(grid[x][y]) <= 122): 
                keys.add(grid[x][y])
            

            ans = [INF for _ in range(6)]
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in range(6): ans[index] = min(ans[index], d[index] + 1) 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start))
        print(dfs(start))
        return -1 if(ans >= INF) else ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(53, 41)",N,function_definition,shortestPathAllKeys,,491,3a49c3cb-ff99-4920-bd8f-070a65685cad
"def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return [INF for _ in range(6)]
            if(node in stack or grid[x][y] == '#'): return [INF for _ in range(6)]
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): 
                return [INF for _ in range(6)]
            
            if(97 <= ord(grid[x][y]) <= 122): 
                keys.add(grid[x][y])
            

            ans = [INF for _ in range(6)]
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in range(6): ans[index] = min(ans[index], d[index] + 1) 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,module/class_definition-Solution/function_definition-shortestPathAllKeys/,shortestPathAllKeys,best = [INF for _ in range(6)],ans = sum(dfs(start)),"(24, 8)","(49, 22)",N,function_definition,dfs,,267,006cb8af-f585-467b-a601-98c1c350b81e
"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return {}
            if(node in stack or grid[x][y] == '#'): return {}
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): return {}
            if(97 <= ord(grid[x][y]) <= 122): keys.add(grid[x][y])
            

            ans = {}
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in d: 
                    if(index in ans):
                        ans[index] = min(ans[index], d[index] + 1)
                    else:
                        ans[index] = d[index] + 1 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start).values())
        print(dfs(start))
        return -1 if(ans >= INF) else ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,module/,module,"class Solution:
    def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()
        best = [INF for _ in range(6)]

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return [INF for _ in range(6)]
            if(node in stack or grid[x][y] == '#'): return [INF for _ in range(6)]
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): 
                return [INF for _ in range(6)]
            
            if(97 <= ord(grid[x][y]) <= 122): 
                keys.add(grid[x][y])
            

            ans = [INF for _ in range(6)]
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in range(6): ans[index] = min(ans[index], d[index] + 1) 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start))
        print(dfs(start))
        return -1 if(ans >= INF) else ans",Next sibling does not exist,"(56, 0)","(109, 41)",N,class_definition,Solution,,468,86bef86c-a501-4ad4-9abd-cccbcde3d13c
"def shortestPathAllKeys(self, grid: List[str]) -> int:

        N = len(grid)
        M = len(grid[0])

        start = None
        k = 0

        for row_index in range(N):
            for col_index in range(M):
                if(grid[row_index][col_index] == '@'):
                    start = (row_index, col_index)
                elif(grid[row_index][col_index] == '.' or grid[row_index][col_index] == '#' or ord(grid[row_index][col_index]) < 97):
                    continue
                elif('a' <= grid[row_index][col_index] <= 'z'):
                    k += 1
        
        INF = 10**10
        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]    
        stack = set()
        keys = set()

        def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return {}
            if(node in stack or grid[x][y] == '#'): return {}
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): return {}
            if(97 <= ord(grid[x][y]) <= 122): keys.add(grid[x][y])
            

            ans = {}
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in d: 
                    if(index in ans):
                        ans[index] = min(ans[index], d[index] + 1)
                    else:
                        ans[index] = d[index] + 1 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans

        ans = sum(dfs(start).values())
        print(dfs(start))
        return -1 if(ans >= INF) else ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(57, 4)","(109, 41)",N,function_definition,shortestPathAllKeys,,464,cf08be7e-67a5-49d6-95fe-714a4f8c77ae
"def dfs(node):
            x, y = node
            if(x < 0 or x >= N or y < 0 or y >= M): return {}
            if(node in stack or grid[x][y] == '#'): return {}
            if(65 <= ord(grid[x][y]) <= 90 and grid[x][y].lower() not in keys): return {}
            if(97 <= ord(grid[x][y]) <= 122): keys.add(grid[x][y])
            

            ans = {}
            stack.add(node)
            for dx, dy in dir:
                newx, newy = x + dx, y + dy
                if((newx, newy) in stack): continue
                
                d = dfs((newx, newy))
                for index in d: 
                    if(index in ans):
                        ans[index] = min(ans[index], d[index] + 1)
                    else:
                        ans[index] = d[index] + 1 

            if(97 <= ord(grid[x][y]) <= 122): 
                keys.remove(grid[x][y])
                ans[ord(grid[x][y]) - 97] = 0
            
            stack.remove(node)
            return ans",shortestPathAllKeys.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\shortestPathAllKeys.py,module/class_definition-Solution/function_definition-shortestPathAllKeys/,shortestPathAllKeys,keys = set(),ans = sum(dfs(start).values()),"(79, 8)","(105, 22)",N,function_definition,dfs,,250,cc8657da-1c05-4c3a-bc8d-d3a8f2e3fbd2
"class Point{
    public int x;
    public int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    public String toString(){
        return x+"" ""+y;
    }
}


class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
     
        Queue<Point> queue = new LinkedList<Point>();
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int[][] dir = {
            {-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}
        }; 
        int ans = 1;        
        
        if(grid[0][0]==1) return -1;
        queue.add(new Point(0,0));
        visited[0][0] = true;
        
        int l = queue.size();
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            
            Point cur = queue.poll();
            l--;
            
            if(cur.x == grid.length-1 && cur.y==grid[0].length-1){
                return ans;
            }
            
            for(int i=0;i<8;i++){
                int newRow = cur.x + dir[i][0];
                int newCol = cur.y + dir[i][1];
                
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol<grid[0].length && !visited[newRow][newCol] && grid[newRow][newCol]==0){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
                
            }
            
            if(l==0){
                ans++;
                l = queue.size();
            }
        }
        
        
        return -1;        
    }
}
",ShortestPathInBinaryMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPathInBinaryMatrix.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(62, 0)",N,program,program,,382,a35c89e0-d4eb-49da-82c7-d1be6712a0b2
"class Point{
    public int x;
    public int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    public String toString(){
        return x+"" ""+y;
    }
}",ShortestPathInBinaryMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPathInBinaryMatrix.java,program/,program,Previous sibling does not exist,"class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
     
        Queue<Point> queue = new LinkedList<Point>();
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int[][] dir = {
            {-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}
        }; 
        int ans = 1;        
        
        if(grid[0][0]==1) return -1;
        queue.add(new Point(0,0));
        visited[0][0] = true;
        
        int l = queue.size();
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            
            Point cur = queue.poll();
            l--;
            
            if(cur.x == grid.length-1 && cur.y==grid[0].length-1){
                return ans;
            }
            
            for(int i=0;i<8;i++){
                int newRow = cur.x + dir[i][0];
                int newCol = cur.y + dir[i][1];
                
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol<grid[0].length && !visited[newRow][newCol] && grid[newRow][newCol]==0){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
                
            }
            
            if(l==0){
                ans++;
                l = queue.size();
            }
        }
        
        
        return -1;        
    }
}","(0, 0)","(12, 1)",N,class_declaration,Point,,52,474e67c5-ad3d-4d84-a736-2c6380c9fc55
"Point(int x, int y){
        this.x = x;
        this.y = y;
    }",ShortestPathInBinaryMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPathInBinaryMatrix.java,program/class_declaration-Point/,Point,public int y;,"public String toString(){
        return x+"" ""+y;
    }","(4, 4)","(7, 5)",N,constructor_declaration,Point,,21,437c9ead-7363-49c5-afad-1277288eb8eb
"public String toString(){
        return x+"" ""+y;
    }",ShortestPathInBinaryMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPathInBinaryMatrix.java,program/class_declaration-Point/,Point,"Point(int x, int y){
        this.x = x;
        this.y = y;
    }",Next sibling does not exist,"(9, 4)","(11, 5)",N,method_declaration,toString,,13,3dd7d092-0dc7-411f-8bca-bd9d848a18b5
"class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
     
        Queue<Point> queue = new LinkedList<Point>();
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int[][] dir = {
            {-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}
        }; 
        int ans = 1;        
        
        if(grid[0][0]==1) return -1;
        queue.add(new Point(0,0));
        visited[0][0] = true;
        
        int l = queue.size();
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            
            Point cur = queue.poll();
            l--;
            
            if(cur.x == grid.length-1 && cur.y==grid[0].length-1){
                return ans;
            }
            
            for(int i=0;i<8;i++){
                int newRow = cur.x + dir[i][0];
                int newCol = cur.y + dir[i][1];
                
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol<grid[0].length && !visited[newRow][newCol] && grid[newRow][newCol]==0){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
                
            }
            
            if(l==0){
                ans++;
                l = queue.size();
            }
        }
        
        
        return -1;        
    }
}",ShortestPathInBinaryMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPathInBinaryMatrix.java,program/,program,"class Point{
    public int x;
    public int y;
    
    Point(int x, int y){
        this.x = x;
        this.y = y;
    }
    
    public String toString(){
        return x+"" ""+y;
    }
}",Next sibling does not exist,"(15, 0)","(61, 1)",N,class_declaration,Solution,,330,cb95e668-81b9-4c35-b741-00617e90cd2c
"public int shortestPathBinaryMatrix(int[][] grid) {
     
        Queue<Point> queue = new LinkedList<Point>();
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int[][] dir = {
            {-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}
        }; 
        int ans = 1;        
        
        if(grid[0][0]==1) return -1;
        queue.add(new Point(0,0));
        visited[0][0] = true;
        
        int l = queue.size();
        while(!queue.isEmpty()){
            
            // System.out.println(queue);
            
            Point cur = queue.poll();
            l--;
            
            if(cur.x == grid.length-1 && cur.y==grid[0].length-1){
                return ans;
            }
            
            for(int i=0;i<8;i++){
                int newRow = cur.x + dir[i][0];
                int newCol = cur.y + dir[i][1];
                
                if(newRow>=0 && newCol>=0 && newRow<grid.length && newCol<grid[0].length && !visited[newRow][newCol] && grid[newRow][newCol]==0){
                    queue.add(new Point(newRow, newCol));
                    visited[newRow][newCol] = true;
                }
                
            }
            
            if(l==0){
                ans++;
                l = queue.size();
            }
        }
        
        
        return -1;        
    }",ShortestPathInBinaryMatrix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\ShortestPathInBinaryMatrix.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(16, 4)","(60, 5)",N,method_declaration,shortestPathBinaryMatrix,,325,79270a30-5013-4d2b-947c-c2d126937fee
"class Solution
{
    //Function to find sum of weights of edges of the Minimum Spanning Tree.
    static int spanningTree(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj) 
    {
        // Add your code here
        
        boolean[] visited = new boolean[V];
        PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) ->  o1.distance - o2.distance);
        
        pq.add(new Node(0,0));
        int ans = 0;
        
        while(!pq.isEmpty()){
            Node cur = pq.poll();
            if(visited[cur.val]) continue;
            
            visited[cur.val] = true;
            ans += cur.distance;
            
            for(ArrayList<Integer> neighbour: adj.get(cur.val)){
                if(visited[neighbour.get(0)]) continue;
                pq.add(new Node(neighbour.get(0), neighbour.get(1)));
            }
        }
        
        
        return ans;
        
    }
}


class Node{
    int val;
    int distance;
    
    Node(int val, int distance){
         this.val = val;
         this.distance = distance;
    }
    
    
}
",SpanningTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\SpanningTree.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(44, 0)",N,program,program,,228,e0f64d5c-aa46-4a87-acea-27713e9829db
"class Solution
{
    //Function to find sum of weights of edges of the Minimum Spanning Tree.
    static int spanningTree(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj) 
    {
        // Add your code here
        
        boolean[] visited = new boolean[V];
        PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) ->  o1.distance - o2.distance);
        
        pq.add(new Node(0,0));
        int ans = 0;
        
        while(!pq.isEmpty()){
            Node cur = pq.poll();
            if(visited[cur.val]) continue;
            
            visited[cur.val] = true;
            ans += cur.distance;
            
            for(ArrayList<Integer> neighbour: adj.get(cur.val)){
                if(visited[neighbour.get(0)]) continue;
                pq.add(new Node(neighbour.get(0), neighbour.get(1)));
            }
        }
        
        
        return ans;
        
    }
}",SpanningTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\SpanningTree.java,program/,program,Previous sibling does not exist,"class Node{
    int val;
    int distance;
    
    Node(int val, int distance){
         this.val = val;
         this.distance = distance;
    }
    
    
}","(0, 0)","(30, 1)",N,class_declaration,Solution,,192,a6d5fe2f-b4a7-4ad0-add2-d2e8c5dd9402
"static int spanningTree(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj) 
    {
        // Add your code here
        
        boolean[] visited = new boolean[V];
        PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) ->  o1.distance - o2.distance);
        
        pq.add(new Node(0,0));
        int ans = 0;
        
        while(!pq.isEmpty()){
            Node cur = pq.poll();
            if(visited[cur.val]) continue;
            
            visited[cur.val] = true;
            ans += cur.distance;
            
            for(ArrayList<Integer> neighbour: adj.get(cur.val)){
                if(visited[neighbour.get(0)]) continue;
                pq.add(new Node(neighbour.get(0), neighbour.get(1)));
            }
        }
        
        
        return ans;
        
    }",SpanningTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\SpanningTree.java,program/class_declaration-Solution/,Solution,//Function to find sum of weights of edges of the Minimum Spanning Tree.,Next sibling does not exist,"(3, 4)","(29, 5)",N,method_declaration,spanningTree,,169,e5a42570-ebc0-427a-ae50-a512c3d0be23
"class Node{
    int val;
    int distance;
    
    Node(int val, int distance){
         this.val = val;
         this.distance = distance;
    }
    
    
}",SpanningTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\SpanningTree.java,program/,program,"class Solution
{
    //Function to find sum of weights of edges of the Minimum Spanning Tree.
    static int spanningTree(int V, ArrayList<ArrayList<ArrayList<Integer>>> adj) 
    {
        // Add your code here
        
        boolean[] visited = new boolean[V];
        PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) ->  o1.distance - o2.distance);
        
        pq.add(new Node(0,0));
        int ans = 0;
        
        while(!pq.isEmpty()){
            Node cur = pq.poll();
            if(visited[cur.val]) continue;
            
            visited[cur.val] = true;
            ans += cur.distance;
            
            for(ArrayList<Integer> neighbour: adj.get(cur.val)){
                if(visited[neighbour.get(0)]) continue;
                pq.add(new Node(neighbour.get(0), neighbour.get(1)));
            }
        }
        
        
        return ans;
        
    }
}",Next sibling does not exist,"(33, 0)","(43, 1)",N,class_declaration,Node,,36,09aca6b7-7b37-4c78-918c-59cf7f7eddc6
"Node(int val, int distance){
         this.val = val;
         this.distance = distance;
    }",SpanningTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\SpanningTree.java,program/class_declaration-Node/,Node,int distance;,Next sibling does not exist,"(37, 4)","(40, 5)",N,constructor_declaration,Node,,21,f530d4e6-cbf6-44b6-a0d4-f245144eb0ba
"class Solution {
    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {
        
        boolean[] visited = new boolean[friends.length];
        Queue<Integer> queue = new LinkedList<>();
        
        queue.offer(id);
        visited[id] = true;
        int l = queue.size();
        
        
        while(level>0){
            int node = queue.poll();
            l--;
            
            for(int friend: friends[node]) {
                if(visited[friend]) continue;
                queue.offer(friend);
                visited[friend] = true;
            }
            
            if(l==0) {
                l = queue.size();
                level--;
            }
        }
        
        HashMap<String, Integer> map = new HashMap<>();
        for(int x: queue){
            for(String video: watchedVideos.get(x)){
                if(!map.containsKey(video)) map.put(video, 1);
                else map.put(video, map.get(video)+1);
            }
        }
        
        ArrayList<String> ans = new ArrayList<>(map.keySet());
        Collections.sort(ans, (O1, O2) -> (map.get(O1) == map.get(O2)) ? (O1.compareTo(O2)) : (map.get(O1) - map.get(O2)));
        
        return ans; 
    }
}
",WatchedVideosByFriends.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\WatchedVideosByFriends.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(41, 0)",N,program,program,,271,a24ab50b-9c30-4724-837c-ef4c7f62d760
"class Solution {
    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {
        
        boolean[] visited = new boolean[friends.length];
        Queue<Integer> queue = new LinkedList<>();
        
        queue.offer(id);
        visited[id] = true;
        int l = queue.size();
        
        
        while(level>0){
            int node = queue.poll();
            l--;
            
            for(int friend: friends[node]) {
                if(visited[friend]) continue;
                queue.offer(friend);
                visited[friend] = true;
            }
            
            if(l==0) {
                l = queue.size();
                level--;
            }
        }
        
        HashMap<String, Integer> map = new HashMap<>();
        for(int x: queue){
            for(String video: watchedVideos.get(x)){
                if(!map.containsKey(video)) map.put(video, 1);
                else map.put(video, map.get(video)+1);
            }
        }
        
        ArrayList<String> ans = new ArrayList<>(map.keySet());
        Collections.sort(ans, (O1, O2) -> (map.get(O1) == map.get(O2)) ? (O1.compareTo(O2)) : (map.get(O1) - map.get(O2)));
        
        return ans; 
    }
}",WatchedVideosByFriends.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\WatchedVideosByFriends.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(40, 1)",N,class_declaration,Solution,,271,87684c96-3be7-49b4-9088-392ece6fb985
"public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {
        
        boolean[] visited = new boolean[friends.length];
        Queue<Integer> queue = new LinkedList<>();
        
        queue.offer(id);
        visited[id] = true;
        int l = queue.size();
        
        
        while(level>0){
            int node = queue.poll();
            l--;
            
            for(int friend: friends[node]) {
                if(visited[friend]) continue;
                queue.offer(friend);
                visited[friend] = true;
            }
            
            if(l==0) {
                l = queue.size();
                level--;
            }
        }
        
        HashMap<String, Integer> map = new HashMap<>();
        for(int x: queue){
            for(String video: watchedVideos.get(x)){
                if(!map.containsKey(video)) map.put(video, 1);
                else map.put(video, map.get(video)+1);
            }
        }
        
        ArrayList<String> ans = new ArrayList<>(map.keySet());
        Collections.sort(ans, (O1, O2) -> (map.get(O1) == map.get(O2)) ? (O1.compareTo(O2)) : (map.get(O1) - map.get(O2)));
        
        return ans; 
    }",WatchedVideosByFriends.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\graphs\WatchedVideosByFriends.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(39, 5)",N,method_declaration,watchedVideosByFriends,,266,6b7dc97a-079c-400a-8ae5-82b3f8892e39
"class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:

        points.sort(key = lambda x:x[1])
        # print(points)

        ans = 0
        index = 0
        N = len(points)

        while(index<N):
            _,end = points[index]
            while(index<N and points[index][0]<=end):
                index+=1
            ans+=1
        
        return ans
",findMinArrowShots.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\findMinArrowShots.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 0)",N,module,module,,93,4cb8c37d-ded3-4904-a4f4-8375b0c5d404
"class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:

        points.sort(key = lambda x:x[1])
        # print(points)

        ans = 0
        index = 0
        N = len(points)

        while(index<N):
            _,end = points[index]
            while(index<N and points[index][0]<=end):
                index+=1
            ans+=1
        
        return ans",findMinArrowShots.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\findMinArrowShots.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 18)",N,class_definition,Solution,,92,c5c8f3e0-bb97-40e0-bd74-5217cea5226e
"def findMinArrowShots(self, points: List[List[int]]) -> int:

        points.sort(key = lambda x:x[1])
        # print(points)

        ans = 0
        index = 0
        N = len(points)

        while(index<N):
            _,end = points[index]
            while(index<N and points[index][0]<=end):
                index+=1
            ans+=1
        
        return ans",findMinArrowShots.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\findMinArrowShots.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(16, 18)",N,function_definition,findMinArrowShots,,88,a4e3cb43-35cc-4af7-9d3e-3a3b382eb265
"class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        for i in range(len(nums)-3,-1,-1):
            if(nums[i] + nums[i+1] > nums[i+2]):
                return nums[i] + nums[i+1] + nums[i+2]
        return 0
",LargestPerimeter.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\LargestPerimeter.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(7, 0)",N,module,module,,75,fee6a141-5739-4e6d-a2f2-ea24e1096c1a
"class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        for i in range(len(nums)-3,-1,-1):
            if(nums[i] + nums[i+1] > nums[i+2]):
                return nums[i] + nums[i+1] + nums[i+2]
        return 0",LargestPerimeter.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\LargestPerimeter.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(6, 16)",N,class_definition,Solution,,74,c4e781c9-2a4c-408a-8d03-41f5a844611e
"def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        for i in range(len(nums)-3,-1,-1):
            if(nums[i] + nums[i+1] > nums[i+2]):
                return nums[i] + nums[i+1] + nums[i+2]
        return 0",LargestPerimeter.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\LargestPerimeter.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(6, 16)",N,function_definition,largestPerimeter,,70,db0377ac-5bca-434f-b1c9-df1e7b8713a7
"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        
        ans = 0
        
        index = 0
        while(index<len(s)):
            cur = 0
            prev = index
            
            while(index<len(s) and (cur*10 + int(s[index])) <= k):
                cur = cur*10 + int(s[index])
                index += 1
            
            if(prev == index): return -1
            else: ans += 1
        
        return ans
            
                
        
",minimumPartition.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\minimumPartition.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 0)",N,module,module,,110,81ffc48e-b7cb-48a7-a33e-6a64639de723
"class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        
        ans = 0
        
        index = 0
        while(index<len(s)):
            cur = 0
            prev = index
            
            while(index<len(s) and (cur*10 + int(s[index])) <= k):
                cur = cur*10 + int(s[index])
                index += 1
            
            if(prev == index): return -1
            else: ans += 1
        
        return ans",minimumPartition.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\minimumPartition.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 18)",N,class_definition,Solution,,107,17082d27-3e72-4684-aa6f-b5a68509a996
"def minimumPartition(self, s: str, k: int) -> int:
        
        ans = 0
        
        index = 0
        while(index<len(s)):
            cur = 0
            prev = index
            
            while(index<len(s) and (cur*10 + int(s[index])) <= k):
                cur = cur*10 + int(s[index])
                index += 1
            
            if(prev == index): return -1
            else: ans += 1
        
        return ans",minimumPartition.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\greedy\minimumPartition.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(17, 18)",N,function_definition,minimumPartition,,103,4bfa4e84-2a14-4ab0-90dd-27785428ff6a
"class Solution:
    def canArrange(self, arr: List[int], k: int) -> bool:

        table = {}
        for i in arr:
            if(i%k not in table):
                table[i%k] = 0
            table[i%k] += 1
        

        for i in table:
            if(i==0): 
                if(table[0]%2 == 1): return False
            elif( ((i in table) ^ ((k-i) in table)) or table[i]!=table[k-i]): return False 
        return True
",CheckIfArrayPairsAreDivisibleByk.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\CheckIfArrayPairsAreDivisibleByk.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(15, 0)",N,module,module,,119,1de77214-9fdb-46fb-b39a-06d44494ae4b
"class Solution:
    def canArrange(self, arr: List[int], k: int) -> bool:

        table = {}
        for i in arr:
            if(i%k not in table):
                table[i%k] = 0
            table[i%k] += 1
        

        for i in table:
            if(i==0): 
                if(table[0]%2 == 1): return False
            elif( ((i in table) ^ ((k-i) in table)) or table[i]!=table[k-i]): return False 
        return True",CheckIfArrayPairsAreDivisibleByk.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\CheckIfArrayPairsAreDivisibleByk.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 19)",N,class_definition,Solution,,118,588b3d63-a3f7-41a8-b2f7-96384191df44
"def canArrange(self, arr: List[int], k: int) -> bool:

        table = {}
        for i in arr:
            if(i%k not in table):
                table[i%k] = 0
            table[i%k] += 1
        

        for i in table:
            if(i==0): 
                if(table[0]%2 == 1): return False
            elif( ((i in table) ^ ((k-i) in table)) or table[i]!=table[k-i]): return False 
        return True",CheckIfArrayPairsAreDivisibleByk.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\CheckIfArrayPairsAreDivisibleByk.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(14, 19)",N,function_definition,canArrange,,114,e0c7f49e-ddff-4b3d-9754-dcecfc64ea15
"class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        
        N = len(grid)
        map = defaultdict(int)
        for row in range(N): map[tuple(grid[row])] += 1

        ans = 0    
        for row_index in range(N):
            for col_index in range(row_index+1, N):
                grid[row_index][col_index], grid[col_index][row_index] = grid[col_index][row_index], grid[row_index][col_index]
            ans += map[tuple(grid[row_index])]
        
        return ans
",equalPairs.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\equalPairs.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 0)",N,module,module,,120,cc99c32a-82b7-48f8-91a3-ae4225772910
"class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        
        N = len(grid)
        map = defaultdict(int)
        for row in range(N): map[tuple(grid[row])] += 1

        ans = 0    
        for row_index in range(N):
            for col_index in range(row_index+1, N):
                grid[row_index][col_index], grid[col_index][row_index] = grid[col_index][row_index], grid[row_index][col_index]
            ans += map[tuple(grid[row_index])]
        
        return ans",equalPairs.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\equalPairs.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(13, 18)",N,class_definition,Solution,,119,bfe73115-a604-4230-8622-e7e263f05271
"def equalPairs(self, grid: List[List[int]]) -> int:
        
        N = len(grid)
        map = defaultdict(int)
        for row in range(N): map[tuple(grid[row])] += 1

        ans = 0    
        for row_index in range(N):
            for col_index in range(row_index+1, N):
                grid[row_index][col_index], grid[col_index][row_index] = grid[col_index][row_index], grid[row_index][col_index]
            ans += map[tuple(grid[row_index])]
        
        return ans",equalPairs.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\equalPairs.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(13, 18)",N,function_definition,equalPairs,,115,aebe4c43-6da8-4b78-a2b9-f8315c06d3e7
"class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        
        mapper = {}
        ans = []
        
        for num in nums:
            if(num in mapper): mapper[num] += 1
            else: mapper[num] = 0
            
            if(mapper[num] >= len(ans)): ans.append([])                
            ans[mapper[num]].append(num)
        
        return ans
",findMatrix.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\findMatrix.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 0)",N,module,module,,87,d06109b5-2a06-46b2-a736-d89a9e5e8745
"class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        
        mapper = {}
        ans = []
        
        for num in nums:
            if(num in mapper): mapper[num] += 1
            else: mapper[num] = 0
            
            if(mapper[num] >= len(ans)): ans.append([])                
            ans[mapper[num]].append(num)
        
        return ans",findMatrix.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\findMatrix.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(13, 18)",N,class_definition,Solution,,86,10debf15-0b4d-480f-ba03-f9dc0d0d4ab6
"def findMatrix(self, nums: List[int]) -> List[List[int]]:
        
        mapper = {}
        ans = []
        
        for num in nums:
            if(num in mapper): mapper[num] += 1
            else: mapper[num] = 0
            
            if(mapper[num] >= len(ans)): ans.append([])                
            ans[mapper[num]].append(num)
        
        return ans",findMatrix.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\findMatrix.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(13, 18)",N,function_definition,findMatrix,,82,b84ae9ce-e576-4c65-873f-485c71617053
"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        
        def mapper(arr):
            ans = 0
            for i in arr:
                ans = (ans<<1) | i
            return ans
        
        N = len(img1)
        
        img1 = [mapper(i) for i in img1]
        img2 = [mapper(i) for i in img2]
                
        visited = {}
        
        self.helper(img1, img2, 0, 0, visited)
                 
        return max(visited[i] for i in visited)
    
    # ~O(1)
    def numOfOnes(self,num):
        count = 0
        while(num>0): 
            num = num&(num-1)
            count+=1
        return count
    
    O(4*(N**2)) ~ O(N**2)
    def helper(self, img1, img2, row, col, visited):
        
        key = (row, col)
        
        if(row<=len(img1)*-1 or row>=len(img1) or col<=len(img1)*-1 or col>=len(img1) or key in visited): 
            return
        
        ans = 0
        
        O(N)
        if(row>=0):
            for index in range(0, len(img1)-row):
                val1 = img1[index] >> col if(col>=0) else img1[index] << (-1*col)
                val2 = img2[index+row]
                ans += self.numOfOnes(val1 & val2)
        else:
            for index in range(0, len(img1)+row):
                val1 = img1[index-row] >> col if(col>=0) else img1[index-row] << (-1*col)
                val2 = img2[index]
                ans += self.numOfOnes(val1 & val2)
        
        visited[key] = ans
        # print(key, ans)
         
        self.helper(img1, img2, row-1, col, visited)
        self.helper(img1, img2, row, col+1, visited)
        self.helper(img1, img2, row+1, col, visited)
        self.helper(img1, img2, row, col-1, visited)
",ImageOverlap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\ImageOverlap.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(57, 0)",Y,module,module,,493,2a0a67ff-8995-450f-a5b7-f46355b69bbe
"class Solution:
    def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        
        def mapper(arr):
            ans = 0
            for i in arr:
                ans = (ans<<1) | i
            return ans
        
        N = len(img1)
        
        img1 = [mapper(i) for i in img1]
        img2 = [mapper(i) for i in img2]
                
        visited = {}
        
        self.helper(img1, img2, 0, 0, visited)
                 
        return max(visited[i] for i in visited)
    
    # ~O(1)
    def numOfOnes(self,num):
        count = 0
        while(num>0): 
            num = num&(num-1)
            count+=1
        return count
    
    O(4*(N**2)) ~ O(N**2)
    def helper(self, img1, img2, row, col, visited):
        
        key = (row, col)
        
        if(row<=len(img1)*-1 or row>=len(img1) or col<=len(img1)*-1 or col>=len(img1) or key in visited): 
            return
        
        ans = 0
        
        O(N)
        if(row>=0):
            for index in range(0, len(img1)-row):
                val1 = img1[index] >> col if(col>=0) else img1[index] << (-1*col)
                val2 = img2[index+row]
                ans += self.numOfOnes(val1 & val2)
        else:
            for index in range(0, len(img1)+row):
                val1 = img1[index-row] >> col if(col>=0) else img1[index-row] << (-1*col)
                val2 = img2[index]
                ans += self.numOfOnes(val1 & val2)
        
        visited[key] = ans
        # print(key, ans)
         
        self.helper(img1, img2, row-1, col, visited)
        self.helper(img1, img2, row, col+1, visited)
        self.helper(img1, img2, row+1, col, visited)
        self.helper(img1, img2, row, col-1, visited)",ImageOverlap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\ImageOverlap.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(56, 52)",Y,class_definition,Solution,,493,89092cec-8975-4578-8650-c2ee4c564f53
"def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
        
        def mapper(arr):
            ans = 0
            for i in arr:
                ans = (ans<<1) | i
            return ans
        
        N = len(img1)
        
        img1 = [mapper(i) for i in img1]
        img2 = [mapper(i) for i in img2]
                
        visited = {}
        
        self.helper(img1, img2, 0, 0, visited)
                 
        return max(visited[i] for i in visited)",ImageOverlap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\ImageOverlap.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,# ~O(1),"(1, 4)","(18, 47)",N,function_definition,largestOverlap,,127,b6f2718d-93e3-4208-b2de-2e3e1431bbed
"def mapper(arr):
            ans = 0
            for i in arr:
                ans = (ans<<1) | i
            return ans",ImageOverlap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\ImageOverlap.py,module/class_definition-Solution/function_definition-largestOverlap/,largestOverlap,Previous sibling does not exist,N = len(img1),"(3, 8)","(7, 22)",N,function_definition,mapper,,30,1ff3cc07-bd78-4695-a53f-38c316b28722
"def numOfOnes(self,num):
        count = 0
        while(num>0): 
            num = num&(num-1)
            count+=1
        return count",ImageOverlap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\ImageOverlap.py,module/class_definition-Solution/,Solution,# ~O(1),O(4*(N**2)),"(21, 4)","(26, 20)",N,function_definition,numOfOnes,,37,f22e9f58-c96e-430c-9f19-22643f7d4598
"def helper(self, img1, img2, row, col, visited):
        
        key = (row, col)
        
        if(row<=len(img1)*-1 or row>=len(img1) or col<=len(img1)*-1 or col>=len(img1) or key in visited): 
            return
        
        ans = 0
        
        O(N)
        if(row>=0):
            for index in range(0, len(img1)-row):
                val1 = img1[index] >> col if(col>=0) else img1[index] << (-1*col)
                val2 = img2[index+row]
                ans += self.numOfOnes(val1 & val2)
        else:
            for index in range(0, len(img1)+row):
                val1 = img1[index-row] >> col if(col>=0) else img1[index-row] << (-1*col)
                val2 = img2[index]
                ans += self.numOfOnes(val1 & val2)
        
        visited[key] = ans
        # print(key, ans)
         
        self.helper(img1, img2, row-1, col, visited)
        self.helper(img1, img2, row, col+1, visited)
        self.helper(img1, img2, row+1, col, visited)
        self.helper(img1, img2, row, col-1, visited)",ImageOverlap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\ImageOverlap.py,module/class_definition-Solution/,Solution,~ O(N**2),Next sibling does not exist,"(29, 4)","(56, 52)",N,function_definition,helper,,299,820e96f8-c4e4-4480-9d8a-33fbcc8c1779
"class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        arr = s.split("" "")
        if(len(pattern) != len(arr)): return False

        mapper = {}
        visited = set()

        for index in range(len(arr)):
            if(pattern[index] in mapper and mapper[pattern[index]] != arr[index]): 
                return False
            elif(pattern[index] in mapper): 
                continue
            else:
                if(arr[index] in visited): return False
                mapper[pattern[index]] = arr[index]
                visited.add(arr[index])

        return True
",wordPattern.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\wordPattern.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(19, 0)",N,module,module,,124,774334eb-4fa3-4846-aa67-777fb0bf8d56
"class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        arr = s.split("" "")
        if(len(pattern) != len(arr)): return False

        mapper = {}
        visited = set()

        for index in range(len(arr)):
            if(pattern[index] in mapper and mapper[pattern[index]] != arr[index]): 
                return False
            elif(pattern[index] in mapper): 
                continue
            else:
                if(arr[index] in visited): return False
                mapper[pattern[index]] = arr[index]
                visited.add(arr[index])

        return True",wordPattern.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\wordPattern.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 19)",N,class_definition,Solution,,123,7b389ed8-b89b-49c9-983a-9d4f531ff218
"def wordPattern(self, pattern: str, s: str) -> bool:
        arr = s.split("" "")
        if(len(pattern) != len(arr)): return False

        mapper = {}
        visited = set()

        for index in range(len(arr)):
            if(pattern[index] in mapper and mapper[pattern[index]] != arr[index]): 
                return False
            elif(pattern[index] in mapper): 
                continue
            else:
                if(arr[index] in visited): return False
                mapper[pattern[index]] = arr[index]
                visited.add(arr[index])

        return True",wordPattern.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashMap\wordPattern.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(18, 19)",N,function_definition,wordPattern,,119,61250930-f6e6-4ed2-80af-d2113abd9339
"class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        
        hashset = set()
        prefix = nums[0] % k
        hashset.add(prefix)
        hashset.add(0) 
        
        count = 0
        for i in nums:
            if((i % k)  == 0): 
                count += 1
            else:
                count = 0
            
            if(count>1): return True
        
        for i in range(1, len(nums)):
            if(nums[i]%k == 0): continue
            prefix = (prefix + nums[i])%k
            if(prefix in hashset):
                return True
            else:
                hashset.add(prefix)
        
        return False
        
        
        
",CheckSubarraySum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\CheckSubarraySum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 0)",N,module,module,,164,2f25595d-4b6e-4495-aace-31edffbf2a5e
"class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        
        hashset = set()
        prefix = nums[0] % k
        hashset.add(prefix)
        hashset.add(0) 
        
        count = 0
        for i in nums:
            if((i % k)  == 0): 
                count += 1
            else:
                count = 0
            
            if(count>1): return True
        
        for i in range(1, len(nums)):
            if(nums[i]%k == 0): continue
            prefix = (prefix + nums[i])%k
            if(prefix in hashset):
                return True
            else:
                hashset.add(prefix)
        
        return False",CheckSubarraySum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\CheckSubarraySum.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 20)",N,class_definition,Solution,,162,bb720e09-4696-421b-9437-cc7c84cf1309
"def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        
        hashset = set()
        prefix = nums[0] % k
        hashset.add(prefix)
        hashset.add(0) 
        
        count = 0
        for i in nums:
            if((i % k)  == 0): 
                count += 1
            else:
                count = 0
            
            if(count>1): return True
        
        for i in range(1, len(nums)):
            if(nums[i]%k == 0): continue
            prefix = (prefix + nums[i])%k
            if(prefix in hashset):
                return True
            else:
                hashset.add(prefix)
        
        return False",CheckSubarraySum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\CheckSubarraySum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(25, 20)",N,function_definition,checkSubarraySum,,158,81d636d8-f670-4532-a65e-9a54b386abd4
"class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        set_a = set(nums1)
        set_b = set(nums2)
        
        return [[num for num in set_a if(num not in set_b)], [num for num in set_b if(num not in set_a)]]
",findDifference.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\findDifference.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(6, 0)",N,module,module,,74,82d7cb58-b5fd-4e35-8ec0-5eb9bd1bb61d
"class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        set_a = set(nums1)
        set_b = set(nums2)
        
        return [[num for num in set_a if(num not in set_b)], [num for num in set_b if(num not in set_a)]]",findDifference.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\findDifference.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(5, 105)",N,class_definition,Solution,,74,78d95a0f-c4e7-458a-91f3-5c99031901d8
"def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        set_a = set(nums1)
        set_b = set(nums2)
        
        return [[num for num in set_a if(num not in set_b)], [num for num in set_b if(num not in set_a)]]",findDifference.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\findDifference.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(5, 105)",N,function_definition,findDifference,,70,bb4922a0-9aae-4b7c-ba4d-6f9285cfaccb
"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        
        
        winner = set()
        runner = set()
        lossers = set()
        
        visited = set()
        
        for w, r in matches:
            
            if(w not in visited): winner.add(w)
            
            if(r not in visited): 
                runner.add(r)
            elif(r in winner): 
                winner.remove(r)
                runner.add(r)
            elif(r in runner):
                runner.remove(r)
                lossers.add(r)
                
            
            visited.add(w)
            visited.add(r)        
        
        return [sorted([i for i in winner]), sorted([i for i in runner])]
",FindPlayersWithZeroOneLosses.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\FindPlayersWithZeroOneLosses.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 0)",N,module,module,,145,8ab63b89-bafe-472c-bde9-a657c0dd7afa
"class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        
        
        winner = set()
        runner = set()
        lossers = set()
        
        visited = set()
        
        for w, r in matches:
            
            if(w not in visited): winner.add(w)
            
            if(r not in visited): 
                runner.add(r)
            elif(r in winner): 
                winner.remove(r)
                runner.add(r)
            elif(r in runner):
                runner.remove(r)
                lossers.add(r)
                
            
            visited.add(w)
            visited.add(r)        
        
        return [sorted([i for i in winner]), sorted([i for i in runner])]",FindPlayersWithZeroOneLosses.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\FindPlayersWithZeroOneLosses.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(27, 73)",N,class_definition,Solution,,145,86294a8d-e6a7-4a4d-afd9-9d3186a4a08e
"def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        
        
        winner = set()
        runner = set()
        lossers = set()
        
        visited = set()
        
        for w, r in matches:
            
            if(w not in visited): winner.add(w)
            
            if(r not in visited): 
                runner.add(r)
            elif(r in winner): 
                winner.remove(r)
                runner.add(r)
            elif(r in runner):
                runner.remove(r)
                lossers.add(r)
                
            
            visited.add(w)
            visited.add(r)        
        
        return [sorted([i for i in winner]), sorted([i for i in runner])]",FindPlayersWithZeroOneLosses.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\FindPlayersWithZeroOneLosses.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(27, 73)",N,function_definition,findWinners,,141,cc77aba7-7530-4f56-93bc-9bfe2afcf094
"class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        
        a_set = set()
        b_set = set()
        
        ans = []
        prev_ans = 0
        
        for a, b in zip(A, B):
            if(a == b): prev_ans += 1
            if(a in b_set): prev_ans +=1
            if(b in a_set): prev_ans +=1
            
            a_set.add(a)
            b_set.add(b)
            ans.append(prev_ans)
        
        return ans
",findThePrefixCommonArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\findThePrefixCommonArray.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(19, 0)",N,module,module,,121,32b22179-ad6c-4cdb-94d4-c59e09149b2d
"class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        
        a_set = set()
        b_set = set()
        
        ans = []
        prev_ans = 0
        
        for a, b in zip(A, B):
            if(a == b): prev_ans += 1
            if(a in b_set): prev_ans +=1
            if(b in a_set): prev_ans +=1
            
            a_set.add(a)
            b_set.add(b)
            ans.append(prev_ans)
        
        return ans",findThePrefixCommonArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\findThePrefixCommonArray.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 18)",N,class_definition,Solution,,120,db2fa3cd-16fb-4ba1-84e4-1b5a4aeee11f
"def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        
        a_set = set()
        b_set = set()
        
        ans = []
        prev_ans = 0
        
        for a, b in zip(A, B):
            if(a == b): prev_ans += 1
            if(a in b_set): prev_ans +=1
            if(b in a_set): prev_ans +=1
            
            a_set.add(a)
            b_set.add(b)
            ans.append(prev_ans)
        
        return ans",findThePrefixCommonArray.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\findThePrefixCommonArray.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(18, 18)",N,function_definition,findThePrefixCommonArray,,116,ca3e4de8-efa9-4c28-86e4-fd963d1f7cf8
"class DoubllyLinkedListNode:

    def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next
    
    def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)

class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)

class MyHashSet:

    def __init__(self):
        self.cap = 101
        self.bucket = [DoubllyLinkedList() for i in range(self.cap)]
        

    def getBucketId(self, num):
        return hash(num)%self.cap

    def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))
        

    def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node) 

    def contains(self, key: int) -> bool:
        id = self.getBucketId(key)
        print(id, key)
        return self.bucket[id].contains(key)  


# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)
s = MyHashSet()
s.add(1)
s.add(2)
print(s.contains(1), s.contains(2))
s.remove(1)
print(s.contains(1), s.contains(2))



",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(123, 0)",N,module,module,,730,2eb8bb4e-7f53-45aa-8707-167d1a006883
"class DoubllyLinkedListNode:

    def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next
    
    def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/,module,Previous sibling does not exist,"class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)","(0, 0)","(8, 54)",N,class_definition,DoubllyLinkedListNode,,67,7b57007f-2ae1-4fb4-9f0e-b91f6e6a384a
"def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedListNode/,DoubllyLinkedListNode,Previous sibling does not exist,"def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)","(2, 4)","(5, 24)",N,function_definition,__init__,,33,9c4a7e6b-6b81-49e1-870e-964bb42ff9f2
"def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedListNode/,DoubllyLinkedListNode,"def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next",Next sibling does not exist,"(7, 4)","(8, 54)",N,function_definition,__str__,,24,75fb78b1-b952-46ca-b54f-0ebebb60d132
"class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/,module,"class DoubllyLinkedListNode:

    def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next
    
    def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)","class MyHashSet:

    def __init__(self):
        self.cap = 101
        self.bucket = [DoubllyLinkedList() for i in range(self.cap)]
        

    def getBucketId(self, num):
        return hash(num)%self.cap

    def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))
        

    def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node) 

    def contains(self, key: int) -> bool:
        id = self.getBucketId(key)
        print(id, key)
        return self.bucket[id].contains(key)","(10, 0)","(78, 29)",N,class_definition,DoubllyLinkedList,,392,cf53cbe6-c3b5-44d1-b1a3-8f476a12e2e2
"def __init__(self):
        self.head = None
        self.tail = None",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,Previous sibling does not exist,"def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node","(12, 4)","(14, 24)",N,function_definition,__init__,,17,aa7c76c2-05be-44aa-9b78-25ce456b4bb7
"def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def __init__(self):
        self.head = None
        self.tail = None","def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node","(17, 4)","(24, 28)",N,function_definition,addNodeToHead,,63,3e82dc01-a94f-417b-b61d-4496203c4b08
"def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node","def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None","(27, 4)","(34, 28)",N,function_definition,addNodeToTail,,63,1c069d37-5492-488a-9ba2-c504e905d6fb
"def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node","def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False","(37, 4)","(47, 40)",N,function_definition,delete,,88,ba34707e-70e4-457c-8544-65c1b3dd5ac3
"def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None","def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None","(49, 4)","(55, 20)",N,function_definition,contains,,35,b33db47d-4119-4be4-8814-2455391d6bda
"def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False","def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)","(57, 4)","(63, 19)",N,function_definition,getNode,,35,5b4c6638-1ab8-480e-ba00-122765fe72d0
"def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None","def __str__(self) -> str:
        return str(self.head)","(68, 4)","(75, 23)",N,function_definition,print,,53,9f48d12f-2677-4704-a1c2-d22d952a1281
"def __str__(self) -> str:
        return str(self.head)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)",Next sibling does not exist,"(77, 4)","(78, 29)",N,function_definition,__str__,,15,c3a58164-d35d-4c07-8a36-c66e901b02bd
"class MyHashSet:

    def __init__(self):
        self.cap = 101
        self.bucket = [DoubllyLinkedList() for i in range(self.cap)]
        

    def getBucketId(self, num):
        return hash(num)%self.cap

    def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))
        

    def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node) 

    def contains(self, key: int) -> bool:
        id = self.getBucketId(key)
        print(id, key)
        return self.bucket[id].contains(key)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/,module,"class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)",# Your MyHashSet object will be instantiated and called as such:,"(80, 0)","(106, 44)",N,class_definition,MyHashSet,,189,598c35aa-3248-44ed-a76a-c1753943b097
"def __init__(self):
        self.cap = 101
        self.bucket = [DoubllyLinkedList() for i in range(self.cap)]",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-MyHashSet/,MyHashSet,Previous sibling does not exist,"def getBucketId(self, num):
        return hash(num)%self.cap","(82, 4)","(84, 68)",N,function_definition,__init__,,30,72fd8f50-998b-4022-b7de-a1f987b22822
"def getBucketId(self, num):
        return hash(num)%self.cap",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-MyHashSet/,MyHashSet,"def __init__(self):
        self.cap = 101
        self.bucket = [DoubllyLinkedList() for i in range(self.cap)]","def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))","(87, 4)","(88, 33)",N,function_definition,getBucketId,,15,3dc498e9-de7d-4d10-9f7d-87e39dccb986
"def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-MyHashSet/,MyHashSet,"def getBucketId(self, num):
        return hash(num)%self.cap","def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node)","(90, 4)","(94, 65)",N,function_definition,add,,51,828a57be-f425-402c-b19d-05d1a227e841
"def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-MyHashSet/,MyHashSet,"def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))","def contains(self, key: int) -> bool:
        id = self.getBucketId(key)
        print(id, key)
        return self.bucket[id].contains(key)","(97, 4)","(101, 36)",N,function_definition,remove,,45,1306e231-fe8d-4ebb-80d2-82299697ac07
"def contains(self, key: int) -> bool:
        id = self.getBucketId(key)
        print(id, key)
        return self.bucket[id].contains(key)",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/class_definition-MyHashSet/,MyHashSet,"def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node)","# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)
s = MyHashSet()
s.add(1)
s.add(2)
print(s.contains(1), s.contains(2))
s.remove(1)
print(s.contains(1), s.contains(2))","(103, 4)","(106, 44)",N,function_definition,contains,,35,33d85e6a-61f2-4cba-916f-e11b8088eb1b
"# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)
s = MyHashSet()
s.add(1)
s.add(2)
print(s.contains(1), s.contains(2))
s.remove(1)
print(s.contains(1), s.contains(2))",MyHashSet.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\MyHashSet.py,module/,module,"class MyHashSet:

    def __init__(self):
        self.cap = 101
        self.bucket = [DoubllyLinkedList() for i in range(self.cap)]
        

    def getBucketId(self, num):
        return hash(num)%self.cap

    def add(self, key: int) -> None:
        if(self.contains(key)): return
        id = self.getBucketId(key)
        print(id, key)
        self.bucket[id].addNodeToTail(DoubllyLinkedListNode(key))
        

    def remove(self, key: int) -> None:
        id = self.getBucketId(key)
        node = self.bucket[id].getNode(key)
        if(not node): return
        self.bucket[id].delete(node) 

    def contains(self, key: int) -> bool:
        id = self.getBucketId(key)
        print(id, key)
        return self.bucket[id].contains(key)",Next sibling does not exist,"(109, 0)","(119, 35)",N,"comment,comment,comment,comment,comment,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement",comment,,80,15eee688-983e-4a06-adf0-4b8c89db48e3
"class Solution:
    def __init__(self):
        self.vowles = set(['a', 'e', 'i', 'o', 'u'])
        
    def isVowelString(self, word):
        return word[0] in self.vowles and word[-1] in self.vowles
    
    def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        return sum(list(map(self.isVowelString, words[left:right+1])))
        
",vowelStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\vowelStrings.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(10, 0)",N,module,module,,105,eb3ac374-4eda-4a20-a107-6246c7f13d37
"class Solution:
    def __init__(self):
        self.vowles = set(['a', 'e', 'i', 'o', 'u'])
        
    def isVowelString(self, word):
        return word[0] in self.vowles and word[-1] in self.vowles
    
    def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        return sum(list(map(self.isVowelString, words[left:right+1])))",vowelStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\vowelStrings.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(8, 70)",N,class_definition,Solution,,104,82179e93-760b-4225-932f-96827a4410a3
"def __init__(self):
        self.vowles = set(['a', 'e', 'i', 'o', 'u'])",vowelStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\vowelStrings.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def isVowelString(self, word):
        return word[0] in self.vowles and word[-1] in self.vowles","(1, 4)","(2, 52)",N,function_definition,__init__,,28,f8aab339-9106-41d1-bdd8-ca84a25a242d
"def isVowelString(self, word):
        return word[0] in self.vowles and word[-1] in self.vowles",vowelStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\vowelStrings.py,module/class_definition-Solution/,Solution,"def __init__(self):
        self.vowles = set(['a', 'e', 'i', 'o', 'u'])","def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        return sum(list(map(self.isVowelString, words[left:right+1])))","(4, 4)","(5, 65)",N,function_definition,isVowelString,,30,72866eb6-8ca9-445f-8de4-35bce2590b4b
"def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        return sum(list(map(self.isVowelString, words[left:right+1])))",vowelStrings.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\Hashing\HashSet\vowelStrings.py,module/class_definition-Solution/,Solution,"def isVowelString(self, word):
        return word[0] in self.vowles and word[-1] in self.vowles",Next sibling does not exist,"(7, 4)","(8, 70)",N,function_definition,vowelStrings,,38,7aaf6843-a9bf-495b-9e19-68fbce452815
"import java.util.Arrays;

public class Heap {

    private int[] heap;
    private int size;

    public Heap() {
        this.heap = new int[8];
        this.size = 0;
    }

    public Heap(int capacity) {
        this.heap = new int[capacity];
        this.size = 0;
    }

    private int getParentIndex(int index){
        return (index-1)/2;
    }

    private int getLeftChildIndex(int index){
        return 2*index + 1;
    }

    private int getRightChildIndex(int index){
        return 2*index + 2;
    }

    public int peek() {
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        return this.heap[0];
    }

     public int poll(){
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        swapElements(0, this.size-1);
        int val = this.heap[size-1];
        size--;
        heapifyDown();
        return val;
    }

    public void insert(int val){
        increaseSize();
        heap[size] = val;
        size++;
        heapifyUp();
    }

    private void heapifyUp() {
        int curIndex = this.size - 1;
        while (curIndex>0 && this.heap[getParentIndex(curIndex)] > this.heap[curIndex]) {
            swapElements(getParentIndex(curIndex), curIndex);
            curIndex = getParentIndex(curIndex);
        }
    }

    private void heapifyDown() {
        int curIndex = 0;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }

    private void heapifyDown(int index) {
        int curIndex = index;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }

    private void increaseSize() {
        if(size<heap.length) return;

        int curSize = heap.length;
        int[] arr = new int[2*curSize];
        System.arraycopy(heap, 0, arr, 0, curSize);
        heap = arr;
    }

    private void swapElements(int sourceIndex, int destinationIndex) {
        if(sourceIndex>=this.heap.length || destinationIndex>=this.heap.length) throw new IllegalStateException();

        int temp = this.heap[sourceIndex];
        this.heap[sourceIndex] = this.heap[destinationIndex];
        this.heap[destinationIndex] = temp;
    }

    @Override
    public String toString(){
        return Arrays.toString(this.heap);
    }

    public boolean isEmpty() {
        return this.size == 0;
    }
}
",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(126, 0)",N,program,program,,743,3c30dc88-efd3-411d-be0f-d59836f58ef8
import java.util.Arrays;,Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/,program,Previous sibling does not exist,"public class Heap {

    private int[] heap;
    private int size;

    public Heap() {
        this.heap = new int[8];
        this.size = 0;
    }

    public Heap(int capacity) {
        this.heap = new int[capacity];
        this.size = 0;
    }

    private int getParentIndex(int index){
        return (index-1)/2;
    }

    private int getLeftChildIndex(int index){
        return 2*index + 1;
    }

    private int getRightChildIndex(int index){
        return 2*index + 2;
    }

    public int peek() {
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        return this.heap[0];
    }

     public int poll(){
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        swapElements(0, this.size-1);
        int val = this.heap[size-1];
        size--;
        heapifyDown();
        return val;
    }

    public void insert(int val){
        increaseSize();
        heap[size] = val;
        size++;
        heapifyUp();
    }

    private void heapifyUp() {
        int curIndex = this.size - 1;
        while (curIndex>0 && this.heap[getParentIndex(curIndex)] > this.heap[curIndex]) {
            swapElements(getParentIndex(curIndex), curIndex);
            curIndex = getParentIndex(curIndex);
        }
    }

    private void heapifyDown() {
        int curIndex = 0;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }

    private void heapifyDown(int index) {
        int curIndex = index;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }

    private void increaseSize() {
        if(size<heap.length) return;

        int curSize = heap.length;
        int[] arr = new int[2*curSize];
        System.arraycopy(heap, 0, arr, 0, curSize);
        heap = arr;
    }

    private void swapElements(int sourceIndex, int destinationIndex) {
        if(sourceIndex>=this.heap.length || destinationIndex>=this.heap.length) throw new IllegalStateException();

        int temp = this.heap[sourceIndex];
        this.heap[sourceIndex] = this.heap[destinationIndex];
        this.heap[destinationIndex] = temp;
    }

    @Override
    public String toString(){
        return Arrays.toString(this.heap);
    }

    public boolean isEmpty() {
        return this.size == 0;
    }
}","(0, 0)","(0, 24)",N,import_declaration,import_declaration,,5,a24470cd-61c9-4156-8c4b-15c65fc6da68
"public class Heap {

    private int[] heap;
    private int size;

    public Heap() {
        this.heap = new int[8];
        this.size = 0;
    }

    public Heap(int capacity) {
        this.heap = new int[capacity];
        this.size = 0;
    }

    private int getParentIndex(int index){
        return (index-1)/2;
    }

    private int getLeftChildIndex(int index){
        return 2*index + 1;
    }

    private int getRightChildIndex(int index){
        return 2*index + 2;
    }

    public int peek() {
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        return this.heap[0];
    }

     public int poll(){
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        swapElements(0, this.size-1);
        int val = this.heap[size-1];
        size--;
        heapifyDown();
        return val;
    }

    public void insert(int val){
        increaseSize();
        heap[size] = val;
        size++;
        heapifyUp();
    }

    private void heapifyUp() {
        int curIndex = this.size - 1;
        while (curIndex>0 && this.heap[getParentIndex(curIndex)] > this.heap[curIndex]) {
            swapElements(getParentIndex(curIndex), curIndex);
            curIndex = getParentIndex(curIndex);
        }
    }

    private void heapifyDown() {
        int curIndex = 0;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }

    private void heapifyDown(int index) {
        int curIndex = index;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }

    private void increaseSize() {
        if(size<heap.length) return;

        int curSize = heap.length;
        int[] arr = new int[2*curSize];
        System.arraycopy(heap, 0, arr, 0, curSize);
        heap = arr;
    }

    private void swapElements(int sourceIndex, int destinationIndex) {
        if(sourceIndex>=this.heap.length || destinationIndex>=this.heap.length) throw new IllegalStateException();

        int temp = this.heap[sourceIndex];
        this.heap[sourceIndex] = this.heap[destinationIndex];
        this.heap[destinationIndex] = temp;
    }

    @Override
    public String toString(){
        return Arrays.toString(this.heap);
    }

    public boolean isEmpty() {
        return this.size == 0;
    }
}",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/,program,import java.util.Arrays;,"private int[] heap;
private int size;","(2, 0)","(125, 1)",N,class_declaration,Heap,,738,bae8cf36-8296-4c64-b7fb-0de32153d3a6
"private int[] heap;
private int size;",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,Previous sibling does not exist,"public Heap() {
        this.heap = new int[8];
        this.size = 0;
    }","(4, 4)","(5, 21)",N,"field_declaration,field_declaration",field_declaration,,9,d861ef02-8939-4167-9cdf-32a5a6c71300
"public Heap() {
        this.heap = new int[8];
        this.size = 0;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private int[] heap;
private int size;","public Heap(int capacity) {
        this.heap = new int[capacity];
        this.size = 0;
    }","(7, 4)","(10, 5)",N,constructor_declaration,Heap,,22,7eba3235-db02-4dba-b807-68429c7dd661
"public Heap(int capacity) {
        this.heap = new int[capacity];
        this.size = 0;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"public Heap() {
        this.heap = new int[8];
        this.size = 0;
    }","private int getParentIndex(int index){
        return (index-1)/2;
    }","(12, 4)","(15, 5)",N,constructor_declaration,Heap,,24,685961f6-b6fc-4ffc-80ac-36275e354998
"private int getParentIndex(int index){
        return (index-1)/2;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"public Heap(int capacity) {
        this.heap = new int[capacity];
        this.size = 0;
    }","private int getLeftChildIndex(int index){
        return 2*index + 1;
    }","(17, 4)","(19, 5)",N,method_declaration,getParentIndex,,18,7ac5541d-2c96-47e8-a844-f474177b2d33
"private int getLeftChildIndex(int index){
        return 2*index + 1;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private int getParentIndex(int index){
        return (index-1)/2;
    }","private int getRightChildIndex(int index){
        return 2*index + 2;
    }","(21, 4)","(23, 5)",N,method_declaration,getLeftChildIndex,,20,3f6985b6-bdd9-4f35-ad8a-0c55c9930c72
"private int getRightChildIndex(int index){
        return 2*index + 2;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private int getLeftChildIndex(int index){
        return 2*index + 1;
    }","public int peek() {
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        return this.heap[0];
    }","(25, 4)","(27, 5)",N,method_declaration,getRightChildIndex,,20,264778b4-9b37-4e0d-9b32-52c47a0249ad
"public int peek() {
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        return this.heap[0];
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private int getRightChildIndex(int index){
        return 2*index + 2;
    }","public int poll(){
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        swapElements(0, this.size-1);
        int val = this.heap[size-1];
        size--;
        heapifyDown();
        return val;
    }","(29, 4)","(32, 5)",N,method_declaration,peek,,31,05a6c7a4-0697-49d7-8ea1-d37741b6c855
"public int poll(){
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        swapElements(0, this.size-1);
        int val = this.heap[size-1];
        size--;
        heapifyDown();
        return val;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"public int peek() {
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        return this.heap[0];
    }","public void insert(int val){
        increaseSize();
        heap[size] = val;
        size++;
        heapifyUp();
    }","(34, 5)","(41, 5)",N,method_declaration,poll,,56,ae8c7a16-f66c-488c-ad36-fb4843c4d224
"public void insert(int val){
        increaseSize();
        heap[size] = val;
        size++;
        heapifyUp();
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"public int poll(){
        if(this.size==0) throw new IllegalStateException(""size of heap is zero"");
        swapElements(0, this.size-1);
        int val = this.heap[size-1];
        size--;
        heapifyDown();
        return val;
    }","private void heapifyUp() {
        int curIndex = this.size - 1;
        while (curIndex>0 && this.heap[getParentIndex(curIndex)] > this.heap[curIndex]) {
            swapElements(getParentIndex(curIndex), curIndex);
            curIndex = getParentIndex(curIndex);
        }
    }","(43, 4)","(48, 5)",N,method_declaration,insert,,27,c7fa2645-46e0-407c-a7d4-5a528617e349
"private void heapifyUp() {
        int curIndex = this.size - 1;
        while (curIndex>0 && this.heap[getParentIndex(curIndex)] > this.heap[curIndex]) {
            swapElements(getParentIndex(curIndex), curIndex);
            curIndex = getParentIndex(curIndex);
        }
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"public void insert(int val){
        increaseSize();
        heap[size] = val;
        size++;
        heapifyUp();
    }","private void heapifyDown() {
        int curIndex = 0;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }","(50, 4)","(56, 5)",N,method_declaration,heapifyUp,,66,50429455-8429-4b8a-aae2-f7aa106cc538
"private void heapifyDown() {
        int curIndex = 0;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private void heapifyUp() {
        int curIndex = this.size - 1;
        while (curIndex>0 && this.heap[getParentIndex(curIndex)] > this.heap[curIndex]) {
            swapElements(getParentIndex(curIndex), curIndex);
            curIndex = getParentIndex(curIndex);
        }
    }","private void heapifyDown(int index) {
        int curIndex = index;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }","(58, 4)","(77, 5)",N,method_declaration,heapifyDown,,132,ae743ca6-d787-4cdf-95b7-1a294ccc4823
"private void heapifyDown(int index) {
        int curIndex = index;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private void heapifyDown() {
        int curIndex = 0;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }","private void increaseSize() {
        if(size<heap.length) return;

        int curSize = heap.length;
        int[] arr = new int[2*curSize];
        System.arraycopy(heap, 0, arr, 0, curSize);
        heap = arr;
    }","(79, 4)","(98, 5)",N,method_declaration,heapifyDown,,133,b4d7a1de-4fbc-4b03-a001-7ef4af2b3a72
"private void increaseSize() {
        if(size<heap.length) return;

        int curSize = heap.length;
        int[] arr = new int[2*curSize];
        System.arraycopy(heap, 0, arr, 0, curSize);
        heap = arr;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private void heapifyDown(int index) {
        int curIndex = index;

        while(true){
            int leftIndex = getLeftChildIndex(curIndex);
            int rightIndex = getRightChildIndex(curIndex);

            if(leftIndex>=this.size) return;

            int smallestIndex = curIndex;

            if(this.heap[curIndex]>this.heap[leftIndex]) smallestIndex = leftIndex;
            if(rightIndex<this.size && this.heap[smallestIndex]>this.heap[rightIndex]) smallestIndex = rightIndex;

            if(curIndex == smallestIndex) return;

            swapElements(curIndex, smallestIndex);
            curIndex = smallestIndex;
        }
    }","private void swapElements(int sourceIndex, int destinationIndex) {
        if(sourceIndex>=this.heap.length || destinationIndex>=this.heap.length) throw new IllegalStateException();

        int temp = this.heap[sourceIndex];
        this.heap[sourceIndex] = this.heap[destinationIndex];
        this.heap[destinationIndex] = temp;
    }","(100, 4)","(107, 5)",N,method_declaration,increaseSize,,59,c4353b5f-2ce5-4ed5-a5cc-50ef18ae0ae8
"private void swapElements(int sourceIndex, int destinationIndex) {
        if(sourceIndex>=this.heap.length || destinationIndex>=this.heap.length) throw new IllegalStateException();

        int temp = this.heap[sourceIndex];
        this.heap[sourceIndex] = this.heap[destinationIndex];
        this.heap[destinationIndex] = temp;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private void increaseSize() {
        if(size<heap.length) return;

        int curSize = heap.length;
        int[] arr = new int[2*curSize];
        System.arraycopy(heap, 0, arr, 0, curSize);
        heap = arr;
    }","@Override
    public String toString(){
        return Arrays.toString(this.heap);
    }","(109, 4)","(115, 5)",N,method_declaration,swapElements,,67,6119ef6b-4832-45bb-9e67-dbc2ddc59763
"@Override
    public String toString(){
        return Arrays.toString(this.heap);
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"private void swapElements(int sourceIndex, int destinationIndex) {
        if(sourceIndex>=this.heap.length || destinationIndex>=this.heap.length) throw new IllegalStateException();

        int temp = this.heap[sourceIndex];
        this.heap[sourceIndex] = this.heap[destinationIndex];
        this.heap[destinationIndex] = temp;
    }","public boolean isEmpty() {
        return this.size == 0;
    }","(117, 4)","(120, 5)",N,method_declaration,toString,,16,13b7972f-bce8-4b2d-94e2-fad2b3bdec3b
"public boolean isEmpty() {
        return this.size == 0;
    }",Heap.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\Heap.java,program/class_declaration-Heap/,Heap,"@Override
    public String toString(){
        return Arrays.toString(this.heap);
    }",Next sibling does not exist,"(122, 4)","(124, 5)",N,method_declaration,isEmpty,,15,4979d9a0-9605-4adf-8ad4-3a6298375b64
"from math import inf


class  Heap:

    def __init__(self, capacity = 8):
        self.capacity = capacity # number of elements it can hold/store currently
        self.size = 0 # number of elements it's actually storing/present currently
        self.heap = [None for _ in range(self.capacity)]

    # main heap operations
    def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)

    def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]
    
    def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]

    def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()

    # heap helper functions
    def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex 

    def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex

    # index calculation helper functions
    @staticmethod
    def leftIndex(index): 
        return 2 * index + 1

    @staticmethod
    def rightIndex(index): 
        return 2 * index + 2

    @staticmethod
    def parentIndex(index): 
        return (index -1)//2

    def isIndexInRange(self, index): 
        return index < self.capacity

    def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))

    def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))

    def hasParent(self, index): 
        return index != 0


heap = Heap()
for i in range(10, -1, -1): 
    heap.add(i)
    print(heap.peek())

heap.decreaseKey(5)
while(heap.size > 0): print(heap.peek(), heap.pop())
",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(100, 0)",N,module,module,,724,75dbefd3-781e-4bf0-a00c-b1bf618fb6c1
from math import inf,heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/,module,Previous sibling does not exist,"class  Heap:

    def __init__(self, capacity = 8):
        self.capacity = capacity # number of elements it can hold/store currently
        self.size = 0 # number of elements it's actually storing/present currently
        self.heap = [None for _ in range(self.capacity)]

    # main heap operations
    def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)

    def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]
    
    def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]

    def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()

    # heap helper functions
    def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex 

    def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex

    # index calculation helper functions
    @staticmethod
    def leftIndex(index): 
        return 2 * index + 1

    @staticmethod
    def rightIndex(index): 
        return 2 * index + 2

    @staticmethod
    def parentIndex(index): 
        return (index -1)//2

    def isIndexInRange(self, index): 
        return index < self.capacity

    def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))

    def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))

    def hasParent(self, index): 
        return index != 0","(0, 0)","(0, 20)",N,import_from_statement,import_from_statement,,4,ffc4ca45-8544-4e7f-bceb-63b0b21141e7
"class  Heap:

    def __init__(self, capacity = 8):
        self.capacity = capacity # number of elements it can hold/store currently
        self.size = 0 # number of elements it's actually storing/present currently
        self.heap = [None for _ in range(self.capacity)]

    # main heap operations
    def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)

    def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]
    
    def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]

    def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()

    # heap helper functions
    def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex 

    def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex

    # index calculation helper functions
    @staticmethod
    def leftIndex(index): 
        return 2 * index + 1

    @staticmethod
    def rightIndex(index): 
        return 2 * index + 2

    @staticmethod
    def parentIndex(index): 
        return (index -1)//2

    def isIndexInRange(self, index): 
        return index < self.capacity

    def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))

    def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))

    def hasParent(self, index): 
        return index != 0",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/,module,from math import inf,heap = Heap(),"(3, 0)","(90, 25)",N,class_definition,Heap,,669,3c911098-db3d-4b36-979c-239e3ce525ae
"def __init__(self, capacity = 8):
        self.capacity = capacity # number of elements it can hold/store currently
        self.size = 0 # number of elements it's actually storing/present currently
        self.heap = [None for _ in range(self.capacity)]",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,Previous sibling does not exist,# main heap operations,"(5, 4)","(8, 56)",N,function_definition,__init__,,57,f0328fdb-1fed-4a4a-b5fd-c7210ba62da3
# main heap operations,heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def __init__(self, capacity = 8):
        self.capacity = capacity # number of elements it can hold/store currently
        self.size = 0 # number of elements it's actually storing/present currently
        self.heap = [None for _ in range(self.capacity)]","def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)","(10, 4)","(10, 26)",N,comment,comment,,4,fed89dba-3433-4fab-a93c-3a19398500f7
"def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,# main heap operations,"def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]","(11, 4)","(22, 35)",N,function_definition,add,,95,76551946-3818-435b-acb4-f3bac8d21845
"def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)","def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]","(24, 4)","(27, 27)",N,function_definition,peek,,36,48930765-9c0e-4640-8b59-4a7c92eb19f9
"def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]","def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()","(29, 4)","(35, 35)",N,function_definition,pop,,69,5c669d31-72d6-4f91-b633-c2bec6f9750c
"def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]",# heap helper functions,"(37, 4)","(42, 18)",N,function_definition,decreaseKey,,44,5abfcb8d-8032-42ed-b30d-88fb74471cc9
# heap helper functions,heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()","def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex","(44, 4)","(44, 27)",N,comment,comment,,4,8fdad9f3-2e3a-4ce2-b00e-67cf9133656d
"def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,# heap helper functions,"def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex","(45, 4)","(51, 31)",N,function_definition,heapifyUp,,64,2ec6c45b-7271-4cf3-a467-1c72c680b300
"def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex",# index calculation helper functions,"(53, 4)","(65, 33)",N,function_definition,heapifyDown,,133,99f650b5-cc7a-40b9-ad27-b58b3e2e5e73
# index calculation helper functions,heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex","@staticmethod
    def leftIndex(index): 
        return 2 * index + 1","(67, 4)","(67, 40)",N,comment,comment,,5,967ca32e-6f2f-46b2-8c77-46bc783cd7e9
"@staticmethod
    def leftIndex(index): 
        return 2 * index + 1",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,# index calculation helper functions,"@staticmethod
    def rightIndex(index): 
        return 2 * index + 2","(68, 4)","(70, 28)",N,function_definition,"def leftIndex(index): 
        return 2 * index + 1",,19,dc5cef33-ae0b-4d5a-b6d1-315cb4d70b7d
"@staticmethod
    def rightIndex(index): 
        return 2 * index + 2",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"@staticmethod
    def leftIndex(index): 
        return 2 * index + 1","@staticmethod
    def parentIndex(index): 
        return (index -1)//2","(72, 4)","(74, 28)",N,function_definition,"def rightIndex(index): 
        return 2 * index + 2",,19,8bd8b68f-37d4-487d-bf68-46b8c00050fc
"@staticmethod
    def parentIndex(index): 
        return (index -1)//2",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"@staticmethod
    def rightIndex(index): 
        return 2 * index + 2","def isIndexInRange(self, index): 
        return index < self.capacity","(76, 4)","(78, 28)",N,function_definition,"def parentIndex(index): 
        return (index -1)//2",,18,4edf9648-e6e3-4f4e-af79-d4112c4a7790
"def isIndexInRange(self, index): 
        return index < self.capacity",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"@staticmethod
    def parentIndex(index): 
        return (index -1)//2","def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))","(80, 4)","(81, 36)",N,function_definition,isIndexInRange,,15,b2044c62-eb0b-4ae0-bce5-5d7fdf02eac3
"def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def isIndexInRange(self, index): 
        return index < self.capacity","def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))","(83, 4)","(84, 57)",N,function_definition,hasLeftChild,,21,d60890e2-5080-4370-a6bb-9030df426a3d
"def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))","def hasParent(self, index): 
        return index != 0","(86, 4)","(87, 58)",N,function_definition,hasRightChild,,21,d59b31b9-1ed5-4d10-b91f-ea99be226d33
"def hasParent(self, index): 
        return index != 0",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/class_definition-Heap/,Heap,"def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))","heap = Heap()
for i in range(10, -1, -1): 
    heap.add(i)
    print(heap.peek())
heap.decreaseKey(5)
while(heap.size > 0): print(heap.peek(), heap.pop())","(89, 4)","(90, 25)",N,function_definition,hasParent,,14,a3f6e8f6-2124-4b90-a4f0-8ef29b734f72
"heap = Heap()
for i in range(10, -1, -1): 
    heap.add(i)
    print(heap.peek())
heap.decreaseKey(5)
while(heap.size > 0): print(heap.peek(), heap.pop())",heap.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\heap.py,module/,module,"class  Heap:

    def __init__(self, capacity = 8):
        self.capacity = capacity # number of elements it can hold/store currently
        self.size = 0 # number of elements it's actually storing/present currently
        self.heap = [None for _ in range(self.capacity)]

    # main heap operations
    def add(self, value): 
        # ran out of memory in heap, so double it!
        if(self.size == self.capacity): 
            for _ in range(self.capacity): self.heap.append(None)
            self.capacity *= 2
        
        # we add the new element to the end og the array
        self.heap[self.size] = value
        self.size += 1

        # heapify up
        self.heapifyUp(self.size-1)

    def peek(self): 
        # simpliest operation in heap
        if(self.size == 0): raise Exception(""index out of bound"")
        return self.heap[0]
    
    def pop(self): 
        if(self.size == 0): raise Exception(""index out of bound"")

        self.heap[0], self.heap[self.size-1] = self.heap[self.size-1], self.heap[0]
        self.size -= 1
        self.heapifyDown(0)
        return self.heap[self.size]

    def decreaseKey(self, index):
        if(index >= self.size): raise Exception(""index out of bound"")

        self.heap[index] = -10**10
        self.heapifyUp(index)
        self.pop()

    # heap helper functions
    def heapifyUp(self, index): 
        while(index > 0):
            parentIndex = Heap.parentIndex(index)
            if(self.heap[parentIndex] <= self.heap[index]): break

            self.heap[parentIndex], self.heap[index] = self.heap[index], self.heap[parentIndex]
            index = parentIndex 

    def heapifyDown(self, index):

        while(index < self.size):
            leftChildIndex = Heap.leftIndex(index)
            rightChildIndex = Heap.rightIndex(index)
            
            smallestIndex = index
            if(leftChildIndex < self.size and self.heap[smallestIndex] > self.heap[leftChildIndex]): smallestIndex =  leftChildIndex
            if(rightChildIndex < self.size and self.heap[smallestIndex] > self.heap[rightChildIndex]): smallestIndex = rightChildIndex

            if(index == smallestIndex): break
            self.heap[smallestIndex], self.heap[index] = self.heap[index], self.heap[smallestIndex]
            index = smallestIndex

    # index calculation helper functions
    @staticmethod
    def leftIndex(index): 
        return 2 * index + 1

    @staticmethod
    def rightIndex(index): 
        return 2 * index + 2

    @staticmethod
    def parentIndex(index): 
        return (index -1)//2

    def isIndexInRange(self, index): 
        return index < self.capacity

    def hasLeftChild(self, index): 
        return self.isIndexInRange(Heap.leftIndex(index))

    def hasRightChild(self, index): 
        return self.isIndexInRange(Heap.rightIndex(index))

    def hasParent(self, index): 
        return index != 0",Next sibling does not exist,"(93, 0)","(99, 52)",N,"expression_statement,for_statement,expression_statement,while_statement",expression_statement,,49,04956e74-97d7-4cee-9c91-b79a8f563922
"class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:

        N = len(nums1)
        M = len(nums2)
        
        row_index = 0
        col_index = 0

        ans = []
        visited = set()
        visited.add((0, 0))
        heap = [(nums1[row_index]+nums2[col_index], row_index, col_index)]
        heapify(heap)

        while(k and heap):
            _, x, y = heappop(heap)
            ans.append([nums1[x], nums2[y]])
            k -= 1
            if(k == 0): return ans

            if(x+1 < N and (x+1, y) not in visited): 
                heappush(heap, (nums1[x+1]+nums2[y], x+1, y))
                visited.add((x+1, y))
            if(y+1 < M and (x, y+1) not in visited): 
                heappush(heap, (nums1[x]+nums2[y+1], x, y+1))
                visited.add((x, y+1))
        
        return ans


",kSmallestSumPairs.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\kSmallestSumPairs.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 0)",N,module,module,,261,0029a6f0-34af-4321-9962-7030b26fe167
"class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:

        N = len(nums1)
        M = len(nums2)
        
        row_index = 0
        col_index = 0

        ans = []
        visited = set()
        visited.add((0, 0))
        heap = [(nums1[row_index]+nums2[col_index], row_index, col_index)]
        heapify(heap)

        while(k and heap):
            _, x, y = heappop(heap)
            ans.append([nums1[x], nums2[y]])
            k -= 1
            if(k == 0): return ans

            if(x+1 < N and (x+1, y) not in visited): 
                heappush(heap, (nums1[x+1]+nums2[y], x+1, y))
                visited.add((x+1, y))
            if(y+1 < M and (x, y+1) not in visited): 
                heappush(heap, (nums1[x]+nums2[y+1], x, y+1))
                visited.add((x, y+1))
        
        return ans",kSmallestSumPairs.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\kSmallestSumPairs.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 18)",N,class_definition,Solution,,260,11586475-9d8a-4541-a906-5ce0a4032b07
"def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:

        N = len(nums1)
        M = len(nums2)
        
        row_index = 0
        col_index = 0

        ans = []
        visited = set()
        visited.add((0, 0))
        heap = [(nums1[row_index]+nums2[col_index], row_index, col_index)]
        heapify(heap)

        while(k and heap):
            _, x, y = heappop(heap)
            ans.append([nums1[x], nums2[y]])
            k -= 1
            if(k == 0): return ans

            if(x+1 < N and (x+1, y) not in visited): 
                heappush(heap, (nums1[x+1]+nums2[y], x+1, y))
                visited.add((x+1, y))
            if(y+1 < M and (x, y+1) not in visited): 
                heappush(heap, (nums1[x]+nums2[y+1], x, y+1))
                visited.add((x, y+1))
        
        return ans",kSmallestSumPairs.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\kSmallestSumPairs.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(28, 18)",N,function_definition,kSmallestPairs,,256,5a825997-d918-4c37-8583-a660e7342a46
"class Solution {
    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {
            long[] prefixsum = new long[runningCosts.length];
            PriorityQueue<Long> queue = new PriorityQueue<>(Collections.reverseOrder());

            prefixsum[0] = runningCosts[0];
            for(int i=1;i<runningCosts.length;i++){
                prefixsum[i] += prefixsum[i-1] + runningCosts[i];
            }


            int start = 0;
            int end = 1;
            int ans = 0;
            queue.add((long) chargeTimes[0]);


            while(start <= end && start<prefixsum.length && end<=prefixsum.length){

                long chargeCost = queue.peek() == null ? 0 : queue.peek();
                long curCost = chargeCost + (end-start) * (prefixsum[end-1]-prefixsum[start]+runningCosts[start]);

                if(curCost<=budget) {
                    ans = Math.max(ans, end-start);
                    if(end<chargeTimes.length) queue.add((long) chargeTimes[end]);
                    end++;
                }
                else {
                    queue.remove((long) chargeTimes[start]);
                    start++;
                }
            }

            return ans;
    }
}
",MaximumRobots.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\MaximumRobots.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(36, 0)",N,program,program,,262,8febb584-5ebe-47e1-8e34-60a03fea245c
"class Solution {
    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {
            long[] prefixsum = new long[runningCosts.length];
            PriorityQueue<Long> queue = new PriorityQueue<>(Collections.reverseOrder());

            prefixsum[0] = runningCosts[0];
            for(int i=1;i<runningCosts.length;i++){
                prefixsum[i] += prefixsum[i-1] + runningCosts[i];
            }


            int start = 0;
            int end = 1;
            int ans = 0;
            queue.add((long) chargeTimes[0]);


            while(start <= end && start<prefixsum.length && end<=prefixsum.length){

                long chargeCost = queue.peek() == null ? 0 : queue.peek();
                long curCost = chargeCost + (end-start) * (prefixsum[end-1]-prefixsum[start]+runningCosts[start]);

                if(curCost<=budget) {
                    ans = Math.max(ans, end-start);
                    if(end<chargeTimes.length) queue.add((long) chargeTimes[end]);
                    end++;
                }
                else {
                    queue.remove((long) chargeTimes[start]);
                    start++;
                }
            }

            return ans;
    }
}",MaximumRobots.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\MaximumRobots.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(35, 1)",N,class_declaration,Solution,,262,82c31d61-5b82-49b1-81be-53a11a8b83de
"public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {
            long[] prefixsum = new long[runningCosts.length];
            PriorityQueue<Long> queue = new PriorityQueue<>(Collections.reverseOrder());

            prefixsum[0] = runningCosts[0];
            for(int i=1;i<runningCosts.length;i++){
                prefixsum[i] += prefixsum[i-1] + runningCosts[i];
            }


            int start = 0;
            int end = 1;
            int ans = 0;
            queue.add((long) chargeTimes[0]);


            while(start <= end && start<prefixsum.length && end<=prefixsum.length){

                long chargeCost = queue.peek() == null ? 0 : queue.peek();
                long curCost = chargeCost + (end-start) * (prefixsum[end-1]-prefixsum[start]+runningCosts[start]);

                if(curCost<=budget) {
                    ans = Math.max(ans, end-start);
                    if(end<chargeTimes.length) queue.add((long) chargeTimes[end]);
                    end++;
                }
                else {
                    queue.remove((long) chargeTimes[start]);
                    start++;
                }
            }

            return ans;
    }",MaximumRobots.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\MaximumRobots.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(34, 5)",N,method_declaration,maximumRobots,,257,89a99552-2d93-416b-a085-3b66454799be
"class Solution:
    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:
        
        N = len(reward1) 
        heap = []
        heapify(heap)
        visited = [False for i in range(N)]
        ans = 0
        
        for index, [rewarda, rewardb] in enumerate(zip(reward1, reward2)):
            heappush(heap, [rewardb-rewarda, index])
        
        while(k>0):
            diff, index = heappop(heap)
            visited[index] = True
            ans += reward1[index]
            k-=1
        
        for index in range(N):
            if(not visited[index]): ans += reward2[index]
        
        return ans
        
",miceAndCheese.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\miceAndCheese.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,module,module,,162,66cecbc3-d8b4-4679-9e32-0623ca3fe8c9
"class Solution:
    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:
        
        N = len(reward1) 
        heap = []
        heapify(heap)
        visited = [False for i in range(N)]
        ans = 0
        
        for index, [rewarda, rewardb] in enumerate(zip(reward1, reward2)):
            heappush(heap, [rewardb-rewarda, index])
        
        while(k>0):
            diff, index = heappop(heap)
            visited[index] = True
            ans += reward1[index]
            k-=1
        
        for index in range(N):
            if(not visited[index]): ans += reward2[index]
        
        return ans",miceAndCheese.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\miceAndCheese.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 18)",N,class_definition,Solution,,161,814c6bf4-00bc-4f20-9b12-94f51c3f64e8
"def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:
        
        N = len(reward1) 
        heap = []
        heapify(heap)
        visited = [False for i in range(N)]
        ans = 0
        
        for index, [rewarda, rewardb] in enumerate(zip(reward1, reward2)):
            heappush(heap, [rewardb-rewarda, index])
        
        while(k>0):
            diff, index = heappop(heap)
            visited[index] = True
            ans += reward1[index]
            k-=1
        
        for index in range(N):
            if(not visited[index]): ans += reward2[index]
        
        return ans",miceAndCheese.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\miceAndCheese.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(21, 18)",N,function_definition,miceAndCheese,,157,efdbf6a1-9314-4987-9d33-3cb9f9ba1454
"# just playing with Comparable classes in python
class Person:

    def __init__(self, name, age, nationality):
        self.name = name
        self.age = age
        self.nationality = nationality
    

    def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'
    
    def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0 
    
    def __lt__(self, __value):
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + str(type(__value)))
        return self.age - __value.age < 0 

Person1 = Person(""akarsh"", 22, ""indian"")
Person2 = Person(""maitrey"", 21, ""american"")
Person3 = Person(""Elon Musk"", 50, ""South African"")


persons = [Person1, Person2, Person3]
for person in persons: print(person)
persons.sort()
for person in persons: print(person)
print(Person1 > Person2, Person2 > Person3)
",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 0)",N,module,module,,265,5361ba8b-16a2-42c4-b92a-344a8a545557
# just playing with Comparable classes in python,person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/,module,Previous sibling does not exist,"class Person:

    def __init__(self, name, age, nationality):
        self.name = name
        self.age = age
        self.nationality = nationality
    

    def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'
    
    def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0 
    
    def __lt__(self, __value):
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + str(type(__value)))
        return self.age - __value.age < 0","(0, 0)","(0, 48)",N,comment,comment,,8,17d8c23a-9e0f-4926-8366-fc8a8ba47edf
"class Person:

    def __init__(self, name, age, nationality):
        self.name = name
        self.age = age
        self.nationality = nationality
    

    def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'
    
    def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0 
    
    def __lt__(self, __value):
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + str(type(__value)))
        return self.age - __value.age < 0",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/,module,# just playing with Comparable classes in python,"Person1 = Person(""akarsh"", 22, ""indian"")","(1, 0)","(18, 41)",N,class_definition,Person,,164,7ea3ba2f-6303-4890-aa1a-dc2079cc0e1d
"def __init__(self, name, age, nationality):
        self.name = name
        self.age = age
        self.nationality = nationality",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/class_definition-Person/,Person,Previous sibling does not exist,"def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'","(3, 4)","(6, 38)",N,function_definition,__init__,,31,02dfabfd-55cc-4a8b-8d4c-51e0559e4288
"def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/class_definition-Person/,Person,"def __init__(self, name, age, nationality):
        self.name = name
        self.age = age
        self.nationality = nationality","def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0","(9, 4)","(10, 94)",N,function_definition,__str__,,33,32d7b78d-5edc-4ec6-b2fb-b644da0ec2fe
"def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/class_definition-Person/,Person,"def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'","def __lt__(self, __value):
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + str(type(__value)))
        return self.age - __value.age < 0","(12, 4)","(14, 42)",N,function_definition,__eq__,,47,9541d890-9bce-4843-81ad-5e3c5baa1149
"def __lt__(self, __value):
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + str(type(__value)))
        return self.age - __value.age < 0",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/class_definition-Person/,Person,"def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0","Person1 = Person(""akarsh"", 22, ""indian"")
Person2 = Person(""maitrey"", 21, ""american"")
Person3 = Person(""Elon Musk"", 50, ""South African"")
persons = [Person1, Person2, Person3]
for person in persons: print(person)
persons.sort()
for person in persons: print(person)
print(Person1 > Person2, Person2 > Person3)","(16, 4)","(18, 41)",N,function_definition,__lt__,,43,f464dc74-4c5b-4c35-9086-bb9cf39eefc8
"Person1 = Person(""akarsh"", 22, ""indian"")
Person2 = Person(""maitrey"", 21, ""american"")
Person3 = Person(""Elon Musk"", 50, ""South African"")
persons = [Person1, Person2, Person3]
for person in persons: print(person)
persons.sort()
for person in persons: print(person)
print(Person1 > Person2, Person2 > Person3)",person.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\person.py,module/,module,"class Person:

    def __init__(self, name, age, nationality):
        self.name = name
        self.age = age
        self.nationality = nationality
    

    def __str__(self):
        return f'Person [name: {self.name}, age: {self.age}, nationality: {self.nationality}]'
    
    def __eq__(self, __value: object) -> bool:
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + type(__value))
        return self.age - __value.age == 0 
    
    def __lt__(self, __value):
        if(not isinstance(__value, Person)): raise Exception(""Cannot compare Person with "" + str(type(__value)))
        return self.age - __value.age < 0",Next sibling does not exist,"(20, 0)","(29, 43)",N,"expression_statement,expression_statement,expression_statement,expression_statement,for_statement,expression_statement,for_statement,expression_statement",expression_statement,,91,fe04363e-3aba-477f-95fa-6639347ea250
"class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:

        def scheduleTask(heap, t, ans):
            taskProcesstingTime, index = heappop(heap)
            t += taskProcesstingTime
            ans.append(index)
            return t

        new = []
        for index,task in enumerate(tasks):
            task.append(index)
            new.append(task)
        tasks = new
    
        tasks.sort(key=lambda x:(x[0]))
        index = 0
        N = len(tasks)

        t = 1
        heap = []
        heapify(heap)
        ans = []

        while(index<N):
            # tasks whose enqueue time is less than equal to t 
            # add them to pq
            while(index<N and tasks[index][0]<=t):
                heappush(heap, [tasks[index][1], tasks[index][2]])
                index += 1
            
            if(heap): t = scheduleTask(heap, t, ans)
            else: t = tasks[index][0]
        
        while(heap): t = scheduleTask(heap, t, ans)

        return ans



",SingleThreadedCPU.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\SingleThreadedCPU.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(40, 0)",N,module,module,,235,ff68d48c-75a5-4e9a-9cad-028a05c6da1f
"class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:

        def scheduleTask(heap, t, ans):
            taskProcesstingTime, index = heappop(heap)
            t += taskProcesstingTime
            ans.append(index)
            return t

        new = []
        for index,task in enumerate(tasks):
            task.append(index)
            new.append(task)
        tasks = new
    
        tasks.sort(key=lambda x:(x[0]))
        index = 0
        N = len(tasks)

        t = 1
        heap = []
        heapify(heap)
        ans = []

        while(index<N):
            # tasks whose enqueue time is less than equal to t 
            # add them to pq
            while(index<N and tasks[index][0]<=t):
                heappush(heap, [tasks[index][1], tasks[index][2]])
                index += 1
            
            if(heap): t = scheduleTask(heap, t, ans)
            else: t = tasks[index][0]
        
        while(heap): t = scheduleTask(heap, t, ans)

        return ans",SingleThreadedCPU.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\SingleThreadedCPU.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(36, 18)",N,class_definition,Solution,,234,3662685c-745e-458b-8d38-dc3a85d1988b
"def getOrder(self, tasks: List[List[int]]) -> List[int]:

        def scheduleTask(heap, t, ans):
            taskProcesstingTime, index = heappop(heap)
            t += taskProcesstingTime
            ans.append(index)
            return t

        new = []
        for index,task in enumerate(tasks):
            task.append(index)
            new.append(task)
        tasks = new
    
        tasks.sort(key=lambda x:(x[0]))
        index = 0
        N = len(tasks)

        t = 1
        heap = []
        heapify(heap)
        ans = []

        while(index<N):
            # tasks whose enqueue time is less than equal to t 
            # add them to pq
            while(index<N and tasks[index][0]<=t):
                heappush(heap, [tasks[index][1], tasks[index][2]])
                index += 1
            
            if(heap): t = scheduleTask(heap, t, ans)
            else: t = tasks[index][0]
        
        while(heap): t = scheduleTask(heap, t, ans)

        return ans",SingleThreadedCPU.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\SingleThreadedCPU.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(36, 18)",N,function_definition,getOrder,,230,e50d0f0a-a618-4c8e-bb0f-ee6f54bf19d6
"def scheduleTask(heap, t, ans):
            taskProcesstingTime, index = heappop(heap)
            t += taskProcesstingTime
            ans.append(index)
            return t",SingleThreadedCPU.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\heap\SingleThreadedCPU.py,module/class_definition-Solution/function_definition-getOrder/,getOrder,Previous sibling does not exist,new = [],"(3, 8)","(7, 20)",N,function_definition,scheduleTask,,42,97f16e30-6b4e-48ae-9975-3a3d84ebb668
"from linkedlist.DoubllyLinkedList import DoubllyLinkedList, DoubllyLinkedListNode

class AuthenticationManager:

    def __init__(self, timeToLive: int):
        self.dll = DoubllyLinkedList()
        self.count = 0
        self.timeToLive = timeToLive
        self.map = {}

    def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1

    def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()


    def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1

    def countUnexpiredTokens(self, currentTime: int) -> int:
        self.cleanup(currentTime)
        return self.count   


# Your AuthenticationManager object will be instantiated and called as such:
# obj = AuthenticationManager(timeToLive)
# obj.generate(tokenId,currentTime)
# obj.renew(tokenId,currentTime)
# param_3 = obj.countUnexpiredTokens(currentTime)
",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(50, 0)",N,module,module,,350,0450dfd7-d603-4c7a-8465-2d52f153b9cb
"from linkedlist.DoubllyLinkedList import DoubllyLinkedList, DoubllyLinkedListNode",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/,module,Previous sibling does not exist,"class AuthenticationManager:

    def __init__(self, timeToLive: int):
        self.dll = DoubllyLinkedList()
        self.count = 0
        self.timeToLive = timeToLive
        self.map = {}

    def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1

    def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()


    def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1

    def countUnexpiredTokens(self, currentTime: int) -> int:
        self.cleanup(currentTime)
        return self.count","(0, 0)","(0, 81)",N,import_from_statement,import_from_statement,,19,05512d8d-d2fb-4232-a9f1-7c2aafd52054
"class AuthenticationManager:

    def __init__(self, timeToLive: int):
        self.dll = DoubllyLinkedList()
        self.count = 0
        self.timeToLive = timeToLive
        self.map = {}

    def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1

    def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()


    def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1

    def countUnexpiredTokens(self, currentTime: int) -> int:
        self.cleanup(currentTime)
        return self.count",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/,module,"from linkedlist.DoubllyLinkedList import DoubllyLinkedList, DoubllyLinkedListNode",# Your AuthenticationManager object will be instantiated and called as such:,"(2, 0)","(42, 25)",N,class_definition,AuthenticationManager,,276,8ebdbb34-6373-44cd-a33d-1c010dde2a7a
"def __init__(self, timeToLive: int):
        self.dll = DoubllyLinkedList()
        self.count = 0
        self.timeToLive = timeToLive
        self.map = {}",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/class_definition-AuthenticationManager/,AuthenticationManager,Previous sibling does not exist,"def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1","(4, 4)","(8, 21)",N,function_definition,__init__,,43,07e960ce-43c6-4ae3-ae12-ddfb18a638a4
"def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/class_definition-AuthenticationManager/,AuthenticationManager,"def __init__(self, timeToLive: int):
        self.dll = DoubllyLinkedList()
        self.count = 0
        self.timeToLive = timeToLive
        self.map = {}","def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()","(10, 4)","(16, 23)",N,function_definition,generate,,67,6dfb876a-15a3-49ea-8b8f-a014850ae32b
"def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/class_definition-AuthenticationManager/,AuthenticationManager,"def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1","def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1","(18, 4)","(26, 26)",N,function_definition,renew,,73,b999638b-99b3-4656-b10c-d509df45a94b
"def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/class_definition-AuthenticationManager/,AuthenticationManager,"def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()","def countUnexpiredTokens(self, currentTime: int) -> int:
        self.cleanup(currentTime)
        return self.count","(29, 4)","(38, 27)",N,function_definition,cleanup,,58,ce705e04-0a28-478e-80c9-2f711b5a1d36
"def countUnexpiredTokens(self, currentTime: int) -> int:
        self.cleanup(currentTime)
        return self.count",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/class_definition-AuthenticationManager/,AuthenticationManager,"def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1","# Your AuthenticationManager object will be instantiated and called as such:
# obj = AuthenticationManager(timeToLive)
# obj.generate(tokenId,currentTime)
# obj.renew(tokenId,currentTime)
# param_3 = obj.countUnexpiredTokens(currentTime)","(40, 4)","(42, 25)",N,function_definition,countUnexpiredTokens,,24,ec10e64d-439e-43ab-abef-7b07344e2692
"# Your AuthenticationManager object will be instantiated and called as such:
# obj = AuthenticationManager(timeToLive)
# obj.generate(tokenId,currentTime)
# obj.renew(tokenId,currentTime)
# param_3 = obj.countUnexpiredTokens(currentTime)",AuthenticationManager.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\AuthenticationManager.py,module/,module,"class AuthenticationManager:

    def __init__(self, timeToLive: int):
        self.dll = DoubllyLinkedList()
        self.count = 0
        self.timeToLive = timeToLive
        self.map = {}

    def generate(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)
        node = DoubllyLinkedListNode([currentTime+self.timeToLive, tokenId])
        self.map[tokenId] = node
        self.dll.addNodeToTail(node)
        # self.dll.print()
        self.count += 1

    def renew(self, tokenId: str, currentTime: int) -> None:
        self.cleanup(currentTime)

        if(tokenId not in self.map): return
        node = self.map[tokenId]
        self.dll.delete(node)
        node.val[0] = currentTime+self.timeToLive
        self.dll.addNodeToTail(node)
        # self.dll.print()


    def cleanup(self, currentTime):
        temp = self.dll.head
        while(temp and temp.val[0]<=currentTime):
            tokenId = temp.val[1]

            del self.map[tokenId]
            self.dll.delete(temp)
            
            temp = temp.next
            self.count -= 1

    def countUnexpiredTokens(self, currentTime: int) -> int:
        self.cleanup(currentTime)
        return self.count",Next sibling does not exist,"(45, 0)","(49, 49)",N,"comment,comment,comment,comment,comment",comment,,52,9bb41c1a-c644-4a2d-a88a-d597c513401f
"class DoubllyLinkedListNode:

    def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next
    
    def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)

class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)

dll = DoubllyLinkedList()
node1 = DoubllyLinkedListNode(1)
dll.addNodeToTail(node1)
dll.delete(node1)
dll.addNodeToTail(DoubllyLinkedListNode(2))
dll.addNodeToTail(DoubllyLinkedListNode(3))
node4 = DoubllyLinkedListNode(4)
dll.addNodeToTail(node4)
dll.addNodeToTail(DoubllyLinkedListNode(5))

dll.print()
dll.print(forward=False)

dll.delete(node4)
dll.print()
dll.print(forward=False)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(95, 24)",N,module,module,,569,9f118478-11ea-4ef5-b638-3cab89c74ce1
"class DoubllyLinkedListNode:

    def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next
    
    def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/,module,Previous sibling does not exist,"class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)","(0, 0)","(8, 54)",N,class_definition,DoubllyLinkedListNode,,67,1e43ecd8-2563-4463-8587-3fa3c345a330
"def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedListNode/,DoubllyLinkedListNode,Previous sibling does not exist,"def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)","(2, 4)","(5, 24)",N,function_definition,__init__,,33,360cb6e1-a8ea-4138-9712-e3999d69f3dd
"def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedListNode/,DoubllyLinkedListNode,"def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next",Next sibling does not exist,"(7, 4)","(8, 54)",N,function_definition,__str__,,24,831c998d-c131-46d9-ab1c-976fa28b376a
"class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/,module,"class DoubllyLinkedListNode:

    def __init__(self, val, prev = None, next = None):
        self.val = val
        self.prev = prev
        self.next = next
    
    def __str__(self) -> str:
        return str(self.val) + "" -> "" + str(self.next)",dll = DoubllyLinkedList(),"(10, 0)","(78, 29)",N,class_definition,DoubllyLinkedList,,392,44f7faa7-d308-44d7-928c-4281b1079966
"def __init__(self):
        self.head = None
        self.tail = None",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,Previous sibling does not exist,"def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node","(12, 4)","(14, 24)",N,function_definition,__init__,,17,9526da95-df05-4148-8d33-41c850265e66
"def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def __init__(self):
        self.head = None
        self.tail = None","def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node","(17, 4)","(24, 28)",N,function_definition,addNodeToHead,,63,7ce2d1ce-3f18-4b87-84e6-0ad38c9db375
"def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node","def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None","(27, 4)","(34, 28)",N,function_definition,addNodeToTail,,63,dc4b6281-f861-4eec-9659-b98171458b87
"def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node","def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False","(37, 4)","(47, 40)",N,function_definition,delete,,88,11dc4c5b-e2d0-4ac4-a580-f96cd0aa7591
"def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None","def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None","(49, 4)","(55, 20)",N,function_definition,contains,,35,7beaab73-458c-4295-be71-3ad7c447d1e5
"def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False","def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)","(57, 4)","(63, 19)",N,function_definition,getNode,,35,65010350-7e5a-4501-9919-31e48f0913ec
"def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None","def __str__(self) -> str:
        return str(self.head)","(68, 4)","(75, 23)",N,function_definition,print,,53,19f6e24d-a431-4917-a5df-b83ceff97f3c
"def __str__(self) -> str:
        return str(self.head)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/class_definition-DoubllyLinkedList/,DoubllyLinkedList,"def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)","dll = DoubllyLinkedList()
node1 = DoubllyLinkedListNode(1)
dll.addNodeToTail(node1)
dll.delete(node1)
dll.addNodeToTail(DoubllyLinkedListNode(2))
dll.addNodeToTail(DoubllyLinkedListNode(3))
node4 = DoubllyLinkedListNode(4)
dll.addNodeToTail(node4)
dll.addNodeToTail(DoubllyLinkedListNode(5))
dll.print()
dll.print(forward=False)
dll.delete(node4)
dll.print()
dll.print(forward=False)","(77, 4)","(78, 29)",N,function_definition,__str__,,15,c186ed10-b579-43f9-840e-3bb1640892c1
"dll = DoubllyLinkedList()
node1 = DoubllyLinkedListNode(1)
dll.addNodeToTail(node1)
dll.delete(node1)
dll.addNodeToTail(DoubllyLinkedListNode(2))
dll.addNodeToTail(DoubllyLinkedListNode(3))
node4 = DoubllyLinkedListNode(4)
dll.addNodeToTail(node4)
dll.addNodeToTail(DoubllyLinkedListNode(5))
dll.print()
dll.print(forward=False)
dll.delete(node4)
dll.print()
dll.print(forward=False)",DoubllyLinkedList.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\DoubllyLinkedList.py,module/,module,"class DoubllyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
    

    def addNodeToHead(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.next = self.head
            self.head.prev = node
            self.head = node
    

    def addNodeToTail(self, node: DoubllyLinkedListNode):
        # linked list is empty 
        if(not self.head and not self.tail):
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
    

    def delete(self, node):
        if(node.next and node.prev):
            node.prev.next, node.next.prev = node.next, node.prev
        elif(node == self.head and node.next):
            self.head = node.next
            self.head.prev = None
        elif(node == self.tail and node.prev):
            self.tail = node.prev
            self.tail.next = None
        else:
            self.tail = self.head = None
    
    def contains(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return True
            temp = temp.prev
        
        return False

    def getNode(self, val):
        temp = self.tail
        while(temp):
            if(temp.val == val): return temp
            temp = temp.prev
        
        return None
    
    

    
    def print(self, forward = True):
        if(forward): print(str(self.head))
        else:
            temp = self.tail
            while(temp):
                print(str(temp.val) + "" -> "", end="""")
                temp = temp.prev
            print(temp)
    
    def __str__(self) -> str:
        return str(self.head)",Next sibling does not exist,"(80, 0)","(95, 24)",N,"expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement",expression_statement,,110,86280a45-c5dd-422b-b220-170a71c080d7
"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        heap = []
        heapify(heap)
        counter = 0

        for node in lists: 
            if(node): 
                heappush(heap, [node.val, counter, node])
                counter += 1

        
        head = ListNode(-10**10)
        temp = head

        while(heap):
            _, _, node = heappop(heap)
            next_node = node.next
            if(next_node): 
                heappush(heap, [next_node.val, counter, next_node])
                counter += 1

            node.next = None
            temp.next = node
            temp = temp.next
        return head.next

",mergeKLists.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\mergeKLists.py,,NA,Previous sibling does not exist,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next","(0, 0)","(33, 0)",N,module,module,,197,5fc2b867-ccbd-479a-aa8e-3b2f6a5efecc
"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next",mergeKLists.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\mergeKLists.py,module/,module,Previous sibling does not exist,"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        heap = []
        heapify(heap)
        counter = 0

        for node in lists: 
            if(node): 
                heappush(heap, [node.val, counter, node])
                counter += 1

        
        head = ListNode(-10**10)
        temp = head

        while(heap):
            _, _, node = heappop(heap)
            next_node = node.next
            if(next_node): 
                heappush(heap, [next_node.val, counter, next_node])
                counter += 1

            node.next = None
            temp.next = node
            temp = temp.next
        return head.next","(0, 0)","(4, 26)",N,"comment,comment,comment,comment,comment",comment,,38,2127d0d9-083f-4f09-b0d0-98e65723d7d8
"class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        heap = []
        heapify(heap)
        counter = 0

        for node in lists: 
            if(node): 
                heappush(heap, [node.val, counter, node])
                counter += 1

        
        head = ListNode(-10**10)
        temp = head

        while(heap):
            _, _, node = heappop(heap)
            next_node = node.next
            if(next_node): 
                heappush(heap, [next_node.val, counter, next_node])
                counter += 1

            node.next = None
            temp.next = node
            temp = temp.next
        return head.next",mergeKLists.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\mergeKLists.py,module/,module,"# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next",Next sibling does not exist,"(5, 0)","(31, 24)",N,class_definition,Solution,,156,cc24cec3-ae40-4f5f-aa43-a2d16a90f451
"def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        heap = []
        heapify(heap)
        counter = 0

        for node in lists: 
            if(node): 
                heappush(heap, [node.val, counter, node])
                counter += 1

        
        head = ListNode(-10**10)
        temp = head

        while(heap):
            _, _, node = heappop(heap)
            next_node = node.next
            if(next_node): 
                heappush(heap, [next_node.val, counter, next_node])
                counter += 1

            node.next = None
            temp.next = node
            temp = temp.next
        return head.next",mergeKLists.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\mergeKLists.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(6, 4)","(31, 24)",N,function_definition,mergeKLists,,152,17ce519e-c4bf-4116-9d78-362b76d28128
"class MyCircularQueue {

    private int size;
    private int capacity;
    private Node head;
    private Node tail;
    
    
    public MyCircularQueue(int k) {
        this.size = 0;
        this.capacity = k;
    }
    
    public boolean enQueue(int value) {
        if(capacity <= size) return false;
        
        if(tail == null){
            head = tail = new Node(value, null, null);
            size++;
        } else {
            Node newNode = new Node(value, tail, null);
            tail.next = newNode;
            tail = tail.next;
            size++;
        }
        
        return true;
    }
    
    public boolean deQueue() {
        if(isEmpty()) return false;
                
        head = head.next;
        size--;
        if(size == 0) tail = null;
        return true;
    }
    
    public int Front() {
        if(head == null) return -1;
        return head.val;
    }
    
    public int Rear() {
        if(tail == null) return -1;
        return tail.val;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
}

class Node{
    int val;
    Node prev;
    Node next;
    
    public Node(int val){
        this.val = val;
    }
    
    public Node(int val, Node prev, Node next){
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}



/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */
",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(85, 0)",N,program,program,,411,7f8480ae-52f7-46b5-a889-12000b486c5d
"class MyCircularQueue {

    private int size;
    private int capacity;
    private Node head;
    private Node tail;
    
    
    public MyCircularQueue(int k) {
        this.size = 0;
        this.capacity = k;
    }
    
    public boolean enQueue(int value) {
        if(capacity <= size) return false;
        
        if(tail == null){
            head = tail = new Node(value, null, null);
            size++;
        } else {
            Node newNode = new Node(value, tail, null);
            tail.next = newNode;
            tail = tail.next;
            size++;
        }
        
        return true;
    }
    
    public boolean deQueue() {
        if(isEmpty()) return false;
                
        head = head.next;
        size--;
        if(size == 0) tail = null;
        return true;
    }
    
    public int Front() {
        if(head == null) return -1;
        return head.val;
    }
    
    public int Rear() {
        if(tail == null) return -1;
        return tail.val;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
}",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/,program,Previous sibling does not exist,"class Node{
    int val;
    Node prev;
    Node next;
    
    public Node(int val){
        this.val = val;
    }
    
    public Node(int val, Node prev, Node next){
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}","(0, 0)","(55, 1)",N,class_declaration,MyCircularQueue,,259,756c9787-909f-4aab-8e59-7064b2246838
"public MyCircularQueue(int k) {
        this.size = 0;
        this.capacity = k;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,private Node tail;,"public boolean enQueue(int value) {
        if(capacity <= size) return false;
        
        if(tail == null){
            head = tail = new Node(value, null, null);
            size++;
        } else {
            Node newNode = new Node(value, tail, null);
            tail.next = newNode;
            tail = tail.next;
            size++;
        }
        
        return true;
    }","(8, 4)","(11, 5)",N,constructor_declaration,MyCircularQueue,,23,b1f8b844-970c-4d25-b3cb-40cad9caa43d
"public boolean enQueue(int value) {
        if(capacity <= size) return false;
        
        if(tail == null){
            head = tail = new Node(value, null, null);
            size++;
        } else {
            Node newNode = new Node(value, tail, null);
            tail.next = newNode;
            tail = tail.next;
            size++;
        }
        
        return true;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,"public MyCircularQueue(int k) {
        this.size = 0;
        this.capacity = k;
    }","public boolean deQueue() {
        if(isEmpty()) return false;
                
        head = head.next;
        size--;
        if(size == 0) tail = null;
        return true;
    }","(13, 4)","(27, 5)",N,method_declaration,enQueue,,82,fe4c5bd1-a69a-4445-af4d-a5d1b03b7385
"public boolean deQueue() {
        if(isEmpty()) return false;
                
        head = head.next;
        size--;
        if(size == 0) tail = null;
        return true;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,"public boolean enQueue(int value) {
        if(capacity <= size) return false;
        
        if(tail == null){
            head = tail = new Node(value, null, null);
            size++;
        } else {
            Node newNode = new Node(value, tail, null);
            tail.next = newNode;
            tail = tail.next;
            size++;
        }
        
        return true;
    }","public int Front() {
        if(head == null) return -1;
        return head.val;
    }","(29, 4)","(36, 5)",N,method_declaration,deQueue,,41,1e80f141-e172-4f1c-bce8-f3032e130745
"public int Front() {
        if(head == null) return -1;
        return head.val;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,"public boolean deQueue() {
        if(isEmpty()) return false;
                
        head = head.next;
        size--;
        if(size == 0) tail = null;
        return true;
    }","public int Rear() {
        if(tail == null) return -1;
        return tail.val;
    }","(38, 4)","(41, 5)",N,method_declaration,Front,,22,e6a68d56-bbd2-443f-9825-6bb66f13c68b
"public int Rear() {
        if(tail == null) return -1;
        return tail.val;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,"public int Front() {
        if(head == null) return -1;
        return head.val;
    }","public boolean isEmpty() {
        return size == 0;
    }","(43, 4)","(46, 5)",N,method_declaration,Rear,,23,9845d5d5-4fe0-4f2a-93e6-92a69b3ddfaf
"public boolean isEmpty() {
        return size == 0;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,"public int Rear() {
        if(tail == null) return -1;
        return tail.val;
    }","public boolean isFull() {
        return size == capacity;
    }","(48, 4)","(50, 5)",N,method_declaration,isEmpty,,14,f1ea2127-f564-4438-801c-82c7029834d0
"public boolean isFull() {
        return size == capacity;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-MyCircularQueue/,MyCircularQueue,"public boolean isEmpty() {
        return size == 0;
    }",Next sibling does not exist,"(52, 4)","(54, 5)",N,method_declaration,isFull,,14,dc77fe6c-cba2-4e5f-a14b-d483f64b2ff7
"class Node{
    int val;
    Node prev;
    Node next;
    
    public Node(int val){
        this.val = val;
    }
    
    public Node(int val, Node prev, Node next){
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/,program,"class MyCircularQueue {

    private int size;
    private int capacity;
    private Node head;
    private Node tail;
    
    
    public MyCircularQueue(int k) {
        this.size = 0;
        this.capacity = k;
    }
    
    public boolean enQueue(int value) {
        if(capacity <= size) return false;
        
        if(tail == null){
            head = tail = new Node(value, null, null);
            size++;
        } else {
            Node newNode = new Node(value, tail, null);
            tail.next = newNode;
            tail = tail.next;
            size++;
        }
        
        return true;
    }
    
    public boolean deQueue() {
        if(isEmpty()) return false;
                
        head = head.next;
        size--;
        if(size == 0) tail = null;
        return true;
    }
    
    public int Front() {
        if(head == null) return -1;
        return head.val;
    }
    
    public int Rear() {
        if(tail == null) return -1;
        return tail.val;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
}","/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */","(57, 0)","(71, 1)",N,class_declaration,Node,,64,4b236ac7-c82b-45ec-af8a-1b6a5aaff941
"public Node(int val){
        this.val = val;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-Node/,Node,Node next;,"public Node(int val, Node prev, Node next){
        this.val = val;
        this.prev = prev;
        this.next = next;
    }","(62, 4)","(64, 5)",N,constructor_declaration,Node,,13,228bef5b-ee6c-4047-9ff8-641ea8b671b8
"public Node(int val, Node prev, Node next){
        this.val = val;
        this.prev = prev;
        this.next = next;
    }",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/class_declaration-Node/,Node,"public Node(int val){
        this.val = val;
    }",Next sibling does not exist,"(66, 4)","(70, 5)",N,constructor_declaration,Node,,31,24ad6280-5afb-498d-9e8c-e5fffd149732
"/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */",MyCircularQueue.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\MyCircularQueue.java,program/,program,"class Node{
    int val;
    Node prev;
    Node next;
    
    public Node(int val){
        this.val = val;
    }
    
    public Node(int val, Node prev, Node next){
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}",Next sibling does not exist,"(75, 0)","(84, 3)",N,block_comment,block_comment,,88,853ffde4-df4c-4beb-bc9c-ee2a3fd8b42b
"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        length = 0
        temp = head
        while(temp):
            temp = temp.next
            length+=1
        
        rounds = length//k

        def helper(head, k, offset, rounds):
            if(not head or offset>rounds): 
                return head

            prev = None
            nextNode = None
            cur = head
            count = k

            while(cur and count>0):
                nextNode = cur.next 
                cur.next = prev

                prev = cur
                cur = nextNode
                count-=1

            head.next = helper(nextNode, k, offset+1, rounds)
            return prev
        
        return helper(head, k, 1, rounds)
",reverseKGroup.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\reverseKGroup.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(32, 0)",N,module,module,,175,34c8f610-88a5-4aab-a296-ca4fdd2788a9
"class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        length = 0
        temp = head
        while(temp):
            temp = temp.next
            length+=1
        
        rounds = length//k

        def helper(head, k, offset, rounds):
            if(not head or offset>rounds): 
                return head

            prev = None
            nextNode = None
            cur = head
            count = k

            while(cur and count>0):
                nextNode = cur.next 
                cur.next = prev

                prev = cur
                cur = nextNode
                count-=1

            head.next = helper(nextNode, k, offset+1, rounds)
            return prev
        
        return helper(head, k, 1, rounds)",reverseKGroup.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\reverseKGroup.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(31, 41)",N,class_definition,Solution,,175,5fd3d676-feeb-40b9-8daa-328301d2d12e
"def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        
        length = 0
        temp = head
        while(temp):
            temp = temp.next
            length+=1
        
        rounds = length//k

        def helper(head, k, offset, rounds):
            if(not head or offset>rounds): 
                return head

            prev = None
            nextNode = None
            cur = head
            count = k

            while(cur and count>0):
                nextNode = cur.next 
                cur.next = prev

                prev = cur
                cur = nextNode
                count-=1

            head.next = helper(nextNode, k, offset+1, rounds)
            return prev
        
        return helper(head, k, 1, rounds)",reverseKGroup.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\reverseKGroup.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(31, 41)",N,function_definition,reverseKGroup,,171,360eb2a5-04c0-4594-8e25-23732c0af768
"def helper(head, k, offset, rounds):
            if(not head or offset>rounds): 
                return head

            prev = None
            nextNode = None
            cur = head
            count = k

            while(cur and count>0):
                nextNode = cur.next 
                cur.next = prev

                prev = cur
                cur = nextNode
                count-=1

            head.next = helper(nextNode, k, offset+1, rounds)
            return prev",reverseKGroup.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\reverseKGroup.py,module/class_definition-Solution/function_definition-reverseKGroup/,reverseKGroup,rounds = length//k,"return helper(head, k, 1, rounds)","(11, 8)","(29, 23)",N,function_definition,helper,,102,66af3213-8c56-41cb-81a1-3cc373c5dd1c
,__init__.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\linkedlist\__init__.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(0, 0)",N,module,module,,0,afa456e2-e82d-42f0-8e5f-8220175562d2
"class Solution:
    def countOdds(self, low: int, high: int) -> int:
        if(low>high): return 0
        if(low%2 == 1): return 1 + self.countOdds(low+1, high)
        if(high%2 == 1): return 1 + self.countOdds(low, high-1)
        return (high-low)//2
",countOdds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\countOdds.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(6, 0)",N,module,module,,85,ae99a57c-ff55-4f3b-90f0-c1ebb4a1ff09
"class Solution:
    def countOdds(self, low: int, high: int) -> int:
        if(low>high): return 0
        if(low%2 == 1): return 1 + self.countOdds(low+1, high)
        if(high%2 == 1): return 1 + self.countOdds(low, high-1)
        return (high-low)//2",countOdds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\countOdds.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(5, 28)",N,class_definition,Solution,,84,8f217f82-9a41-4577-a979-3d8b292476e4
"def countOdds(self, low: int, high: int) -> int:
        if(low>high): return 0
        if(low%2 == 1): return 1 + self.countOdds(low+1, high)
        if(high%2 == 1): return 1 + self.countOdds(low, high-1)
        return (high-low)//2",countOdds.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\countOdds.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(5, 28)",N,function_definition,countOdds,,80,d16ba53a-73c1-4440-a1bb-b43ac0dd073a
"class Solution:
    def sumOfPower(self, nums: List[int]) -> int:
        
        ans = 0
        N = len(nums)
        mod = 10**9 + 7
        nums.sort() 

        def mul(a, b): return (a%mod * b%mod)%mod
        def sum(a, b): return (a%mod + b%mod)%mod

        cur = 0
        for index in range(N):
            cur = mul(cur, 2)
            if(index-1>=0): cur = sum(cur, nums[index-1])
            ans = sum(ans, nums[index] ** 3)
            ans = sum(ans, nums[index]**2 * cur)

        return ans


sol = Solution()
arr = [1 for i in range(10**5)]
ans = sol.sumOfPower(arr)
print(ans)",sumOfPower.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\sumOfPower.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(24, 10)",N,module,module,,183,78826280-e37a-414c-9951-286b9f666bb9
"class Solution:
    def sumOfPower(self, nums: List[int]) -> int:
        
        ans = 0
        N = len(nums)
        mod = 10**9 + 7
        nums.sort() 

        def mul(a, b): return (a%mod * b%mod)%mod
        def sum(a, b): return (a%mod + b%mod)%mod

        cur = 0
        for index in range(N):
            cur = mul(cur, 2)
            if(index-1>=0): cur = sum(cur, nums[index-1])
            ans = sum(ans, nums[index] ** 3)
            ans = sum(ans, nums[index]**2 * cur)

        return ans",sumOfPower.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\sumOfPower.py,module/,module,Previous sibling does not exist,sol = Solution(),"(0, 0)","(18, 18)",N,class_definition,Solution,,154,92d78ed7-085c-4aa2-8c97-affc332370cc
"def sumOfPower(self, nums: List[int]) -> int:
        
        ans = 0
        N = len(nums)
        mod = 10**9 + 7
        nums.sort() 

        def mul(a, b): return (a%mod * b%mod)%mod
        def sum(a, b): return (a%mod + b%mod)%mod

        cur = 0
        for index in range(N):
            cur = mul(cur, 2)
            if(index-1>=0): cur = sum(cur, nums[index-1])
            ans = sum(ans, nums[index] ** 3)
            ans = sum(ans, nums[index]**2 * cur)

        return ans",sumOfPower.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\sumOfPower.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(18, 18)",N,function_definition,sumOfPower,,150,3ab17834-e062-469f-b532-3533e402f7fb
"def mul(a, b): return (a%mod * b%mod)%mod",sumOfPower.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\sumOfPower.py,module/class_definition-Solution/function_definition-sumOfPower/,sumOfPower,nums.sort(),"def sum(a, b): return (a%mod + b%mod)%mod","(8, 8)","(8, 49)",N,function_definition,mul,,17,0e52ef1e-77ce-402f-ade2-31c2755bc43f
"def sum(a, b): return (a%mod + b%mod)%mod",sumOfPower.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\sumOfPower.py,module/class_definition-Solution/function_definition-sumOfPower/,sumOfPower,"def mul(a, b): return (a%mod * b%mod)%mod","sol = Solution()
arr = [1 for i in range(10**5)]
ans = sol.sumOfPower(arr)
print(ans)","(9, 8)","(9, 49)",N,function_definition,sum,,17,1a6aa19d-55cd-44e7-99d3-c7264d03c33e
"sol = Solution()
arr = [1 for i in range(10**5)]
ans = sol.sumOfPower(arr)
print(ans)",sumOfPower.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\math\sumOfPower.py,module/,module,"class Solution:
    def sumOfPower(self, nums: List[int]) -> int:
        
        ans = 0
        N = len(nums)
        mod = 10**9 + 7
        nums.sort() 

        def mul(a, b): return (a%mod * b%mod)%mod
        def sum(a, b): return (a%mod + b%mod)%mod

        cur = 0
        for index in range(N):
            cur = mul(cur, 2)
            if(index-1>=0): cur = sum(cur, nums[index-1])
            ans = sum(ans, nums[index] ** 3)
            ans = sum(ans, nums[index]**2 * cur)

        return ans",Next sibling does not exist,"(21, 0)","(24, 10)",N,"expression_statement,expression_statement,expression_statement,expression_statement",expression_statement,,28,38e37960-25dd-49af-9673-9ccdbe656e9b
"class Solution:
    def PredictTheWinner(self, nums: List[int]) -> bool:

        @cache
        def helper(startIndex, endIndex):
            if(startIndex > endIndex): return 0

            return max(
                nums[startIndex] - helper(startIndex+1, endIndex), 
                nums[endIndex] - helper(startIndex, endIndex-1)
                )

        
        return helper(0, len(nums)-1) >= 0
",PredictTheWinner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\PredictTheWinner.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 0)",N,module,module,,92,990d6b20-c9bc-427d-b7cd-04cf1777cd00
"class Solution:
    def PredictTheWinner(self, nums: List[int]) -> bool:

        @cache
        def helper(startIndex, endIndex):
            if(startIndex > endIndex): return 0

            return max(
                nums[startIndex] - helper(startIndex+1, endIndex), 
                nums[endIndex] - helper(startIndex, endIndex-1)
                )

        
        return helper(0, len(nums)-1) >= 0",PredictTheWinner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\PredictTheWinner.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(13, 42)",N,class_definition,Solution,,91,4229e41d-1a55-45a9-9d6b-9f31089cd1d3
"def PredictTheWinner(self, nums: List[int]) -> bool:

        @cache
        def helper(startIndex, endIndex):
            if(startIndex > endIndex): return 0

            return max(
                nums[startIndex] - helper(startIndex+1, endIndex), 
                nums[endIndex] - helper(startIndex, endIndex-1)
                )

        
        return helper(0, len(nums)-1) >= 0",PredictTheWinner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\PredictTheWinner.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(13, 42)",N,function_definition,PredictTheWinner,,87,6acbcf55-a66a-4e16-974a-8ef87fd2dc0d
"@cache
        def helper(startIndex, endIndex):
            if(startIndex > endIndex): return 0

            return max(
                nums[startIndex] - helper(startIndex+1, endIndex), 
                nums[endIndex] - helper(startIndex, endIndex-1)
                )",PredictTheWinner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\PredictTheWinner.py,module/class_definition-Solution/function_definition-PredictTheWinner/,PredictTheWinner,Previous sibling does not exist,"return helper(0, len(nums)-1) >= 0","(3, 8)","(10, 17)",N,function_definition,"def helper(startIndex, endIndex):
            if(startIndex > endIndex): return 0

            return max(
                nums[startIndex] - helper(startIndex+1, endIndex), 
                nums[endIndex] - helper(startIndex, endIndex-1)
                )",,57,b75ca37a-b276-4e76-9ca2-c6752c09a4c9
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:

        @cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans
        
        return (sum(piles) + helper(0, 1))//2
",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\stoneGameII.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 0)",N,module,module,,147,938da55f-052b-4980-91c1-711a88ec3125
"class Solution:
    def stoneGameII(self, piles: List[int]) -> int:

        @cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans
        
        return (sum(piles) + helper(0, 1))//2",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\stoneGameII.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 45)",N,class_definition,Solution,,146,1098e6df-9b49-43bd-8cc3-fd619c1dea25
"def stoneGameII(self, piles: List[int]) -> int:

        @cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans
        
        return (sum(piles) + helper(0, 1))//2",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\stoneGameII.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(17, 45)",N,function_definition,stoneGameII,,142,89a13c90-3ba9-4ad1-abb7-e98f2ed1ba1b
"@cache
        def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans",stoneGameII.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\minimax\stoneGameII.py,module/class_definition-Solution/function_definition-stoneGameII/,stoneGameII,Previous sibling does not exist,"return (sum(piles) + helper(0, 1))//2","(3, 8)","(15, 22)",N,function_definition,"def helper(index, M):
            if(index>=len(piles)): return 0
            rem_piles = len(piles) - index
            if(rem_piles<=2*M): return sum(piles[index:])
            
            ans = -10**10
            running_sum = 0
            for i in range(2*M):
                running_sum += piles[index+i]
                ans = max(ans, running_sum - helper(index+i+1, max(M, i+1)))
            
            return ans",,109,c487d48d-091d-4fec-8580-70b59d972055
"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        
        def getVal(num):
            num+=1
            if(num<3): return 0
            else: return (num * num)//2 - (3*num)//2 + 1
        
        N = len(nums)
        if(N<3): return 0
        
        prevdiff = nums[1] - nums[0]
        curCount = 1
        ans = 0
        
        for index in range(2, N):
            diff  = nums[index] - nums[index-1]
            if(diff == prevdiff): 
                curCount += 1
            else:
                # print(curCount)
                ans += getVal(curCount) #something with cur count
                curCount = 1
            
            prevdiff = diff
        
        # print(curCount)
        ans += getVal(curCount)
        return ans
",ArithmeticSlices.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\ArithmeticSlices.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 0)",N,module,module,,196,285fc2d1-953b-4aa3-bb45-82f44ed1e784
"class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        
        def getVal(num):
            num+=1
            if(num<3): return 0
            else: return (num * num)//2 - (3*num)//2 + 1
        
        N = len(nums)
        if(N<3): return 0
        
        prevdiff = nums[1] - nums[0]
        curCount = 1
        ans = 0
        
        for index in range(2, N):
            diff  = nums[index] - nums[index-1]
            if(diff == prevdiff): 
                curCount += 1
            else:
                # print(curCount)
                ans += getVal(curCount) #something with cur count
                curCount = 1
            
            prevdiff = diff
        
        # print(curCount)
        ans += getVal(curCount)
        return ans",ArithmeticSlices.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\ArithmeticSlices.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 18)",N,class_definition,Solution,,195,811735bd-23fc-48b3-93e9-a7d53b224a7d
"def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        
        def getVal(num):
            num+=1
            if(num<3): return 0
            else: return (num * num)//2 - (3*num)//2 + 1
        
        N = len(nums)
        if(N<3): return 0
        
        prevdiff = nums[1] - nums[0]
        curCount = 1
        ans = 0
        
        for index in range(2, N):
            diff  = nums[index] - nums[index-1]
            if(diff == prevdiff): 
                curCount += 1
            else:
                # print(curCount)
                ans += getVal(curCount) #something with cur count
                curCount = 1
            
            prevdiff = diff
        
        # print(curCount)
        ans += getVal(curCount)
        return ans",ArithmeticSlices.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\ArithmeticSlices.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(28, 18)",N,function_definition,numberOfArithmeticSlices,,191,dd2b6d83-a836-40f6-b75d-82c7adcdb525
"def getVal(num):
            num+=1
            if(num<3): return 0
            else: return (num * num)//2 - (3*num)//2 + 1",ArithmeticSlices.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\ArithmeticSlices.py,module/class_definition-Solution/function_definition-numberOfArithmeticSlices/,numberOfArithmeticSlices,Previous sibling does not exist,N = len(nums),"(3, 8)","(6, 56)",N,function_definition,getVal,,39,9c7d889e-9b53-4646-b86d-3b7c6c244659
"class Solution:
    def closestPrimes(self, left: int, right: int) -> List[int]:
        prime = [True for i in range(right+1)]
        
        def SieveOfEratosthenes(prime):
            N = len(prime)
            p = 2
            while (p * p <= N-1):
                if (prime[p] == True):
                    for i in range(p * p, N, p):
                        prime[i] = False
                p += 1
        
        SieveOfEratosthenes(prime)
        
        ans = 10**10
        prev = -1
        arr = [-1, -1]
        
        for p in range(max(2, left), len(prime)):
            if prime[p]:
                if(prev != -1):
                    cur = p - prev
                    if(cur<ans):
                        ans = cur
                        arr = [prev, p]
                prev = p
        
        return arr
",closestPrimes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\closestPrimes.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 0)",N,module,module,,207,6467f6a2-7909-41eb-979c-501b35b8be3f
"class Solution:
    def closestPrimes(self, left: int, right: int) -> List[int]:
        prime = [True for i in range(right+1)]
        
        def SieveOfEratosthenes(prime):
            N = len(prime)
            p = 2
            while (p * p <= N-1):
                if (prime[p] == True):
                    for i in range(p * p, N, p):
                        prime[i] = False
                p += 1
        
        SieveOfEratosthenes(prime)
        
        ans = 10**10
        prev = -1
        arr = [-1, -1]
        
        for p in range(max(2, left), len(prime)):
            if prime[p]:
                if(prev != -1):
                    cur = p - prev
                    if(cur<ans):
                        ans = cur
                        arr = [prev, p]
                prev = p
        
        return arr",closestPrimes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\closestPrimes.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 18)",N,class_definition,Solution,,206,29f2afbb-2c46-4b1b-a41e-e817383169df
"def closestPrimes(self, left: int, right: int) -> List[int]:
        prime = [True for i in range(right+1)]
        
        def SieveOfEratosthenes(prime):
            N = len(prime)
            p = 2
            while (p * p <= N-1):
                if (prime[p] == True):
                    for i in range(p * p, N, p):
                        prime[i] = False
                p += 1
        
        SieveOfEratosthenes(prime)
        
        ans = 10**10
        prev = -1
        arr = [-1, -1]
        
        for p in range(max(2, left), len(prime)):
            if prime[p]:
                if(prev != -1):
                    cur = p - prev
                    if(cur<ans):
                        ans = cur
                        arr = [prev, p]
                prev = p
        
        return arr",closestPrimes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\closestPrimes.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(28, 18)",N,function_definition,closestPrimes,,202,71d83ac5-20d7-48ee-813e-5bfebf7a7b9e
"def SieveOfEratosthenes(prime):
            N = len(prime)
            p = 2
            while (p * p <= N-1):
                if (prime[p] == True):
                    for i in range(p * p, N, p):
                        prime[i] = False
                p += 1",closestPrimes.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\closestPrimes.py,module/class_definition-Solution/function_definition-closestPrimes/,closestPrimes,prime = [True for i in range(right+1)],SieveOfEratosthenes(prime),"(4, 8)","(11, 22)",N,function_definition,SieveOfEratosthenes,,70,811a57d2-71f7-4aa0-b208-b70d2cb34f16
"class Solution {
    public int commonFactors(int a, int b) {
        int ans=0;
        for(int i=1; i<=Math.min(a,b); i++){
            if(a%i ==0 && b%i==0) ans++;
        }
        
        return ans;
    }
}
",CommonFactors.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\CommonFactors.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(10, 0)",N,program,program,,61,2cfa5bd7-e003-4b64-b2f8-3480256c8090
"class Solution {
    public int commonFactors(int a, int b) {
        int ans=0;
        for(int i=1; i<=Math.min(a,b); i++){
            if(a%i ==0 && b%i==0) ans++;
        }
        
        return ans;
    }
}",CommonFactors.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\CommonFactors.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(9, 1)",N,class_declaration,Solution,,61,4790861d-a599-48be-89f9-7f71c90b498b
"public int commonFactors(int a, int b) {
        int ans=0;
        for(int i=1; i<=Math.min(a,b); i++){
            if(a%i ==0 && b%i==0) ans++;
        }
        
        return ans;
    }",CommonFactors.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\CommonFactors.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(8, 5)",N,method_declaration,commonFactors,,56,6458aca8-7466-425b-91f1-a004605dc619
"class Solution:
    def maximizeSum(self, nums: List[int], k: int) -> int:
        def sumOfn(num): return (num * (num+1))//2
        
        m = max(nums)
        return sumOfn(m+k-1) - sumOfn(m-1)
",maximizeSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\maximizeSum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(6, 0)",N,module,module,,64,d6be396a-6bd3-43f2-85ea-bb8b6a302647
"class Solution:
    def maximizeSum(self, nums: List[int], k: int) -> int:
        def sumOfn(num): return (num * (num+1))//2
        
        m = max(nums)
        return sumOfn(m+k-1) - sumOfn(m-1)",maximizeSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\maximizeSum.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(5, 42)",N,class_definition,Solution,,64,32facca5-94e6-4574-bc28-fa09cb1a0298
"def maximizeSum(self, nums: List[int], k: int) -> int:
        def sumOfn(num): return (num * (num+1))//2
        
        m = max(nums)
        return sumOfn(m+k-1) - sumOfn(m-1)",maximizeSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\maximizeSum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(5, 42)",N,function_definition,maximizeSum,,60,6c75d4e2-99f1-40ee-a756-a04e82302867
def sumOfn(num): return (num * (num+1))//2,maximizeSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\maximizeSum.py,module/class_definition-Solution/function_definition-maximizeSum/,maximizeSum,Previous sibling does not exist,m = max(nums),"(2, 8)","(2, 50)",N,function_definition,sumOfn,,17,6ac3170d-b6f6-45db-86fb-264fbcfd026f
"class Solution {
    public int maxSum(int[][] grid) {
        int ans = 0;
        for(int i=0; i<grid.length-2; i++){
            for(int j=0; j<grid[0].length-2;j++){
                ans = Math.max(ans, getValue(grid, i, j));
            }
        }
        return ans;
    }
    
    public int getValue(int[][] grid, int index1, int index2){
        return grid[index1][index2] + grid[index1][index2+1] + grid[index1][index2+2] + 
            grid[index1+1][index2+1] + 
            grid[index1+2][index2] + grid[index1+2][index2+1] + grid[index1+2][index2+2];
    }
}
",MaxSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\MaxSum.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 0)",N,program,program,,177,8a9285d3-d962-4c94-a707-0d0d4e489543
"class Solution {
    public int maxSum(int[][] grid) {
        int ans = 0;
        for(int i=0; i<grid.length-2; i++){
            for(int j=0; j<grid[0].length-2;j++){
                ans = Math.max(ans, getValue(grid, i, j));
            }
        }
        return ans;
    }
    
    public int getValue(int[][] grid, int index1, int index2){
        return grid[index1][index2] + grid[index1][index2+1] + grid[index1][index2+2] + 
            grid[index1+1][index2+1] + 
            grid[index1+2][index2] + grid[index1+2][index2+1] + grid[index1+2][index2+2];
    }
}",MaxSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\MaxSum.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 1)",N,class_declaration,Solution,,177,3da71ae3-dbcc-46a9-8bb3-478fd2a5853c
"public int maxSum(int[][] grid) {
        int ans = 0;
        for(int i=0; i<grid.length-2; i++){
            for(int j=0; j<grid[0].length-2;j++){
                ans = Math.max(ans, getValue(grid, i, j));
            }
        }
        return ans;
    }",MaxSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\MaxSum.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public int getValue(int[][] grid, int index1, int index2){
        return grid[index1][index2] + grid[index1][index2+1] + grid[index1][index2+2] + 
            grid[index1+1][index2+1] + 
            grid[index1+2][index2] + grid[index1+2][index2+1] + grid[index1+2][index2+2];
    }","(1, 4)","(9, 5)",N,method_declaration,maxSum,,74,559a4e3f-19b7-4d62-ad45-6145295f51b4
"public int getValue(int[][] grid, int index1, int index2){
        return grid[index1][index2] + grid[index1][index2+1] + grid[index1][index2+2] + 
            grid[index1+1][index2+1] + 
            grid[index1+2][index2] + grid[index1+2][index2+1] + grid[index1+2][index2+2];
    }",MaxSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\miscellaneous\MaxSum.java,program/class_declaration-Solution/,Solution,"public int maxSum(int[][] grid) {
        int ans = 0;
        for(int i=0; i<grid.length-2; i++){
            for(int j=0; j<grid[0].length-2;j++){
                ans = Math.max(ans, getValue(grid, i, j));
            }
        }
        return ans;
    }",Next sibling does not exist,"(11, 4)","(15, 5)",N,method_declaration,getValue,,96,57223a4f-c3eb-4359-9ab7-5d1bebaefbbd
"from SegmentTree import SegmentTree


class MinimumComputingTime:

    def findMinimumTime(self, tasks) -> int:
        timeline = SegmentTree([0 for i in range(10)], operator=lambda x, y : x+y, operationIdentity=0)
        ans = 0
        for start, end, duration in tasks:
            onTime =  timeline.query(start, end)
            if(onTime >= duration): continue

            remaining = duration - onTime
            ans += remaining
            timeline.rightfill(remaining, start, end)
        
        return ans

MinimumComputingTime = MinimumComputingTime()
MinimumComputingTime.findMinimumTime([[2,3,1],[4,5,1],[1,5,2]])",MinimumComputingTime.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\MinimumComputingTime.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(19, 63)",N,module,module,,154,49eab4c9-e373-45e8-83be-cfc376b3ee0e
from SegmentTree import SegmentTree,MinimumComputingTime.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\MinimumComputingTime.py,module/,module,Previous sibling does not exist,"class MinimumComputingTime:

    def findMinimumTime(self, tasks) -> int:
        timeline = SegmentTree([0 for i in range(10)], operator=lambda x, y : x+y, operationIdentity=0)
        ans = 0
        for start, end, duration in tasks:
            onTime =  timeline.query(start, end)
            if(onTime >= duration): continue

            remaining = duration - onTime
            ans += remaining
            timeline.rightfill(remaining, start, end)
        
        return ans","(0, 0)","(0, 35)",N,import_from_statement,import_from_statement,,6,d3eac04d-b8e2-416b-9529-05f65095c0fd
"class MinimumComputingTime:

    def findMinimumTime(self, tasks) -> int:
        timeline = SegmentTree([0 for i in range(10)], operator=lambda x, y : x+y, operationIdentity=0)
        ans = 0
        for start, end, duration in tasks:
            onTime =  timeline.query(start, end)
            if(onTime >= duration): continue

            remaining = duration - onTime
            ans += remaining
            timeline.rightfill(remaining, start, end)
        
        return ans",MinimumComputingTime.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\MinimumComputingTime.py,module/,module,from SegmentTree import SegmentTree,MinimumComputingTime = MinimumComputingTime(),"(3, 0)","(16, 18)",N,class_definition,MinimumComputingTime,,110,1c64a75b-93a4-497c-afd6-ad4bc3acd348
"def findMinimumTime(self, tasks) -> int:
        timeline = SegmentTree([0 for i in range(10)], operator=lambda x, y : x+y, operationIdentity=0)
        ans = 0
        for start, end, duration in tasks:
            onTime =  timeline.query(start, end)
            if(onTime >= duration): continue

            remaining = duration - onTime
            ans += remaining
            timeline.rightfill(remaining, start, end)
        
        return ans",MinimumComputingTime.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\MinimumComputingTime.py,module/class_definition-MinimumComputingTime/,MinimumComputingTime,Previous sibling does not exist,"MinimumComputingTime = MinimumComputingTime()
MinimumComputingTime.findMinimumTime([[2,3,1],[4,5,1],[1,5,2]])","(5, 4)","(16, 18)",N,function_definition,findMinimumTime,,103,7a762898-0841-4a8f-81aa-285238998117
"MinimumComputingTime = MinimumComputingTime()
MinimumComputingTime.findMinimumTime([[2,3,1],[4,5,1],[1,5,2]])",MinimumComputingTime.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\MinimumComputingTime.py,module/,module,"class MinimumComputingTime:

    def findMinimumTime(self, tasks) -> int:
        timeline = SegmentTree([0 for i in range(10)], operator=lambda x, y : x+y, operationIdentity=0)
        ans = 0
        for start, end, duration in tasks:
            onTime =  timeline.query(start, end)
            if(onTime >= duration): continue

            remaining = duration - onTime
            ans += remaining
            timeline.rightfill(remaining, start, end)
        
        return ans",Next sibling does not exist,"(18, 0)","(19, 63)",N,"expression_statement,expression_statement",expression_statement,,36,0fc85e85-5b0c-40b5-b232-41440caa43be
"package com.akarsh.codechef.segmentTree;

import java.util.Arrays;

public class SegmentTree<T extends Number> {

    private final int n;
    private final double[] segmentTree;
    private final T[] arr;

    SegmentTree(int n, T[] arr){
        this.n = n;
        int modifiedChildCount = (int) Math.pow(2, Math.ceil(Math.log(n)/Math.log(2)));
        int size = 2 * modifiedChildCount - 1;
        this.segmentTree = new double[size];
        this.arr = arr;
        buildSegmentTree(arr);
    }

    public void buildSegmentTree(T[] arr){
        helper(0, arr.length-1, 0);
    }

    public void helper(int start, int end, int index){

        if(start == end){
            this.segmentTree[index] = arr[start].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        helper(start, mid, 2*index + 1);
        helper(mid+1, end, 2*index + 2);
        this.segmentTree[index] = this.segmentTree[2*index+1] + this.segmentTree[2*index+2];
    }

    public void updateHelper(int start, int end, int arrIndex, int segIndex) {

        if(start == end){
            this.segmentTree[segIndex] = this.arr[arrIndex].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        if(arrIndex <= mid) updateHelper(start, mid, arrIndex, segIndex*2 + 1);
        else updateHelper(mid+1, end, arrIndex, segIndex*2 + 2);

        this.segmentTree[segIndex] = this.segmentTree[2*segIndex+1] + this.segmentTree[2*segIndex+2];
    }

    public void update(int index, T newValue){
        this.arr[index] = newValue;
        updateHelper(0,n-1, index, 0);
    }

    public Double query(int start, int end){
        return query(start, end, 0, n-1,0);
    }

    private Double query(int start, int end, int vStart, int vEnd, int index){

        System.out.println(start + "" "" + end + "" "" + vStart + "" "" + vEnd + "" "" + index);
        if(start>end) return 0.0;

        if(start == vStart && end == vEnd) return segmentTree[index];
        if(start>vEnd || end<vStart) return 0.0;

        int mid = vStart + (vEnd - vStart)/2;

        if(end<=mid) return query(start, end, vStart, mid, 2*index+1);
        if(start>mid) return query(start, end, mid+1, vEnd, 2*index+2);

        return query(start, mid, vStart, mid, 2*index+1) +  query(mid+1, end, mid+1, vEnd, 2*index+2);
    }



    @Override
    public String toString() {
        return ""SegmentTree{"" +
                ""segmentTree="" + Arrays.toString(segmentTree) +
                "", arr="" + Arrays.toString(arr) +
                '}';
    }
}
",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,,NA,Previous sibling does not exist,"package com.akarsh.codechef.segmentTree;
import java.util.Arrays;","(0, 0)","(85, 0)",N,program,program,,706,2016c271-11f3-499a-b9cd-ee1c2ce2d49f
"package com.akarsh.codechef.segmentTree;
import java.util.Arrays;",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/,program,Previous sibling does not exist,"public class SegmentTree<T extends Number> {

    private final int n;
    private final double[] segmentTree;
    private final T[] arr;

    SegmentTree(int n, T[] arr){
        this.n = n;
        int modifiedChildCount = (int) Math.pow(2, Math.ceil(Math.log(n)/Math.log(2)));
        int size = 2 * modifiedChildCount - 1;
        this.segmentTree = new double[size];
        this.arr = arr;
        buildSegmentTree(arr);
    }

    public void buildSegmentTree(T[] arr){
        helper(0, arr.length-1, 0);
    }

    public void helper(int start, int end, int index){

        if(start == end){
            this.segmentTree[index] = arr[start].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        helper(start, mid, 2*index + 1);
        helper(mid+1, end, 2*index + 2);
        this.segmentTree[index] = this.segmentTree[2*index+1] + this.segmentTree[2*index+2];
    }

    public void updateHelper(int start, int end, int arrIndex, int segIndex) {

        if(start == end){
            this.segmentTree[segIndex] = this.arr[arrIndex].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        if(arrIndex <= mid) updateHelper(start, mid, arrIndex, segIndex*2 + 1);
        else updateHelper(mid+1, end, arrIndex, segIndex*2 + 2);

        this.segmentTree[segIndex] = this.segmentTree[2*segIndex+1] + this.segmentTree[2*segIndex+2];
    }

    public void update(int index, T newValue){
        this.arr[index] = newValue;
        updateHelper(0,n-1, index, 0);
    }

    public Double query(int start, int end){
        return query(start, end, 0, n-1,0);
    }

    private Double query(int start, int end, int vStart, int vEnd, int index){

        System.out.println(start + "" "" + end + "" "" + vStart + "" "" + vEnd + "" "" + index);
        if(start>end) return 0.0;

        if(start == vStart && end == vEnd) return segmentTree[index];
        if(start>vEnd || end<vStart) return 0.0;

        int mid = vStart + (vEnd - vStart)/2;

        if(end<=mid) return query(start, end, vStart, mid, 2*index+1);
        if(start>mid) return query(start, end, mid+1, vEnd, 2*index+2);

        return query(start, mid, vStart, mid, 2*index+1) +  query(mid+1, end, mid+1, vEnd, 2*index+2);
    }



    @Override
    public String toString() {
        return ""SegmentTree{"" +
                ""segmentTree="" + Arrays.toString(segmentTree) +
                "", arr="" + Arrays.toString(arr) +
                '}';
    }
}","(0, 0)","(2, 24)",N,"package_declaration,import_declaration",package_declaration,,15,6332c91f-adbc-4b56-8ee3-6026921ca760
"public class SegmentTree<T extends Number> {

    private final int n;
    private final double[] segmentTree;
    private final T[] arr;

    SegmentTree(int n, T[] arr){
        this.n = n;
        int modifiedChildCount = (int) Math.pow(2, Math.ceil(Math.log(n)/Math.log(2)));
        int size = 2 * modifiedChildCount - 1;
        this.segmentTree = new double[size];
        this.arr = arr;
        buildSegmentTree(arr);
    }

    public void buildSegmentTree(T[] arr){
        helper(0, arr.length-1, 0);
    }

    public void helper(int start, int end, int index){

        if(start == end){
            this.segmentTree[index] = arr[start].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        helper(start, mid, 2*index + 1);
        helper(mid+1, end, 2*index + 2);
        this.segmentTree[index] = this.segmentTree[2*index+1] + this.segmentTree[2*index+2];
    }

    public void updateHelper(int start, int end, int arrIndex, int segIndex) {

        if(start == end){
            this.segmentTree[segIndex] = this.arr[arrIndex].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        if(arrIndex <= mid) updateHelper(start, mid, arrIndex, segIndex*2 + 1);
        else updateHelper(mid+1, end, arrIndex, segIndex*2 + 2);

        this.segmentTree[segIndex] = this.segmentTree[2*segIndex+1] + this.segmentTree[2*segIndex+2];
    }

    public void update(int index, T newValue){
        this.arr[index] = newValue;
        updateHelper(0,n-1, index, 0);
    }

    public Double query(int start, int end){
        return query(start, end, 0, n-1,0);
    }

    private Double query(int start, int end, int vStart, int vEnd, int index){

        System.out.println(start + "" "" + end + "" "" + vStart + "" "" + vEnd + "" "" + index);
        if(start>end) return 0.0;

        if(start == vStart && end == vEnd) return segmentTree[index];
        if(start>vEnd || end<vStart) return 0.0;

        int mid = vStart + (vEnd - vStart)/2;

        if(end<=mid) return query(start, end, vStart, mid, 2*index+1);
        if(start>mid) return query(start, end, mid+1, vEnd, 2*index+2);

        return query(start, mid, vStart, mid, 2*index+1) +  query(mid+1, end, mid+1, vEnd, 2*index+2);
    }



    @Override
    public String toString() {
        return ""SegmentTree{"" +
                ""segmentTree="" + Arrays.toString(segmentTree) +
                "", arr="" + Arrays.toString(arr) +
                '}';
    }
}",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/,program,"package com.akarsh.codechef.segmentTree;
import java.util.Arrays;","private final int n;
private final double[] segmentTree;
private final T[] arr;","(4, 0)","(84, 1)",N,class_declaration,SegmentTree,,691,0a313c2d-8bd0-4e23-91de-2521ac4adbfc
"private final int n;
private final double[] segmentTree;
private final T[] arr;",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,Previous sibling does not exist,"SegmentTree(int n, T[] arr){
        this.n = n;
        int modifiedChildCount = (int) Math.pow(2, Math.ceil(Math.log(n)/Math.log(2)));
        int size = 2 * modifiedChildCount - 1;
        this.segmentTree = new double[size];
        this.arr = arr;
        buildSegmentTree(arr);
    }","(6, 4)","(8, 26)",N,"field_declaration,field_declaration,field_declaration",field_declaration,,18,ca6d2c96-41ae-4b9c-b8d7-710328c539ec
"SegmentTree(int n, T[] arr){
        this.n = n;
        int modifiedChildCount = (int) Math.pow(2, Math.ceil(Math.log(n)/Math.log(2)));
        int size = 2 * modifiedChildCount - 1;
        this.segmentTree = new double[size];
        this.arr = arr;
        buildSegmentTree(arr);
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"private final int n;
private final double[] segmentTree;
private final T[] arr;","public void buildSegmentTree(T[] arr){
        helper(0, arr.length-1, 0);
    }","(10, 4)","(17, 5)",N,constructor_declaration,SegmentTree,,77,906c1e7e-16ce-4689-b2f0-00130949227d
"public void buildSegmentTree(T[] arr){
        helper(0, arr.length-1, 0);
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"SegmentTree(int n, T[] arr){
        this.n = n;
        int modifiedChildCount = (int) Math.pow(2, Math.ceil(Math.log(n)/Math.log(2)));
        int size = 2 * modifiedChildCount - 1;
        this.segmentTree = new double[size];
        this.arr = arr;
        buildSegmentTree(arr);
    }","public void helper(int start, int end, int index){

        if(start == end){
            this.segmentTree[index] = arr[start].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        helper(start, mid, 2*index + 1);
        helper(mid+1, end, 2*index + 2);
        this.segmentTree[index] = this.segmentTree[2*index+1] + this.segmentTree[2*index+2];
    }","(19, 4)","(21, 5)",N,method_declaration,buildSegmentTree,,24,db4f0ce0-0f2e-4eb3-80d2-07242288a93a
"public void helper(int start, int end, int index){

        if(start == end){
            this.segmentTree[index] = arr[start].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        helper(start, mid, 2*index + 1);
        helper(mid+1, end, 2*index + 2);
        this.segmentTree[index] = this.segmentTree[2*index+1] + this.segmentTree[2*index+2];
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"public void buildSegmentTree(T[] arr){
        helper(0, arr.length-1, 0);
    }","public void updateHelper(int start, int end, int arrIndex, int segIndex) {

        if(start == end){
            this.segmentTree[segIndex] = this.arr[arrIndex].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        if(arrIndex <= mid) updateHelper(start, mid, arrIndex, segIndex*2 + 1);
        else updateHelper(mid+1, end, arrIndex, segIndex*2 + 2);

        this.segmentTree[segIndex] = this.segmentTree[2*segIndex+1] + this.segmentTree[2*segIndex+2];
    }","(23, 4)","(34, 5)",N,method_declaration,helper,,108,903ee6d2-e49f-4e8c-9dc7-9ba530d39978
"public void updateHelper(int start, int end, int arrIndex, int segIndex) {

        if(start == end){
            this.segmentTree[segIndex] = this.arr[arrIndex].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        if(arrIndex <= mid) updateHelper(start, mid, arrIndex, segIndex*2 + 1);
        else updateHelper(mid+1, end, arrIndex, segIndex*2 + 2);

        this.segmentTree[segIndex] = this.segmentTree[2*segIndex+1] + this.segmentTree[2*segIndex+2];
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"public void helper(int start, int end, int index){

        if(start == end){
            this.segmentTree[index] = arr[start].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        helper(start, mid, 2*index + 1);
        helper(mid+1, end, 2*index + 2);
        this.segmentTree[index] = this.segmentTree[2*index+1] + this.segmentTree[2*index+2];
    }","public void update(int index, T newValue){
        this.arr[index] = newValue;
        updateHelper(0,n-1, index, 0);
    }","(36, 4)","(48, 5)",N,method_declaration,updateHelper,,138,94399a8a-6b38-4b8a-9f31-d003f1416222
"public void update(int index, T newValue){
        this.arr[index] = newValue;
        updateHelper(0,n-1, index, 0);
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"public void updateHelper(int start, int end, int arrIndex, int segIndex) {

        if(start == end){
            this.segmentTree[segIndex] = this.arr[arrIndex].doubleValue();
            return;
        }

        int mid = start + (end - start)/2;
        if(arrIndex <= mid) updateHelper(start, mid, arrIndex, segIndex*2 + 1);
        else updateHelper(mid+1, end, arrIndex, segIndex*2 + 2);

        this.segmentTree[segIndex] = this.segmentTree[2*segIndex+1] + this.segmentTree[2*segIndex+2];
    }","public Double query(int start, int end){
        return query(start, end, 0, n-1,0);
    }","(50, 4)","(53, 5)",N,method_declaration,update,,33,413d9dd2-38e5-4186-bfae-7fa1ee38968b
"public Double query(int start, int end){
        return query(start, end, 0, n-1,0);
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"public void update(int index, T newValue){
        this.arr[index] = newValue;
        updateHelper(0,n-1, index, 0);
    }","private Double query(int start, int end, int vStart, int vEnd, int index){

        System.out.println(start + "" "" + end + "" "" + vStart + "" "" + vEnd + "" "" + index);
        if(start>end) return 0.0;

        if(start == vStart && end == vEnd) return segmentTree[index];
        if(start>vEnd || end<vStart) return 0.0;

        int mid = vStart + (vEnd - vStart)/2;

        if(end<=mid) return query(start, end, vStart, mid, 2*index+1);
        if(start>mid) return query(start, end, mid+1, vEnd, 2*index+2);

        return query(start, mid, vStart, mid, 2*index+1) +  query(mid+1, end, mid+1, vEnd, 2*index+2);
    }","(55, 4)","(57, 5)",N,method_declaration,query,,27,04476e9f-f3bd-420f-8e6a-b08d8c816273
"private Double query(int start, int end, int vStart, int vEnd, int index){

        System.out.println(start + "" "" + end + "" "" + vStart + "" "" + vEnd + "" "" + index);
        if(start>end) return 0.0;

        if(start == vStart && end == vEnd) return segmentTree[index];
        if(start>vEnd || end<vStart) return 0.0;

        int mid = vStart + (vEnd - vStart)/2;

        if(end<=mid) return query(start, end, vStart, mid, 2*index+1);
        if(start>mid) return query(start, end, mid+1, vEnd, 2*index+2);

        return query(start, mid, vStart, mid, 2*index+1) +  query(mid+1, end, mid+1, vEnd, 2*index+2);
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"public Double query(int start, int end){
        return query(start, end, 0, n-1,0);
    }","@Override
    public String toString() {
        return ""SegmentTree{"" +
                ""segmentTree="" + Arrays.toString(segmentTree) +
                "", arr="" + Arrays.toString(arr) +
                '}';
    }","(59, 4)","(73, 5)",N,method_declaration,query,,203,5f758d51-1617-40ed-b2ba-f90487e99a98
"@Override
    public String toString() {
        return ""SegmentTree{"" +
                ""segmentTree="" + Arrays.toString(segmentTree) +
                "", arr="" + Arrays.toString(arr) +
                '}';
    }",SegmentTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.java,program/class_declaration-SegmentTree/,SegmentTree,"private Double query(int start, int end, int vStart, int vEnd, int index){

        System.out.println(start + "" "" + end + "" "" + vStart + "" "" + vEnd + "" "" + index);
        if(start>end) return 0.0;

        if(start == vStart && end == vEnd) return segmentTree[index];
        if(start>vEnd || end<vStart) return 0.0;

        int mid = vStart + (vEnd - vStart)/2;

        if(end<=mid) return query(start, end, vStart, mid, 2*index+1);
        if(start>mid) return query(start, end, mid+1, vEnd, 2*index+2);

        return query(start, mid, vStart, mid, 2*index+1) +  query(mid+1, end, mid+1, vEnd, 2*index+2);
    }",Next sibling does not exist,"(77, 4)","(83, 5)",N,method_declaration,toString,,41,d1ddcec2-0829-4189-80ec-82383a306649
"import math


class SegmentTree:

    def __init__(self, arr, operator, operationIdentity) -> None:
        self.arrLength = len(arr)
        self.arr = arr
        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))
        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1
        self.segmentTree = [None for i in range(self.segmentTreeLength)]
        self.operationIdentity = operationIdentity
        self.operation = operator
        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)
    
    
    def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]


    def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)
    
    def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)

    def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])
    
    def rightfill(self, num, start, end, fillNum = None):    
        if(not fillNum): fillNum = self.operationIdentity 
        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)

tree = SegmentTree([1,2,3,4,5,6], operator=lambda x, y : x*y, operationIdentity=1)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))

tree.update(0, 6)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))



tree.update(0,1)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))



tree.update(5, 0)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))


tree = SegmentTree([0 for i in range(6)], operator=lambda x, y : x+y, operationIdentity=0)

tree.rightfill(2, 0, 4, fillNum=1)
print(tree.segmentTree)

tree.rightfill(2, 0, 5, fillNum=1)
print(tree.segmentTree)

tree.rightfill(1, 0, 5, fillNum=1)
print(tree.segmentTree)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(127, 23)",N,module,module,,1237,0447d0b4-d519-4f2b-813d-372d33ca2acc
import math,SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/,module,Previous sibling does not exist,"class SegmentTree:

    def __init__(self, arr, operator, operationIdentity) -> None:
        self.arrLength = len(arr)
        self.arr = arr
        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))
        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1
        self.segmentTree = [None for i in range(self.segmentTreeLength)]
        self.operationIdentity = operationIdentity
        self.operation = operator
        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)
    
    
    def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]


    def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)
    
    def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)

    def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])
    
    def rightfill(self, num, start, end, fillNum = None):    
        if(not fillNum): fillNum = self.operationIdentity 
        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)","(0, 0)","(0, 11)",N,import_statement,import_statement,,2,f436e234-12cc-4830-a356-0ac419095b71
"class SegmentTree:

    def __init__(self, arr, operator, operationIdentity) -> None:
        self.arrLength = len(arr)
        self.arr = arr
        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))
        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1
        self.segmentTree = [None for i in range(self.segmentTreeLength)]
        self.operationIdentity = operationIdentity
        self.operation = operator
        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)
    
    
    def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]


    def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)
    
    def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)

    def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])
    
    def rightfill(self, num, start, end, fillNum = None):    
        if(not fillNum): fillNum = self.operationIdentity 
        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/,module,import math,"tree = SegmentTree([1,2,3,4,5,6], operator=lambda x, y : x*y, operationIdentity=1)","(3, 0)","(83, 88)",N,class_definition,SegmentTree,,937,ebfebc6c-4806-4c6a-a4ea-1e5a137b4cd3
"def __init__(self, arr, operator, operationIdentity) -> None:
        self.arrLength = len(arr)
        self.arr = arr
        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))
        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1
        self.segmentTree = [None for i in range(self.segmentTreeLength)]
        self.operationIdentity = operationIdentity
        self.operation = operator
        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/,SegmentTree,Previous sibling does not exist,"def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]","(5, 4)","(13, 67)",N,function_definition,__init__,,113,f057f372-5a0c-427a-ba1b-c1993573beda
"def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/,SegmentTree,"def __init__(self, arr, operator, operationIdentity) -> None:
        self.arrLength = len(arr)
        self.arr = arr
        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))
        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1
        self.segmentTree = [None for i in range(self.segmentTreeLength)]
        self.operationIdentity = operationIdentity
        self.operation = operator
        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)","def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)","(16, 4)","(25, 38)",N,function_definition,buildSegmentTree,,128,191b876a-ae0f-41e8-b738-7e4dcb12857e
"def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/,SegmentTree,"def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]","def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)","(28, 4)","(38, 77)",N,function_definition,query,,148,9d9551e1-84c3-4a1a-97c7-6c9d056f4828
"def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/function_definition-query/,query,Previous sibling does not exist,"return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)","(30, 8)","(36, 97)",N,function_definition,queryHelper,,118,bd2937c1-9860-4dc6-9a8b-bfb3cc0ce4be
"def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/,SegmentTree,"def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)","def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])","(40, 4)","(56, 77)",N,function_definition,update,,169,738d6a17-ef12-4323-841f-10bd58f51864
"def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/function_definition-update/,update,Previous sibling does not exist,self.arr[index] = newValue,"(42, 8)","(51, 119)",N,function_definition,updateHelper,,131,34b65845-6194-4c83-923f-03bba56680d6
"def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/,SegmentTree,"def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)","def rightfill(self, num, start, end, fillNum = None):    
        if(not fillNum): fillNum = self.operationIdentity 
        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)","(58, 4)","(79, 106)",N,function_definition,fillhelper,,310,68ff6c68-6a21-45c5-aeaf-7cad760b16b6
"def rightfill(self, num, start, end, fillNum = None):    
        if(not fillNum): fillNum = self.operationIdentity 
        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/class_definition-SegmentTree/,SegmentTree,"def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])","tree = SegmentTree([1,2,3,4,5,6], operator=lambda x, y : x*y, operationIdentity=1)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree.update(0, 6)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree.update(0,1)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree.update(5, 0)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree = SegmentTree([0 for i in range(6)], operator=lambda x, y : x+y, operationIdentity=0)
tree.rightfill(2, 0, 4, fillNum=1)
print(tree.segmentTree)
tree.rightfill(2, 0, 5, fillNum=1)
print(tree.segmentTree)
tree.rightfill(1, 0, 5, fillNum=1)
print(tree.segmentTree)","(81, 4)","(83, 88)",N,function_definition,rightfill,,56,83681615-a422-4590-8141-5dceff830b07
"tree = SegmentTree([1,2,3,4,5,6], operator=lambda x, y : x*y, operationIdentity=1)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree.update(0, 6)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree.update(0,1)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree.update(5, 0)
print(tree.segmentTree)
print(tree.query(0,5))
print(tree.query(0,4))
print(tree.query(1,4))
print(tree.query(2,5))
tree = SegmentTree([0 for i in range(6)], operator=lambda x, y : x+y, operationIdentity=0)
tree.rightfill(2, 0, 4, fillNum=1)
print(tree.segmentTree)
tree.rightfill(2, 0, 5, fillNum=1)
print(tree.segmentTree)
tree.rightfill(1, 0, 5, fillNum=1)
print(tree.segmentTree)",SegmentTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\SegmentTree.py,module/,module,"class SegmentTree:

    def __init__(self, arr, operator, operationIdentity) -> None:
        self.arrLength = len(arr)
        self.arr = arr
        self.modifiedNumberOfChildren = 2**(math.ceil(math.log(self.arrLength, 2)))
        self.segmentTreeLength = 2*self.modifiedNumberOfChildren - 1
        self.segmentTree = [None for i in range(self.segmentTreeLength)]
        self.operationIdentity = operationIdentity
        self.operation = operator
        self.buildSegmentTree(0,self.modifiedNumberOfChildren-1, 0)
    
    
    def buildSegmentTree(self, start, end, index):
        if(start == end): 
            self.segmentTree[index] = self.arr[start] if(start < self.arrLength) else self.operationIdentity
            return self.segmentTree[index]
          
        mid = start + (end - start)//2
        leftSegmentValue = self.buildSegmentTree(start, mid, 2*index+1)
        rightSegmentValue = self.buildSegmentTree(mid+1, end, 2*index+2)
        self.segmentTree[index] = self.operation(leftSegmentValue, rightSegmentValue)
        return self.segmentTree[index]


    def query(self, start, end):

        def queryHelper(qstart, qend, start, end, index):
            if(qstart>end or qend<start): return self.operationIdentity
            if(qstart == start and qend == end): return self.segmentTree[index]

            mid = start + (end - start)//2
            return self.operation(queryHelper(qstart, min(qend, mid), start, mid, 2*index + 1), 
                                  queryHelper(max(qstart, mid+1), qend, mid+1, end, 2*index + 2))

        return queryHelper(start, end, 0, self.modifiedNumberOfChildren-1, 0)
    
    def update(self, index, newValue):

        def updateHelper(start, end, segIndex, index, newValue):
            if(start == end == index): 
                self.segmentTree[segIndex] = newValue
                return

            mid = start + (end - start)//2
            if(start <= index <= mid): updateHelper(start, mid, 2*segIndex+1, index, newValue)
            else: updateHelper(mid+1, end, 2*segIndex+2, index, newValue)

            self.segmentTree[segIndex] = self.operation(self.segmentTree[2*segIndex+1], self.segmentTree[2*segIndex+2])



        self.arr[index] = newValue
        updateHelper(0, self.modifiedNumberOfChildren -1, 0, index, newValue)

    def fillhelper(self, num, rstart, rend, fillNum, segstart, segend, index):
        if(num == 0 or fillNum == 0): return
        if(segend<rstart or rend<segstart): return
        
        # leaf node 
        if(segstart == segend  and num == 1): 
            self.segmentTree[index] = fillNum
            return

        mid = segstart + (segend - segstart)//2
        rightSum = self.query(max(mid+1, rstart), rend)
        numEmptyToRight = (rend - max(mid+1, rstart)) + 1 - rightSum
        if(numEmptyToRight<0): numEmptyToRight = 0
        
        # enough to fill only right segment
        if(numEmptyToRight >= num): self.fillhelper(num, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
        else:
            # have to fill in both segments
            self.fillhelper(numEmptyToRight, mid+1, rend, fillNum, mid+1, segend, 2*index+2)
            self.fillhelper(num - numEmptyToRight, rstart, min(mid, rend), fillNum, segstart, mid, 2*index+1)

        self.segmentTree[index] = self.operation(self.segmentTree[2*index+1], self.segmentTree[2*index+2])
    
    def rightfill(self, num, start, end, fillNum = None):    
        if(not fillNum): fillNum = self.operationIdentity 
        self.fillhelper(num, start, end, fillNum, 0, self.modifiedNumberOfChildren-1, 0)",Next sibling does not exist,"(85, 0)","(127, 23)",N,"expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement",expression_statement,,295,cd8119c9-904c-4964-963c-19cf03559aa3
,__init__.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\segmentTree\__init__.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(0, 0)",N,module,module,,0,19258df2-e2c4-443f-ad21-329b62d77d16
"public class BubbleSort implements SortingAlgorithm{

    @Override
    public int[] sort(int[] arr) {
        for(int i=0; i < arr.length-1; i++){
            for(int j=0; j < arr.length-i-1; j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        return arr;
    }

}

// time: theta(n^2)
// space : theta(1)



// can use swap flag to check if ( arr is sorted before all the comparison ) to break out of the loop;

// in one iteration if no swaps
// arr is sorted
// break out of loop
",BubbleSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\BubbleSort.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 0)",N,program,program,,163,663380c4-87d1-49cb-b2aa-040a08b610f4
"public class BubbleSort implements SortingAlgorithm{

    @Override
    public int[] sort(int[] arr) {
        for(int i=0; i < arr.length-1; i++){
            for(int j=0; j < arr.length-i-1; j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        return arr;
    }

}",BubbleSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\BubbleSort.java,program/,program,Previous sibling does not exist,// time: theta(n^2),"(0, 0)","(16, 1)",N,class_declaration,BubbleSort,,105,adcda8fc-1631-48bf-85ad-1e43b50eba8f
"@Override
    public int[] sort(int[] arr) {
        for(int i=0; i < arr.length-1; i++){
            for(int j=0; j < arr.length-i-1; j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        return arr;
    }",BubbleSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\BubbleSort.java,program/class_declaration-BubbleSort/,BubbleSort,Previous sibling does not exist,"// time: theta(n^2)
// space : theta(1)
// can use swap flag to check if ( arr is sorted before all the comparison ) to break out of the loop;
// in one iteration if no swaps
// arr is sorted
// break out of loop","(2, 4)","(14, 5)",N,method_declaration,sort,,94,4a8aef54-0733-41a8-ae57-4ce9d50d1160
"// time: theta(n^2)
// space : theta(1)
// can use swap flag to check if ( arr is sorted before all the comparison ) to break out of the loop;
// in one iteration if no swaps
// arr is sorted
// break out of loop",BubbleSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\BubbleSort.java,program/,program,"public class BubbleSort implements SortingAlgorithm{

    @Override
    public int[] sort(int[] arr) {
        for(int i=0; i < arr.length-1; i++){
            for(int j=0; j < arr.length-i-1; j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        return arr;
    }

}",Next sibling does not exist,"(18, 0)","(27, 20)",N,"line_comment,line_comment,line_comment,line_comment,line_comment,line_comment",line_comment,,55,33b035b3-a1e9-4357-93eb-b62c5c64f2e7
"class Solution:
    def maxScore(self, arr: List[int]) -> int:
        arr.sort(reverse = True)
        
        count = 0
        running_sum = 0
        
        for i in arr:
            running_sum += i
            if(running_sum>0): count+=1
        
        return count
",maxScore.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\maxScore.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(12, 0)",N,module,module,,66,f5711d08-e02f-4076-b2aa-247c99a59bf1
"class Solution:
    def maxScore(self, arr: List[int]) -> int:
        arr.sort(reverse = True)
        
        count = 0
        running_sum = 0
        
        for i in arr:
            running_sum += i
            if(running_sum>0): count+=1
        
        return count",maxScore.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\maxScore.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(11, 20)",N,class_definition,Solution,,65,ce0e8b32-f1eb-481e-800a-58744b9e8476
"def maxScore(self, arr: List[int]) -> int:
        arr.sort(reverse = True)
        
        count = 0
        running_sum = 0
        
        for i in arr:
            running_sum += i
            if(running_sum>0): count+=1
        
        return count",maxScore.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\maxScore.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(11, 20)",N,function_definition,maxScore,,61,d8ecf595-7155-4bbc-93cf-da0136959f3b
"public class QuickSort implements SortingAlgorithm{

    @Override
    public int[] sort(int[] arr) {
        System.out.println(""using quick sort"");
        quicksort(arr,0, arr.length-1);
        return arr;
    }

    public void quicksort(int[] arr, int start, int end){

        if(start >= end) return;

        int pivot = arr[end];

        int left = start;
        int right = end-1;

        while(left<=right){
            if(arr[left]<=pivot) {
                left++;
            } else {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                right--;
            }
        }

        arr[end] = arr[left];
        arr[left] = pivot;

        quicksort(arr, start, left-1);
        quicksort(arr, left+1, end);
    }

}
",Quicksort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\Quicksort.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(37, 0)",N,program,program,,183,a1b2aed1-c2a2-4385-8900-7867aa6cff65
"public class QuickSort implements SortingAlgorithm{

    @Override
    public int[] sort(int[] arr) {
        System.out.println(""using quick sort"");
        quicksort(arr,0, arr.length-1);
        return arr;
    }

    public void quicksort(int[] arr, int start, int end){

        if(start >= end) return;

        int pivot = arr[end];

        int left = start;
        int right = end-1;

        while(left<=right){
            if(arr[left]<=pivot) {
                left++;
            } else {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                right--;
            }
        }

        arr[end] = arr[left];
        arr[left] = pivot;

        quicksort(arr, start, left-1);
        quicksort(arr, left+1, end);
    }

}",Quicksort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\Quicksort.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(36, 1)",N,class_declaration,QuickSort,,183,0177caf2-f5a5-4c12-a172-f01375d07e2f
"@Override
    public int[] sort(int[] arr) {
        System.out.println(""using quick sort"");
        quicksort(arr,0, arr.length-1);
        return arr;
    }",Quicksort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\Quicksort.java,program/class_declaration-QuickSort/,QuickSort,Previous sibling does not exist,"public void quicksort(int[] arr, int start, int end){

        if(start >= end) return;

        int pivot = arr[end];

        int left = start;
        int right = end-1;

        while(left<=right){
            if(arr[left]<=pivot) {
                left++;
            } else {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                right--;
            }
        }

        arr[end] = arr[left];
        arr[left] = pivot;

        quicksort(arr, start, left-1);
        quicksort(arr, left+1, end);
    }","(2, 4)","(7, 5)",N,method_declaration,sort,,39,111a829b-c494-4169-a063-1e739ba6c2cb
"public void quicksort(int[] arr, int start, int end){

        if(start >= end) return;

        int pivot = arr[end];

        int left = start;
        int right = end-1;

        while(left<=right){
            if(arr[left]<=pivot) {
                left++;
            } else {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                right--;
            }
        }

        arr[end] = arr[left];
        arr[left] = pivot;

        quicksort(arr, start, left-1);
        quicksort(arr, left+1, end);
    }",Quicksort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\Quicksort.java,program/class_declaration-QuickSort/,QuickSort,"@Override
    public int[] sort(int[] arr) {
        System.out.println(""using quick sort"");
        quicksort(arr,0, arr.length-1);
        return arr;
    }",Next sibling does not exist,"(9, 4)","(34, 5)",N,method_declaration,quicksort,,132,7d3c5c43-1d40-4a64-bef1-8687977bfd23
"public class SelectionSort implements SortingAlgorithm{
    @Override
    public int[] sort(int[] arr) {

        for(int i=arr.length-1; i>=1; i--){
            int max = Integer.MIN_VALUE;
            int index = -1;

            for(int j=0; j<=i; j++){
                if(arr[j]>max){
                    max = arr[j];
                    index = j;
                }
            }

            arr[index] = arr[i];
            arr[i] = max;

        }

        return arr;
    }
}

//time: theta(n^2) space: O(1)
",SelectionSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\SelectionSort.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(25, 0)",N,program,program,,126,39e9ccd2-bc75-49f6-bb5b-253139e9f0cd
"public class SelectionSort implements SortingAlgorithm{
    @Override
    public int[] sort(int[] arr) {

        for(int i=arr.length-1; i>=1; i--){
            int max = Integer.MIN_VALUE;
            int index = -1;

            for(int j=0; j<=i; j++){
                if(arr[j]>max){
                    max = arr[j];
                    index = j;
                }
            }

            arr[index] = arr[i];
            arr[i] = max;

        }

        return arr;
    }
}",SelectionSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\SelectionSort.java,program/,program,Previous sibling does not exist,//time: theta(n^2) space: O(1),"(0, 0)","(22, 1)",N,class_declaration,SelectionSort,,112,6cf3f9ba-ab0b-4b01-a93f-00ff06926308
"@Override
    public int[] sort(int[] arr) {

        for(int i=arr.length-1; i>=1; i--){
            int max = Integer.MIN_VALUE;
            int index = -1;

            for(int j=0; j<=i; j++){
                if(arr[j]>max){
                    max = arr[j];
                    index = j;
                }
            }

            arr[index] = arr[i];
            arr[i] = max;

        }

        return arr;
    }",SelectionSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\SelectionSort.java,program/class_declaration-SelectionSort/,SelectionSort,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(21, 5)",N,method_declaration,sort,,101,f9e92b51-1d67-4ec5-b55a-694e100db989
//time: theta(n^2) space: O(1),SelectionSort.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\SelectionSort.java,program/,program,"public class SelectionSort implements SortingAlgorithm{
    @Override
    public int[] sort(int[] arr) {

        for(int i=arr.length-1; i>=1; i--){
            int max = Integer.MIN_VALUE;
            int index = -1;

            for(int j=0; j<=i; j++){
                if(arr[j]>max){
                    max = arr[j];
                    index = j;
                }
            }

            arr[index] = arr[i];
            arr[i] = max;

        }

        return arr;
    }
}",Next sibling does not exist,"(24, 0)","(24, 30)",N,line_comment,line_comment,,14,98682afd-b183-47d0-a51c-883e90f89a91
"public interface SortingAlgorithm {
    int[] sort(int[] arr);
}
",SortingAlgorithm.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\SortingAlgorithm.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(3, 0)",N,program,program,,14,15105522-b58a-476a-8fa4-cca269471dba
"public interface SortingAlgorithm {
    int[] sort(int[] arr);
}",SortingAlgorithm.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\SortingAlgorithm.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(2, 1)",N,interface_declaration,interface_declaration,,14,bb8de848-c1c2-4641-b3f7-e5053faa54b8
"# using bucket sort -- O(n logk)
# another way it to use a heap of size k -- O(n)
# quickselect (loop this up) -- O(n)
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)
        counter = defaultdict(int)
        for num in nums: counter[num] += 1

        buckets = [[] for i in range(N+1)]
        for key in counter: buckets[counter[key]].append(key)

        ans = []
        index = N
        count = k
        while(count>0):
            bucket = buckets[index]
            for i in bucket: ans.append(i)
            index -= 1
            count -= len(bucket)

        return ans[:k]
",topKFrequent.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\topKFrequent.py,,NA,Previous sibling does not exist,"# using bucket sort -- O(n logk)
# another way it to use a heap of size k -- O(n)
# quickselect (loop this up) -- O(n)","(0, 0)","(23, 0)",N,module,module,,164,e15b3986-9cea-4ec3-83c9-85dbcefdb062
"# using bucket sort -- O(n logk)
# another way it to use a heap of size k -- O(n)
# quickselect (loop this up) -- O(n)",topKFrequent.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\topKFrequent.py,module/,module,Previous sibling does not exist,"class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)
        counter = defaultdict(int)
        for num in nums: counter[num] += 1

        buckets = [[] for i in range(N+1)]
        for key in counter: buckets[counter[key]].append(key)

        ans = []
        index = N
        count = k
        while(count>0):
            bucket = buckets[index]
            for i in bucket: ans.append(i)
            index -= 1
            count -= len(bucket)

        return ans[:k]","(0, 0)","(2, 36)",N,"comment,comment,comment",comment,,37,a772f9e6-6dca-4b84-813e-ffbf6020a86e
"class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)
        counter = defaultdict(int)
        for num in nums: counter[num] += 1

        buckets = [[] for i in range(N+1)]
        for key in counter: buckets[counter[key]].append(key)

        ans = []
        index = N
        count = k
        while(count>0):
            bucket = buckets[index]
            for i in bucket: ans.append(i)
            index -= 1
            count -= len(bucket)

        return ans[:k]",topKFrequent.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\topKFrequent.py,module/,module,"# using bucket sort -- O(n logk)
# another way it to use a heap of size k -- O(n)
# quickselect (loop this up) -- O(n)",Next sibling does not exist,"(3, 0)","(22, 22)",N,class_definition,Solution,,127,d5989fa9-7236-4e3d-a347-e0b73b15d465
"def topKFrequent(self, nums: List[int], k: int) -> List[int]:

        N = len(nums)
        counter = defaultdict(int)
        for num in nums: counter[num] += 1

        buckets = [[] for i in range(N+1)]
        for key in counter: buckets[counter[key]].append(key)

        ans = []
        index = N
        count = k
        while(count>0):
            bucket = buckets[index]
            for i in bucket: ans.append(i)
            index -= 1
            count -= len(bucket)

        return ans[:k]",topKFrequent.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\sorting\topKFrequent.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(4, 4)","(22, 22)",N,function_definition,topKFrequent,,123,c21eb74a-b199-4a6e-9f5e-65267f79da96
"class Solution {
    public String removeStars(String s) {
        Stack<Character> stack = new Stack();
        
        for(char ch: s.toCharArray()){
            if(ch=='*' && stack.isEmpty()) return """";
            else if(ch=='*') stack.pop();
            else stack.push(ch);
        }
        
        StringBuffer sb = new StringBuffer();
        
        while(!stack.isEmpty()) sb.append(stack.pop());
        
        return sb.reverse().toString();
        
    }
}
",RemoveStars.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\RemoveStars.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(18, 0)",N,program,program,,91,3b15feb8-5576-4465-9d6e-3a4979cfbfec
"class Solution {
    public String removeStars(String s) {
        Stack<Character> stack = new Stack();
        
        for(char ch: s.toCharArray()){
            if(ch=='*' && stack.isEmpty()) return """";
            else if(ch=='*') stack.pop();
            else stack.push(ch);
        }
        
        StringBuffer sb = new StringBuffer();
        
        while(!stack.isEmpty()) sb.append(stack.pop());
        
        return sb.reverse().toString();
        
    }
}",RemoveStars.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\RemoveStars.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 1)",N,class_declaration,Solution,,91,0466b3a5-80bb-4b5d-aec0-967c5bd982bc
"public String removeStars(String s) {
        Stack<Character> stack = new Stack();
        
        for(char ch: s.toCharArray()){
            if(ch=='*' && stack.isEmpty()) return """";
            else if(ch=='*') stack.pop();
            else stack.push(ch);
        }
        
        StringBuffer sb = new StringBuffer();
        
        while(!stack.isEmpty()) sb.append(stack.pop());
        
        return sb.reverse().toString();
        
    }",RemoveStars.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\RemoveStars.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(16, 5)",N,method_declaration,removeStars,,86,b2c24823-1931-45f8-833b-93877822d9fe
"class Solution:
    def simplifyPath(self, path: str) -> str:

        arr = path.split('/')
        stack = []

        for op in arr:
            if(op == '' or op == '.'): continue
            elif(op == ""..""):
                if(stack): stack.pop()
            else:
                stack.append(op)

        return '/' + ""/"".join(stack)
",simplifyPath.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\simplifyPath.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(14, 0)",N,module,module,,74,320187ad-ae44-4562-9883-f7ece32b2d0d
"class Solution:
    def simplifyPath(self, path: str) -> str:

        arr = path.split('/')
        stack = []

        for op in arr:
            if(op == '' or op == '.'): continue
            elif(op == ""..""):
                if(stack): stack.pop()
            else:
                stack.append(op)

        return '/' + ""/"".join(stack)",simplifyPath.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\simplifyPath.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(13, 36)",N,class_definition,Solution,,74,ce6be9b5-22dc-4497-815d-4317d69942b5
"def simplifyPath(self, path: str) -> str:

        arr = path.split('/')
        stack = []

        for op in arr:
            if(op == '' or op == '.'): continue
            elif(op == ""..""):
                if(stack): stack.pop()
            else:
                stack.append(op)

        return '/' + ""/"".join(stack)",simplifyPath.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\simplifyPath.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(13, 36)",N,function_definition,simplifyPath,,70,9b50a0f1-7903-4c74-bee7-3aee9abfa5d4
"class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        
        stack = set()
        pop_index = 0
        push_index = 0
        N = len(pushed)
        arr = []

        while(pop_index < N):
            val = popped[pop_index]

            while(push_index<N and val not in stack):
                arr.append(pushed[push_index])
                stack.add(pushed[push_index])
                push_index += 1
            
            # print(val, stack, arr)


            if(val in stack):
                if(arr[-1] == val):
                    arr.pop()
                    stack.remove(val)
                    pop_index += 1
                else:
                    return False
        
        return True

",validateStackSequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\validateStackSequences.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 0)",N,module,module,,157,1d092c7b-0b2a-4138-8212-bffaa983de00
"class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        
        stack = set()
        pop_index = 0
        push_index = 0
        N = len(pushed)
        arr = []

        while(pop_index < N):
            val = popped[pop_index]

            while(push_index<N and val not in stack):
                arr.append(pushed[push_index])
                stack.add(pushed[push_index])
                push_index += 1
            
            # print(val, stack, arr)


            if(val in stack):
                if(arr[-1] == val):
                    arr.pop()
                    stack.remove(val)
                    pop_index += 1
                else:
                    return False
        
        return True",validateStackSequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\validateStackSequences.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(28, 19)",N,class_definition,Solution,,156,4a9ee242-38f8-45da-92c0-bc2d62c3c07b
"def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        
        stack = set()
        pop_index = 0
        push_index = 0
        N = len(pushed)
        arr = []

        while(pop_index < N):
            val = popped[pop_index]

            while(push_index<N and val not in stack):
                arr.append(pushed[push_index])
                stack.add(pushed[push_index])
                push_index += 1
            
            # print(val, stack, arr)


            if(val in stack):
                if(arr[-1] == val):
                    arr.pop()
                    stack.remove(val)
                    pop_index += 1
                else:
                    return False
        
        return True",validateStackSequences.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\validateStackSequences.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(28, 19)",N,function_definition,validateStackSequences,,152,d10af315-c472-4cc4-b366-e6145ecb158b
"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;

public class NextGraterTemp {

    public static <T extends Comparable> List<Integer> getNextGraterTemp(List<T> tempartures){
        
        ArrayList<Integer> ans = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        
        for(int index = tempartures.size() -1; index>=0; index--){
            T temp = tempartures.get(index);
            
            while(!stack.empty() && tempartures.get(stack.peek()).compareTo(temp) != 1){
                stack.pop();
            }
            
            if(stack.isEmpty()) {
                ans.add(-1);
            } else {
                ans.add(stack.peek() - index);
            }
            
            stack.push(index);
        }

        Collections.reverse(ans);
        return ans;
    }

    public static void main(String[] args) {
        ArrayList<Double> input  = new ArrayList<>();
        // Arrays.asList()
        // input.add(73);
        // input.add(74);
        // input.add(75);
        // input.add(71);
        // input.add(69);
        // input.add(72);
        // input.add(76);
        // input.add(73);

        // 78.6,25.2,36.5,83.5,71.5
        input.add(78.6);
        input.add(25.2);
        input.add(36.5);
        input.add(83.5);
        input.add(71.5);


        List<Integer> ans = getNextGraterTemp(input);
        System.out.println(ans);
    }

}",NextGraterTemp.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\NextGraterTemp.java,,NA,Previous sibling does not exist,"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;","(0, 0)","(56, 1)",N,program,program,,338,b06523e0-901a-4cbc-af75-b297e14e8bd8
"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;",NextGraterTemp.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\NextGraterTemp.java,program/,program,Previous sibling does not exist,"public class NextGraterTemp {

    public static <T extends Comparable> List<Integer> getNextGraterTemp(List<T> tempartures){
        
        ArrayList<Integer> ans = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        
        for(int index = tempartures.size() -1; index>=0; index--){
            T temp = tempartures.get(index);
            
            while(!stack.empty() && tempartures.get(stack.peek()).compareTo(temp) != 1){
                stack.pop();
            }
            
            if(stack.isEmpty()) {
                ans.add(-1);
            } else {
                ans.add(stack.peek() - index);
            }
            
            stack.push(index);
        }

        Collections.reverse(ans);
        return ans;
    }

    public static void main(String[] args) {
        ArrayList<Double> input  = new ArrayList<>();
        // Arrays.asList()
        // input.add(73);
        // input.add(74);
        // input.add(75);
        // input.add(71);
        // input.add(69);
        // input.add(72);
        // input.add(76);
        // input.add(73);

        // 78.6,25.2,36.5,83.5,71.5
        input.add(78.6);
        input.add(25.2);
        input.add(36.5);
        input.add(83.5);
        input.add(71.5);


        List<Integer> ans = getNextGraterTemp(input);
        System.out.println(ans);
    }

}","(0, 0)","(3, 23)",N,"import_declaration,import_declaration,import_declaration,import_declaration",import_declaration,,20,9f11369d-a38c-45e8-8b1b-943e53a07d88
"public class NextGraterTemp {

    public static <T extends Comparable> List<Integer> getNextGraterTemp(List<T> tempartures){
        
        ArrayList<Integer> ans = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        
        for(int index = tempartures.size() -1; index>=0; index--){
            T temp = tempartures.get(index);
            
            while(!stack.empty() && tempartures.get(stack.peek()).compareTo(temp) != 1){
                stack.pop();
            }
            
            if(stack.isEmpty()) {
                ans.add(-1);
            } else {
                ans.add(stack.peek() - index);
            }
            
            stack.push(index);
        }

        Collections.reverse(ans);
        return ans;
    }

    public static void main(String[] args) {
        ArrayList<Double> input  = new ArrayList<>();
        // Arrays.asList()
        // input.add(73);
        // input.add(74);
        // input.add(75);
        // input.add(71);
        // input.add(69);
        // input.add(72);
        // input.add(76);
        // input.add(73);

        // 78.6,25.2,36.5,83.5,71.5
        input.add(78.6);
        input.add(25.2);
        input.add(36.5);
        input.add(83.5);
        input.add(71.5);


        List<Integer> ans = getNextGraterTemp(input);
        System.out.println(ans);
    }

}",NextGraterTemp.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\NextGraterTemp.java,program/,program,"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;",Next sibling does not exist,"(5, 0)","(56, 1)",N,class_declaration,NextGraterTemp,,318,92193e50-62ea-4d3f-9bb7-10703131bf89
"public static <T extends Comparable> List<Integer> getNextGraterTemp(List<T> tempartures){
        
        ArrayList<Integer> ans = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        
        for(int index = tempartures.size() -1; index>=0; index--){
            T temp = tempartures.get(index);
            
            while(!stack.empty() && tempartures.get(stack.peek()).compareTo(temp) != 1){
                stack.pop();
            }
            
            if(stack.isEmpty()) {
                ans.add(-1);
            } else {
                ans.add(stack.peek() - index);
            }
            
            stack.push(index);
        }

        Collections.reverse(ans);
        return ans;
    }",NextGraterTemp.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\NextGraterTemp.java,program/class_declaration-NextGraterTemp/,NextGraterTemp,Previous sibling does not exist,"public static void main(String[] args) {
        ArrayList<Double> input  = new ArrayList<>();
        // Arrays.asList()
        // input.add(73);
        // input.add(74);
        // input.add(75);
        // input.add(71);
        // input.add(69);
        // input.add(72);
        // input.add(76);
        // input.add(73);

        // 78.6,25.2,36.5,83.5,71.5
        input.add(78.6);
        input.add(25.2);
        input.add(36.5);
        input.add(83.5);
        input.add(71.5);


        List<Integer> ans = getNextGraterTemp(input);
        System.out.println(ans);
    }","(7, 4)","(30, 5)",N,method_declaration,getNextGraterTemp,,145,55af6c61-b006-4384-aabc-6df34fa02a3a
"public static void main(String[] args) {
        ArrayList<Double> input  = new ArrayList<>();
        // Arrays.asList()
        // input.add(73);
        // input.add(74);
        // input.add(75);
        // input.add(71);
        // input.add(69);
        // input.add(72);
        // input.add(76);
        // input.add(73);

        // 78.6,25.2,36.5,83.5,71.5
        input.add(78.6);
        input.add(25.2);
        input.add(36.5);
        input.add(83.5);
        input.add(71.5);


        List<Integer> ans = getNextGraterTemp(input);
        System.out.println(ans);
    }",NextGraterTemp.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\NextGraterTemp.java,program/class_declaration-NextGraterTemp/,NextGraterTemp,"public static <T extends Comparable> List<Integer> getNextGraterTemp(List<T> tempartures){
        
        ArrayList<Integer> ans = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        
        for(int index = tempartures.size() -1; index>=0; index--){
            T temp = tempartures.get(index);
            
            while(!stack.empty() && tempartures.get(stack.peek()).compareTo(temp) != 1){
                stack.pop();
            }
            
            if(stack.isEmpty()) {
                ans.add(-1);
            } else {
                ans.add(stack.peek() - index);
            }
            
            stack.push(index);
        }

        Collections.reverse(ans);
        return ans;
    }",Next sibling does not exist,"(32, 4)","(54, 5)",N,method_declaration,main,,163,e3f3fbef-1da1-4251-b6cd-2599fbe04f5c
"class StockSpanner:

    def __init__(self):
        self.arr=[]
        self.count = 0

    def next(self, price: int) -> int:
        self.count += 1
        
        while(self.arr and self.arr[-1][0]<=price): self.arr.pop()
        self.arr.append([price, self.count])
        
        # print(self. count, self.arr)
        
        return self.count - self.arr[-2][1]  if(len(self.arr)>=2) else self.count
            


# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)
",StockSpanner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\StockSpanner.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 0)",N,module,module,,138,6acc725b-4ade-460b-860b-314110b93b93
"class StockSpanner:

    def __init__(self):
        self.arr=[]
        self.count = 0

    def next(self, price: int) -> int:
        self.count += 1
        
        while(self.arr and self.arr[-1][0]<=price): self.arr.pop()
        self.arr.append([price, self.count])
        
        # print(self. count, self.arr)
        
        return self.count - self.arr[-2][1]  if(len(self.arr)>=2) else self.count",StockSpanner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\StockSpanner.py,module/,module,Previous sibling does not exist,# Your StockSpanner object will be instantiated and called as such:,"(0, 0)","(14, 81)",N,class_definition,StockSpanner,,105,d8d78edb-9c00-43ab-ae08-ca7d958bc4ff
"def __init__(self):
        self.arr=[]
        self.count = 0",StockSpanner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\StockSpanner.py,module/class_definition-StockSpanner/,StockSpanner,Previous sibling does not exist,"def next(self, price: int) -> int:
        self.count += 1
        
        while(self.arr and self.arr[-1][0]<=price): self.arr.pop()
        self.arr.append([price, self.count])
        
        # print(self. count, self.arr)
        
        return self.count - self.arr[-2][1]  if(len(self.arr)>=2) else self.count","(2, 4)","(4, 22)",N,function_definition,__init__,,16,25e00bb2-d524-40fb-aa9a-0e9383282368
"def next(self, price: int) -> int:
        self.count += 1
        
        while(self.arr and self.arr[-1][0]<=price): self.arr.pop()
        self.arr.append([price, self.count])
        
        # print(self. count, self.arr)
        
        return self.count - self.arr[-2][1]  if(len(self.arr)>=2) else self.count",StockSpanner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\StockSpanner.py,module/class_definition-StockSpanner/,StockSpanner,"def __init__(self):
        self.arr=[]
        self.count = 0","# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)","(6, 4)","(14, 81)",N,function_definition,next,,81,3af52efa-4516-49b5-9c7b-cb4abef72470
"# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner()
# param_1 = obj.next(price)",StockSpanner.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\StockSpanner.py,module/,module,"class StockSpanner:

    def __init__(self):
        self.arr=[]
        self.count = 0

    def next(self, price: int) -> int:
        self.count += 1
        
        while(self.arr and self.arr[-1][0]<=price): self.arr.pop()
        self.arr.append([price, self.count])
        
        # print(self. count, self.arr)
        
        return self.count - self.arr[-2][1]  if(len(self.arr)>=2) else self.count",Next sibling does not exist,"(18, 0)","(20, 27)",N,"comment,comment,comment",comment,,30,f163eb67-29af-4490-82b8-eb3f77cde52e
"class Solution {
    public int trap(int[] height) {
     
        int ans = 0;
        int index = 0;
        
        Stack<StackNode> stack = new Stack<>();
        
        while(index<height.length){
            
            int popedHeight = 0;
            
            while(!stack.empty() && height[index]>stack.peek().height) {
                ans += (stack.peek().height - popedHeight) * (index - stack.peek().index - 1);
                popedHeight = stack.peek().height;
                stack.pop();
            }
            
            if(!stack.empty()) ans += (height[index] - popedHeight) * (index - stack.peek().index - 1);
            stack.push(new StackNode(height[index], index));
            index++;
        }
        
        
        return ans;
    }
}


class StackNode{
    int height;
    int index;
    
    public StackNode(int height, int index){
        this.height = height;
        this.index = index;
    }
    
    public String toString(){
        return this.height + "" "" + this.index;
    }
    
}
",TrappingRainWater.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\TrappingRainWater.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(43, 0)",N,program,program,,227,62dbcbfe-c9fb-4978-abc7-6d4f98d73e47
"class Solution {
    public int trap(int[] height) {
     
        int ans = 0;
        int index = 0;
        
        Stack<StackNode> stack = new Stack<>();
        
        while(index<height.length){
            
            int popedHeight = 0;
            
            while(!stack.empty() && height[index]>stack.peek().height) {
                ans += (stack.peek().height - popedHeight) * (index - stack.peek().index - 1);
                popedHeight = stack.peek().height;
                stack.pop();
            }
            
            if(!stack.empty()) ans += (height[index] - popedHeight) * (index - stack.peek().index - 1);
            stack.push(new StackNode(height[index], index));
            index++;
        }
        
        
        return ans;
    }
}",TrappingRainWater.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\TrappingRainWater.java,program/,program,Previous sibling does not exist,"class StackNode{
    int height;
    int index;
    
    public StackNode(int height, int index){
        this.height = height;
        this.index = index;
    }
    
    public String toString(){
        return this.height + "" "" + this.index;
    }
    
}","(0, 0)","(26, 1)",N,class_declaration,Solution,,169,ee2d8a0f-fd2f-4270-82e6-78c308e1a390
"public int trap(int[] height) {
     
        int ans = 0;
        int index = 0;
        
        Stack<StackNode> stack = new Stack<>();
        
        while(index<height.length){
            
            int popedHeight = 0;
            
            while(!stack.empty() && height[index]>stack.peek().height) {
                ans += (stack.peek().height - popedHeight) * (index - stack.peek().index - 1);
                popedHeight = stack.peek().height;
                stack.pop();
            }
            
            if(!stack.empty()) ans += (height[index] - popedHeight) * (index - stack.peek().index - 1);
            stack.push(new StackNode(height[index], index));
            index++;
        }
        
        
        return ans;
    }",TrappingRainWater.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\TrappingRainWater.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(25, 5)",N,method_declaration,trap,,164,e0d23dee-da5a-4f62-b59a-cc856904aa0a
"class StackNode{
    int height;
    int index;
    
    public StackNode(int height, int index){
        this.height = height;
        this.index = index;
    }
    
    public String toString(){
        return this.height + "" "" + this.index;
    }
    
}",TrappingRainWater.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\TrappingRainWater.java,program/,program,"class Solution {
    public int trap(int[] height) {
     
        int ans = 0;
        int index = 0;
        
        Stack<StackNode> stack = new Stack<>();
        
        while(index<height.length){
            
            int popedHeight = 0;
            
            while(!stack.empty() && height[index]>stack.peek().height) {
                ans += (stack.peek().height - popedHeight) * (index - stack.peek().index - 1);
                popedHeight = stack.peek().height;
                stack.pop();
            }
            
            if(!stack.empty()) ans += (height[index] - popedHeight) * (index - stack.peek().index - 1);
            stack.push(new StackNode(height[index], index));
            index++;
        }
        
        
        return ans;
    }
}",Next sibling does not exist,"(29, 0)","(42, 1)",N,class_declaration,StackNode,,58,14c44c7e-4cf2-46da-b7a8-dfeb35fb8308
"public StackNode(int height, int index){
        this.height = height;
        this.index = index;
    }",TrappingRainWater.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\TrappingRainWater.java,program/class_declaration-StackNode/,StackNode,int index;,"public String toString(){
        return this.height + "" "" + this.index;
    }","(33, 4)","(36, 5)",N,constructor_declaration,StackNode,,23,8f2d71ef-1c0a-4d04-a708-c11447a873a9
"public String toString(){
        return this.height + "" "" + this.index;
    }",TrappingRainWater.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\stack\monotonic-stack\TrappingRainWater.java,program/class_declaration-StackNode/,StackNode,"public StackNode(int height, int index){
        this.height = height;
        this.index = index;
    }",Next sibling does not exist,"(38, 4)","(40, 5)",N,method_declaration,toString,,17,4665966f-a2a9-444d-9908-eae361e3b8ba
"class PatternMatcher:

    def __init__(self):
        self.mod = 10**9 + 9
        self.p = 31
        self.pow_p = []

        self.pattern = None
        self.s = None

        self.n = None
        self.m = None
        self.strHash = {}
    
    def fill_pow_p(self, num):
        cur = 1

        while(num>=0):
            self.pow_p.append(cur)
            cur *= self.p
            num -= 1
    
    def getStrHash(self, index):
        if(index == 0):
            ans = 0
            for index, ch in enumerate(self.s[:self.m]):
                ans = (ans%self.mod +  ((ord(ch) - 96) * self.pow_p[self.m-1-index])%self.mod) % self.mod 
        
            self.strHash[0] = ans
            return ans

        if(index in self.strHash): return  self.strHash[index]
        
        prevHash = self.getStrHash(index-1)
        ans = (
            (prevHash * self.p) 
            - ( (ord(self.s[index-1]) - 96) * self.pow_p[self.m]) 
            + (ord(self.s[index+self.m-1]) - 96)
            ) % self.mod
        self.strHash[index] = ans
        return ans

    def patternMatching(self, s, pattern):
        ans = []

        self.pattern = pattern
        self.s = s
        self.m = len(pattern)
        self.n = len(s)
        self.fill_pow_p(self.m)

        patternHash = 0
        for pi, pc in enumerate(self.pattern):
            patternHash = (patternHash%self.mod +  ((ord(pc) - 96) * self.pow_p[self.m-1-pi])%self.mod) % self.mod
    
        strHash = None

        endIndex = (self.n-self.m+1)
        index = 0
        while(index < endIndex):
            strHash = self.getStrHash(index)
            if(patternHash == strHash): ans.append(index)
            index += 1

        return ans


sol = PatternMatcher()
print(sol.patternMatching(""hellohello"", ""llo""))
print(sol.strHash)
print(sol.pow_p)
",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(71, 0)",N,module,module,,483,6b28e4a8-c3e5-4f0f-b5f5-28b561384510
"class PatternMatcher:

    def __init__(self):
        self.mod = 10**9 + 9
        self.p = 31
        self.pow_p = []

        self.pattern = None
        self.s = None

        self.n = None
        self.m = None
        self.strHash = {}
    
    def fill_pow_p(self, num):
        cur = 1

        while(num>=0):
            self.pow_p.append(cur)
            cur *= self.p
            num -= 1
    
    def getStrHash(self, index):
        if(index == 0):
            ans = 0
            for index, ch in enumerate(self.s[:self.m]):
                ans = (ans%self.mod +  ((ord(ch) - 96) * self.pow_p[self.m-1-index])%self.mod) % self.mod 
        
            self.strHash[0] = ans
            return ans

        if(index in self.strHash): return  self.strHash[index]
        
        prevHash = self.getStrHash(index-1)
        ans = (
            (prevHash * self.p) 
            - ( (ord(self.s[index-1]) - 96) * self.pow_p[self.m]) 
            + (ord(self.s[index+self.m-1]) - 96)
            ) % self.mod
        self.strHash[index] = ans
        return ans

    def patternMatching(self, s, pattern):
        ans = []

        self.pattern = pattern
        self.s = s
        self.m = len(pattern)
        self.n = len(s)
        self.fill_pow_p(self.m)

        patternHash = 0
        for pi, pc in enumerate(self.pattern):
            patternHash = (patternHash%self.mod +  ((ord(pc) - 96) * self.pow_p[self.m-1-pi])%self.mod) % self.mod
    
        strHash = None

        endIndex = (self.n-self.m+1)
        index = 0
        while(index < endIndex):
            strHash = self.getStrHash(index)
            if(patternHash == strHash): ans.append(index)
            index += 1

        return ans",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,module/,module,Previous sibling does not exist,sol = PatternMatcher(),"(0, 0)","(64, 18)",N,class_definition,PatternMatcher,,455,88058dc6-9435-4a9f-bcf6-58ff43d33e5f
"def __init__(self):
        self.mod = 10**9 + 9
        self.p = 31
        self.pow_p = []

        self.pattern = None
        self.s = None

        self.n = None
        self.m = None
        self.strHash = {}",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,module/class_definition-PatternMatcher/,PatternMatcher,Previous sibling does not exist,"def fill_pow_p(self, num):
        cur = 1

        while(num>=0):
            self.pow_p.append(cur)
            cur *= self.p
            num -= 1","(2, 4)","(12, 25)",N,function_definition,__init__,,61,e54f4630-1775-4743-ba90-f2ac6eca1c01
"def fill_pow_p(self, num):
        cur = 1

        while(num>=0):
            self.pow_p.append(cur)
            cur *= self.p
            num -= 1",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,module/class_definition-PatternMatcher/,PatternMatcher,"def __init__(self):
        self.mod = 10**9 + 9
        self.p = 31
        self.pow_p = []

        self.pattern = None
        self.s = None

        self.n = None
        self.m = None
        self.strHash = {}","def getStrHash(self, index):
        if(index == 0):
            ans = 0
            for index, ch in enumerate(self.s[:self.m]):
                ans = (ans%self.mod +  ((ord(ch) - 96) * self.pow_p[self.m-1-index])%self.mod) % self.mod 
        
            self.strHash[0] = ans
            return ans

        if(index in self.strHash): return  self.strHash[index]
        
        prevHash = self.getStrHash(index-1)
        ans = (
            (prevHash * self.p) 
            - ( (ord(self.s[index-1]) - 96) * self.pow_p[self.m]) 
            + (ord(self.s[index+self.m-1]) - 96)
            ) % self.mod
        self.strHash[index] = ans
        return ans","(14, 4)","(20, 20)",N,function_definition,fill_pow_p,,38,47501249-1ead-4df5-9be0-7e42d0cc58eb
"def getStrHash(self, index):
        if(index == 0):
            ans = 0
            for index, ch in enumerate(self.s[:self.m]):
                ans = (ans%self.mod +  ((ord(ch) - 96) * self.pow_p[self.m-1-index])%self.mod) % self.mod 
        
            self.strHash[0] = ans
            return ans

        if(index in self.strHash): return  self.strHash[index]
        
        prevHash = self.getStrHash(index-1)
        ans = (
            (prevHash * self.p) 
            - ( (ord(self.s[index-1]) - 96) * self.pow_p[self.m]) 
            + (ord(self.s[index+self.m-1]) - 96)
            ) % self.mod
        self.strHash[index] = ans
        return ans",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,module/class_definition-PatternMatcher/,PatternMatcher,"def fill_pow_p(self, num):
        cur = 1

        while(num>=0):
            self.pow_p.append(cur)
            cur *= self.p
            num -= 1","def patternMatching(self, s, pattern):
        ans = []

        self.pattern = pattern
        self.s = s
        self.m = len(pattern)
        self.n = len(s)
        self.fill_pow_p(self.m)

        patternHash = 0
        for pi, pc in enumerate(self.pattern):
            patternHash = (patternHash%self.mod +  ((ord(pc) - 96) * self.pow_p[self.m-1-pi])%self.mod) % self.mod
    
        strHash = None

        endIndex = (self.n-self.m+1)
        index = 0
        while(index < endIndex):
            strHash = self.getStrHash(index)
            if(patternHash == strHash): ans.append(index)
            index += 1

        return ans","(22, 4)","(40, 18)",N,function_definition,getStrHash,,182,1765343d-3a33-4a5e-a9c3-b26a25be48f1
"def patternMatching(self, s, pattern):
        ans = []

        self.pattern = pattern
        self.s = s
        self.m = len(pattern)
        self.n = len(s)
        self.fill_pow_p(self.m)

        patternHash = 0
        for pi, pc in enumerate(self.pattern):
            patternHash = (patternHash%self.mod +  ((ord(pc) - 96) * self.pow_p[self.m-1-pi])%self.mod) % self.mod
    
        strHash = None

        endIndex = (self.n-self.m+1)
        index = 0
        while(index < endIndex):
            strHash = self.getStrHash(index)
            if(patternHash == strHash): ans.append(index)
            index += 1

        return ans",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,module/class_definition-PatternMatcher/,PatternMatcher,"def getStrHash(self, index):
        if(index == 0):
            ans = 0
            for index, ch in enumerate(self.s[:self.m]):
                ans = (ans%self.mod +  ((ord(ch) - 96) * self.pow_p[self.m-1-index])%self.mod) % self.mod 
        
            self.strHash[0] = ans
            return ans

        if(index in self.strHash): return  self.strHash[index]
        
        prevHash = self.getStrHash(index-1)
        ans = (
            (prevHash * self.p) 
            - ( (ord(self.s[index-1]) - 96) * self.pow_p[self.m]) 
            + (ord(self.s[index+self.m-1]) - 96)
            ) % self.mod
        self.strHash[index] = ans
        return ans","sol = PatternMatcher()
print(sol.patternMatching(""hellohello"", ""llo""))
print(sol.strHash)
print(sol.pow_p)","(42, 4)","(64, 18)",N,function_definition,patternMatching,,163,92b89d21-19e2-47c4-8116-7334a9cdb519
"sol = PatternMatcher()
print(sol.patternMatching(""hellohello"", ""llo""))
print(sol.strHash)
print(sol.pow_p)",PatternMatcher.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\strings\string-matching\PatternMatcher.py,module/,module,"class PatternMatcher:

    def __init__(self):
        self.mod = 10**9 + 9
        self.p = 31
        self.pow_p = []

        self.pattern = None
        self.s = None

        self.n = None
        self.m = None
        self.strHash = {}
    
    def fill_pow_p(self, num):
        cur = 1

        while(num>=0):
            self.pow_p.append(cur)
            cur *= self.p
            num -= 1
    
    def getStrHash(self, index):
        if(index == 0):
            ans = 0
            for index, ch in enumerate(self.s[:self.m]):
                ans = (ans%self.mod +  ((ord(ch) - 96) * self.pow_p[self.m-1-index])%self.mod) % self.mod 
        
            self.strHash[0] = ans
            return ans

        if(index in self.strHash): return  self.strHash[index]
        
        prevHash = self.getStrHash(index-1)
        ans = (
            (prevHash * self.p) 
            - ( (ord(self.s[index-1]) - 96) * self.pow_p[self.m]) 
            + (ord(self.s[index+self.m-1]) - 96)
            ) % self.mod
        self.strHash[index] = ans
        return ans

    def patternMatching(self, s, pattern):
        ans = []

        self.pattern = pattern
        self.s = s
        self.m = len(pattern)
        self.n = len(s)
        self.fill_pow_p(self.m)

        patternHash = 0
        for pi, pc in enumerate(self.pattern):
            patternHash = (patternHash%self.mod +  ((ord(pc) - 96) * self.pow_p[self.m-1-pi])%self.mod) % self.mod
    
        strHash = None

        endIndex = (self.n-self.m+1)
        index = 0
        while(index < endIndex):
            strHash = self.getStrHash(index)
            if(patternHash == strHash): ans.append(index)
            index += 1

        return ans",Next sibling does not exist,"(67, 0)","(70, 16)",N,"expression_statement,expression_statement,expression_statement,expression_statement",expression_statement,,27,cdb205ea-b10b-4205-927e-c64625891bfc
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
        ans = []
        visited = collections.defaultdict(int)

        def inorder(root):
            if(not root): return (""null"", ""null"")

            in_l, pre_l = inorder(root.left)
            in_r, pre_r = inorder(root.right)

            cur_in = in_l + str(root.val) + in_r
            cur_pre = str(root.val) + pre_l + pre_r
            cur = (cur_in, cur_pre)

            if(cur in visited and visited[cur] == 1):
                # print(cur)
                ans.append(root)
                visited[cur] += 1
            else:
                visited[cur] += 1
            return cur
        
        inorder(root)
        return ans
",findDuplicateSubtrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\findDuplicateSubtrees.py,,NA,Previous sibling does not exist,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right","(0, 0)","(31, 0)",N,module,module,,220,739ecc92-dfa8-46a1-9fdb-cb711564efa2
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",findDuplicateSubtrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\findDuplicateSubtrees.py,module/,module,Previous sibling does not exist,"class Solution:
    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
        ans = []
        visited = collections.defaultdict(int)

        def inorder(root):
            if(not root): return (""null"", ""null"")

            in_l, pre_l = inorder(root.left)
            in_r, pre_r = inorder(root.right)

            cur_in = in_l + str(root.val) + in_r
            cur_pre = str(root.val) + pre_l + pre_r
            cur = (cur_in, cur_pre)

            if(cur in visited and visited[cur] == 1):
                # print(cur)
                ans.append(root)
                visited[cur] += 1
            else:
                visited[cur] += 1
            return cur
        
        inorder(root)
        return ans","(0, 0)","(5, 28)",N,"comment,comment,comment,comment,comment,comment",comment,,48,1615f151-8197-4e84-83d7-0559288256ee
"class Solution:
    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
        ans = []
        visited = collections.defaultdict(int)

        def inorder(root):
            if(not root): return (""null"", ""null"")

            in_l, pre_l = inorder(root.left)
            in_r, pre_r = inorder(root.right)

            cur_in = in_l + str(root.val) + in_r
            cur_pre = str(root.val) + pre_l + pre_r
            cur = (cur_in, cur_pre)

            if(cur in visited and visited[cur] == 1):
                # print(cur)
                ans.append(root)
                visited[cur] += 1
            else:
                visited[cur] += 1
            return cur
        
        inorder(root)
        return ans",findDuplicateSubtrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\findDuplicateSubtrees.py,module/,module,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",Next sibling does not exist,"(6, 0)","(30, 18)",N,class_definition,Solution,,168,2f744c07-2209-4a26-bc1b-4c7005a2a6b1
"def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
        ans = []
        visited = collections.defaultdict(int)

        def inorder(root):
            if(not root): return (""null"", ""null"")

            in_l, pre_l = inorder(root.left)
            in_r, pre_r = inorder(root.right)

            cur_in = in_l + str(root.val) + in_r
            cur_pre = str(root.val) + pre_l + pre_r
            cur = (cur_in, cur_pre)

            if(cur in visited and visited[cur] == 1):
                # print(cur)
                ans.append(root)
                visited[cur] += 1
            else:
                visited[cur] += 1
            return cur
        
        inorder(root)
        return ans",findDuplicateSubtrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\findDuplicateSubtrees.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(7, 4)","(30, 18)",N,function_definition,findDuplicateSubtrees,,164,0f9e0800-ce99-4340-917b-c7683b37c096
"def inorder(root):
            if(not root): return (""null"", ""null"")

            in_l, pre_l = inorder(root.left)
            in_r, pre_r = inorder(root.right)

            cur_in = in_l + str(root.val) + in_r
            cur_pre = str(root.val) + pre_l + pre_r
            cur = (cur_in, cur_pre)

            if(cur in visited and visited[cur] == 1):
                # print(cur)
                ans.append(root)
                visited[cur] += 1
            else:
                visited[cur] += 1
            return cur",findDuplicateSubtrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\findDuplicateSubtrees.py,module/class_definition-Solution/function_definition-findDuplicateSubtrees/,findDuplicateSubtrees,visited = collections.defaultdict(int),inorder(root),"(11, 8)","(27, 22)",N,function_definition,inorder,,123,6bca9bcd-0f61-4af2-8d90-1714e4f13667
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:

        def helper(low, high):
            if(low > high): return []
            if(low == high): return [TreeNode(low)]

            ans = []
            for cur in range(low, high+1):
                left = helper(low, cur-1)
                right = helper(cur+1, high)

                if(not left):
                    for r in right:
                        node = TreeNode(cur)
                        node.right = r
                        ans.append(node)
                
                if(not right):
                    for l in left:
                        node = TreeNode(cur)
                        node.left = l
                        ans.append(node)
                    
                
                for l in left:
                    for r in right:
                        node = TreeNode(cur)
                        node.left, node.right = l, r
                        ans.append(node)
            
            return ans
        
        return helper(1, n)
",generateTrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\generateTrees.py,,NA,Previous sibling does not exist,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right","(0, 0)","(40, 0)",N,module,module,,239,7333d7ea-6082-4927-8ba3-5e5d8c6b4cd9
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",generateTrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\generateTrees.py,module/,module,Previous sibling does not exist,"class Solution:
    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:

        def helper(low, high):
            if(low > high): return []
            if(low == high): return [TreeNode(low)]

            ans = []
            for cur in range(low, high+1):
                left = helper(low, cur-1)
                right = helper(cur+1, high)

                if(not left):
                    for r in right:
                        node = TreeNode(cur)
                        node.right = r
                        ans.append(node)
                
                if(not right):
                    for l in left:
                        node = TreeNode(cur)
                        node.left = l
                        ans.append(node)
                    
                
                for l in left:
                    for r in right:
                        node = TreeNode(cur)
                        node.left, node.right = l, r
                        ans.append(node)
            
            return ans
        
        return helper(1, n)","(0, 0)","(5, 28)",N,"comment,comment,comment,comment,comment,comment",comment,,48,8e36e65f-db08-4ddb-9978-e973d059aee6
"class Solution:
    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:

        def helper(low, high):
            if(low > high): return []
            if(low == high): return [TreeNode(low)]

            ans = []
            for cur in range(low, high+1):
                left = helper(low, cur-1)
                right = helper(cur+1, high)

                if(not left):
                    for r in right:
                        node = TreeNode(cur)
                        node.right = r
                        ans.append(node)
                
                if(not right):
                    for l in left:
                        node = TreeNode(cur)
                        node.left = l
                        ans.append(node)
                    
                
                for l in left:
                    for r in right:
                        node = TreeNode(cur)
                        node.left, node.right = l, r
                        ans.append(node)
            
            return ans
        
        return helper(1, n)",generateTrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\generateTrees.py,module/,module,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",Next sibling does not exist,"(6, 0)","(39, 27)",N,class_definition,Solution,,188,a777df74-764e-4b88-9db1-ad37dabf04ed
"def generateTrees(self, n: int) -> List[Optional[TreeNode]]:

        def helper(low, high):
            if(low > high): return []
            if(low == high): return [TreeNode(low)]

            ans = []
            for cur in range(low, high+1):
                left = helper(low, cur-1)
                right = helper(cur+1, high)

                if(not left):
                    for r in right:
                        node = TreeNode(cur)
                        node.right = r
                        ans.append(node)
                
                if(not right):
                    for l in left:
                        node = TreeNode(cur)
                        node.left = l
                        ans.append(node)
                    
                
                for l in left:
                    for r in right:
                        node = TreeNode(cur)
                        node.left, node.right = l, r
                        ans.append(node)
            
            return ans
        
        return helper(1, n)",generateTrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\generateTrees.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(7, 4)","(39, 27)",N,function_definition,generateTrees,,184,b2a97e30-bef0-4f21-a360-3c074450587a
"def helper(low, high):
            if(low > high): return []
            if(low == high): return [TreeNode(low)]

            ans = []
            for cur in range(low, high+1):
                left = helper(low, cur-1)
                right = helper(cur+1, high)

                if(not left):
                    for r in right:
                        node = TreeNode(cur)
                        node.right = r
                        ans.append(node)
                
                if(not right):
                    for l in left:
                        node = TreeNode(cur)
                        node.left = l
                        ans.append(node)
                    
                
                for l in left:
                    for r in right:
                        node = TreeNode(cur)
                        node.left, node.right = l, r
                        ans.append(node)
            
            return ans",generateTrees.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\generateTrees.py,module/class_definition-Solution/function_definition-generateTrees/,generateTrees,Previous sibling does not exist,"return helper(1, n)","(9, 8)","(37, 22)",N,function_definition,helper,,157,275b3678-aeac-45dc-a2d4-1a9ed1263d79
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && targetSum == root.val) return true;
        
        return hasPathSum(root.left, targetSum-root.val) || hasPathSum(root.right, targetSum-root.val);
    }
}
",HasPathSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\HasPathSum.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(24, 0)",N,program,program,,163,af98e687-1f1a-4dcf-9721-826d07838a08
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",HasPathSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\HasPathSum.java,program/,program,Previous sibling does not exist,"class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && targetSum == root.val) return true;
        
        return hasPathSum(root.left, targetSum-root.val) || hasPathSum(root.right, targetSum-root.val);
    }
}","(0, 0)","(14, 3)",N,block_comment,block_comment,,87,03cfa84e-38a1-4a3e-a76f-a2f6750857d0
"class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && targetSum == root.val) return true;
        
        return hasPathSum(root.left, targetSum-root.val) || hasPathSum(root.right, targetSum-root.val);
    }
}",HasPathSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\HasPathSum.java,program/,program,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",Next sibling does not exist,"(16, 0)","(23, 1)",N,class_declaration,Solution,,76,bd5626da-f74f-444d-9235-db61a347634c
"public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && targetSum == root.val) return true;
        
        return hasPathSum(root.left, targetSum-root.val) || hasPathSum(root.right, targetSum-root.val);
    }",HasPathSum.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\HasPathSum.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(17, 4)","(22, 5)",N,method_declaration,hasPathSum,,71,637ab17d-04a6-4cc8-b550-43c5d809715c
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        helper(root, ans);
        return ans;
    }
    
    
    public void helper(TreeNode root, List<Integer> ans){
        if(root==null) return;
        helper(root.left, ans);
        ans.add(root.val);
        helper(root.right, ans);
    }
}
",InorderTraversal.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\InorderTraversal.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(30, 0)",N,program,program,,167,800b3202-eb28-43ba-aad0-3ea4bac59e60
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",InorderTraversal.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\InorderTraversal.java,program/,program,Previous sibling does not exist,"class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        helper(root, ans);
        return ans;
    }
    
    
    public void helper(TreeNode root, List<Integer> ans){
        if(root==null) return;
        helper(root.left, ans);
        ans.add(root.val);
        helper(root.right, ans);
    }
}","(0, 0)","(14, 3)",N,block_comment,block_comment,,87,e4f1397c-290d-407c-bc65-d4fbd094afe2
"class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        helper(root, ans);
        return ans;
    }
    
    
    public void helper(TreeNode root, List<Integer> ans){
        if(root==null) return;
        helper(root.left, ans);
        ans.add(root.val);
        helper(root.right, ans);
    }
}",InorderTraversal.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\InorderTraversal.java,program/,program,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",Next sibling does not exist,"(15, 0)","(29, 1)",N,class_declaration,Solution,,80,0150004d-5eec-4e88-ba2e-576c24e88f80
"public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        helper(root, ans);
        return ans;
    }",InorderTraversal.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\InorderTraversal.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public void helper(TreeNode root, List<Integer> ans){
        if(root==null) return;
        helper(root.left, ans);
        ans.add(root.val);
        helper(root.right, ans);
    }","(16, 4)","(20, 5)",N,method_declaration,inorderTraversal,,32,27cbf5a7-c4b9-4aeb-b740-13d33ece152c
"public void helper(TreeNode root, List<Integer> ans){
        if(root==null) return;
        helper(root.left, ans);
        ans.add(root.val);
        helper(root.right, ans);
    }",InorderTraversal.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\InorderTraversal.java,program/class_declaration-Solution/,Solution,"public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<Integer>();
        helper(root, ans);
        return ans;
    }",Next sibling does not exist,"(23, 4)","(28, 5)",N,method_declaration,helper,,41,05b9f09d-8a27-4996-9df1-d9c2abdc670e
"class Solution:
    def getLeaves(self, root):
        if(not root): return []


        left = []
        right = []

        if(not root.left and not root.right): return [root.val]
        if(root.left): left = self.getLeaves(root.left)
        if(root.right): right = self.getLeaves(root.right)

        return left + right


    
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:

        a = self.getLeaves(root1)
        b = self.getLeaves(root2)

        if(len(a)!=len(b)): return False

        return all(i == j for i, j in zip(a,b))
",leafSimilar.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\leafSimilar.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(24, 0)",N,module,module,,146,21a6c1cd-4ab0-48fc-8efc-646d54127229
"class Solution:
    def getLeaves(self, root):
        if(not root): return []


        left = []
        right = []

        if(not root.left and not root.right): return [root.val]
        if(root.left): left = self.getLeaves(root.left)
        if(root.right): right = self.getLeaves(root.right)

        return left + right


    
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:

        a = self.getLeaves(root1)
        b = self.getLeaves(root2)

        if(len(a)!=len(b)): return False

        return all(i == j for i, j in zip(a,b))",leafSimilar.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\leafSimilar.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 47)",N,class_definition,Solution,,146,e203657f-dab1-4af0-bbbe-1c762e480c39
"def getLeaves(self, root):
        if(not root): return []


        left = []
        right = []

        if(not root.left and not root.right): return [root.val]
        if(root.left): left = self.getLeaves(root.left)
        if(root.right): right = self.getLeaves(root.right)

        return left + right",leafSimilar.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\leafSimilar.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:

        a = self.getLeaves(root1)
        b = self.getLeaves(root2)

        if(len(a)!=len(b)): return False

        return all(i == j for i, j in zip(a,b))","(1, 4)","(12, 27)",N,function_definition,getLeaves,,71,1e5582dc-f0ec-4e6a-ab10-ae5d6afeb963
"def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:

        a = self.getLeaves(root1)
        b = self.getLeaves(root2)

        if(len(a)!=len(b)): return False

        return all(i == j for i, j in zip(a,b))",leafSimilar.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\leafSimilar.py,module/class_definition-Solution/,Solution,"def getLeaves(self, root):
        if(not root): return []


        left = []
        right = []

        if(not root.left and not root.right): return [root.val]
        if(root.left): left = self.getLeaves(root.left)
        if(root.right): right = self.getLeaves(root.right)

        return left + right",Next sibling does not exist,"(16, 4)","(23, 47)",N,function_definition,leafSimilar,,68,ff5032a2-8d23-4c93-867c-fb27988e941e
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:

    def helper(self, root):
        if(not root): return [0, 0]
        left, right = self.helper(root.left), self.helper(root.right)
        cur = [1 + left[1], 1 + right[0]]
        self.ans = max(self.ans, left[0], right[1], max(cur))
        return cur



    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.helper(root)
        return self.ans -1
        

",longestZigZag.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\longestZigZag.py,,NA,Previous sibling does not exist,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right","(0, 0)","(23, 0)",N,module,module,,170,a7d580db-eab9-47a2-a79c-dffc9c679f11
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",longestZigZag.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\longestZigZag.py,module/,module,Previous sibling does not exist,"class Solution:

    def helper(self, root):
        if(not root): return [0, 0]
        left, right = self.helper(root.left), self.helper(root.right)
        cur = [1 + left[1], 1 + right[0]]
        self.ans = max(self.ans, left[0], right[1], max(cur))
        return cur



    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.helper(root)
        return self.ans -1","(0, 0)","(5, 28)",N,"comment,comment,comment,comment,comment,comment",comment,,48,38a9f677-8828-4216-814b-eb3edbca30bf
"class Solution:

    def helper(self, root):
        if(not root): return [0, 0]
        left, right = self.helper(root.left), self.helper(root.right)
        cur = [1 + left[1], 1 + right[0]]
        self.ans = max(self.ans, left[0], right[1], max(cur))
        return cur



    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.helper(root)
        return self.ans -1",longestZigZag.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\longestZigZag.py,module/,module,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",Next sibling does not exist,"(6, 0)","(20, 26)",N,class_definition,Solution,,117,bc46d9d0-4014-4663-80e7-2ef48514fb78
"def helper(self, root):
        if(not root): return [0, 0]
        left, right = self.helper(root.left), self.helper(root.right)
        cur = [1 + left[1], 1 + right[0]]
        self.ans = max(self.ans, left[0], right[1], max(cur))
        return cur",longestZigZag.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\longestZigZag.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def longestZigZag(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.helper(root)
        return self.ans -1","(8, 4)","(13, 18)",N,function_definition,helper,,74,153d7f00-826c-4be0-8ee9-04b2db19626d
"def longestZigZag(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.helper(root)
        return self.ans -1",longestZigZag.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\longestZigZag.py,module/class_definition-Solution/,Solution,"def helper(self, root):
        if(not root): return [0, 0]
        left, right = self.helper(root.left), self.helper(root.right)
        cur = [1 + left[1], 1 + right[0]]
        self.ans = max(self.ans, left[0], right[1], max(cur))
        return cur",Next sibling does not exist,"(17, 4)","(20, 26)",N,function_definition,longestZigZag,,37,175b4e90-8672-4358-a645-e55d8e784597
"class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:

        def helper(root, minVal, maxVal):
            if(not root): return -1

            a = abs(root.val - maxVal)
            b = abs(root.val - minVal)
            cur = max(a, b)

            left = helper(root.left, min(minVal, root.val), max(maxVal, root.val))
            right = helper(root.right, min(minVal, root.val), max(maxVal, root.val))

            return max(left, right, cur)
        
        return helper(root, root.val, root.val)
",maxAncestorDiff.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxAncestorDiff.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 0)",N,module,module,,131,2f70cbc5-db84-42a9-8434-825891732d08
"class Solution:
    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:

        def helper(root, minVal, maxVal):
            if(not root): return -1

            a = abs(root.val - maxVal)
            b = abs(root.val - minVal)
            cur = max(a, b)

            left = helper(root.left, min(minVal, root.val), max(maxVal, root.val))
            right = helper(root.right, min(minVal, root.val), max(maxVal, root.val))

            return max(left, right, cur)
        
        return helper(root, root.val, root.val)",maxAncestorDiff.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxAncestorDiff.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(15, 47)",N,class_definition,Solution,,131,a53171e9-fa00-4db1-aaff-39492004e57b
"def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:

        def helper(root, minVal, maxVal):
            if(not root): return -1

            a = abs(root.val - maxVal)
            b = abs(root.val - minVal)
            cur = max(a, b)

            left = helper(root.left, min(minVal, root.val), max(maxVal, root.val))
            right = helper(root.right, min(minVal, root.val), max(maxVal, root.val))

            return max(left, right, cur)
        
        return helper(root, root.val, root.val)",maxAncestorDiff.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxAncestorDiff.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(15, 47)",N,function_definition,maxAncestorDiff,,127,8d282c5c-7e3c-480a-bc87-95cc59e00e2e
"def helper(root, minVal, maxVal):
            if(not root): return -1

            a = abs(root.val - maxVal)
            b = abs(root.val - minVal)
            cur = max(a, b)

            left = helper(root.left, min(minVal, root.val), max(maxVal, root.val))
            right = helper(root.right, min(minVal, root.val), max(maxVal, root.val))

            return max(left, right, cur)",maxAncestorDiff.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxAncestorDiff.py,module/class_definition-Solution/function_definition-maxAncestorDiff/,maxAncestorDiff,Previous sibling does not exist,"return helper(root, root.val, root.val)","(3, 8)","(13, 40)",N,function_definition,helper,,98,7b93ad7a-2bdd-4582-8eb2-cb1b1973d683
"class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:

        def helper(root):
            if(not root): return -10001,-10001

            leftx, leftmax  = helper(root.left)
            rightx, rightmax = helper(root.right)
            val = root.val

            ansx = max(val, val+leftx, val+rightx)
            ans = max(ansx, val + leftx + rightx, leftmax, rightmax) 
            return (ansx, ans)

        
        return max(helper(root))
",maxPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxPathSum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 0)",N,module,module,,120,0583d014-7028-4638-9cf6-3fe2142ae8eb
"class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:

        def helper(root):
            if(not root): return -10001,-10001

            leftx, leftmax  = helper(root.left)
            rightx, rightmax = helper(root.right)
            val = root.val

            ansx = max(val, val+leftx, val+rightx)
            ans = max(ansx, val + leftx + rightx, leftmax, rightmax) 
            return (ansx, ans)

        
        return max(helper(root))",maxPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxPathSum.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(15, 32)",N,class_definition,Solution,,120,a003699a-1d50-406d-9ca6-4b5388e7639f
"def maxPathSum(self, root: Optional[TreeNode]) -> int:

        def helper(root):
            if(not root): return -10001,-10001

            leftx, leftmax  = helper(root.left)
            rightx, rightmax = helper(root.right)
            val = root.val

            ansx = max(val, val+leftx, val+rightx)
            ans = max(ansx, val + leftx + rightx, leftmax, rightmax) 
            return (ansx, ans)

        
        return max(helper(root))",maxPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxPathSum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(15, 32)",N,function_definition,maxPathSum,,116,7051ae68-791e-4e16-aaca-8eb965d7ae4b
"def helper(root):
            if(not root): return -10001,-10001

            leftx, leftmax  = helper(root.left)
            rightx, rightmax = helper(root.right)
            val = root.val

            ansx = max(val, val+leftx, val+rightx)
            ans = max(ansx, val + leftx + rightx, leftmax, rightmax) 
            return (ansx, ans)",maxPathSum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxPathSum.py,module/class_definition-Solution/function_definition-maxPathSum/,maxPathSum,Previous sibling does not exist,return max(helper(root)),"(3, 8)","(12, 30)",N,function_definition,helper,,93,de1fe129-0a08-41fb-936e-a3f9ca93f150
"# Approach

# Two pass
# - first pass to get the sum of the tree
# - second pass to find the max product 


# Complexity
# - Time complexity: $$O(n)$$
# - Space complexity: $$O(n)$$


# Code

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:

        cache = {}
        mod = 10**9 + 7

        def getSumOfTree(root):
            if(root in cache): return cache[root]
            if not root: return 0

            left = getSumOfTree(root.left)
            right = getSumOfTree(root.right)
            
            ans = left + right + root.val

            cache[root] = ans
            return ans
        
        def ans(root, totalSum):
            if(not root): return -1

            sumVal = getSumOfTree(root)
            cur = (totalSum-sumVal) * (sumVal%mod)

            return max(cur, ans(root.left, totalSum), ans(root.right, totalSum))
        
        return ans(root, getSumOfTree(root))%mod
",maxProduct.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxProduct.py,,NA,Previous sibling does not exist,"# Approach
# Two pass
# - first pass to get the sum of the tree
# - second pass to find the max product 
# Complexity
# - Time complexity: $$O(n)$$
# - Space complexity: $$O(n)$$
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right","(0, 0)","(48, 0)",N,module,module,,287,10336552-719f-4b79-a833-010066d4c483
"# Approach
# Two pass
# - first pass to get the sum of the tree
# - second pass to find the max product 
# Complexity
# - Time complexity: $$O(n)$$
# - Space complexity: $$O(n)$$
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",maxProduct.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxProduct.py,module/,module,Previous sibling does not exist,"class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:

        cache = {}
        mod = 10**9 + 7

        def getSumOfTree(root):
            if(root in cache): return cache[root]
            if not root: return 0

            left = getSumOfTree(root.left)
            right = getSumOfTree(root.right)
            
            ans = left + right + root.val

            cache[root] = ans
            return ans
        
        def ans(root, totalSum):
            if(not root): return -1

            sumVal = getSumOfTree(root)
            cur = (totalSum-sumVal) * (sumVal%mod)

            return max(cur, ans(root.left, totalSum), ans(root.right, totalSum))
        
        return ans(root, getSumOfTree(root))%mod","(0, 0)","(19, 28)",N,"comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment,comment",comment,,98,c9a2e4be-a06b-42e5-8427-f8c28fbcb376
"class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:

        cache = {}
        mod = 10**9 + 7

        def getSumOfTree(root):
            if(root in cache): return cache[root]
            if not root: return 0

            left = getSumOfTree(root.left)
            right = getSumOfTree(root.right)
            
            ans = left + right + root.val

            cache[root] = ans
            return ans
        
        def ans(root, totalSum):
            if(not root): return -1

            sumVal = getSumOfTree(root)
            cur = (totalSum-sumVal) * (sumVal%mod)

            return max(cur, ans(root.left, totalSum), ans(root.right, totalSum))
        
        return ans(root, getSumOfTree(root))%mod",maxProduct.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxProduct.py,module/,module,"# Approach
# Two pass
# - first pass to get the sum of the tree
# - second pass to find the max product 
# Complexity
# - Time complexity: $$O(n)$$
# - Space complexity: $$O(n)$$
# Code
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",Next sibling does not exist,"(21, 0)","(47, 48)",N,class_definition,Solution,,178,a32bdb78-a3ae-4d89-81ef-6253f22b59a0
"def maxProduct(self, root: Optional[TreeNode]) -> int:

        cache = {}
        mod = 10**9 + 7

        def getSumOfTree(root):
            if(root in cache): return cache[root]
            if not root: return 0

            left = getSumOfTree(root.left)
            right = getSumOfTree(root.right)
            
            ans = left + right + root.val

            cache[root] = ans
            return ans
        
        def ans(root, totalSum):
            if(not root): return -1

            sumVal = getSumOfTree(root)
            cur = (totalSum-sumVal) * (sumVal%mod)

            return max(cur, ans(root.left, totalSum), ans(root.right, totalSum))
        
        return ans(root, getSumOfTree(root))%mod",maxProduct.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxProduct.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(22, 4)","(47, 48)",N,function_definition,maxProduct,,174,b00a2726-442e-4787-a0fd-e6e520fad4f8
"def getSumOfTree(root):
            if(root in cache): return cache[root]
            if not root: return 0

            left = getSumOfTree(root.left)
            right = getSumOfTree(root.right)
            
            ans = left + right + root.val

            cache[root] = ans
            return ans",maxProduct.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxProduct.py,module/class_definition-Solution/function_definition-maxProduct/,maxProduct,mod = 10**9 + 7,"def ans(root, totalSum):
            if(not root): return -1

            sumVal = getSumOfTree(root)
            cur = (totalSum-sumVal) * (sumVal%mod)

            return max(cur, ans(root.left, totalSum), ans(root.right, totalSum))","(27, 8)","(37, 22)",N,function_definition,getSumOfTree,,67,e693f10b-98d2-4759-a765-6c7cd37a2382
"def ans(root, totalSum):
            if(not root): return -1

            sumVal = getSumOfTree(root)
            cur = (totalSum-sumVal) * (sumVal%mod)

            return max(cur, ans(root.left, totalSum), ans(root.right, totalSum))",maxProduct.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\maxProduct.py,module/class_definition-Solution/function_definition-maxProduct/,maxProduct,"def getSumOfTree(root):
            if(root in cache): return cache[root]
            if not root: return 0

            left = getSumOfTree(root.left)
            right = getSumOfTree(root.right)
            
            ans = left + right + root.val

            cache[root] = ans
            return ans","return ans(root, getSumOfTree(root))%mod","(39, 8)","(45, 80)",N,function_definition,ans,,61,4aca5146-cf21-476f-aa96-9f0346d53dfb
"class Node:
    def  __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
    
    def __str__(self):
        return f""{{val: {self.val}, left: {self.left}, right: {self.right}}}""
    
class BST:

    def __init__(self):
        self.root = None
    
    def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)
    
    def __str__(self):
        return str(self.root)

class Solution:
    def numOfWays(self, nums: List[int]) -> int:
        bst = BST()
        for num in nums: bst.add(num)

        mod = 10**9 + 7

        @cache
        def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)


        def helper(node):
            if(not node): return 0, 1

            left, lp = helper(node.left)
            right, rp = helper(node.right)
            
            curp = (getPossiblePermutations(left, right)%mod * lp%mod * rp%mod)%mod
            return (left + 1 + right, curp)
        
        _, ans = helper(bst.root)
        return ans-1
",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(58, 0)",N,module,module,,394,3ccda4b9-9f6f-4c48-8170-01119b17c4d3
"class Node:
    def  __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
    
    def __str__(self):
        return f""{{val: {self.val}, left: {self.left}, right: {self.right}}}""",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/,module,Previous sibling does not exist,"class BST:

    def __init__(self):
        self.root = None
    
    def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)
    
    def __str__(self):
        return str(self.root)","(0, 0)","(7, 77)",N,class_definition,Node,,62,0865ec81-4397-41d7-90c3-8538d14361a6
"def  __init__(self, val):
        self.val = val
        self.left = None
        self.right = None",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-Node/,Node,Previous sibling does not exist,"def __str__(self):
        return f""{{val: {self.val}, left: {self.left}, right: {self.right}}}""","(1, 4)","(4, 25)",N,function_definition,__init__,,26,ae9f27d7-ffa3-4e4a-82cf-6973128552d9
"def __str__(self):
        return f""{{val: {self.val}, left: {self.left}, right: {self.right}}}""",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-Node/,Node,"def  __init__(self, val):
        self.val = val
        self.left = None
        self.right = None",Next sibling does not exist,"(6, 4)","(7, 77)",N,function_definition,__str__,,30,4a9acae7-6364-4430-9c4a-9bc35a425f4a
"class BST:

    def __init__(self):
        self.root = None
    
    def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)
    
    def __str__(self):
        return str(self.root)",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/,module,"class Node:
    def  __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
    
    def __str__(self):
        return f""{{val: {self.val}, left: {self.left}, right: {self.right}}}""","class Solution:
    def numOfWays(self, nums: List[int]) -> int:
        bst = BST()
        for num in nums: bst.add(num)

        mod = 10**9 + 7

        @cache
        def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)


        def helper(node):
            if(not node): return 0, 1

            left, lp = helper(node.left)
            right, rp = helper(node.right)
            
            curp = (getPossiblePermutations(left, right)%mod * lp%mod * rp%mod)%mod
            return (left + 1 + right, curp)
        
        _, ans = helper(bst.root)
        return ans-1","(9, 0)","(29, 29)",N,class_definition,BST,,119,0255f4d8-ee85-4fe1-b6df-310d7b587e7a
"def __init__(self):
        self.root = None",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-BST/,BST,Previous sibling does not exist,"def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)","(11, 4)","(12, 24)",N,function_definition,__init__,,11,39ab573d-7ccd-4dfa-8f8a-cbba67a438da
"def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-BST/,BST,"def __init__(self):
        self.root = None","def __str__(self):
        return str(self.root)","(14, 4)","(26, 37)",N,function_definition,add,,88,23e485d5-5b67-4d42-888b-81c9352c9e38
"def __str__(self):
        return str(self.root)",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-BST/,BST,"def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)",Next sibling does not exist,"(28, 4)","(29, 29)",N,function_definition,__str__,,12,77c222a1-8bfc-4747-9849-f00fc6efa057
"class Solution:
    def numOfWays(self, nums: List[int]) -> int:
        bst = BST()
        for num in nums: bst.add(num)

        mod = 10**9 + 7

        @cache
        def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)


        def helper(node):
            if(not node): return 0, 1

            left, lp = helper(node.left)
            right, rp = helper(node.right)
            
            curp = (getPossiblePermutations(left, right)%mod * lp%mod * rp%mod)%mod
            return (left + 1 + right, curp)
        
        _, ans = helper(bst.root)
        return ans-1",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/,module,"class BST:

    def __init__(self):
        self.root = None
    
    def add(self, val):
        if(not self.root): 
            self.root = Node(val)
            return 
        
        parent = None
        temp = self.root
        while(temp):
            if(temp.val < val): parent, temp = temp, temp.right
            else: parent, temp = temp, temp.left
        
        if(parent.val < val): parent.right = Node(val)
        else: parent.left = Node(val)
    
    def __str__(self):
        return str(self.root)",Next sibling does not exist,"(31, 0)","(57, 20)",N,class_definition,Solution,,211,e24971ff-82d9-4763-9cf7-5779b4ea8fb9
"def numOfWays(self, nums: List[int]) -> int:
        bst = BST()
        for num in nums: bst.add(num)

        mod = 10**9 + 7

        @cache
        def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)


        def helper(node):
            if(not node): return 0, 1

            left, lp = helper(node.left)
            right, rp = helper(node.right)
            
            curp = (getPossiblePermutations(left, right)%mod * lp%mod * rp%mod)%mod
            return (left + 1 + right, curp)
        
        _, ans = helper(bst.root)
        return ans-1",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(32, 4)","(57, 20)",N,function_definition,numOfWays,,207,3b1c989a-30b2-4afd-b49b-f3254a708691
"@cache
        def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-Solution/function_definition-numOfWays/,numOfWays,mod = 10**9 + 7,"def helper(node):
            if(not node): return 0, 1

            left, lp = helper(node.left)
            right, rp = helper(node.right)
            
            curp = (getPossiblePermutations(left, right)%mod * lp%mod * rp%mod)%mod
            return (left + 1 + right, curp)","(38, 8)","(44, 96)",N,function_definition,"def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)",,77,5cad039d-04f7-4424-abaf-2830271c1be3
"def helper(node):
            if(not node): return 0, 1

            left, lp = helper(node.left)
            right, rp = helper(node.right)
            
            curp = (getPossiblePermutations(left, right)%mod * lp%mod * rp%mod)%mod
            return (left + 1 + right, curp)",numOfWays.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\numOfWays.py,module/class_definition-Solution/function_definition-numOfWays/,numOfWays,"@cache
        def getPossiblePermutations(num1, num2):
            # num in slots (num1, slots)
            if(num1 == 0): return 1
            if(num2 == 0): return 1

            return getPossiblePermutations(num1-1, num2) + getPossiblePermutations(num1, num2-1)","_, ans = helper(bst.root)","(47, 8)","(54, 43)",N,function_definition,helper,,73,6c82846f-972b-4ddd-abf8-8353ddabfd3c
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode pruneTree(TreeNode root) {
        return helper(root) ? root : null;
    }
    
    public boolean helper(TreeNode root){
        if(root == null ) return false;
        
        boolean leftSubTreeHasOnes = helper(root.left);
        boolean rightSubTreeHasOnes = helper(root.right);
        
        if(!leftSubTreeHasOnes) root.left = null;
        if(!rightSubTreeHasOnes) root.right = null;
        
        return root.val == 1 || leftSubTreeHasOnes || rightSubTreeHasOnes;
    } 
    
    
}
",PruneTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\PruneTree.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(34, 0)",N,program,program,,214,05bd3f08-38a1-47dc-8072-f044be2a7b83
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",PruneTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\PruneTree.java,program/,program,Previous sibling does not exist,"class Solution {
    public TreeNode pruneTree(TreeNode root) {
        return helper(root) ? root : null;
    }
    
    public boolean helper(TreeNode root){
        if(root == null ) return false;
        
        boolean leftSubTreeHasOnes = helper(root.left);
        boolean rightSubTreeHasOnes = helper(root.right);
        
        if(!leftSubTreeHasOnes) root.left = null;
        if(!rightSubTreeHasOnes) root.right = null;
        
        return root.val == 1 || leftSubTreeHasOnes || rightSubTreeHasOnes;
    } 
    
    
}","(0, 0)","(14, 3)",N,block_comment,block_comment,,87,7e85b485-8338-4903-8cde-5dfc1f9789a9
"class Solution {
    public TreeNode pruneTree(TreeNode root) {
        return helper(root) ? root : null;
    }
    
    public boolean helper(TreeNode root){
        if(root == null ) return false;
        
        boolean leftSubTreeHasOnes = helper(root.left);
        boolean rightSubTreeHasOnes = helper(root.right);
        
        if(!leftSubTreeHasOnes) root.left = null;
        if(!rightSubTreeHasOnes) root.right = null;
        
        return root.val == 1 || leftSubTreeHasOnes || rightSubTreeHasOnes;
    } 
    
    
}",PruneTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\PruneTree.java,program/,program,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",Next sibling does not exist,"(15, 0)","(33, 1)",N,class_declaration,Solution,,127,e47a1fea-142b-478c-9561-e91ba00f8d6f
"public TreeNode pruneTree(TreeNode root) {
        return helper(root) ? root : null;
    }",PruneTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\PruneTree.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public boolean helper(TreeNode root){
        if(root == null ) return false;
        
        boolean leftSubTreeHasOnes = helper(root.left);
        boolean rightSubTreeHasOnes = helper(root.right);
        
        if(!leftSubTreeHasOnes) root.left = null;
        if(!rightSubTreeHasOnes) root.right = null;
        
        return root.val == 1 || leftSubTreeHasOnes || rightSubTreeHasOnes;
    }","(16, 4)","(18, 5)",N,method_declaration,pruneTree,,20,23d14b56-82aa-4324-b599-4365d5f3e6da
"public boolean helper(TreeNode root){
        if(root == null ) return false;
        
        boolean leftSubTreeHasOnes = helper(root.left);
        boolean rightSubTreeHasOnes = helper(root.right);
        
        if(!leftSubTreeHasOnes) root.left = null;
        if(!rightSubTreeHasOnes) root.right = null;
        
        return root.val == 1 || leftSubTreeHasOnes || rightSubTreeHasOnes;
    }",PruneTree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\PruneTree.java,program/class_declaration-Solution/,Solution,"public TreeNode pruneTree(TreeNode root) {
        return helper(root) ? root : null;
    }",Next sibling does not exist,"(20, 4)","(30, 5)",N,method_declaration,helper,,98,56415d5a-d813-4acf-8875-f3b4a3ed9573
"class Solution:
    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:

        if(not root): 
            return 0
        
        ans = 0
        val = root.val

        if(low<=val<=high): 
            ans += val
        if(low<=val):
            ans += self.rangeSumBST(root.left, low, high)
        if(val<=high):
            ans += self.rangeSumBST(root.right, low, high)
        
        return ans
",rangeSumBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\rangeSumBST.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(17, 0)",N,module,module,,109,13e768dd-05b9-4117-b903-14479d2c568a
"class Solution:
    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:

        if(not root): 
            return 0
        
        ans = 0
        val = root.val

        if(low<=val<=high): 
            ans += val
        if(low<=val):
            ans += self.rangeSumBST(root.left, low, high)
        if(val<=high):
            ans += self.rangeSumBST(root.right, low, high)
        
        return ans",rangeSumBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\rangeSumBST.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(16, 18)",N,class_definition,Solution,,108,5ac5fdca-1b55-4d07-812e-d2c03686dc78
"def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:

        if(not root): 
            return 0
        
        ans = 0
        val = root.val

        if(low<=val<=high): 
            ans += val
        if(low<=val):
            ans += self.rangeSumBST(root.left, low, high)
        if(val<=high):
            ans += self.rangeSumBST(root.right, low, high)
        
        return ans",rangeSumBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\rangeSumBST.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(16, 18)",N,function_definition,rangeSumBST,,104,a1d1dfec-0d91-40ca-89d3-8878f03682fb
"# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right



class Solution:
    def getMiddleNode(self, head):
        slow = head
        fast = head
        prev = None

        while(slow and fast and fast.next):
            prev = slow
            slow = slow.next
            fast = fast.next.next
        return prev


    def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root
    
    def inorder(self, node):
        if(not node): return
        self.inorder(node.left)
        print(node.val)
        self.inorder(node.right)

node = ListNode(-10)
node.next  = ListNode(-2)
node.next.next  = ListNode(3)
node.next.next.next  = ListNode(5)
node.next.next.next.next  = ListNode(10)
node.next.next.next.next.next  = ListNode(12)

Solution = Solution()
root = Solution.sortedListToBST(node)
Solution.inorder(root)",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(58, 22)",N,module,module,,348,76a819b3-d6d3-488d-a2bb-513ae1527074
# Definition for singly-linked list.,sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/,module,Previous sibling does not exist,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next","(0, 0)","(0, 36)",N,comment,comment,,7,a0a60730-63eb-4989-9436-92afbf51cb91
"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/,module,# Definition for singly-linked list.,# Definition for a binary tree node.,"(1, 0)","(4, 24)",N,class_definition,ListNode,,28,33d51045-005f-4572-a87c-7dbad74c02f5
"def __init__(self, val=0, next=None):
        self.val = val
        self.next = next",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/class_definition-ListNode/,ListNode,Previous sibling does not exist,Next sibling does not exist,"(2, 4)","(4, 24)",N,function_definition,__init__,,24,61dc3ae1-a0f6-4133-bf91-b68b4ec6b96b
# Definition for a binary tree node.,sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/,module,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next","class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right","(5, 0)","(5, 36)",N,comment,comment,,8,7b8c5695-6e20-4dbc-bceb-f9a4992b4470
"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/,module,# Definition for a binary tree node.,"class Solution:
    def getMiddleNode(self, head):
        slow = head
        fast = head
        prev = None

        while(slow and fast and fast.next):
            prev = slow
            slow = slow.next
            fast = fast.next.next
        return prev


    def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root
    
    def inorder(self, node):
        if(not node): return
        self.inorder(node.left)
        print(node.val)
        self.inorder(node.right)","(6, 0)","(10, 26)",N,class_definition,TreeNode,,37,daa31031-e9da-42cc-84a6-751caaecb98c
"def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/class_definition-TreeNode/,TreeNode,Previous sibling does not exist,Next sibling does not exist,"(7, 4)","(10, 26)",N,function_definition,__init__,,33,5b12eb6c-6d30-4683-80de-f5dd127a191a
"class Solution:
    def getMiddleNode(self, head):
        slow = head
        fast = head
        prev = None

        while(slow and fast and fast.next):
            prev = slow
            slow = slow.next
            fast = fast.next.next
        return prev


    def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root
    
    def inorder(self, node):
        if(not node): return
        self.inorder(node.left)
        print(node.val)
        self.inorder(node.right)",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/,module,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right",node = ListNode(-10),"(14, 0)","(47, 32)",N,class_definition,Solution,,192,1edc524d-1d9b-47a2-82dc-00a6ca8c3722
"def getMiddleNode(self, head):
        slow = head
        fast = head
        prev = None

        while(slow and fast and fast.next):
            prev = slow
            slow = slow.next
            fast = fast.next.next
        return prev",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root","(15, 4)","(24, 19)",N,function_definition,getMiddleNode,,54,7adf5484-24bd-47b3-a59c-21f62ed1d7ed
"def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/class_definition-Solution/,Solution,"def getMiddleNode(self, head):
        slow = head
        fast = head
        prev = None

        while(slow and fast and fast.next):
            prev = slow
            slow = slow.next
            fast = fast.next.next
        return prev","def inorder(self, node):
        if(not node): return
        self.inorder(node.left)
        print(node.val)
        self.inorder(node.right)","(27, 4)","(41, 19)",N,function_definition,sortedListToBST,,98,93b0afae-beb8-4ea5-9692-443be730a08a
"def inorder(self, node):
        if(not node): return
        self.inorder(node.left)
        print(node.val)
        self.inorder(node.right)",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/class_definition-Solution/,Solution,"def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root","node = ListNode(-10)
node.next  = ListNode(-2)
node.next.next  = ListNode(3)
node.next.next.next  = ListNode(5)
node.next.next.next.next  = ListNode(10)
node.next.next.next.next.next  = ListNode(12)
Solution = Solution()
root = Solution.sortedListToBST(node)
Solution.inorder(root)","(43, 4)","(47, 32)",N,function_definition,inorder,,32,98764ec8-6f0e-4c9a-8cac-5ba013408449
"node = ListNode(-10)
node.next  = ListNode(-2)
node.next.next  = ListNode(3)
node.next.next.next  = ListNode(5)
node.next.next.next.next  = ListNode(10)
node.next.next.next.next.next  = ListNode(12)
Solution = Solution()
root = Solution.sortedListToBST(node)
Solution.inorder(root)",sortedListToBST.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\sortedListToBST.py,module/,module,"class Solution:
    def getMiddleNode(self, head):
        slow = head
        fast = head
        prev = None

        while(slow and fast and fast.next):
            prev = slow
            slow = slow.next
            fast = fast.next.next
        return prev


    def sortedListToBST(self, head):
        if(not head):return 
        if(not head.next): return TreeNode(head.val)  
        
        prev = self.getMiddleNode(head)
        middlenode = prev.next
        nextnode = middlenode.next
        prev.next = None

        root = TreeNode(middlenode.val)

        root.left =  self.sortedListToBST(head)
        root.right = self.sortedListToBST(nextnode)

        return root
    
    def inorder(self, node):
        if(not node): return
        self.inorder(node.left)
        print(node.val)
        self.inorder(node.right)",Next sibling does not exist,"(49, 0)","(58, 22)",N,"expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement,expression_statement",expression_statement,,74,944462c6-be4a-48a1-8a5c-5c85028a6af8
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public String tree2str(TreeNode root) {
        String ans = helper(root);
        return ans.substring(1, ans.length()-1);
    }
    
    public String helper(TreeNode node){
        if(node==null) return ""()"";
        
        String ans = """";
        ans = ans + node.val;
        
        String left = helper(node.left);
        String right = helper(node.right);
        
        if(left.length()>=2 && right.length()>2) {
            ans = ans + left; 
            ans = ans + right;
        } else if(left.length()>2) ans = ans + left;
        
        return ""("" + ans + "")"";
    };
}
",Tree2Str.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\Tree2Str.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(38, 0)",N,program,program,,225,82778836-e976-4e0b-9bfd-d12a366c95ce
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",Tree2Str.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\Tree2Str.java,program/,program,Previous sibling does not exist,"class Solution {
    public String tree2str(TreeNode root) {
        String ans = helper(root);
        return ans.substring(1, ans.length()-1);
    }
    
    public String helper(TreeNode node){
        if(node==null) return ""()"";
        
        String ans = """";
        ans = ans + node.val;
        
        String left = helper(node.left);
        String right = helper(node.right);
        
        if(left.length()>=2 && right.length()>2) {
            ans = ans + left; 
            ans = ans + right;
        } else if(left.length()>2) ans = ans + left;
        
        return ""("" + ans + "")"";
    };
}","(0, 0)","(14, 3)",N,block_comment,block_comment,,87,2a131cf1-d778-49ad-90da-9e6cfe971876
"class Solution {
    public String tree2str(TreeNode root) {
        String ans = helper(root);
        return ans.substring(1, ans.length()-1);
    }
    
    public String helper(TreeNode node){
        if(node==null) return ""()"";
        
        String ans = """";
        ans = ans + node.val;
        
        String left = helper(node.left);
        String right = helper(node.right);
        
        if(left.length()>=2 && right.length()>2) {
            ans = ans + left; 
            ans = ans + right;
        } else if(left.length()>2) ans = ans + left;
        
        return ""("" + ans + "")"";
    };
}",Tree2Str.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\Tree2Str.java,program/,program,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */",Next sibling does not exist,"(15, 0)","(37, 1)",N,class_declaration,Solution,,138,14e608df-b75b-49cd-b6a3-2d2a9efa6dda
"public String tree2str(TreeNode root) {
        String ans = helper(root);
        return ans.substring(1, ans.length()-1);
    }",Tree2Str.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\Tree2Str.java,program/class_declaration-Solution/,Solution,Previous sibling does not exist,"public String helper(TreeNode node){
        if(node==null) return ""()"";
        
        String ans = """";
        ans = ans + node.val;
        
        String left = helper(node.left);
        String right = helper(node.right);
        
        if(left.length()>=2 && right.length()>2) {
            ans = ans + left; 
            ans = ans + right;
        } else if(left.length()>2) ans = ans + left;
        
        return ""("" + ans + "")"";
    }","(16, 4)","(19, 5)",N,method_declaration,tree2str,,30,d06f8aa3-f971-45db-9d8f-e19ee2f15ed1
"public String helper(TreeNode node){
        if(node==null) return ""()"";
        
        String ans = """";
        ans = ans + node.val;
        
        String left = helper(node.left);
        String right = helper(node.right);
        
        if(left.length()>=2 && right.length()>2) {
            ans = ans + left; 
            ans = ans + right;
        } else if(left.length()>2) ans = ans + left;
        
        return ""("" + ans + "")"";
    }",Tree2Str.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\Tree2Str.java,program/class_declaration-Solution/,Solution,"public String tree2str(TreeNode root) {
        String ans = helper(root);
        return ans.substring(1, ans.length()-1);
    }",},"(21, 4)","(36, 5)",N,method_declaration,helper,,101,436c5f4e-64ac-4e6d-9cf3-ffda150effa3
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:

        def appendNone(queue, count):
            while(queue and queue[-1][0] == None):
                node, sub_count = queue.pop()
                count += sub_count
            queue.append([None, count])

        if(not root): return 0

        ans = 1
        queue = [[root, 1]]
        l = 1

        while(queue):
            cur, count = queue.pop(0)
            l -= 1

            if(not cur): appendNone(queue, count*2)
            else:
                if(cur.left): queue.append([cur.left, 1])
                else: appendNone(queue, 1)
                
                if(cur.right): queue.append([cur.right, 1])
                else: appendNone(queue, 1)
            

            if(l == 0):
                while(queue and not queue[0][0]): queue.pop(0)
                while(queue and not queue[-1][0]): queue.pop()
                
                l = len(queue)
                ans = max(ans, sum([i[-1] for i in queue]))

        
        return ans


",widthOfBinaryTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\widthOfBinaryTree.py,,NA,Previous sibling does not exist,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right","(0, 0)","(45, 0)",N,module,module,,297,005f7a35-6690-4c75-b9db-6416b9936578
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",widthOfBinaryTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\widthOfBinaryTree.py,module/,module,Previous sibling does not exist,"class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:

        def appendNone(queue, count):
            while(queue and queue[-1][0] == None):
                node, sub_count = queue.pop()
                count += sub_count
            queue.append([None, count])

        if(not root): return 0

        ans = 1
        queue = [[root, 1]]
        l = 1

        while(queue):
            cur, count = queue.pop(0)
            l -= 1

            if(not cur): appendNone(queue, count*2)
            else:
                if(cur.left): queue.append([cur.left, 1])
                else: appendNone(queue, 1)
                
                if(cur.right): queue.append([cur.right, 1])
                else: appendNone(queue, 1)
            

            if(l == 0):
                while(queue and not queue[0][0]): queue.pop(0)
                while(queue and not queue[-1][0]): queue.pop()
                
                l = len(queue)
                ans = max(ans, sum([i[-1] for i in queue]))

        
        return ans","(0, 0)","(5, 28)",N,"comment,comment,comment,comment,comment,comment",comment,,48,991aaf68-90aa-4baa-9fd0-1729a38c988a
"class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:

        def appendNone(queue, count):
            while(queue and queue[-1][0] == None):
                node, sub_count = queue.pop()
                count += sub_count
            queue.append([None, count])

        if(not root): return 0

        ans = 1
        queue = [[root, 1]]
        l = 1

        while(queue):
            cur, count = queue.pop(0)
            l -= 1

            if(not cur): appendNone(queue, count*2)
            else:
                if(cur.left): queue.append([cur.left, 1])
                else: appendNone(queue, 1)
                
                if(cur.right): queue.append([cur.right, 1])
                else: appendNone(queue, 1)
            

            if(l == 0):
                while(queue and not queue[0][0]): queue.pop(0)
                while(queue and not queue[-1][0]): queue.pop()
                
                l = len(queue)
                ans = max(ans, sum([i[-1] for i in queue]))

        
        return ans",widthOfBinaryTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\widthOfBinaryTree.py,module/,module,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",Next sibling does not exist,"(6, 0)","(42, 18)",N,class_definition,Solution,,245,a0861310-dcc3-4be7-8830-f5eca6269dc3
"def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:

        def appendNone(queue, count):
            while(queue and queue[-1][0] == None):
                node, sub_count = queue.pop()
                count += sub_count
            queue.append([None, count])

        if(not root): return 0

        ans = 1
        queue = [[root, 1]]
        l = 1

        while(queue):
            cur, count = queue.pop(0)
            l -= 1

            if(not cur): appendNone(queue, count*2)
            else:
                if(cur.left): queue.append([cur.left, 1])
                else: appendNone(queue, 1)
                
                if(cur.right): queue.append([cur.right, 1])
                else: appendNone(queue, 1)
            

            if(l == 0):
                while(queue and not queue[0][0]): queue.pop(0)
                while(queue and not queue[-1][0]): queue.pop()
                
                l = len(queue)
                ans = max(ans, sum([i[-1] for i in queue]))

        
        return ans",widthOfBinaryTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\widthOfBinaryTree.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(7, 4)","(42, 18)",N,function_definition,widthOfBinaryTree,,241,8bc0ae01-6b8f-473e-b2dc-ca8f7d33660e
"def appendNone(queue, count):
            while(queue and queue[-1][0] == None):
                node, sub_count = queue.pop()
                count += sub_count
            queue.append([None, count])",widthOfBinaryTree.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\widthOfBinaryTree.py,module/class_definition-Solution/function_definition-widthOfBinaryTree/,widthOfBinaryTree,Previous sibling does not exist,if(not root): return 0,"(9, 8)","(13, 39)",N,function_definition,appendNone,,43,e7bf8b49-2db9-4cf8-849c-f12216a3b821
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if(not root): return []

        ans = []
        cur_ans = []
        queue = [root]
        l = 1
        reverse_flag = False

        while(queue):
            # print([i.val for i in queue])
            cur = queue.pop(0)
            l -= 1
            cur_ans.append(cur.val)

            if(cur.left): queue.append(cur.left)
            if(cur.right): queue.append(cur.right)

            if(l == 0):
                ans.append(cur_ans if not reverse_flag else cur_ans[::-1])
                cur_ans = []
                l = len(queue)
                reverse_flag = True ^ reverse_flag
        
        return ans
",zigzagLevelOrder.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\zigzagLevelOrder.py,,NA,Previous sibling does not exist,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right","(0, 0)","(32, 0)",N,module,module,,209,4e49fd24-b61b-43e3-ac45-285373a13223
"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",zigzagLevelOrder.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\zigzagLevelOrder.py,module/,module,Previous sibling does not exist,"class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if(not root): return []

        ans = []
        cur_ans = []
        queue = [root]
        l = 1
        reverse_flag = False

        while(queue):
            # print([i.val for i in queue])
            cur = queue.pop(0)
            l -= 1
            cur_ans.append(cur.val)

            if(cur.left): queue.append(cur.left)
            if(cur.right): queue.append(cur.right)

            if(l == 0):
                ans.append(cur_ans if not reverse_flag else cur_ans[::-1])
                cur_ans = []
                l = len(queue)
                reverse_flag = True ^ reverse_flag
        
        return ans","(0, 0)","(5, 28)",N,"comment,comment,comment,comment,comment,comment",comment,,48,4567ea02-87a1-4b4a-937b-b982530a946f
"class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if(not root): return []

        ans = []
        cur_ans = []
        queue = [root]
        l = 1
        reverse_flag = False

        while(queue):
            # print([i.val for i in queue])
            cur = queue.pop(0)
            l -= 1
            cur_ans.append(cur.val)

            if(cur.left): queue.append(cur.left)
            if(cur.right): queue.append(cur.right)

            if(l == 0):
                ans.append(cur_ans if not reverse_flag else cur_ans[::-1])
                cur_ans = []
                l = len(queue)
                reverse_flag = True ^ reverse_flag
        
        return ans",zigzagLevelOrder.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\zigzagLevelOrder.py,module/,module,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right",Next sibling does not exist,"(6, 0)","(31, 18)",N,class_definition,Solution,,157,edf8a3a5-e8ad-45a3-a392-4869d0454bf2
"def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if(not root): return []

        ans = []
        cur_ans = []
        queue = [root]
        l = 1
        reverse_flag = False

        while(queue):
            # print([i.val for i in queue])
            cur = queue.pop(0)
            l -= 1
            cur_ans.append(cur.val)

            if(cur.left): queue.append(cur.left)
            if(cur.right): queue.append(cur.right)

            if(l == 0):
                ans.append(cur_ans if not reverse_flag else cur_ans[::-1])
                cur_ans = []
                l = len(queue)
                reverse_flag = True ^ reverse_flag
        
        return ans",zigzagLevelOrder.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\tree\zigzagLevelOrder.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(7, 4)","(31, 18)",N,function_definition,zigzagLevelOrder,,153,278925d9-42e8-4614-8731-da90f34218eb
"package com.akarsh.codechef.TreeMap;

import java.util.Arrays;
import java.util.TreeMap;

public class MaximumProfitJobScheduling {
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {

        int n = startTime.length;
        int[][] jobs = new int[n][3];
        TreeMap<Integer, Integer> dp = new TreeMap<Integer, Integer>();

        for (int i = 0; i < n; i++) {
            jobs[i] = new int[] { startTime[i], endTime[i], profit[i] };
        }
        Arrays.sort(jobs, (o1, o2) -> Integer.compare(o1[1], o2[1]));
        dp.put(0, 0);

        for (int i = 0; i < n; i++) {
            int start = jobs[i][0];
            int end = jobs[i][1];
            int p = jobs[i][2];

            int maxProfitEarnedBeforeStart = dp.floorEntry(start).getValue();

            if(dp.lastEntry().getValue() < maxProfitEarnedBeforeStart + p){
                dp.put(end, p);
            }
        }

        return dp.lastEntry().getValue();
    }
}
",MaximumProfitJobScheduling.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MaximumProfitJobScheduling.java,,NA,Previous sibling does not exist,"package com.akarsh.codechef.TreeMap;
import java.util.Arrays;
import java.util.TreeMap;","(0, 0)","(33, 0)",N,program,program,,251,e73bc7e7-b301-4b10-8323-943f8fbfc353
"package com.akarsh.codechef.TreeMap;
import java.util.Arrays;
import java.util.TreeMap;",MaximumProfitJobScheduling.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MaximumProfitJobScheduling.java,program/,program,Previous sibling does not exist,"public class MaximumProfitJobScheduling {
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {

        int n = startTime.length;
        int[][] jobs = new int[n][3];
        TreeMap<Integer, Integer> dp = new TreeMap<Integer, Integer>();

        for (int i = 0; i < n; i++) {
            jobs[i] = new int[] { startTime[i], endTime[i], profit[i] };
        }
        Arrays.sort(jobs, (o1, o2) -> Integer.compare(o1[1], o2[1]));
        dp.put(0, 0);

        for (int i = 0; i < n; i++) {
            int start = jobs[i][0];
            int end = jobs[i][1];
            int p = jobs[i][2];

            int maxProfitEarnedBeforeStart = dp.floorEntry(start).getValue();

            if(dp.lastEntry().getValue() < maxProfitEarnedBeforeStart + p){
                dp.put(end, p);
            }
        }

        return dp.lastEntry().getValue();
    }
}","(0, 0)","(3, 25)",N,"package_declaration,import_declaration,import_declaration",package_declaration,,21,6f724161-205b-4085-ab02-98e2fae7e6a2
"public class MaximumProfitJobScheduling {
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {

        int n = startTime.length;
        int[][] jobs = new int[n][3];
        TreeMap<Integer, Integer> dp = new TreeMap<Integer, Integer>();

        for (int i = 0; i < n; i++) {
            jobs[i] = new int[] { startTime[i], endTime[i], profit[i] };
        }
        Arrays.sort(jobs, (o1, o2) -> Integer.compare(o1[1], o2[1]));
        dp.put(0, 0);

        for (int i = 0; i < n; i++) {
            int start = jobs[i][0];
            int end = jobs[i][1];
            int p = jobs[i][2];

            int maxProfitEarnedBeforeStart = dp.floorEntry(start).getValue();

            if(dp.lastEntry().getValue() < maxProfitEarnedBeforeStart + p){
                dp.put(end, p);
            }
        }

        return dp.lastEntry().getValue();
    }
}",MaximumProfitJobScheduling.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MaximumProfitJobScheduling.java,program/,program,"package com.akarsh.codechef.TreeMap;
import java.util.Arrays;
import java.util.TreeMap;",Next sibling does not exist,"(5, 0)","(32, 1)",N,class_declaration,MaximumProfitJobScheduling,,230,3ce49e00-751a-4b63-bc0b-7b98de4e636d
"public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {

        int n = startTime.length;
        int[][] jobs = new int[n][3];
        TreeMap<Integer, Integer> dp = new TreeMap<Integer, Integer>();

        for (int i = 0; i < n; i++) {
            jobs[i] = new int[] { startTime[i], endTime[i], profit[i] };
        }
        Arrays.sort(jobs, (o1, o2) -> Integer.compare(o1[1], o2[1]));
        dp.put(0, 0);

        for (int i = 0; i < n; i++) {
            int start = jobs[i][0];
            int end = jobs[i][1];
            int p = jobs[i][2];

            int maxProfitEarnedBeforeStart = dp.floorEntry(start).getValue();

            if(dp.lastEntry().getValue() < maxProfitEarnedBeforeStart + p){
                dp.put(end, p);
            }
        }

        return dp.lastEntry().getValue();
    }",MaximumProfitJobScheduling.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MaximumProfitJobScheduling.java,program/class_declaration-MaximumProfitJobScheduling/,MaximumProfitJobScheduling,Previous sibling does not exist,Next sibling does not exist,"(6, 4)","(31, 5)",N,method_declaration,jobScheduling,,220,bfc73cac-70d0-4c85-a005-3e562c2c040c
"// line sweep


class MyCalendarThree {

    TreeMap<Integer, Integer> map;
    
    public MyCalendarThree() {
        map = new TreeMap<>();
    }
    
    public int book(int start, int end) {
        map.put(start, map.getOrDefault(start, 0)+1);
        map.put(end, map.getOrDefault(end, 0)-1);
        
        int ans = 0;
        int cur = 0;
        
        for(int x: map.values()){
            cur += x;
            ans = Math.max(ans, cur);
        }
        
        return ans;
    }
}

/**
 * Your MyCalendarThree object will be instantiated and called as such:
 * MyCalendarThree obj = new MyCalendarThree();
 * int param_1 = obj.book(start,end);
 */
",MyCalendarThree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MyCalendarThree.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(32, 0)",N,program,program,,161,5ac91f05-8c86-4dc2-9859-f0dbaf064a42
// line sweep,MyCalendarThree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MyCalendarThree.java,program/,program,Previous sibling does not exist,"class MyCalendarThree {

    TreeMap<Integer, Integer> map;
    
    public MyCalendarThree() {
        map = new TreeMap<>();
    }
    
    public int book(int start, int end) {
        map.put(start, map.getOrDefault(start, 0)+1);
        map.put(end, map.getOrDefault(end, 0)-1);
        
        int ans = 0;
        int cur = 0;
        
        for(int x: map.values()){
            cur += x;
            ans = Math.max(ans, cur);
        }
        
        return ans;
    }
}","(0, 0)","(0, 13)",N,line_comment,line_comment,,3,f476bb81-a7b7-4d58-a217-808786139af9
"class MyCalendarThree {

    TreeMap<Integer, Integer> map;
    
    public MyCalendarThree() {
        map = new TreeMap<>();
    }
    
    public int book(int start, int end) {
        map.put(start, map.getOrDefault(start, 0)+1);
        map.put(end, map.getOrDefault(end, 0)-1);
        
        int ans = 0;
        int cur = 0;
        
        for(int x: map.values()){
            cur += x;
            ans = Math.max(ans, cur);
        }
        
        return ans;
    }
}",MyCalendarThree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MyCalendarThree.java,program/,program,// line sweep,"/**
 * Your MyCalendarThree object will be instantiated and called as such:
 * MyCalendarThree obj = new MyCalendarThree();
 * int param_1 = obj.book(start,end);
 */","(3, 0)","(25, 1)",N,class_declaration,MyCalendarThree,,119,b5c109cb-3f14-4bda-81f3-9e57cf5975f8
"public MyCalendarThree() {
        map = new TreeMap<>();
    }",MyCalendarThree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MyCalendarThree.java,program/class_declaration-MyCalendarThree/,MyCalendarThree,"TreeMap<Integer, Integer> map;","public int book(int start, int end) {
        map.put(start, map.getOrDefault(start, 0)+1);
        map.put(end, map.getOrDefault(end, 0)-1);
        
        int ans = 0;
        int cur = 0;
        
        for(int x: map.values()){
            cur += x;
            ans = Math.max(ans, cur);
        }
        
        return ans;
    }","(7, 4)","(9, 5)",N,constructor_declaration,MyCalendarThree,,14,6c1f13a5-c65a-4637-854e-084666494ba1
"public int book(int start, int end) {
        map.put(start, map.getOrDefault(start, 0)+1);
        map.put(end, map.getOrDefault(end, 0)-1);
        
        int ans = 0;
        int cur = 0;
        
        for(int x: map.values()){
            cur += x;
            ans = Math.max(ans, cur);
        }
        
        return ans;
    }",MyCalendarThree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MyCalendarThree.java,program/class_declaration-MyCalendarThree/,MyCalendarThree,"public MyCalendarThree() {
        map = new TreeMap<>();
    }",Next sibling does not exist,"(11, 4)","(24, 5)",N,method_declaration,book,,87,98bfe031-f4e6-40b3-aba3-271a2695b576
"/**
 * Your MyCalendarThree object will be instantiated and called as such:
 * MyCalendarThree obj = new MyCalendarThree();
 * int param_1 = obj.book(start,end);
 */",MyCalendarThree.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\TreeMap\MyCalendarThree.java,program/,program,"class MyCalendarThree {

    TreeMap<Integer, Integer> map;
    
    public MyCalendarThree() {
        map = new TreeMap<>();
    }
    
    public int book(int start, int end) {
        map.put(start, map.getOrDefault(start, 0)+1);
        map.put(end, map.getOrDefault(end, 0)-1);
        
        int ans = 0;
        int cur = 0;
        
        for(int x: map.values()){
            cur += x;
            ans = Math.max(ans, cur);
        }
        
        return ans;
    }
}",Next sibling does not exist,"(27, 0)","(31, 3)",N,block_comment,block_comment,,38,0e0f463c-db87-4c25-bcf1-3e44f0527cc6
"class TrieNode:
    def __init__(self) -> None:
        self.children = [None for i in range(26)]
        self.isWord = False

class Trie:

    def __init__(self) -> None:
        self. root = TrieNode()
    
    def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True


    def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord
 

    def startsWith(self, prefix):
        arr = [] 

        def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])

        temp =  self.root
        for ch in prefix:
            if(not temp.children[ord(ch) - 97]): return
            temp = temp.children[ord(ch) - 97]
        
        dfs(prefix, temp)
        return arr


class Solution:

    def isConcatWord(self, word, trie, count):
        if((not word or word == '') and count>=2): return True
        
        root = trie.root
        for index in range(len(word)):
            ch = word[index]
            root = root.children[ord(ch) - 97]
            if(not root): return False
            if(root.isWord and self.isConcatWord(word[index+1:], trie, count+1)): return True
        
        return False


    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        trie = Trie()
        for word in words: trie.insert(word)

        ans  = []
        for word in words:
            if(self.isConcatWord(word, trie, 0)):
                ans.append(word)
        
        return ans



        
",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(78, 0)",N,module,module,,461,fc551177-35d9-4209-b376-6a52edf74554
"class TrieNode:
    def __init__(self) -> None:
        self.children = [None for i in range(26)]
        self.isWord = False",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/,module,Previous sibling does not exist,"class Trie:

    def __init__(self) -> None:
        self. root = TrieNode()
    
    def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True


    def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord
 

    def startsWith(self, prefix):
        arr = [] 

        def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])

        temp =  self.root
        for ch in prefix:
            if(not temp.children[ord(ch) - 97]): return
            temp = temp.children[ord(ch) - 97]
        
        dfs(prefix, temp)
        return arr","(0, 0)","(3, 27)",N,class_definition,TrieNode,,33,1e516433-58cd-45c5-8696-78e821e409f4
"def __init__(self) -> None:
        self.children = [None for i in range(26)]
        self.isWord = False",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-TrieNode/,TrieNode,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(3, 27)",N,function_definition,__init__,,28,81164c96-04ea-4b08-a95d-8571364db3bd
"class Trie:

    def __init__(self) -> None:
        self. root = TrieNode()
    
    def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True


    def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord
 

    def startsWith(self, prefix):
        arr = [] 

        def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])

        temp =  self.root
        for ch in prefix:
            if(not temp.children[ord(ch) - 97]): return
            temp = temp.children[ord(ch) - 97]
        
        dfs(prefix, temp)
        return arr",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/,module,"class TrieNode:
    def __init__(self) -> None:
        self.children = [None for i in range(26)]
        self.isWord = False","class Solution:

    def isConcatWord(self, word, trie, count):
        if((not word or word == '') and count>=2): return True
        
        root = trie.root
        for index in range(len(word)):
            ch = word[index]
            root = root.children[ord(ch) - 97]
            if(not root): return False
            if(root.isWord and self.isConcatWord(word[index+1:], trie, count+1)): return True
        
        return False


    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        trie = Trie()
        for word in words: trie.insert(word)

        ans  = []
        for word in words:
            if(self.isConcatWord(word, trie, 0)):
                ans.append(word)
        
        return ans","(5, 0)","(46, 18)",N,class_definition,Trie,,253,56f78a38-c130-4f23-8a27-15815285fb52
"def __init__(self) -> None:
        self. root = TrieNode()",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Trie/,Trie,Previous sibling does not exist,"def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True","(7, 4)","(8, 31)",N,function_definition,__init__,,17,e34ad6a1-649c-4f8d-80a8-47e44646081f
"def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Trie/,Trie,"def __init__(self) -> None:
        self. root = TrieNode()","def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord","(10, 4)","(17, 26)",N,function_definition,insert,,64,278cd7f1-3a7c-4e43-952a-482007beffdf
"def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Trie/,Trie,"def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True","def startsWith(self, prefix):
        arr = [] 

        def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])

        temp =  self.root
        for ch in prefix:
            if(not temp.children[ord(ch) - 97]): return
            temp = temp.children[ord(ch) - 97]
        
        dfs(prefix, temp)
        return arr","(20, 4)","(27, 26)",N,function_definition,containsWord,,53,c83ec72c-869d-404c-82b4-6b535a589e30
"def startsWith(self, prefix):
        arr = [] 

        def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])

        temp =  self.root
        for ch in prefix:
            if(not temp.children[ord(ch) - 97]): return
            temp = temp.children[ord(ch) - 97]
        
        dfs(prefix, temp)
        return arr",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Trie/,Trie,"def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord",Next sibling does not exist,"(30, 4)","(46, 18)",N,function_definition,startsWith,,108,471726cf-0e61-47c9-a5d3-10052e922213
"def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Trie/function_definition-startsWith/,startsWith,arr = [],temp =  self.root,"(33, 8)","(38, 54)",N,function_definition,dfs,,44,7b38c43b-6c83-44eb-a885-94f949c84589
"class Solution:

    def isConcatWord(self, word, trie, count):
        if((not word or word == '') and count>=2): return True
        
        root = trie.root
        for index in range(len(word)):
            ch = word[index]
            root = root.children[ord(ch) - 97]
            if(not root): return False
            if(root.isWord and self.isConcatWord(word[index+1:], trie, count+1)): return True
        
        return False


    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        trie = Trie()
        for word in words: trie.insert(word)

        ans  = []
        for word in words:
            if(self.isConcatWord(word, trie, 0)):
                ans.append(word)
        
        return ans",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/,module,"class Trie:

    def __init__(self) -> None:
        self. root = TrieNode()
    
    def insert(self, x):
        node = self.root
        
        for ch in x:
            if(not node.children[ord(ch) - 97]): node.children[ord(ch) - 97] = TrieNode()
            node = node.children[ord(ch) - 97]

        node.isWord = True


    def containsWord(self, word):
        node = self.root
        
        for ch in word:
            if(not node.children[ord(ch) - 97]): return False
            node = node.children[ord(ch) - 97]

        return node.isWord
 

    def startsWith(self, prefix):
        arr = [] 

        def dfs(cur, node):
            if(not node): return
            
            if(node.isWord): arr.append(cur)
            for i in range(26):
                dfs(cur + chr(97+i), node.children[i])

        temp =  self.root
        for ch in prefix:
            if(not temp.children[ord(ch) - 97]): return
            temp = temp.children[ord(ch) - 97]
        
        dfs(prefix, temp)
        return arr",Next sibling does not exist,"(49, 0)","(73, 18)",N,class_definition,Solution,,171,e57fe89f-c9d5-402d-b23e-043a01e55ea9
"def isConcatWord(self, word, trie, count):
        if((not word or word == '') and count>=2): return True
        
        root = trie.root
        for index in range(len(word)):
            ch = word[index]
            root = root.children[ord(ch) - 97]
            if(not root): return False
            if(root.isWord and self.isConcatWord(word[index+1:], trie, count+1)): return True
        
        return False",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,"def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        trie = Trie()
        for word in words: trie.insert(word)

        ans  = []
        for word in words:
            if(self.isConcatWord(word, trie, 0)):
                ans.append(word)
        
        return ans","(51, 4)","(61, 20)",N,function_definition,isConcatWord,,97,fc3143db-e77a-4c75-8f3c-e1793afffe9c
"def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        trie = Trie()
        for word in words: trie.insert(word)

        ans  = []
        for word in words:
            if(self.isConcatWord(word, trie, 0)):
                ans.append(word)
        
        return ans",findAllConcatenatedWordsInADict.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findAllConcatenatedWordsInADict.py,module/class_definition-Solution/,Solution,"def isConcatWord(self, word, trie, count):
        if((not word or word == '') and count>=2): return True
        
        root = trie.root
        for index in range(len(word)):
            ch = word[index]
            root = root.children[ord(ch) - 97]
            if(not root): return False
            if(root.isWord and self.isConcatWord(word[index+1:], trie, count+1)): return True
        
        return False",Next sibling does not exist,"(64, 4)","(73, 18)",N,function_definition,findAllConcatenatedWordsInADict,,68,0edb110e-77e0-4e3a-adf6-9fe93fd56174
"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.word = None


class Trie:
    def __init__(self):
        self.root = TrieNode()
    

    def add(self, word):
        node = self.root
        index = 0

        while(index<len(word)):
            idx = word[index]
            if(idx not in node.childern): node.childern[idx] = TrieNode()
            node = node.childern[idx]
            index += 1
        
        node.word = word


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        N = len(board)
        M = len(board[0])

        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]
        def dfs(rowIndex, colIndex, node):
            if(not node): return
            if(rowIndex<0 or rowIndex>=N or colIndex<0 or colIndex>=M or board[rowIndex][colIndex] == '.'): return

            ch = board[rowIndex][colIndex]
            if(ch not in node.childern): return

            parent = node
            node = node.childern[ch]
            if('$' in node.childern):
                ans.add(node.childern['$'].word[:-1])
                del node.childern['$']

            board[rowIndex][colIndex] = '.'            
            for dx, dy in dir:
                newx, newy = rowIndex + dx, colIndex + dy
                dfs(newx, newy, node)
                if(len(node.childern) == 0):
                    del parent.childern[ch]
                    break
            board[rowIndex][colIndex] = ch

            

        trie = Trie()
        for word in words: trie.add(word+'$')
        ans = set()

        for rowIndex in range(N):
            for colIndex in range(M):
                dfs(rowIndex, colIndex, trie.root)
        
        return list(ans)
",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(63, 0)",N,module,module,,420,878be7f3-de0f-4f40-a86a-6a5803b63ce5
"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.word = None",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/,module,Previous sibling does not exist,"class Trie:
    def __init__(self):
        self.root = TrieNode()
    

    def add(self, word):
        node = self.root
        index = 0

        while(index<len(word)):
            idx = word[index]
            if(idx not in node.childern): node.childern[idx] = TrieNode()
            node = node.childern[idx]
            index += 1
        
        node.word = word","(0, 0)","(3, 24)",N,class_definition,TrieNode,,22,e1236e3b-b89e-40fc-8d16-663b0e372ea0
"def __init__(self):
        self.childern = {}
        self.word = None",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/class_definition-TrieNode/,TrieNode,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(3, 24)",N,function_definition,__init__,,17,a6243358-1fb9-46ba-aef6-b5781d034da0
"class Trie:
    def __init__(self):
        self.root = TrieNode()
    

    def add(self, word):
        node = self.root
        index = 0

        while(index<len(word)):
            idx = word[index]
            if(idx not in node.childern): node.childern[idx] = TrieNode()
            node = node.childern[idx]
            index += 1
        
        node.word = word",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/,module,"class TrieNode:
    def __init__(self):
        self.childern = {}
        self.word = None","class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        N = len(board)
        M = len(board[0])

        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]
        def dfs(rowIndex, colIndex, node):
            if(not node): return
            if(rowIndex<0 or rowIndex>=N or colIndex<0 or colIndex>=M or board[rowIndex][colIndex] == '.'): return

            ch = board[rowIndex][colIndex]
            if(ch not in node.childern): return

            parent = node
            node = node.childern[ch]
            if('$' in node.childern):
                ans.add(node.childern['$'].word[:-1])
                del node.childern['$']

            board[rowIndex][colIndex] = '.'            
            for dx, dy in dir:
                newx, newy = rowIndex + dx, colIndex + dy
                dfs(newx, newy, node)
                if(len(node.childern) == 0):
                    del parent.childern[ch]
                    break
            board[rowIndex][colIndex] = ch

            

        trie = Trie()
        for word in words: trie.add(word+'$')
        ans = set()

        for rowIndex in range(N):
            for colIndex in range(M):
                dfs(rowIndex, colIndex, trie.root)
        
        return list(ans)","(6, 0)","(21, 24)",N,class_definition,Trie,,86,962809ec-4895-40cd-bde9-9944a2d68fef
"def __init__(self):
        self.root = TrieNode()",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/class_definition-Trie/,Trie,Previous sibling does not exist,"def add(self, word):
        node = self.root
        index = 0

        while(index<len(word)):
            idx = word[index]
            if(idx not in node.childern): node.childern[idx] = TrieNode()
            node = node.childern[idx]
            index += 1
        
        node.word = word","(7, 4)","(8, 30)",N,function_definition,__init__,,13,d43f75e4-18aa-49e3-a8fc-f22594895249
"def add(self, word):
        node = self.root
        index = 0

        while(index<len(word)):
            idx = word[index]
            if(idx not in node.childern): node.childern[idx] = TrieNode()
            node = node.childern[idx]
            index += 1
        
        node.word = word",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/class_definition-Trie/,Trie,"def __init__(self):
        self.root = TrieNode()",Next sibling does not exist,"(11, 4)","(21, 24)",N,function_definition,add,,67,750ab71c-848b-4134-92d0-a0a93a545808
"class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        N = len(board)
        M = len(board[0])

        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]
        def dfs(rowIndex, colIndex, node):
            if(not node): return
            if(rowIndex<0 or rowIndex>=N or colIndex<0 or colIndex>=M or board[rowIndex][colIndex] == '.'): return

            ch = board[rowIndex][colIndex]
            if(ch not in node.childern): return

            parent = node
            node = node.childern[ch]
            if('$' in node.childern):
                ans.add(node.childern['$'].word[:-1])
                del node.childern['$']

            board[rowIndex][colIndex] = '.'            
            for dx, dy in dir:
                newx, newy = rowIndex + dx, colIndex + dy
                dfs(newx, newy, node)
                if(len(node.childern) == 0):
                    del parent.childern[ch]
                    break
            board[rowIndex][colIndex] = ch

            

        trie = Trie()
        for word in words: trie.add(word+'$')
        ans = set()

        for rowIndex in range(N):
            for colIndex in range(M):
                dfs(rowIndex, colIndex, trie.root)
        
        return list(ans)",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/,module,"class Trie:
    def __init__(self):
        self.root = TrieNode()
    

    def add(self, word):
        node = self.root
        index = 0

        while(index<len(word)):
            idx = word[index]
            if(idx not in node.childern): node.childern[idx] = TrieNode()
            node = node.childern[idx]
            index += 1
        
        node.word = word",Next sibling does not exist,"(24, 0)","(62, 24)",N,class_definition,Solution,,310,849dffd2-a8e7-4cb7-8497-35c289fd7029
"def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        N = len(board)
        M = len(board[0])

        dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]
        def dfs(rowIndex, colIndex, node):
            if(not node): return
            if(rowIndex<0 or rowIndex>=N or colIndex<0 or colIndex>=M or board[rowIndex][colIndex] == '.'): return

            ch = board[rowIndex][colIndex]
            if(ch not in node.childern): return

            parent = node
            node = node.childern[ch]
            if('$' in node.childern):
                ans.add(node.childern['$'].word[:-1])
                del node.childern['$']

            board[rowIndex][colIndex] = '.'            
            for dx, dy in dir:
                newx, newy = rowIndex + dx, colIndex + dy
                dfs(newx, newy, node)
                if(len(node.childern) == 0):
                    del parent.childern[ch]
                    break
            board[rowIndex][colIndex] = ch

            

        trie = Trie()
        for word in words: trie.add(word+'$')
        ans = set()

        for rowIndex in range(N):
            for colIndex in range(M):
                dfs(rowIndex, colIndex, trie.root)
        
        return list(ans)",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(25, 4)","(62, 24)",N,function_definition,findWords,,306,9dc40974-0e01-4a42-88e5-8af642764aae
"def dfs(rowIndex, colIndex, node):
            if(not node): return
            if(rowIndex<0 or rowIndex>=N or colIndex<0 or colIndex>=M or board[rowIndex][colIndex] == '.'): return

            ch = board[rowIndex][colIndex]
            if(ch not in node.childern): return

            parent = node
            node = node.childern[ch]
            if('$' in node.childern):
                ans.add(node.childern['$'].word[:-1])
                del node.childern['$']

            board[rowIndex][colIndex] = '.'            
            for dx, dy in dir:
                newx, newy = rowIndex + dx, colIndex + dy
                dfs(newx, newy, node)
                if(len(node.childern) == 0):
                    del parent.childern[ch]
                    break
            board[rowIndex][colIndex] = ch",findWords.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\trie\findWords.py,module/class_definition-Solution/function_definition-findWords/,findWords,"dir = [[-1, 0], [0, 1], [1, 0], [0, -1]]",trie = Trie(),"(30, 8)","(50, 42)",N,function_definition,dfs,,188,05469688-a10a-4b60-a274-bc8b1a20a090
"class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for s, d in edges:
            graph[s].append(d)
            graph[d].append(s)
        
        uf = UnionFind(n)
        for source, dest in edges: uf.merge(source, dest)
        
        def sumOfN(n): return (n*(n-1))//2
        count = 0
        for index in range(n):
            if(uf.idx[index] == index):
                ec = 0
                for ne in range(n):
                    if(uf.connected(index, ne)):
                        ec += len(graph[ne])
                
                x = uf.componentSize(index)
                if(ec//2 == sumOfN(x)): count+=1
        
        return count
        
",countCompleteComponents.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\countCompleteComponents.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(24, 0)",N,module,module,,173,505a6112-fcae-4422-aa6d-8e864aab472e
"class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for s, d in edges:
            graph[s].append(d)
            graph[d].append(s)
        
        uf = UnionFind(n)
        for source, dest in edges: uf.merge(source, dest)
        
        def sumOfN(n): return (n*(n-1))//2
        count = 0
        for index in range(n):
            if(uf.idx[index] == index):
                ec = 0
                for ne in range(n):
                    if(uf.connected(index, ne)):
                        ec += len(graph[ne])
                
                x = uf.componentSize(index)
                if(ec//2 == sumOfN(x)): count+=1
        
        return count",countCompleteComponents.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\countCompleteComponents.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(22, 20)",N,class_definition,Solution,,172,231dbdf4-ac68-4c9c-9625-a7a88b363a1f
"def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for s, d in edges:
            graph[s].append(d)
            graph[d].append(s)
        
        uf = UnionFind(n)
        for source, dest in edges: uf.merge(source, dest)
        
        def sumOfN(n): return (n*(n-1))//2
        count = 0
        for index in range(n):
            if(uf.idx[index] == index):
                ec = 0
                for ne in range(n):
                    if(uf.connected(index, ne)):
                        ec += len(graph[ne])
                
                x = uf.componentSize(index)
                if(ec//2 == sumOfN(x)): count+=1
        
        return count",countCompleteComponents.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\countCompleteComponents.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(22, 20)",N,function_definition,countCompleteComponents,,168,b7c7a71a-bb72-4c19-823b-aa802a806c47
def sumOfN(n): return (n*(n-1))//2,countCompleteComponents.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\countCompleteComponents.py,module/class_definition-Solution/function_definition-countCompleteComponents/,countCompleteComponents,"for source, dest in edges: uf.merge(source, dest)",count = 0,"(10, 8)","(10, 42)",N,function_definition,sumOfN,,16,11e63a7e-21a2-4385-b7f7-0705f477075f
"from SimilarStringGroups import UnionFind

class Solution:
    def distanceLimitedPathsExist(self, n: int, edgeList, queries):

        for index, query in enumerate(queries): query.append(index)
        queries.sort(key = lambda x: x[2])
        uf = UnionFind(n)
        index = 0
        queriesLength = len(queries)
        ans = [None for i in range(queriesLength)]

        edgeList.sort(key = lambda x: x[-1])
        edgesLength = len(edgeList)
        edgesIndex = 0

        while(index < queriesLength):
            source, dest, limit, qindex = queries[index]
            while(edgesIndex<edgesLength and edgeList[edgesIndex][-1]<limit):
                uf.merge(edgeList[edgesIndex][0], edgeList[edgesIndex][1])
                edgesIndex += 1
            ans[qindex] = uf.areConnected(source, dest)
            index += 1
        
        return ans",distanceLimitedPathsExist.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\distanceLimitedPathsExist.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(24, 18)",N,module,module,,202,da81d31f-a368-418c-b4c6-18ce0d4190a6
from SimilarStringGroups import UnionFind,distanceLimitedPathsExist.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\distanceLimitedPathsExist.py,module/,module,Previous sibling does not exist,"class Solution:
    def distanceLimitedPathsExist(self, n: int, edgeList, queries):

        for index, query in enumerate(queries): query.append(index)
        queries.sort(key = lambda x: x[2])
        uf = UnionFind(n)
        index = 0
        queriesLength = len(queries)
        ans = [None for i in range(queriesLength)]

        edgeList.sort(key = lambda x: x[-1])
        edgesLength = len(edgeList)
        edgesIndex = 0

        while(index < queriesLength):
            source, dest, limit, qindex = queries[index]
            while(edgesIndex<edgesLength and edgeList[edgesIndex][-1]<limit):
                uf.merge(edgeList[edgesIndex][0], edgeList[edgesIndex][1])
                edgesIndex += 1
            ans[qindex] = uf.areConnected(source, dest)
            index += 1
        
        return ans","(0, 0)","(0, 41)",N,import_from_statement,import_from_statement,,7,d34ff038-3466-4be2-81f1-ad29b6d5ce47
"class Solution:
    def distanceLimitedPathsExist(self, n: int, edgeList, queries):

        for index, query in enumerate(queries): query.append(index)
        queries.sort(key = lambda x: x[2])
        uf = UnionFind(n)
        index = 0
        queriesLength = len(queries)
        ans = [None for i in range(queriesLength)]

        edgeList.sort(key = lambda x: x[-1])
        edgesLength = len(edgeList)
        edgesIndex = 0

        while(index < queriesLength):
            source, dest, limit, qindex = queries[index]
            while(edgesIndex<edgesLength and edgeList[edgesIndex][-1]<limit):
                uf.merge(edgeList[edgesIndex][0], edgeList[edgesIndex][1])
                edgesIndex += 1
            ans[qindex] = uf.areConnected(source, dest)
            index += 1
        
        return ans",distanceLimitedPathsExist.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\distanceLimitedPathsExist.py,module/,module,from SimilarStringGroups import UnionFind,Next sibling does not exist,"(2, 0)","(24, 18)",N,class_definition,Solution,,194,6fa2898d-9317-44ae-90a2-3c84eef06e85
"def distanceLimitedPathsExist(self, n: int, edgeList, queries):

        for index, query in enumerate(queries): query.append(index)
        queries.sort(key = lambda x: x[2])
        uf = UnionFind(n)
        index = 0
        queriesLength = len(queries)
        ans = [None for i in range(queriesLength)]

        edgeList.sort(key = lambda x: x[-1])
        edgesLength = len(edgeList)
        edgesIndex = 0

        while(index < queriesLength):
            source, dest, limit, qindex = queries[index]
            while(edgesIndex<edgesLength and edgeList[edgesIndex][-1]<limit):
                uf.merge(edgeList[edgesIndex][0], edgeList[edgesIndex][1])
                edgesIndex += 1
            ans[qindex] = uf.areConnected(source, dest)
            index += 1
        
        return ans",distanceLimitedPathsExist.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\distanceLimitedPathsExist.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(3, 4)","(24, 18)",N,function_definition,distanceLimitedPathsExist,,190,9d0575fc-23a3-4d08-b285-eabe2ec43f6c
"class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        uf = UnionFind(26)
        passedIndexs = []
        
        for index,equation in enumerate(equations):
            
            if(equation[1] == '!'):
                passedIndexs.append(index)
                continue
                
            char1 = ord(equation[0]) -97
            char2 = ord(equation[-1]) -97
            uf.merge(char1, char2)
        
        for index in passedIndexs:
            char1 = ord(equations[index][0]) -97
            char2 = ord(equations[index][-1]) -97
            
            if(uf.connected(char1, char2)): 
                return False
        
        return True
            

        
        
        
        
class UnionFind:
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.idx = [i for i in range(self.capacity)]
        self.sz = [1 for i in range(self.capacity)]
        self.numComponents = self.capacity
        
    def find(self, index):
        rootIndex = index
        while(self.idx[rootIndex]!=rootIndex):
            rootIndex = self.idx[rootIndex]
            
        while(index!=rootIndex):
            curParent = self.idx[index]
            self.idx[index] = rootIndex
            index = curParent
        return rootIndex
    
    def connected(self, index1, index2):
        return self.find(index1) == self.find(index2)
    
    def componentSize(self, index):
        return self.sz[self.find(index)]

    def getNumberOfComponents(self):
        return self.numComponents
    
    def merge(self, index1, index2):
        
        root1 = self.find(index1)
        root2 = self.find(index2)        
        
        if(root1 == root2): return
        
        if(self.componentSize(root1) <= self.componentSize(root2)):
            self.idx[root1] = root2
            self.sz[root2] += self.sz[root1]
        else:
            self.idx[root2] = root1
            self.sz[root1] += self.sz[root2]
            
        self.numComponents -= 1

            
",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(74, 0)",N,module,module,,454,a3b0b9de-bcf2-4914-8a1c-1b12b069af87
"class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        uf = UnionFind(26)
        passedIndexs = []
        
        for index,equation in enumerate(equations):
            
            if(equation[1] == '!'):
                passedIndexs.append(index)
                continue
                
            char1 = ord(equation[0]) -97
            char2 = ord(equation[-1]) -97
            uf.merge(char1, char2)
        
        for index in passedIndexs:
            char1 = ord(equations[index][0]) -97
            char2 = ord(equations[index][-1]) -97
            
            if(uf.connected(char1, char2)): 
                return False
        
        return True",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/,module,Previous sibling does not exist,"class UnionFind:
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.idx = [i for i in range(self.capacity)]
        self.sz = [1 for i in range(self.capacity)]
        self.numComponents = self.capacity
        
    def find(self, index):
        rootIndex = index
        while(self.idx[rootIndex]!=rootIndex):
            rootIndex = self.idx[rootIndex]
            
        while(index!=rootIndex):
            curParent = self.idx[index]
            self.idx[index] = rootIndex
            index = curParent
        return rootIndex
    
    def connected(self, index1, index2):
        return self.find(index1) == self.find(index2)
    
    def componentSize(self, index):
        return self.sz[self.find(index)]

    def getNumberOfComponents(self):
        return self.numComponents
    
    def merge(self, index1, index2):
        
        root1 = self.find(index1)
        root2 = self.find(index2)        
        
        if(root1 == root2): return
        
        if(self.componentSize(root1) <= self.componentSize(root2)):
            self.idx[root1] = root2
            self.sz[root2] += self.sz[root1]
        else:
            self.idx[root2] = root1
            self.sz[root1] += self.sz[root2]
            
        self.numComponents -= 1","(0, 0)","(22, 19)",N,class_definition,Solution,,161,8ac3e4b2-f247-4761-a012-28a2f0d28ced
"def equationsPossible(self, equations: List[str]) -> bool:
        uf = UnionFind(26)
        passedIndexs = []
        
        for index,equation in enumerate(equations):
            
            if(equation[1] == '!'):
                passedIndexs.append(index)
                continue
                
            char1 = ord(equation[0]) -97
            char2 = ord(equation[-1]) -97
            uf.merge(char1, char2)
        
        for index in passedIndexs:
            char1 = ord(equations[index][0]) -97
            char2 = ord(equations[index][-1]) -97
            
            if(uf.connected(char1, char2)): 
                return False
        
        return True",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(22, 19)",N,function_definition,equationsPossible,,157,381a80c8-a5ef-40c4-a898-89786b7688d5
"class UnionFind:
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.idx = [i for i in range(self.capacity)]
        self.sz = [1 for i in range(self.capacity)]
        self.numComponents = self.capacity
        
    def find(self, index):
        rootIndex = index
        while(self.idx[rootIndex]!=rootIndex):
            rootIndex = self.idx[rootIndex]
            
        while(index!=rootIndex):
            curParent = self.idx[index]
            self.idx[index] = rootIndex
            index = curParent
        return rootIndex
    
    def connected(self, index1, index2):
        return self.find(index1) == self.find(index2)
    
    def componentSize(self, index):
        return self.sz[self.find(index)]

    def getNumberOfComponents(self):
        return self.numComponents
    
    def merge(self, index1, index2):
        
        root1 = self.find(index1)
        root2 = self.find(index2)        
        
        if(root1 == root2): return
        
        if(self.componentSize(root1) <= self.componentSize(root2)):
            self.idx[root1] = root2
            self.sz[root2] += self.sz[root1]
        else:
            self.idx[root2] = root1
            self.sz[root1] += self.sz[root2]
            
        self.numComponents -= 1",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/,module,"class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        uf = UnionFind(26)
        passedIndexs = []
        
        for index,equation in enumerate(equations):
            
            if(equation[1] == '!'):
                passedIndexs.append(index)
                continue
                
            char1 = ord(equation[0]) -97
            char2 = ord(equation[-1]) -97
            uf.merge(char1, char2)
        
        for index in passedIndexs:
            char1 = ord(equations[index][0]) -97
            char2 = ord(equations[index][-1]) -97
            
            if(uf.connected(char1, char2)): 
                return False
        
        return True",Next sibling does not exist,"(29, 0)","(71, 31)",N,class_definition,UnionFind,,287,6a5b2734-c1e6-4b4a-96dd-f98fb1239525
"def __init__(self, capacity):
        self.capacity = capacity
        self.idx = [i for i in range(self.capacity)]
        self.sz = [1 for i in range(self.capacity)]
        self.numComponents = self.capacity",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-UnionFind/,UnionFind,Previous sibling does not exist,"def find(self, index):
        rootIndex = index
        while(self.idx[rootIndex]!=rootIndex):
            rootIndex = self.idx[rootIndex]
            
        while(index!=rootIndex):
            curParent = self.idx[index]
            self.idx[index] = rootIndex
            index = curParent
        return rootIndex","(31, 4)","(35, 42)",N,function_definition,__init__,,47,2d5ad973-d06e-4f71-8637-5169b84f9d3f
"def find(self, index):
        rootIndex = index
        while(self.idx[rootIndex]!=rootIndex):
            rootIndex = self.idx[rootIndex]
            
        while(index!=rootIndex):
            curParent = self.idx[index]
            self.idx[index] = rootIndex
            index = curParent
        return rootIndex",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-UnionFind/,UnionFind,"def __init__(self, capacity):
        self.capacity = capacity
        self.idx = [i for i in range(self.capacity)]
        self.sz = [1 for i in range(self.capacity)]
        self.numComponents = self.capacity","def connected(self, index1, index2):
        return self.find(index1) == self.find(index2)","(37, 4)","(46, 24)",N,function_definition,find,,66,85ad10fc-2d39-4ef6-a9f0-b85ce6764de0
"def connected(self, index1, index2):
        return self.find(index1) == self.find(index2)",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-UnionFind/,UnionFind,"def find(self, index):
        rootIndex = index
        while(self.idx[rootIndex]!=rootIndex):
            rootIndex = self.idx[rootIndex]
            
        while(index!=rootIndex):
            curParent = self.idx[index]
            self.idx[index] = rootIndex
            index = curParent
        return rootIndex","def componentSize(self, index):
        return self.sz[self.find(index)]","(48, 4)","(49, 53)",N,function_definition,connected,,23,cf1f8153-6cc7-4566-a901-cbbd2f47ff2c
"def componentSize(self, index):
        return self.sz[self.find(index)]",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-UnionFind/,UnionFind,"def connected(self, index1, index2):
        return self.find(index1) == self.find(index2)","def getNumberOfComponents(self):
        return self.numComponents","(51, 4)","(52, 40)",N,function_definition,componentSize,,15,a918b5d3-aae5-4414-93ed-baae68e8a110
"def getNumberOfComponents(self):
        return self.numComponents",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-UnionFind/,UnionFind,"def componentSize(self, index):
        return self.sz[self.find(index)]","def merge(self, index1, index2):
        
        root1 = self.find(index1)
        root2 = self.find(index2)        
        
        if(root1 == root2): return
        
        if(self.componentSize(root1) <= self.componentSize(root2)):
            self.idx[root1] = root2
            self.sz[root2] += self.sz[root1]
        else:
            self.idx[root2] = root1
            self.sz[root1] += self.sz[root2]
            
        self.numComponents -= 1","(54, 4)","(55, 33)",N,function_definition,getNumberOfComponents,,11,d10941cb-1c92-48bc-8489-52de955e12b3
"def merge(self, index1, index2):
        
        root1 = self.find(index1)
        root2 = self.find(index2)        
        
        if(root1 == root2): return
        
        if(self.componentSize(root1) <= self.componentSize(root2)):
            self.idx[root1] = root2
            self.sz[root2] += self.sz[root1]
        else:
            self.idx[root2] = root1
            self.sz[root1] += self.sz[root2]
            
        self.numComponents -= 1",EquationsPossible.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\EquationsPossible.py,module/class_definition-UnionFind/,UnionFind,"def getNumberOfComponents(self):
        return self.numComponents",Next sibling does not exist,"(57, 4)","(71, 31)",N,function_definition,merge,,110,10f45a78-9b5a-467f-a6e6-5910e7dbed03
"class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
      
        n = len(isConnected)
        uf = UnionFind(n)
        for index1 in range(n):
            for index2 in range(index1+1, n):
                if(isConnected[index1][index2]==1):
                    uf.merge(index1, index2)
        
        return uf.getNumberOfComponents()
",findCircleNum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\findCircleNum.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(11, 0)",N,module,module,,84,1a36ae7b-9906-43f1-b8b2-c1966e1d9294
"class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
      
        n = len(isConnected)
        uf = UnionFind(n)
        for index1 in range(n):
            for index2 in range(index1+1, n):
                if(isConnected[index1][index2]==1):
                    uf.merge(index1, index2)
        
        return uf.getNumberOfComponents()",findCircleNum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\findCircleNum.py,module/,module,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(10, 41)",N,class_definition,Solution,,84,2bbf58f7-de70-4089-9152-52eefbe87e14
"def findCircleNum(self, isConnected: List[List[int]]) -> int:
      
        n = len(isConnected)
        uf = UnionFind(n)
        for index1 in range(n):
            for index2 in range(index1+1, n):
                if(isConnected[index1][index2]==1):
                    uf.merge(index1, index2)
        
        return uf.getNumberOfComponents()",findCircleNum.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\findCircleNum.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(10, 41)",N,function_definition,findCircleNum,,80,9b9ab1a6-106a-4874-82eb-04d4d814aa04
"class LUPrefix {

    UnionFind uf;
    boolean[] uploaded;
    
    public LUPrefix(int n) {
        uf = new UnionFind(n+1);
        uploaded = new boolean[n+1];
    }
    
    public void upload(int video) {
        
        if(video>0 && uploaded[video-1]) uf.merge(video, video-1);
        if(video<uploaded.length-1 && uploaded[video+1]) uf.merge(video, video+1);
        
        uploaded[video] = true;
    }
    
    public int longest() {
        return uploaded[1] ? uf.componentSize(1) :  0;
    }
}

",LUPrefix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\LUPrefix.java,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(23, 0)",N,program,program,,138,c9febf1b-5c42-458c-b115-20dcec6c0e25
"class LUPrefix {

    UnionFind uf;
    boolean[] uploaded;
    
    public LUPrefix(int n) {
        uf = new UnionFind(n+1);
        uploaded = new boolean[n+1];
    }
    
    public void upload(int video) {
        
        if(video>0 && uploaded[video-1]) uf.merge(video, video-1);
        if(video<uploaded.length-1 && uploaded[video+1]) uf.merge(video, video+1);
        
        uploaded[video] = true;
    }
    
    public int longest() {
        return uploaded[1] ? uf.componentSize(1) :  0;
    }
}",LUPrefix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\LUPrefix.java,program/,program,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(21, 1)",N,class_declaration,LUPrefix,,138,17b48553-e7fe-42c9-bbbb-058ad867b84e
"public LUPrefix(int n) {
        uf = new UnionFind(n+1);
        uploaded = new boolean[n+1];
    }",LUPrefix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\LUPrefix.java,program/class_declaration-LUPrefix/,LUPrefix,boolean[] uploaded;,"public void upload(int video) {
        
        if(video>0 && uploaded[video-1]) uf.merge(video, video-1);
        if(video<uploaded.length-1 && uploaded[video+1]) uf.merge(video, video+1);
        
        uploaded[video] = true;
    }","(5, 4)","(8, 5)",N,constructor_declaration,LUPrefix,,29,4fbc6057-1ef4-4eab-963e-7e875f3ad6dc
"public void upload(int video) {
        
        if(video>0 && uploaded[video-1]) uf.merge(video, video-1);
        if(video<uploaded.length-1 && uploaded[video+1]) uf.merge(video, video+1);
        
        uploaded[video] = true;
    }",LUPrefix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\LUPrefix.java,program/class_declaration-LUPrefix/,LUPrefix,"public LUPrefix(int n) {
        uf = new UnionFind(n+1);
        uploaded = new boolean[n+1];
    }","public int longest() {
        return uploaded[1] ? uf.componentSize(1) :  0;
    }","(10, 4)","(16, 5)",N,method_declaration,upload,,62,65bb57bc-f3c9-4364-8a83-838de920e68d
"public int longest() {
        return uploaded[1] ? uf.componentSize(1) :  0;
    }",LUPrefix.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\LUPrefix.java,program/class_declaration-LUPrefix/,LUPrefix,"public void upload(int video) {
        
        if(video>0 && uploaded[video-1]) uf.merge(video, video-1);
        if(video<uploaded.length-1 && uploaded[video+1]) uf.merge(video, video+1);
        
        uploaded[video] = true;
    }",Next sibling does not exist,"(18, 4)","(20, 5)",N,method_declaration,longest,,25,7e062e9a-964b-42d5-9458-66f7993ae031
"from SimilarStringGroups import UnionFind


class Solution:
    def maxNumEdgesToRemove(self, n, edges):

        alice = UnionFind(n)
        count = 0
        numEdges = len(edges)

        for edgeType, source, dest in edges:
            if(edgeType == 3):
                alice.merge(source-1, dest-1)
                count += 1
                if(alice.getNumberOfComponents() == 1): return numEdges - count

        bob = alice.clone()

        graph = [alice, bob]

        for edgeType, source, dest in edges:
            if(edgeType == 3): continue
            if(edgeType == 1 and alice.areConnected(source-1, dest-1)): continue 
            if(edgeType == 2 and bob.areConnected(source-1, dest-1)): continue
            
            graph[edgeType].merge(source-1, dest-1)
            count += 1
            if(alice.getNumberOfComponents() == 1 and bob.getNumberOfComponents() == 1): return numEdges - count
        
        return -1",maxNumEdgesToRemove.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\maxNumEdgesToRemove.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(29, 17)",N,module,module,,225,46b77a4a-aec8-43fe-b6c8-ea6904a15913
from SimilarStringGroups import UnionFind,maxNumEdgesToRemove.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\maxNumEdgesToRemove.py,module/,module,Previous sibling does not exist,"class Solution:
    def maxNumEdgesToRemove(self, n, edges):

        alice = UnionFind(n)
        count = 0
        numEdges = len(edges)

        for edgeType, source, dest in edges:
            if(edgeType == 3):
                alice.merge(source-1, dest-1)
                count += 1
                if(alice.getNumberOfComponents() == 1): return numEdges - count

        bob = alice.clone()

        graph = [alice, bob]

        for edgeType, source, dest in edges:
            if(edgeType == 3): continue
            if(edgeType == 1 and alice.areConnected(source-1, dest-1)): continue 
            if(edgeType == 2 and bob.areConnected(source-1, dest-1)): continue
            
            graph[edgeType].merge(source-1, dest-1)
            count += 1
            if(alice.getNumberOfComponents() == 1 and bob.getNumberOfComponents() == 1): return numEdges - count
        
        return -1","(0, 0)","(0, 41)",N,import_from_statement,import_from_statement,,7,e1f302ce-a208-4fbb-818e-b5381b5b8fb6
"class Solution:
    def maxNumEdgesToRemove(self, n, edges):

        alice = UnionFind(n)
        count = 0
        numEdges = len(edges)

        for edgeType, source, dest in edges:
            if(edgeType == 3):
                alice.merge(source-1, dest-1)
                count += 1
                if(alice.getNumberOfComponents() == 1): return numEdges - count

        bob = alice.clone()

        graph = [alice, bob]

        for edgeType, source, dest in edges:
            if(edgeType == 3): continue
            if(edgeType == 1 and alice.areConnected(source-1, dest-1)): continue 
            if(edgeType == 2 and bob.areConnected(source-1, dest-1)): continue
            
            graph[edgeType].merge(source-1, dest-1)
            count += 1
            if(alice.getNumberOfComponents() == 1 and bob.getNumberOfComponents() == 1): return numEdges - count
        
        return -1",maxNumEdgesToRemove.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\maxNumEdgesToRemove.py,module/,module,from SimilarStringGroups import UnionFind,Next sibling does not exist,"(3, 0)","(29, 17)",N,class_definition,Solution,,217,88fc5d61-d3bd-4748-92ca-3bf5cccc7062
"def maxNumEdgesToRemove(self, n, edges):

        alice = UnionFind(n)
        count = 0
        numEdges = len(edges)

        for edgeType, source, dest in edges:
            if(edgeType == 3):
                alice.merge(source-1, dest-1)
                count += 1
                if(alice.getNumberOfComponents() == 1): return numEdges - count

        bob = alice.clone()

        graph = [alice, bob]

        for edgeType, source, dest in edges:
            if(edgeType == 3): continue
            if(edgeType == 1 and alice.areConnected(source-1, dest-1)): continue 
            if(edgeType == 2 and bob.areConnected(source-1, dest-1)): continue
            
            graph[edgeType].merge(source-1, dest-1)
            count += 1
            if(alice.getNumberOfComponents() == 1 and bob.getNumberOfComponents() == 1): return numEdges - count
        
        return -1",maxNumEdgesToRemove.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\maxNumEdgesToRemove.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(4, 4)","(29, 17)",N,function_definition,maxNumEdgesToRemove,,213,81203877-faaf-4a82-8e08-ef7f6630a195
"class Solution:
    def minMalwareSpread(self, graph, initial):

        N = len(graph)
        uf = UnionFind(N)
        

        for i in initial: uf.numOfMalwareSources[i] = 1

        for i in range(N):
            for j in range(i+1, N):
                if(graph[i][j] == 1): uf.merge(i, j)
        

        print(uf.id, uf.numOfMalwareSources, uf.size)

        ans_index = -1
        ans_component_size = -1

        for comp_index in initial:
            comp_root = uf.find(comp_index)
            if(uf.numOfMalwareSources[comp_root] == 1):
                cur_comp_size = uf.getComponentSize(comp_root)
                if(cur_comp_size > ans_component_size):
                    ans_component_size = cur_comp_size
                    ans_index = comp_index
                elif(cur_comp_size == ans_component_size):
                    ans_index = min(ans_index, comp_index)
        
        if(ans_index == -1): return min(initial)
        return ans_index





class UnionFind:

    def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]


    def getNumberOfComponents(self): return self.numOfComponents

    def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root

    def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)

    def getComponentSize(self, component): return self.size[self.find(component)]

    def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot


solution = Solution()
# solution.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1])
ans = solution.minMalwareSpread([[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,1,0],[0,0,0,1,1,0],[0,0,0,0,0,1]], [5,0])
print(ans)

",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(89, 0)",N,module,module,,745,64921980-f582-4675-a3c7-0cbb82dbcb02
"class Solution:
    def minMalwareSpread(self, graph, initial):

        N = len(graph)
        uf = UnionFind(N)
        

        for i in initial: uf.numOfMalwareSources[i] = 1

        for i in range(N):
            for j in range(i+1, N):
                if(graph[i][j] == 1): uf.merge(i, j)
        

        print(uf.id, uf.numOfMalwareSources, uf.size)

        ans_index = -1
        ans_component_size = -1

        for comp_index in initial:
            comp_root = uf.find(comp_index)
            if(uf.numOfMalwareSources[comp_root] == 1):
                cur_comp_size = uf.getComponentSize(comp_root)
                if(cur_comp_size > ans_component_size):
                    ans_component_size = cur_comp_size
                    ans_index = comp_index
                elif(cur_comp_size == ans_component_size):
                    ans_index = min(ans_index, comp_index)
        
        if(ans_index == -1): return min(initial)
        return ans_index",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/,module,Previous sibling does not exist,"class UnionFind:

    def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]


    def getNumberOfComponents(self): return self.numOfComponents

    def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root

    def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)

    def getComponentSize(self, component): return self.size[self.find(component)]

    def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot","(0, 0)","(30, 24)",N,class_definition,Solution,,222,f3b0a70e-5d89-4922-a96e-6d02134d0a8d
"def minMalwareSpread(self, graph, initial):

        N = len(graph)
        uf = UnionFind(N)
        

        for i in initial: uf.numOfMalwareSources[i] = 1

        for i in range(N):
            for j in range(i+1, N):
                if(graph[i][j] == 1): uf.merge(i, j)
        

        print(uf.id, uf.numOfMalwareSources, uf.size)

        ans_index = -1
        ans_component_size = -1

        for comp_index in initial:
            comp_root = uf.find(comp_index)
            if(uf.numOfMalwareSources[comp_root] == 1):
                cur_comp_size = uf.getComponentSize(comp_root)
                if(cur_comp_size > ans_component_size):
                    ans_component_size = cur_comp_size
                    ans_index = comp_index
                elif(cur_comp_size == ans_component_size):
                    ans_index = min(ans_index, comp_index)
        
        if(ans_index == -1): return min(initial)
        return ans_index",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(1, 4)","(30, 24)",N,function_definition,minMalwareSpread,,218,03edaed3-ba11-4828-b53e-a653fb8fb85b
"class UnionFind:

    def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]


    def getNumberOfComponents(self): return self.numOfComponents

    def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root

    def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)

    def getComponentSize(self, component): return self.size[self.find(component)]

    def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/,module,"class Solution:
    def minMalwareSpread(self, graph, initial):

        N = len(graph)
        uf = UnionFind(N)
        

        for i in initial: uf.numOfMalwareSources[i] = 1

        for i in range(N):
            for j in range(i+1, N):
                if(graph[i][j] == 1): uf.merge(i, j)
        

        print(uf.id, uf.numOfMalwareSources, uf.size)

        ans_index = -1
        ans_component_size = -1

        for comp_index in initial:
            comp_root = uf.find(comp_index)
            if(uf.numOfMalwareSources[comp_root] == 1):
                cur_comp_size = uf.getComponentSize(comp_root)
                if(cur_comp_size > ans_component_size):
                    ans_component_size = cur_comp_size
                    ans_index = comp_index
                elif(cur_comp_size == ans_component_size):
                    ans_index = min(ans_index, comp_index)
        
        if(ans_index == -1): return min(initial)
        return ans_index",solution = Solution(),"(36, 0)","(81, 61)",N,class_definition,UnionFind,,399,325ecc24-f335-4d6f-8a0e-5ed2bc4105a3
"def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-UnionFind/,UnionFind,Previous sibling does not exist,def getNumberOfComponents(self): return self.numOfComponents,"(38, 4)","(43, 76)",N,function_definition,__init__,,69,1c48c199-2a9b-45fb-8b52-46ca0a20e9d4
def getNumberOfComponents(self): return self.numOfComponents,MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-UnionFind/,UnionFind,"def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]","def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root","(46, 4)","(46, 64)",N,function_definition,getNumberOfComponents,,11,2b627e02-e01e-4651-a06d-cd7c4f2fa91b
"def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-UnionFind/,UnionFind,def getNumberOfComponents(self): return self.numOfComponents,"def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)","(48, 4)","(56, 19)",N,function_definition,find,,67,d26c4ea6-eee6-40b7-aa80-70daef2c3c06
"def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-UnionFind/,UnionFind,"def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root","def getComponentSize(self, component): return self.size[self.find(component)]","(58, 4)","(58, 104)",N,function_definition,isConnected,,22,1e0712f8-cee9-4790-b6b6-7cd5f5eec657
"def getComponentSize(self, component): return self.size[self.find(component)]",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-UnionFind/,UnionFind,"def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)","def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot","(60, 4)","(60, 81)",N,function_definition,getComponentSize,,15,cff13a4d-d7c2-490c-9f13-089bd3cd522a
"def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/class_definition-UnionFind/,UnionFind,"def getComponentSize(self, component): return self.size[self.find(component)]","solution = Solution()
# solution.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1])
ans = solution.minMalwareSpread([[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,1,0],[0,0,0,1,1,0],[0,0,0,0,0,1]], [5,0])
print(ans)","(62, 4)","(81, 61)",N,function_definition,merge,,202,c45c4b52-e14d-4828-8834-cb0516215a30
"solution = Solution()
# solution.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1])
ans = solution.minMalwareSpread([[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,1,0],[0,0,0,1,1,0],[0,0,0,0,0,1]], [5,0])
print(ans)",MinimizeMalwareSpread.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\MinimizeMalwareSpread.py,module/,module,"class UnionFind:

    def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]


    def getNumberOfComponents(self): return self.numOfComponents

    def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root

    def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)

    def getComponentSize(self, component): return self.size[self.find(component)]

    def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot",Next sibling does not exist,"(84, 0)","(87, 10)",N,"expression_statement,comment,expression_statement,expression_statement",expression_statement,,122,e2df9e4c-a833-45db-a935-d390a7d16574
"class UnionFind:

    def __init__(self, size):
        self.size = size
        self.componentSize = [1 for i in range(size)]
        self.id = [i for i in range(size)]
        self.numberOfComponents = size
    

    def getNumberOfComponents(self): return self.numberOfComponents
    
    def find(self, index):
        temp = index
        while(self.id[index] != index): index = self.id[index]

        
        # path compression
        while(self.id[temp] != index):
            temp = self.id[temp]
            self.id[temp] = index 
        
        return index

    def getComponentSize(self, index): return self.componentSize(self.find(index))
    def areConnected(self, index1, index2): return self.find(index1) == self.find(index2)

    def merge(self, index1, index2):
        if(self.areConnected(index1, index2)): return

        root1 = self.find(index1)
        root2 = self.find(index2)

        if(self.componentSize[root1] >= self.componentSize[root2]): 
            self.id[root2] = root1
            self.componentSize[root1] += self.componentSize[root2]
        else: 
            self.id[root1] = root2
            self.componentSize[root2] += self.componentSize[root1]
        
        self.numberOfComponents -= 1
    
    def clone(self):
        new = UnionFind(self.size)
        new.componentSize = [i for i in self.componentSize]
        new.id = [i for i in self.id]
        new.numberOfComponents = self.numberOfComponents

        return new


class Solution:
    def numSimilarGroups(self, strs):

        N = len(strs)
        uf = UnionFind(N)


        def similar(s1, s2):
            count = 0
            
            for ch1, ch2 in zip(s1, s2):
                if(ch1 != ch2): 
                    count += 1
                    if(count>2): return False
            
            return True

        for index1 in range(N):
            for index2 in range(index1+1, N):
                if(similar(strs[index1], strs[index2]) and not uf.areConnected(index1, index2)):
                    uf.merge(index1, index2) 
        
        return uf.getNumberOfComponents()",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,,NA,Previous sibling does not exist,Next sibling does not exist,"(0, 0)","(72, 41)",N,module,module,,482,14dc4fd4-958b-41ab-89d2-7dd58f231243
"class UnionFind:

    def __init__(self, size):
        self.size = size
        self.componentSize = [1 for i in range(size)]
        self.id = [i for i in range(size)]
        self.numberOfComponents = size
    

    def getNumberOfComponents(self): return self.numberOfComponents
    
    def find(self, index):
        temp = index
        while(self.id[index] != index): index = self.id[index]

        
        # path compression
        while(self.id[temp] != index):
            temp = self.id[temp]
            self.id[temp] = index 
        
        return index

    def getComponentSize(self, index): return self.componentSize(self.find(index))
    def areConnected(self, index1, index2): return self.find(index1) == self.find(index2)

    def merge(self, index1, index2):
        if(self.areConnected(index1, index2)): return

        root1 = self.find(index1)
        root2 = self.find(index2)

        if(self.componentSize[root1] >= self.componentSize[root2]): 
            self.id[root2] = root1
            self.componentSize[root1] += self.componentSize[root2]
        else: 
            self.id[root1] = root2
            self.componentSize[root2] += self.componentSize[root1]
        
        self.numberOfComponents -= 1
    
    def clone(self):
        new = UnionFind(self.size)
        new.componentSize = [i for i in self.componentSize]
        new.id = [i for i in self.id]
        new.numberOfComponents = self.numberOfComponents

        return new",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/,module,Previous sibling does not exist,"class Solution:
    def numSimilarGroups(self, strs):

        N = len(strs)
        uf = UnionFind(N)


        def similar(s1, s2):
            count = 0
            
            for ch1, ch2 in zip(s1, s2):
                if(ch1 != ch2): 
                    count += 1
                    if(count>2): return False
            
            return True

        for index1 in range(N):
            for index2 in range(index1+1, N):
                if(similar(strs[index1], strs[index2]) and not uf.areConnected(index1, index2)):
                    uf.merge(index1, index2) 
        
        return uf.getNumberOfComponents()","(0, 0)","(47, 18)",N,class_definition,UnionFind,,335,d4aa1d1f-bde1-4035-94fb-f08fa77c3e40
"def __init__(self, size):
        self.size = size
        self.componentSize = [1 for i in range(size)]
        self.id = [i for i in range(size)]
        self.numberOfComponents = size",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,Previous sibling does not exist,def getNumberOfComponents(self): return self.numberOfComponents,"(2, 4)","(6, 38)",N,function_definition,__init__,,45,50f6e3a6-6292-4425-b245-ce32b6a88c45
def getNumberOfComponents(self): return self.numberOfComponents,SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,"def __init__(self, size):
        self.size = size
        self.componentSize = [1 for i in range(size)]
        self.id = [i for i in range(size)]
        self.numberOfComponents = size","def find(self, index):
        temp = index
        while(self.id[index] != index): index = self.id[index]

        
        # path compression
        while(self.id[temp] != index):
            temp = self.id[temp]
            self.id[temp] = index 
        
        return index","(9, 4)","(9, 67)",N,function_definition,getNumberOfComponents,,10,675d76b9-6f61-45b5-9543-9e6511aaadfe
"def find(self, index):
        temp = index
        while(self.id[index] != index): index = self.id[index]

        
        # path compression
        while(self.id[temp] != index):
            temp = self.id[temp]
            self.id[temp] = index 
        
        return index",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,def getNumberOfComponents(self): return self.numberOfComponents,"def getComponentSize(self, index): return self.componentSize(self.find(index))","(11, 4)","(21, 20)",N,function_definition,find,,59,d6c07e10-88e8-4476-b823-41c59e3e367a
"def getComponentSize(self, index): return self.componentSize(self.find(index))",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,"def find(self, index):
        temp = index
        while(self.id[index] != index): index = self.id[index]

        
        # path compression
        while(self.id[temp] != index):
            temp = self.id[temp]
            self.id[temp] = index 
        
        return index","def areConnected(self, index1, index2): return self.find(index1) == self.find(index2)","(23, 4)","(23, 82)",N,function_definition,getComponentSize,,16,9aa7e3d8-4d6d-42fb-9366-3e0ec9fabbb3
"def areConnected(self, index1, index2): return self.find(index1) == self.find(index2)",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,"def getComponentSize(self, index): return self.componentSize(self.find(index))","def merge(self, index1, index2):
        if(self.areConnected(index1, index2)): return

        root1 = self.find(index1)
        root2 = self.find(index2)

        if(self.componentSize[root1] >= self.componentSize[root2]): 
            self.id[root2] = root1
            self.componentSize[root1] += self.componentSize[root2]
        else: 
            self.id[root1] = root2
            self.componentSize[root2] += self.componentSize[root1]
        
        self.numberOfComponents -= 1","(24, 4)","(24, 89)",N,function_definition,areConnected,,23,6160c239-0a9f-42e5-abd7-a2cf4cfcc2f4
"def merge(self, index1, index2):
        if(self.areConnected(index1, index2)): return

        root1 = self.find(index1)
        root2 = self.find(index2)

        if(self.componentSize[root1] >= self.componentSize[root2]): 
            self.id[root2] = root1
            self.componentSize[root1] += self.componentSize[root2]
        else: 
            self.id[root1] = root2
            self.componentSize[root2] += self.componentSize[root1]
        
        self.numberOfComponents -= 1",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,"def areConnected(self, index1, index2): return self.find(index1) == self.find(index2)","def clone(self):
        new = UnionFind(self.size)
        new.componentSize = [i for i in self.componentSize]
        new.id = [i for i in self.id]
        new.numberOfComponents = self.numberOfComponents

        return new","(26, 4)","(39, 36)",N,function_definition,merge,,117,a3c1e61d-5434-410b-b362-7d0a2c3bf4d8
"def clone(self):
        new = UnionFind(self.size)
        new.componentSize = [i for i in self.componentSize]
        new.id = [i for i in self.id]
        new.numberOfComponents = self.numberOfComponents

        return new",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-UnionFind/,UnionFind,"def merge(self, index1, index2):
        if(self.areConnected(index1, index2)): return

        root1 = self.find(index1)
        root2 = self.find(index2)

        if(self.componentSize[root1] >= self.componentSize[root2]): 
            self.id[root2] = root1
            self.componentSize[root1] += self.componentSize[root2]
        else: 
            self.id[root1] = root2
            self.componentSize[root2] += self.componentSize[root1]
        
        self.numberOfComponents -= 1",Next sibling does not exist,"(41, 4)","(47, 18)",N,function_definition,clone,,50,e98c7044-a752-4f45-afc2-ff35edf5a5e6
"class Solution:
    def numSimilarGroups(self, strs):

        N = len(strs)
        uf = UnionFind(N)


        def similar(s1, s2):
            count = 0
            
            for ch1, ch2 in zip(s1, s2):
                if(ch1 != ch2): 
                    count += 1
                    if(count>2): return False
            
            return True

        for index1 in range(N):
            for index2 in range(index1+1, N):
                if(similar(strs[index1], strs[index2]) and not uf.areConnected(index1, index2)):
                    uf.merge(index1, index2) 
        
        return uf.getNumberOfComponents()",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/,module,"class UnionFind:

    def __init__(self, size):
        self.size = size
        self.componentSize = [1 for i in range(size)]
        self.id = [i for i in range(size)]
        self.numberOfComponents = size
    

    def getNumberOfComponents(self): return self.numberOfComponents
    
    def find(self, index):
        temp = index
        while(self.id[index] != index): index = self.id[index]

        
        # path compression
        while(self.id[temp] != index):
            temp = self.id[temp]
            self.id[temp] = index 
        
        return index

    def getComponentSize(self, index): return self.componentSize(self.find(index))
    def areConnected(self, index1, index2): return self.find(index1) == self.find(index2)

    def merge(self, index1, index2):
        if(self.areConnected(index1, index2)): return

        root1 = self.find(index1)
        root2 = self.find(index2)

        if(self.componentSize[root1] >= self.componentSize[root2]): 
            self.id[root2] = root1
            self.componentSize[root1] += self.componentSize[root2]
        else: 
            self.id[root1] = root2
            self.componentSize[root2] += self.componentSize[root1]
        
        self.numberOfComponents -= 1
    
    def clone(self):
        new = UnionFind(self.size)
        new.componentSize = [i for i in self.componentSize]
        new.id = [i for i in self.id]
        new.numberOfComponents = self.numberOfComponents

        return new",Next sibling does not exist,"(50, 0)","(72, 41)",N,class_definition,Solution,,146,0e16dd24-86da-4121-a4c8-9ff6779ffb4b
"def numSimilarGroups(self, strs):

        N = len(strs)
        uf = UnionFind(N)


        def similar(s1, s2):
            count = 0
            
            for ch1, ch2 in zip(s1, s2):
                if(ch1 != ch2): 
                    count += 1
                    if(count>2): return False
            
            return True

        for index1 in range(N):
            for index2 in range(index1+1, N):
                if(similar(strs[index1], strs[index2]) and not uf.areConnected(index1, index2)):
                    uf.merge(index1, index2) 
        
        return uf.getNumberOfComponents()",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-Solution/,Solution,Previous sibling does not exist,Next sibling does not exist,"(51, 4)","(72, 41)",N,function_definition,numSimilarGroups,,142,6c64a070-78c5-4a93-95e1-8efcfba4546b
"def similar(s1, s2):
            count = 0
            
            for ch1, ch2 in zip(s1, s2):
                if(ch1 != ch2): 
                    count += 1
                    if(count>2): return False
            
            return True",SimilarStringGroups.py,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\SimilarStringGroups.py,module/class_definition-Solution/function_definition-numSimilarGroups/,numSimilarGroups,uf = UnionFind(N),"for index1 in range(N):
            for index2 in range(index1+1, N):
                if(similar(strs[index1], strs[index2]) and not uf.areConnected(index1, index2)):
                    uf.merge(index1, index2)","(57, 8)","(65, 23)",N,function_definition,similar,,56,95cd7141-1372-45ab-9e30-5f35e754cf4b
"package com.akarsh.codechef.unionfind;

// ds which tracks elements of split into one or more disjoint group/sets


// primary operation:
// find -> returns which set the element belongs to
// union -> merges two sets


public class UnionFind {
    private int size; // number of elements in union find
    private int[] sz; // size of each component
    private int[] id; // id[idx] -> has parent index of idx
    private int numComponents;

    public UnionFind(int size){
        if(size<=0) throw new IllegalArgumentException(""size should be greater than zero"");
        this.size = size;
        this.numComponents = size;
        this.id = new int[size];
        this.sz = new int[size];

        for(int index=0; index<size; index++) {
            id[index] = index;
            sz[index] = 1;
        }
    }

    public int find(int index){
        int root = index;
        while(this.id[root] != root) root = this.id[root];

        while(index!=root){
            int temp = this.id[index];
            this.id[index] = root;
            index = temp;
        }
        return root;
    }

    public boolean isConnected(int index1, int index2){
        return find(index1) == find(index2);
    }

    public int componentSize(int index){
        return this.sz[find(index)];
    }

    public int getSize(){
        return this.size;
    }

    public int getNumComponents(){
        return this.numComponents;
    }

    public void merge(int index1, int index2){
        int root1 = find(index1);
        int root2 = find(index2);

        if(root1 == root2) return;


        if(this.sz[root1]<=this.sz[root2]){
            sz[root2] +=  sz[root1];
            id[root1] = root2;
        } else {
            sz[root1] +=  sz[root2];
            id[root2] = root1;
        }

        numComponents--;
    }

}
",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,,NA,Previous sibling does not exist,"package com.akarsh.codechef.unionfind;
// ds which tracks elements of split into one or more disjoint group/sets
// primary operation:
// find -> returns which set the element belongs to
// union -> merges two sets","(0, 0)","(76, 0)",N,program,program,,424,f53b5c4b-4147-4635-a732-e13c87d30355
"package com.akarsh.codechef.unionfind;
// ds which tracks elements of split into one or more disjoint group/sets
// primary operation:
// find -> returns which set the element belongs to
// union -> merges two sets",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/,program,Previous sibling does not exist,"public class UnionFind {
    private int size; // number of elements in union find
    private int[] sz; // size of each component
    private int[] id; // id[idx] -> has parent index of idx
    private int numComponents;

    public UnionFind(int size){
        if(size<=0) throw new IllegalArgumentException(""size should be greater than zero"");
        this.size = size;
        this.numComponents = size;
        this.id = new int[size];
        this.sz = new int[size];

        for(int index=0; index<size; index++) {
            id[index] = index;
            sz[index] = 1;
        }
    }

    public int find(int index){
        int root = index;
        while(this.id[root] != root) root = this.id[root];

        while(index!=root){
            int temp = this.id[index];
            this.id[index] = root;
            index = temp;
        }
        return root;
    }

    public boolean isConnected(int index1, int index2){
        return find(index1) == find(index2);
    }

    public int componentSize(int index){
        return this.sz[find(index)];
    }

    public int getSize(){
        return this.size;
    }

    public int getNumComponents(){
        return this.numComponents;
    }

    public void merge(int index1, int index2){
        int root1 = find(index1);
        int root2 = find(index2);

        if(root1 == root2) return;


        if(this.sz[root1]<=this.sz[root2]){
            sz[root2] +=  sz[root1];
            id[root1] = root2;
        } else {
            sz[root1] +=  sz[root2];
            id[root2] = root1;
        }

        numComponents--;
    }

}","(0, 0)","(7, 27)",N,"package_declaration,line_comment,line_comment,line_comment,line_comment",package_declaration,,45,59e92ff5-2121-416a-a846-226012553659
"public class UnionFind {
    private int size; // number of elements in union find
    private int[] sz; // size of each component
    private int[] id; // id[idx] -> has parent index of idx
    private int numComponents;

    public UnionFind(int size){
        if(size<=0) throw new IllegalArgumentException(""size should be greater than zero"");
        this.size = size;
        this.numComponents = size;
        this.id = new int[size];
        this.sz = new int[size];

        for(int index=0; index<size; index++) {
            id[index] = index;
            sz[index] = 1;
        }
    }

    public int find(int index){
        int root = index;
        while(this.id[root] != root) root = this.id[root];

        while(index!=root){
            int temp = this.id[index];
            this.id[index] = root;
            index = temp;
        }
        return root;
    }

    public boolean isConnected(int index1, int index2){
        return find(index1) == find(index2);
    }

    public int componentSize(int index){
        return this.sz[find(index)];
    }

    public int getSize(){
        return this.size;
    }

    public int getNumComponents(){
        return this.numComponents;
    }

    public void merge(int index1, int index2){
        int root1 = find(index1);
        int root2 = find(index2);

        if(root1 == root2) return;


        if(this.sz[root1]<=this.sz[root2]){
            sz[root2] +=  sz[root1];
            id[root1] = root2;
        } else {
            sz[root1] +=  sz[root2];
            id[root2] = root1;
        }

        numComponents--;
    }

}",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/,program,"package com.akarsh.codechef.unionfind;
// ds which tracks elements of split into one or more disjoint group/sets
// primary operation:
// find -> returns which set the element belongs to
// union -> merges two sets",Next sibling does not exist,"(10, 0)","(75, 1)",N,class_declaration,UnionFind,,376,169357a8-16cc-4977-aed6-4fb95d486508
"public UnionFind(int size){
        if(size<=0) throw new IllegalArgumentException(""size should be greater than zero"");
        this.size = size;
        this.numComponents = size;
        this.id = new int[size];
        this.sz = new int[size];

        for(int index=0; index<size; index++) {
            id[index] = index;
            sz[index] = 1;
        }
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,private int numComponents;,"public int find(int index){
        int root = index;
        while(this.id[root] != root) root = this.id[root];

        while(index!=root){
            int temp = this.id[index];
            this.id[index] = root;
            index = temp;
        }
        return root;
    }","(16, 4)","(27, 5)",N,constructor_declaration,UnionFind,,84,bdbd6ff7-22dc-401e-88df-ad7a2be00421
"public int find(int index){
        int root = index;
        while(this.id[root] != root) root = this.id[root];

        while(index!=root){
            int temp = this.id[index];
            this.id[index] = root;
            index = temp;
        }
        return root;
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,"public UnionFind(int size){
        if(size<=0) throw new IllegalArgumentException(""size should be greater than zero"");
        this.size = size;
        this.numComponents = size;
        this.id = new int[size];
        this.sz = new int[size];

        for(int index=0; index<size; index++) {
            id[index] = index;
            sz[index] = 1;
        }
    }","public boolean isConnected(int index1, int index2){
        return find(index1) == find(index2);
    }","(29, 4)","(39, 5)",N,method_declaration,find,,62,aeb3298f-280b-4f23-a57d-3b6c374c01ec
"public boolean isConnected(int index1, int index2){
        return find(index1) == find(index2);
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,"public int find(int index){
        int root = index;
        while(this.id[root] != root) root = this.id[root];

        while(index!=root){
            int temp = this.id[index];
            this.id[index] = root;
            index = temp;
        }
        return root;
    }","public int componentSize(int index){
        return this.sz[find(index)];
    }","(41, 4)","(43, 5)",N,method_declaration,isConnected,,24,cfc92c36-fad1-4faa-b372-6da2480aab91
"public int componentSize(int index){
        return this.sz[find(index)];
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,"public boolean isConnected(int index1, int index2){
        return find(index1) == find(index2);
    }","public int getSize(){
        return this.size;
    }","(45, 4)","(47, 5)",N,method_declaration,componentSize,,17,d070d90c-ee29-4a33-8b4a-072f50241716
"public int getSize(){
        return this.size;
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,"public int componentSize(int index){
        return this.sz[find(index)];
    }","public int getNumComponents(){
        return this.numComponents;
    }","(49, 4)","(51, 5)",N,method_declaration,getSize,,11,da7bc902-457b-47d7-98ba-586ed002645b
"public int getNumComponents(){
        return this.numComponents;
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,"public int getSize(){
        return this.size;
    }","public void merge(int index1, int index2){
        int root1 = find(index1);
        int root2 = find(index2);

        if(root1 == root2) return;


        if(this.sz[root1]<=this.sz[root2]){
            sz[root2] +=  sz[root1];
            id[root1] = root2;
        } else {
            sz[root1] +=  sz[root2];
            id[root2] = root1;
        }

        numComponents--;
    }","(53, 4)","(55, 5)",N,method_declaration,getNumComponents,,14,135ba5a5-b9e1-48ab-b423-eac94cfe27da
"public void merge(int index1, int index2){
        int root1 = find(index1);
        int root2 = find(index2);

        if(root1 == root2) return;


        if(this.sz[root1]<=this.sz[root2]){
            sz[root2] +=  sz[root1];
            id[root1] = root2;
        } else {
            sz[root1] +=  sz[root2];
            id[root2] = root1;
        }

        numComponents--;
    }",UnionFind.java,C:\Users\Tanmay Saini\Desktop\codeconverse\backend\repositories\akarshippili_dsa\UnionFind\UnionFind.java,program/class_declaration-UnionFind/,UnionFind,"public int getNumComponents(){
        return this.numComponents;
    }",Next sibling does not exist,"(57, 4)","(73, 5)",N,method_declaration,merge,,103,d6369738-8eaa-406b-81f9-7c787de41dbf
